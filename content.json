{"meta":{"title":"Reria's BLOG","subtitle":"","description":"","author":"reria","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-09-22T12:12:27.438Z","updated":"2021-09-22T12:12:27.438Z","comments":false,"path":"notice.html","permalink":"http://example.com/notice.html","excerpt":"","text":"本站默认替换了右键菜单，如需唤醒原系统菜单请使用： ctrl + 右键"},{"title":"404 Not Found","date":"2021-07-23T06:13:25.410Z","updated":"2021-07-23T06:13:25.410Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"【】","date":"2021-09-22T12:12:40.562Z","updated":"2021-09-20T03:38:29.350Z","comments":true,"path":"模板.html","permalink":"http://example.com/%E6%A8%A1%E6%9D%BF.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T03:29:26.295Z","updated":"2021-07-29T03:29:26.295Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"正在维护(其实是懒得写介绍🤭"},{"title":"","date":"2021-07-27T01:43:04.243Z","updated":"2021-07-27T01:43:04.243Z","comments":true,"path":"bangumis/index.html","permalink":"http://example.com/bangumis/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-29T03:28:37.138Z","updated":"2021-07-29T03:28:37.138Z","comments":true,"path":"bb/index.html","permalink":"http://example.com/bb/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-26T05:59:04.234Z","updated":"2021-07-26T05:59:04.234Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-07-29T09:43:44.508Z","updated":"2021-07-29T09:43:44.508Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-27T01:43:04.243Z","updated":"2021-07-27T01:43:04.243Z","comments":true,"path":"cinema/index.html","permalink":"http://example.com/cinema/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-08-24T08:21:05.250Z","updated":"2021-08-24T08:21:05.250Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"🧡💛💚💙💜🤎🖤🤍"},{"title":"所有标签","date":"2021-07-29T09:43:17.916Z","updated":"2021-07-29T09:43:17.916Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【项目笔记】商城项目实战7","slug":"【项目笔记】商城项目实战7","date":"2021-11-21T03:00:19.310Z","updated":"2021-11-24T10:56:34.628Z","comments":true,"path":"2021/11/21/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-7/","link":"","permalink":"http://example.com/2021/11/21/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-7/","excerpt":"","text":"消息队列异步处理、应用解耦、流量削峰 消息中间件 大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力 消息服务中两个重要概念： 消息代理（message broker）和目的地（destination） 当消息发送者发送消息以后，将由消息代理（安装了消息中间件的服务器）接管，消息代理保证消息传递到指定目的地。 消息队列主要有两种形式的目的地 队列（queue）：点对点消息通信（point-to-point） 主题（topic）：发布（publish）/订阅（subscribe）消息通信 点对点式 ： 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 消息只有唯一的发送者和接受者，但并不是说只能有一个接收者 发布订阅式： 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息 JMS（Java Message Service）JAVA消息服务： 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 AMQP（Advanced Message Queuing Protocol） 高级消息队列协议，也是一个消息代理的规范，兼容JMS RabbitMQ是AMQP的实现 RabbitMQ RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现 Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher消息的生产者，也是一个向交换器发布消息的客户端应用程序 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别 Queue 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走 Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系 Connection网络连接，比如一个TCP连接。 Channel信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。 Consumer消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 Virtual Host虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。 Broker 表示消息队列服务器实体 安装 https://www.rabbitmq.com/networking.html docker run -d –name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management docker update rabbitmq –restart=always 4369, 25672 (Erlang发现&amp;集群端口)5672, 5671 (AMQP端口)15672 (web管理后台端口)61613, 61614 (STOMP协议端口)1883, 8883 (MQTT协议端口) Exchange类型 Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了 消息中的路由键（routing key）如果和Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routingkey 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。 每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。 topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0个或多个单词，匹配一个单词。 spring整合依赖、配置12345&lt;!-- rabbitMQ --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 1@EnableRabbit // 开启rabbit 123456spring: rabbitmq: host: 192.168.128.129 port: 5672 virtual-host: / # 其他 AmqpAdmin123456789101112131415161718192021222324252627282930@Slf4j@RunWith(SpringRunner.class)@SpringBootTestpublic class GulimallOrderApplicationTests &#123; @Autowired AmqpAdmin amqpAdmin; @Test public void createExchange() &#123; DirectExchange directExchange = new DirectExchange(&quot;test-direct&quot;, true, false); amqpAdmin.declareExchange(directExchange); log.debug(&quot;Exchange[&#123;&#125;]创建成功&quot;, directExchange.getName()); &#125; @Test public void createQueue() &#123; Queue queue = new Queue(&quot;test-hello&quot;); amqpAdmin.declareQueue(queue); log.debug(&quot;Queue[&#123;&#125;]创建成功&quot;, queue.getName()); &#125; @Test public void binding() &#123; Binding binding = new Binding(&quot;test-hello&quot;, Binding.DestinationType.QUEUE, &quot;test-direct&quot;, &quot;test-hello&quot;, new HashMap&lt;&gt;()); amqpAdmin.declareBinding(binding); log.debug(&quot;Binding创建成功,目的地[&#123;&#125;]&quot;, binding.getDestination()); &#125;&#125; RabbitTemplate123456789101112@AutowiredRabbitTemplate rabbitTemplate;@Testpublic void sendMsg() &#123; OrderEntity orderEntity = new OrderEntity(); orderEntity.setCouponId(1L); // 如果消息内容是对象，默认序列化转换，所以对象类要求实现序列化 // 也可以配置默认转为JSON rabbitTemplate.convertAndSend(&quot;test-direct&quot;, &quot;test-hello&quot;, orderEntity); log.debug(&quot;消息发送成功&quot;);&#125; 12345678@Configurationpublic class OrderRabbitConfig &#123; // 配置默认MessageConverter为Jackson2JsonMessageConverter（转为JSON） @Bean public MessageConverter messageConverter() &#123; return new Jackson2JsonMessageConverter(); &#125;&#125; RabbitListener、RabbitHandler12345678// 监听队列@RabbitListener(queues = &#123;&quot;test-hello&quot;&#125;)public void testListener(Message msg, OrderEntity content, Channel channel) &#123; // msg 包括头+体 // content 可以使用具体类型接收内容 // channel 传输数据通道 log.debug(&quot;监听到了消息:&quot; + msg + &quot;; 内容为:&quot; + content);&#125; 订单服务启动多个的话，同一个消息只有一个客户端可以收到 只有一个消息完全处理完之后，才能接收下一个消息 RabbitListener注解可以标在类、方法上（一般类上） RabbitHandler注解可以标在方法上，可以自动判断方法参数的内容类型（重载，不过方法名不需要一样） 可靠投递 保证消息不丢失，可靠抵达，可以使用事务消息，但是性能会下降，为此引入确认机制 ConfirmCallback ReturnCallback Ack消息确认机制 订单服务 环境搭建 老生常谈 订单登录拦截OrderWebConfig123456789101112131415@Configurationpublic class OrderWebConfig implements WebMvcConfigurer &#123; @Autowired OrderLoginUserInterceptor loginInterceptor; /* * 添加拦截器 * 配置拦截地址 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(loginInterceptor).addPathPatterns(&quot;/**&quot;); &#125;&#125; OrderLoginUserInterceptor12345678910111213141516171819202122232425/* * 登录拦截 */@Componentpublic class OrderLoginUserInterceptor implements HandlerInterceptor &#123; public static ThreadLocal&lt;MemberEntityVo&gt; loginUser = new ThreadLocal&lt;&gt;(); /* * 在方法执行之前拦截 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; MemberEntityVo attribute = (MemberEntityVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER); if (attribute != null) &#123; // 已登录 loginUser.set(attribute); return true; &#125; else &#123; request.getSession().setAttribute(&quot;msg&quot;, &quot;请先登录&quot;); response.sendRedirect(&quot;http://auth.gulimall.com/login.html&quot;); return false; &#125; &#125;&#125; DEBUG OrderLoginUserInterceptor需写成如下，加入loginUser判断，否则会有cannot get session的问题 debug的时候会进入两次interceptor，然后第二次拿不到session所以就会报错 1234567891011121314151617181920212223242526272829303132333435363738394041/* * 登录拦截 */@Componentpublic class OrderLoginUserInterceptor implements HandlerInterceptor &#123; public static ThreadLocal&lt;MemberEntityVo&gt; loginUser = new ThreadLocal&lt;&gt;(); /* * 在方法执行之前拦截 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // /order/order/status/2948294820984028420 String uri = request.getRequestURI(); AntPathMatcher antPathMatcher = new AntPathMatcher(); boolean match = antPathMatcher.match(&quot;/order/order/status/**&quot;, uri); boolean match1 = antPathMatcher.match(&quot;/payed/notify&quot;, uri); if (match || match1) &#123; return true; &#125; if (loginUser.get() != null) &#123; return true; &#125; else &#123; MemberEntityVo attribute = (MemberEntityVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER); if (attribute != null) &#123; loginUser.set(attribute); return true; &#125; else &#123; //没登录就去登录 request.getSession().setAttribute(&quot;msg&quot;, &quot;请先进行登录&quot;); response.sendRedirect(&quot;http://auth.gulimall.com/login.html&quot;); return false; &#125; &#125; &#125;&#125; 订单服务 - 确认页Feign远程调用丢失请求头丢失请求头 MyFeignConfig 题外话，跟着雷神学我现在也习惯点进源码看一看，而且不会啥也看不懂了，真不戳 12345678910111213141516171819202122/* * 配置feign */@Configurationpublic class MyFeignConfig &#123; // 配置请求拦截器，防止头丢失 // 默认request拦截器是空,存入一个即可 @Bean(&quot;requestInterceptor&quot;) public RequestInterceptor requestInterceptor() &#123; return new RequestInterceptor() &#123; @Override public void apply(RequestTemplate requestTemplate) &#123; // RequestContextHolder利用了ThreadLocal，存放了请求内容 ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); // 获得request （原请求） HttpServletRequest request = requestAttributes.getRequest(); // 获得cookie 并存入新请求 requestTemplate.header(&quot;Cookie&quot;, request.getHeader(&quot;Cookie&quot;)); &#125; &#125;; &#125;&#125; 异步情况下丢失上下文 12345RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); CompletableFuture&lt;Void&gt; addressFuture = CompletableFuture.runAsync(() -&gt; &#123; // 在异步请求中共享之前的请求数据 RequestContextHolder.setRequestAttributes(requestAttributes);&#125;, executor); Order模块OrderConfirmVo1234567891011121314151617181920212223242526/** * 订单确认页模型 */@Datapublic class OrderConfirmVo &#123; // 订单防重复令牌 private String orderToken; // 收货地址表 private List&lt;MemberAddressVo&gt; address; // 订单商品 private List&lt;OrderItemVo&gt; items; // 发票 // 优惠 private Integer integration; private BigDecimal total; private BigDecimal payPrice; public BigDecimal getPayPrice() &#123; return total.subtract(new BigDecimal(integration)); &#125; public BigDecimal getTotal() &#123; for (OrderItemVo item : items) &#123; total = total.add(item.getTotalPrice()); &#125; return total; &#125;&#125; OrderItemVo1234567891011121314@Datapublic class OrderItemVo &#123; private Long skuId; private String title; private String image; private List&lt;String&gt; skuAttr; private BigDecimal price; private Integer count; private BigDecimal totalPrice; public BigDecimal getTotalPrice() &#123; return this.price.multiply(new BigDecimal(this.count)); &#125;&#125; OrderWebController123456789/* * 前往订单确认页 */@GetMapping(&quot;/toTrade&quot;)public String toConfirmPage(Model model) &#123; OrderConfirmVo orderConfirmVo = orderService.confirmOrder(); model.addAttribute(&quot;orderConfirmData&quot;, orderConfirmVo); return &quot;confirm&quot;;&#125; OrderServiceImpl feign远程调用和页面进入不同，后者会带cookie，前者没有带header所有没有cookie 1234567891011121314151617181920212223242526272829303132333435 /* * 确认订单的信息 */@Overridepublic OrderConfirmVo confirmOrder() throws ExecutionException, InterruptedException &#123; OrderConfirmVo orderConfirmVo = new OrderConfirmVo(); // TODO 设置防重复令牌 // orderConfirmVo.setOrderToken(); // 设置收货地址 (用户id可以从拦截器中的ThreadLocal的loginUser中查找) CompletableFuture&lt;Void&gt; addressFuture = CompletableFuture.runAsync(() -&gt; &#123; R r = memberFeignService.getAddressListByMemberId(OrderLoginUserInterceptor.loginUser.get().getId()); if (r.getCode() == 0) &#123; List&lt;MemberAddressVo&gt; memberAddressVoList = r.getData(&quot;data&quot;, new TypeReference&lt;List&lt;MemberAddressVo&gt;&gt;() &#123; &#125;); orderConfirmVo.setAddress(memberAddressVoList); &#125; else &#123; log.error(&quot;member远程调用失败&quot;); &#125; &#125;, executor); // 设置购物项 （从redis中获取） CompletableFuture&lt;Void&gt; itemFuture = CompletableFuture.runAsync(() -&gt; &#123; List&lt;OrderItemVo&gt; checkedCartItems = cartFeignService.getCheckedCartItems(); orderConfirmVo.setItems(checkedCartItems); &#125;, executor); // 设置总价格 (get方法已经写好了) // 设置优惠价 orderConfirmVo.setIntegration(OrderLoginUserInterceptor.loginUser.get().getIntegration()); // 设置支付价 (get方法已经写好了) CompletableFuture.allOf(itemFuture, addressFuture).get(); return orderConfirmVo;&#125; MemberFeignService12345678@FeignClient(&quot;gulimall-member&quot;)public interface MemberFeignService &#123; /** * 获取对应会员的所有收货地址 */ @GetMapping(&quot;/member/memberreceiveaddress/&#123;memberId&#125;/list&quot;) R getAddressListByMemberId(@PathVariable(&quot;memberId&quot;) Long memberId);&#125; CartFeignService12345678@FeignClient(&quot;gulimall-cart&quot;)public interface CartFeignService &#123; /* * 获得购物车商品 */ @GetMapping(&quot;/checkItems&quot;) List&lt;OrderItemVo&gt; getCheckedCartItems();&#125; Member模块MemberReceiveAddressController12345678/** * 获取对应会员的所有收货地址 */@GetMapping(&quot;/&#123;memberId&#125;/list&quot;)public R getAddressListByMemberId(@PathVariable(&quot;memberId&quot;) Long memberId) &#123; List&lt;MemberReceiveAddressEntity&gt; addressList = memberReceiveAddressService.list(new QueryWrapper&lt;MemberReceiveAddressEntity&gt;().eq(&quot;member_id&quot;, memberId)); return R.ok().put(&quot;data&quot;, addressList);&#125; Cart模块CartServiceImpl1234567891011121314151617/* * 获取用户选中的所有商品 */@Overridepublic List&lt;CartItemEntity&gt; getCheckedCartItems() &#123; // 从redis中根据userId获得cartItem UserInfoTo userInfoTo = CartInterceptor.threadLocal.get(); // 封装list List&lt;CartItemEntity&gt; cartItem = getCartItem(CartConstant.CART_PREFIX + userInfoTo.getUserId()); return cartItem.stream().filter(CartItemEntity::getCheck).map((item) -&gt; &#123; // 存放在redis中的购物项的价格可能会变（冗余字段，用id去查） // 我这里就不写了 // item.setPrice(); return item; &#125;) .collect(Collectors.toList());&#125; CartController123456789/* * 获得购物车商品 */@ResponseBody@GetMapping(&quot;/checkItems&quot;)public List&lt;CartItemEntity&gt; getCheckedCartItems() &#123; List&lt;CartItemEntity&gt; cartItemEntityList = cartService.getCheckedCartItems(); return cartItemEntityList;&#125; TODO 怎么说呢，感觉不是很想写网页前台了，现在写给用户的还是小程序 app这种流行，网页基本就是后台管理了，再加上thymeleaf实在是让人难受，就这样吧，不写了，我把重要的业务逻辑记录一下就行。 唉阻碍我的另一个原因是身体状况，突然理解了讲座的那位学长说的话，多锻炼身体，有体力才能继续啊。 接口幂等性 接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的， 不会因为多次点击而产生了副作用； 比如说支付场景， 用户购买了商品支付扣款成功， 但是返回结果的时候网络异常， 此时钱已经扣了， 用户再次点击按钮， 此时会进行第二次扣款， 返回结果成功， 用户查询余额返发现多扣钱了， 流水记录也变成了两条． ． ． ,这就没有保证接口的幂等性。 哪些情况需要防止 用户多次点击按钮 用户页面回退再次提交 微服务互相调用， 由于网络问题， 导致请求失败。 feign 触发重试机制 其他业务情况 什么情况下需要幂等 以 SQL 为例， 有些操作是天然幂等的。 SELECT * FROM table WHER id=?， 无论执行多少次都不会改变状态， 是天然的幂等。UPDATE tab1 SET col1=1 WHERE col2=2， 无论执行成功多少次状态都是一致的， 也是幂等操作。delete from user where userid=1， 多次操作， 结果一样， 具备幂等性insert into user(userid,name) values(1,’a’) 如 userid 为唯一主键， 即重复操作上面的业务， 只会插入一条用户数据， 具备幂等性。 UPDATE tab1 SET col1=col1+1 WHERE col2=2， 每次执行的结果都会发生变化， 不是幂等的。insert into user(userid,name) values(1,’a’) 如 userid 不是主键， 可以重复， 那上面业务多次操作， 数据都会新增多条， 不具备幂等性。 token 机制 1、 服务端提供了发送 token 的接口。 我们在分析业务的时候， 哪些业务是存在幂等问题的，就必须在执行业务前， 先去获取 token， 服务器会把 token 保存到 redis 中。2、然后调用业务接口请求时， 把 token 携带过去， 一般放在请求头部。3、 服务器判断 token 是否存在 redis 中， 存在表示第一次请求， 然后删除 token,继续执行业务。4、 如果判断 token 不存在 redis 中， 就表示是重复操作， 直接返回重复标记给 client， 这样就保证了业务代码， 不被重复执行。 危险性：1、 先删除 token 还是后删除 token； (1) 先删除可能导致， 业务确实没有执行， 重试还带上之前 token， 由于防重设计导致，请求还是不能执行。 (2) 后删除可能导致， 业务处理成功， 但是服务闪断， 出现超时， 没有删除 token， 别人继续重试， 导致业务被执行两边 (3) 我们最好设计为先删除 token， 如果业务调用失败， 就重新获取 token 再次请求。2、 Token 获取、 比较和删除必须是原子性 (1) redis.get(token) 、 token.equals、 redis.del(token)如果这两个操作不是原子， 可能导致， 高并发下， 都 get 到同样的数据， 判断都成功， 继续业务并发执行 (2) 可以在 redis 使用 lua 脚本完成这个操作 if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end 各种锁机制数据库悲观锁 select * from xxxx where id = 1 for update;悲观锁使用时一般伴随事务一起使用， 数据锁定时间可能会很长， 需要根据实际情况选用。另外要注意的是， id 字段一定是主键或者唯一索引， 不然可能造成锁表的结果， 处理起来会非常麻烦。 数据库乐观锁 这种方法适合在更新的场景中，update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1根据 version 版本， 也就是在操作库存前先获取当前商品的 version 版本号， 然后操作的时候带上此 version 号。 我们梳理下， 我们第一次操作库存时， 得到 version 为 1， 调用库存服务version 变成了 2； 但返回给订单服务出现了问题， 订单服务又一次发起调用库存服务， 当订单服务传如的 version 还是 1， 再执行上面的 sql 语句时， 就不会执行； 因为 version 已经变为 2 了， where 条件就不成立。 这样就保证了不管调用几次， 只会真正的处理一次。乐观锁主要使用于处理读多写少的问题 业务层分布式锁 如果多个机器可能在同一时间同时处理相同的数据， 比如多台机器定时任务都拿到了相同数据处理， 我们就可以加分布式锁， 锁定此数据， 处理完成后释放锁。 获取到锁的必须先判断这个数据是否被处理过。 各种唯一约束数据库唯一约束 插入数据， 应该按照唯一索引进行插入， 比如订单号， 相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。这个机制是利用了数据库的主键唯一约束的特性， 解决了在 insert 场景时幂等问题。 但主键的要求不是自增的主键， 这样就需要业务生成全局唯一的主键。如果是分库分表场景下， 路由规则要保证相同请求下， 落地在同一个数据库和同一表中， 要不然数据库主键约束就不起效果了， 因为是不同的数据库和表主键不相关。 redis set 防重 很多数据需要处理， 只能被处理一次， 比如我们可以计算数据的 MD5 将其放入 redis 的 set，每次处理数据， 先看这个 MD5 是否已经存在， 存在就不处理 防重表 使用订单号 orderNo 做为去重表的唯一索引， 把唯一索引插入去重表， 再进行业务操作， 且他们在同一个事务中。 这个保证了重复请求时， 因为去重表有唯一约束， 导致请求失败， 避免了幂等问题。 这里要注意的是， 去重表和业务表应该在同一库中， 这样就保证了在同一个事务， 即使业务操作失败了， 也会把去重表的数据回滚。 这个很好的保证了数据一致性。之前说的 redis 防重也算 全局请求唯一 id 调用接口时， 生成一个唯一 id， redis 将数据保存到集合中（去重） ， 存在即处理过。可以使用 nginx 设置每一个请求的唯一 id；proxy_set_header X-Request-Id $request_id; 订单提交 token添加token123String token = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);redisTemplate.opsForValue().set(AuthServerConstant.USER_ORDER_TOKEN_PREFIX + memberRespVo.getId(), token, 30, TimeUnit.MINUTES);confirmVo.setOrderToken(token); 原子验证token12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Transaction // 本第事务，只能控制自己服务的事务@Override public SubmitOrderResponseVo submitOrder(OrderSubmitVo vo) &#123; confirmVoThreadLocal.set(vo); SubmitOrderResponseVo response = new SubmitOrderResponseVo(); MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get(); response.setCode(0); //1、验证令牌【令牌的对比和删除必须保证原子性】 //0令牌失败 - 1删除成功 String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;; String orderToken = vo.getOrderToken(); //原子验证令牌和删除令牌 Long result = redisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList(OrderConstant.USER_ORDER_TOKEN_PREFIX + memberRespVo.getId()), orderToken); if (result == 0L) &#123; //令牌验证失败 response.setCode(1); return response; &#125; else &#123; //令牌验证成功 //下单：去创建订单，验令牌，验价格，锁库存... //1、创建订单，订单项等信息 OrderCreateTo order = createOrder(); //2、验价 BigDecimal payAmount = order.getOrder().getPayAmount(); BigDecimal payPrice = vo.getPayPrice(); if (Math.abs(payAmount.subtract(payPrice).doubleValue()) &lt; 0.01) &#123; //金额对比 //.... //TODO 3、保存订单 saveOrder(order); //4、库存锁定。只要有异常回滚订单数据。 // 订单号，所有订单项（skuId，skuName，num） WareSkuLockVo lockVo = new WareSkuLockVo(); lockVo.setOrderSn(order.getOrder().getOrderSn()); List&lt;OrderItemVo&gt; locks = order.getOrderItems().stream().map(item -&gt; &#123; OrderItemVo itemVo = new OrderItemVo(); itemVo.setSkuId(item.getSkuId()); itemVo.setCount(item.getSkuQuantity()); itemVo.setTitle(item.getSkuName()); return itemVo; &#125;).collect(Collectors.toList()); lockVo.setLocks(locks); //4、远程锁库存 //库存成功了，但是网络原因超时了，订单回滚，库存不滚。 //为了保证高并发。库存服务自己回滚。可以发消息给库存服务； //库存服务本身也可以使用自动解锁模式 消息 R r = wmsFeignService.orderLockStock(lockVo); if (r.getCode() == 0) &#123; //锁成功了 response.setOrder(order.getOrder()); //TODO 5、远程扣减积分 出异常// int i = 10/0; //订单回滚，库存不滚 //订单创建成功发送消息给MQ rabbitTemplate.convertAndSend(&quot;order-event-exchange&quot;, &quot;order.create.order&quot;, order.getOrder()); //TODO 6、清除购物车已经下单的商品 return response; &#125; else &#123; //锁定失败 String msg = (String) r.get(&quot;msg&quot;); throw new NoStockException(msg); &#125; &#125; else &#123; response.setCode(2); return response; &#125; &#125; 分布式事务本地事务 详见文档 事务的隔离级别 READ UNCOMMITTED（读未提交）该隔离级别的事务会读到其它未提交事务的数据， 此现象也称之为脏读。 READ COMMITTED（ 读提交）一个事务可以读取另一个已提交的事务， 多次读取会造成不一样的结果， 此现象称为不可重复读问题， Oracle 和 SQL Server 的默认隔离级别。 REPEATABLE READ（ 可重复读）该隔离级别是 MySQL 默认的隔离级别， 在同一个事务里， select 的结果是事务开始时时间点的状态， 因此， 同样的 select 操作读到的结果会是一致的， 但是， 会有幻读现象。 MySQL的 InnoDB 引擎可以通过 next-key locks 机制（ 参考下文”行锁的算法”一节） 来避免幻读。 SERIALIZABLE（ 序列化）在该隔离级别下事务都是串行顺序执行的， MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁， 从而避免了脏读、 不可重读复读和幻读问题。 事务的传播行为 1、 PROPAGATION_REQUIRED： 如果当前没有事务， 就创建一个新事务， 如果当前存在事务，就加入该事务， 该设置是最常用的设置。2、 PROPAGATION_SUPPORTS： 支持当前事务， 如果当前存在事务， 就加入该事务， 如果当前不存在事务， 就以非事务执行。3、 PROPAGATION_MANDATORY： 支持当前事务， 如果当前存在事务， 就加入该事务， 如果当前不存在事务， 就抛出异常。4、 PROPAGATION_REQUIRES_NEW： 创建新事务， 无论当前存不存在事务， 都创建新事务。5、 PROPAGATION_NOT_SUPPORTED： 以非事务方式执行操作， 如果当前存在事务， 就把当前事务挂起。6、 PROPAGATION_NEVER： 以非事务方式执行， 如果当前存在事务， 则抛出异常。7、 PROPAGATION_NESTED： 如果当前存在事务， 则在嵌套事务内执行。 如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"微服务","slug":"微服务","permalink":"http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"【项目笔记】商城项目实战6","slug":"【项目笔记】商城项目实战6","date":"2021-11-17T04:50:09.771Z","updated":"2021-11-20T09:34:26.432Z","comments":true,"path":"2021/11/17/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-6/","link":"","permalink":"http://example.com/2021/11/17/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-6/","excerpt":"","text":"认证服务 - 短信验证码基础环境搭建配置 开启nacos，feign 123456789101112131415161718192021# springspring: # nacos 注册中心 cloud: nacos: discovery: # nacos地址 server-addr: 127.0.0.1:8848 # 服务名 application: name: gulimall-auto-server jackson: # 时间戳格式化 date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 thymeleaf: # thymeleaf缓存 cache: false#服务器server: port: 20000 资源 放入登录注册页面文件，静态资源放到nacos中 配置 host gateway viewController templates下不为index名的html页面都需要通过controller映射后跳转 如果只是跳转不写任何其他方法，可以使用viewController 1234567891011@Configurationpublic class MyWebConfig implements WebMvcConfigurer &#123; /* * 重写，可以添加urlPath和视图名的对应映射 */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/login.html&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/reg.html&quot;).setViewName(&quot;reg&quot;); &#125;&#125; 发送验证码倒计时 使用定时器 12345678910&lt;!-- 验证码 --&gt;&lt;div class=&quot;register-box&quot;&gt; &lt;label class=&quot;other_label&quot;&gt;验 证 码 &lt;input name=&quot;code&quot; maxlength=&quot;20&quot; type=&quot;text&quot; placeholder=&quot;请输入验证码&quot; class=&quot;caa&quot;&gt; &lt;/label&gt; &lt;a id=&quot;sendCode&quot;&gt; 发送验证码 &lt;/a&gt; &lt;div class=&quot;tips&quot; style=&quot;color:red&quot; th:text=&quot;$&#123;errors!=null?(#maps.containsKey(errors, &#x27;code&#x27;)?errors.code:&#x27;&#x27;):&#x27;&#x27;&#125;&quot;&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031$(function () &#123; $(&quot;#sendCode&quot;).click(function () &#123; //2、倒计时 if ($(this).hasClass(&quot;disabled&quot;)) &#123; //正在倒计时。 &#125; else &#123; //1、给指定手机号发送验证码 $.get(&quot;/sms/sendcode?phone=&quot; + $(&quot;#phoneNum&quot;).val(), function (data) &#123; if (data.code != 0) &#123; alert(data.msg); &#125; &#125;); timeoutChangeStyle(); &#125; &#125;);&#125;)var num = 60;function timeoutChangeStyle() &#123; $(&quot;#sendCode&quot;).attr(&quot;class&quot;, &quot;disabled&quot;); if (num == 0) &#123; $(&quot;#sendCode&quot;).text(&quot;发送验证码&quot;); num = 60; $(&quot;#sendCode&quot;).attr(&quot;class&quot;, &quot;&quot;); &#125; else &#123; var str = num + &quot;s 后再次发送&quot;; $(&quot;#sendCode&quot;).text(str); setTimeout(&quot;timeoutChangeStyle()&quot;, 1000); &#125; num--;&#125; 短信验证码 写在第三方工具的模块中 HttpClient123456789/** * 重要提示如下: * HttpUtils请从 * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java * 下载 * * 相应的依赖请参照 * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318package com.atguigu.gulimall.thirdparty.utils;import org.apache.commons.lang.StringUtils;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.HttpClient;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpDelete;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.HttpPut;import org.apache.http.conn.ClientConnectionManager;import org.apache.http.conn.scheme.Scheme;import org.apache.http.conn.scheme.SchemeRegistry;import org.apache.http.conn.ssl.SSLSocketFactory;import org.apache.http.entity.ByteArrayEntity;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.message.BasicNameValuePair;import javax.net.ssl.SSLContext;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import java.security.cert.X509Certificate;import java.util.ArrayList;import java.util.List;import java.util.Map;public class HttpUtils &#123; /** * get * * @param host * @param path * @param method * @param headers * @param querys * @return * @throws Exception */ public static HttpResponse doGet(String host, String path, String method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; querys) throws Exception &#123; HttpClient httpClient = wrapClient(host); HttpGet request = new HttpGet(buildUrl(host, path, querys)); for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123; request.addHeader(e.getKey(), e.getValue()); &#125; return httpClient.execute(request); &#125; /** * post form * * @param host * @param path * @param method * @param headers * @param querys * @param bodys * @return * @throws Exception */ public static HttpResponse doPost(String host, String path, String method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; querys, Map&lt;String, String&gt; bodys) throws Exception &#123; HttpClient httpClient = wrapClient(host); HttpPost request = new HttpPost(buildUrl(host, path, querys)); for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123; request.addHeader(e.getKey(), e.getValue()); &#125; if (bodys != null) &#123; List&lt;NameValuePair&gt; nameValuePairList = new ArrayList&lt;NameValuePair&gt;(); for (String key : bodys.keySet()) &#123; nameValuePairList.add(new BasicNameValuePair(key, bodys.get(key))); &#125; UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(nameValuePairList, &quot;utf-8&quot;); formEntity.setContentType(&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;); request.setEntity(formEntity); &#125; return httpClient.execute(request); &#125; /** * Post String * * @param host * @param path * @param method * @param headers * @param querys * @param body * @return * @throws Exception */ public static HttpResponse doPost(String host, String path, String method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; querys, String body) throws Exception &#123; HttpClient httpClient = wrapClient(host); HttpPost request = new HttpPost(buildUrl(host, path, querys)); for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123; request.addHeader(e.getKey(), e.getValue()); &#125; if (StringUtils.isNotBlank(body)) &#123; request.setEntity(new StringEntity(body, &quot;utf-8&quot;)); &#125; return httpClient.execute(request); &#125; /** * Post stream * * @param host * @param path * @param method * @param headers * @param querys * @param body * @return * @throws Exception */ public static HttpResponse doPost(String host, String path, String method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; querys, byte[] body) throws Exception &#123; HttpClient httpClient = wrapClient(host); HttpPost request = new HttpPost(buildUrl(host, path, querys)); for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123; request.addHeader(e.getKey(), e.getValue()); &#125; if (body != null) &#123; request.setEntity(new ByteArrayEntity(body)); &#125; return httpClient.execute(request); &#125; /** * Put String * * @param host * @param path * @param method * @param headers * @param querys * @param body * @return * @throws Exception */ public static HttpResponse doPut(String host, String path, String method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; querys, String body) throws Exception &#123; HttpClient httpClient = wrapClient(host); HttpPut request = new HttpPut(buildUrl(host, path, querys)); for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123; request.addHeader(e.getKey(), e.getValue()); &#125; if (StringUtils.isNotBlank(body)) &#123; request.setEntity(new StringEntity(body, &quot;utf-8&quot;)); &#125; return httpClient.execute(request); &#125; /** * Put stream * * @param host * @param path * @param method * @param headers * @param querys * @param body * @return * @throws Exception */ public static HttpResponse doPut(String host, String path, String method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; querys, byte[] body) throws Exception &#123; HttpClient httpClient = wrapClient(host); HttpPut request = new HttpPut(buildUrl(host, path, querys)); for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123; request.addHeader(e.getKey(), e.getValue()); &#125; if (body != null) &#123; request.setEntity(new ByteArrayEntity(body)); &#125; return httpClient.execute(request); &#125; /** * Delete * * @param host * @param path * @param method * @param headers * @param querys * @return * @throws Exception */ public static HttpResponse doDelete(String host, String path, String method, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; querys) throws Exception &#123; HttpClient httpClient = wrapClient(host); HttpDelete request = new HttpDelete(buildUrl(host, path, querys)); for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) &#123; request.addHeader(e.getKey(), e.getValue()); &#125; return httpClient.execute(request); &#125; private static String buildUrl(String host, String path, Map&lt;String, String&gt; querys) throws UnsupportedEncodingException &#123; StringBuilder sbUrl = new StringBuilder(); sbUrl.append(host); if (!StringUtils.isBlank(path)) &#123; sbUrl.append(path); &#125; if (null != querys) &#123; StringBuilder sbQuery = new StringBuilder(); for (Map.Entry&lt;String, String&gt; query : querys.entrySet()) &#123; if (0 &lt; sbQuery.length()) &#123; sbQuery.append(&quot;&amp;&quot;); &#125; if (StringUtils.isBlank(query.getKey()) &amp;&amp; !StringUtils.isBlank(query.getValue())) &#123; sbQuery.append(query.getValue()); &#125; if (!StringUtils.isBlank(query.getKey())) &#123; sbQuery.append(query.getKey()); if (!StringUtils.isBlank(query.getValue())) &#123; sbQuery.append(&quot;=&quot;); sbQuery.append(URLEncoder.encode(query.getValue(), &quot;utf-8&quot;)); &#125; &#125; &#125; if (0 &lt; sbQuery.length()) &#123; sbUrl.append(&quot;?&quot;).append(sbQuery); &#125; &#125; return sbUrl.toString(); &#125; private static HttpClient wrapClient(String host) &#123; HttpClient httpClient = new DefaultHttpClient(); if (host.startsWith(&quot;https://&quot;)) &#123; sslClient(httpClient); &#125; return httpClient; &#125; private static void sslClient(HttpClient httpClient) &#123; try &#123; SSLContext ctx = SSLContext.getInstance(&quot;TLS&quot;); X509TrustManager tm = new X509TrustManager() &#123; @Override public X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; @Override public void checkClientTrusted(X509Certificate[] xcs, String str) &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] xcs, String str) &#123; &#125; &#125;; ctx.init(null, new TrustManager[]&#123;tm&#125;, null); SSLSocketFactory ssf = new SSLSocketFactory(ctx); ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); ClientConnectionManager ccm = httpClient.getConnectionManager(); SchemeRegistry registry = ccm.getSchemeRegistry(); registry.register(new Scheme(&quot;https&quot;, 443, ssf)); &#125; catch (KeyManagementException ex) &#123; throw new RuntimeException(ex); &#125; catch (NoSuchAlgorithmException ex) &#123; throw new RuntimeException(ex); &#125; &#125;&#125; HttpClient是阿里云已经封装好的 阿里云搜短信，然后找到下面的第三方提供的服务，不过模板要联系客服？我不理解 这块不记录了，短信还是用不了 SmsComponent1234567891011121314151617181920212223242526272829303132333435363738@ConfigurationProperties(prefix = &quot;gulimall.alicloud.sms&quot;) // 外部化配置@Component@Datapublic class SmsComponent &#123; private String host; private String path; private String appcode; // 发送短信验证码 public void sendCode(String phone, String code) &#123; String method = &quot;POST&quot;; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105 headers.put(&quot;Authorization&quot;, &quot;APPCODE &quot; + appcode); Map&lt;String, String&gt; querys = new HashMap&lt;String, String&gt;(); querys.put(&quot;content&quot;, &quot;【gulimall】你的验证码是：&quot; + code + &quot;，3分钟内有效！&quot;); querys.put(&quot;mobile&quot;, phone); Map&lt;String, String&gt; bodys = new HashMap&lt;String, String&gt;(); try &#123; /** * 重要提示如下: * HttpUtils请从 * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java * 下载 * * 相应的依赖请参照 * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml */ HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys); System.out.println(response.toString()); //获取response的body //System.out.println(EntityUtils.toString(response.getEntity())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567# 自定义 短信服务配置gulimall: alicloud: sms: host: https://cxwg.market.alicloudapi.com path: /sendSms appcode: 你自己的AppCode SmsSendController1234567891011121314151617@RestController@RequestMapping(&quot;/sms&quot;)public class SmsSendController &#123; @Autowired SmsComponent smsComponent; /* * 提供调用接口 */ @GetMapping(&quot;/sms/sendCode&quot;) public R sendCode(@RequestParam(&quot;phone&quot;) String phone, @RequestParam(&quot;code&quot;) String code) &#123; smsComponent.sendCode(phone, code); return R.ok(); &#125;&#125; 远程调用发送短信验证码服务 auth模块调用third-part模块的短信服务 ThirdPartFeignService12345678910111213141516package com.atguigu.gulimall.auth.feign;import com.atguigu.common.utils.R;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;/* * 第三方服务的远程接口 */@FeignClientpublic interface ThirdPartFeignService &#123; // 远程调用发送短信验证码服务 @GetMapping(&quot;/sms/sendCode&quot;) R sendCode(@RequestParam(&quot;phone&quot;) String phone, @RequestParam(&quot;code&quot;) String code);&#125; LoginController12345678910111213@RestControllerpublic class LoginController &#123; @Autowired ThirdPartFeignService thirdPartFeignService; @ResponseBody @GetMapping(&quot;/sms/sendcode&quot;) public R sendCode(@RequestParam(&quot;phone&quot;) String phone) &#123; // 随机生成验证码 String code = UUID.randomUUID().toString().substring(0, 5); thirdPartFeignService.sendCode(phone, code); return R.ok(); &#125;&#125; 验证码防刷验证 防刷+校验时间 使用redis并配置好地址 12345678910111213141516171819202122232425262728293031@RestControllerpublic class LoginController &#123; @Autowired ThirdPartFeignService thirdPartFeignService; @Autowired StringRedisTemplate redisTemplate; @ResponseBody @GetMapping(&quot;/sms/sendcode&quot;) public R sendCode(@RequestParam(&quot;phone&quot;) String phone) &#123; // 判断redis中是否有该手机号的验证码，并且在过期时间内 String existCode = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREDIX + phone); if (!StringUtils.isEmpty(existCode)) &#123; long preTime = Long.parseLong(existCode.split(&quot;_&quot;)[1]); if ((System.currentTimeMillis() - preTime) &lt; 60000) &#123; // 存在小于六十秒，不能再发验证码 return R.error(BizCodeEnum.SMS_CODE_EXCEPTION.getCode(), BizCodeEnum.SMS_CODE_EXCEPTION.getMsg()); &#125; &#125; // 随机生成验证码+系统时间，防刷 String code = UUID.randomUUID().toString().substring(0, 5); // 存入redis(key:value == prefix+phone:code)，并设置超时时间 redisTemplate.opsForValue().set(AuthServerConstant.SMS_CODE_CACHE_PREDIX + phone, code + &quot;_&quot; + System.currentTimeMillis(), 10, TimeUnit.MINUTES); // 发送短信 thirdPartFeignService.sendCode(phone, code); return R.ok(); &#125;&#125; 认证服务 - 注册 使用JSR303校验 Auth模块UserRegistVo123456789101112131415161718@Datapublic class UserRegistVo &#123; // JSR303校验 @NotEmpty(message = &quot;用户名必须提交&quot;) @Length(min = 6, max = 18, message = &quot;用户名必须是6-18位字符&quot;) private String userName; @NotEmpty(message = &quot;密码必须填写&quot;) @Length(min = 6, max = 18, message = &quot;密码必须是6-18位字符&quot;) private String password; @NotEmpty(message = &quot;手机号必须填写&quot;) @Pattern(regexp = &quot;^[1]([3-9])[0-9]&#123;9&#125;$&quot;, message = &quot;手机号格式不正确&quot;) private String phone; @NotEmpty(message = &quot;验证码必须填写&quot;) private String code;&#125; MemberFeignService12345678@FeignClient(&quot;gulimall-member&quot;)public interface MemberFeignService &#123; /** * 注册会员 */ @PostMapping(&quot;/member/member/regist&quot;) R regist(@RequestBody UserRegistVo registVo);&#125; LoginController1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@PostMapping(&quot;/regist&quot;)public String register(@Valid UserRegistVo vo, BindingResult bindingResult, RedirectAttributes attributes) &#123; if (bindingResult.hasErrors()) &#123; Map&lt;String, String&gt; errors = bindingResult.getFieldErrors().stream().collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage)); // 校验有错误 // RedirectAttributes 用于重定向带数据 attributes.addFlashAttribute(&quot;errors&quot;, errors); return &quot;redirect:http://auth.gulimall.com/reg.html&quot;; &#125; // 远程注册服务 // 1 校验验证码 String inputCode = vo.getCode(); String existCode = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREDIX + vo.getPhone()); if (!StringUtils.isEmpty(existCode)) &#123; if (inputCode.equals(existCode.split(&quot;_&quot;)[0])) &#123; // 验证码正确 // 删除验证码 redisTemplate.delete(AuthServerConstant.SMS_CODE_CACHE_PREDIX + vo.getPhone()); // 远程调用会员服务 R r = memberFeignService.regist(vo); if (r.getCode() == 0) &#123; // 注册成功 return &quot;redirect:http://auth.gulimall.com/login.html&quot;; &#125; else &#123; // 远程服务异常 Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;(); errors.put(&quot;msg&quot;, r.getMsg()); attributes.addFlashAttribute(&quot;errors&quot;, errors); return &quot;redirect:http://auth.gulimall.com/reg.html&quot;; &#125; &#125; else &#123; // 验证码错误 Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;(); errors.put(&quot;code&quot;, &quot;验证码错误&quot;); attributes.addFlashAttribute(&quot;errors&quot;, errors); return &quot;redirect:http://auth.gulimall.com/reg.html&quot;; &#125; &#125; else &#123; // 不存在验证码 Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;(); errors.put(&quot;code&quot;, &quot;验证码错误&quot;); attributes.addFlashAttribute(&quot;errors&quot;, errors); return &quot;redirect:http://auth.gulimall.com/reg.html&quot;; &#125;&#125; Member模块MemberController123456789101112131415161718192021@RestController@RequestMapping(&quot;member/member&quot;)public class MemberController &#123; @Autowired private MemberService memberService; /** * 注册会员 */ @PostMapping(&quot;/regist&quot;) public R regist(@RequestBody UserRegistVo registVo) &#123; try &#123; // 可能会抛已存在的异常 memberService.regist(registVo); &#125; catch (PhoneExistException e) &#123; return R.error(BizCodeEnum.PHONE_EXIST_EXCEPTION.getCode(), BizCodeEnum.PHONE_EXIST_EXCEPTION.getMsg()); &#125; catch (UsernameExistException e) &#123; return R.error(BizCodeEnum.USERNAME_EXIST_EXCEPTION.getCode(), BizCodeEnum.USERNAME_EXIST_EXCEPTION.getMsg()); &#125; return R.ok(); &#125; MemberServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142@Service(&quot;memberService&quot;)public class MemberServiceImpl extends ServiceImpl&lt;MemberDao, MemberEntity&gt; implements MemberService &#123; @Autowired MemberLevelService levelService; @Override public void regist(UserRegistVo registVo) &#123; // 检查用户名和手机号的唯一性 MemberEntity member = new MemberEntity(); member.setUsername(registVo.getUserName()); member.setMobile(registVo.getPhone()); member.setLevelId(levelService.getDefaultLevel().getId()); // 判断是否已存在 checkPhoneUnique(registVo.getPhone()); checkUsernameUnique(registVo.getUserName()); // 加密 BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); member.setPassword(passwordEncoder.encode(registVo.getPassword())); baseMapper.insert(member); &#125; @Override public void checkPhoneUnique(String phone) throws PhoneExistException &#123; Integer mobile = baseMapper.selectCount(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;mobile&quot;, phone)); if (mobile &gt; 0) &#123; throw new PhoneExistException(); &#125; &#125; @Override public void checkUsernameUnique(String username) throws UsernameExistException &#123; Integer existUsername = baseMapper.selectCount(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;username&quot;, username)); if (existUsername &gt; 0) &#123; throw new UsernameExistException(); &#125; &#125;&#125; 异常机制异常类UsernameExistException12345public class UsernameExistException extends RuntimeException &#123; public UsernameExistException() &#123; super(&quot;用户名已存在&quot;); &#125;&#125; 异常类PhoneExistException12345public class PhoneExistException extends RuntimeException &#123; public PhoneExistException() &#123; super(&quot;手机号已存在&quot;); &#125;&#125; MD5盐值加密 MD5可以使用彩虹表暴力破解，所以需要加盐 认证服务 - 账号登录Auth模块UserLoginVo12345@Datapublic class UserLoginVo &#123; private String loginacct; private String password;&#125; MemberFeignService1234567891011121314@FeignClient(&quot;gulimall-member&quot;)public interface MemberFeignService &#123; /** * 注册会员 */ @PostMapping(&quot;/member/member/regist&quot;) R regist(@RequestBody UserRegistVo registVo); /** * 会员登录 */ @PostMapping(&quot;/member/member/login&quot;) R login(@RequestBody UserLoginVo loginVo);&#125; LoginController1234567891011121314151617181920@PostMapping(&quot;/login&quot;)public String login(UserLoginVo vo, RedirectAttributes attributes) &#123; R r = memberFeignService.login(vo); if (r.getCode() == 0) &#123; // 登录成功 // r取出来的值为map类型，map -&gt; json -&gt; bean String memberJSON = JSONObject.toJSONString(r.get(&quot;member&quot;)); MemberEntityVo memberEntityVo = JSON.parseObject(memberJSON, MemberEntityVo.class); log.info(&quot;登陆成功，用户：&#123;&#125;&quot;, memberJSON); // 保存用户信息至session,注意这里对象的类必须实现序列化，才能保存到redis中 session.setAttribute(AuthServerConstant.LOGIN_USER, memberEntityVo); return &quot;redirect:http://gulimall.com&quot;; &#125; else &#123; // 账号或密码错误 Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;(); errors.put(&quot;msg&quot;, r.getMsg()); attributes.addFlashAttribute(&quot;errors&quot;, errors); return &quot;redirect:http://auth.gulimall.com/login.html&quot;; &#125;&#125; Member模块MemberController1234567891011/** * 会员登录 */@PostMapping(&quot;/login&quot;)public R login(@RequestBody UserLoginVo loginVo) &#123; MemberEntity member = memberService.login(loginVo); if (member == null) &#123; return R.error(BizCodeEnum.LOGIN_FAILED_EXCEPTION.getCode(), BizCodeEnum.LOGIN_FAILED_EXCEPTION.getMsg()); &#125; return R.ok().put(&quot;member&quot;, member);&#125; MemberServiceImpl123456789101112131415@Overridepublic MemberEntity login(UserLoginVo loginVo) &#123; String loginacct = loginVo.getLoginacct(); String password = loginVo.getPassword(); MemberEntity member = baseMapper.selectOne(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;username&quot;, loginacct).or().eq(&quot;mobile&quot;, loginacct)); if (member != null) &#123; // 判断密码是否匹配 BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); boolean matches = passwordEncoder.matches(password, member.getPassword()); return matches ? member : null; &#125; else &#123; // 该账号不存在 return null; &#125;&#125; 认证服务 - 社交登录OAuth2 OAuth： OAuth（开放授权） 是一个开放标准， 允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息， 而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。 OAuth2.0： 对于用户相关的 OpenAPI（例如获取用户信息， 动态同步， 照片， 日志， 分享等） ， 为了保护用户数据的安全和隐私， 第三方网站访问用户数据前都需要显式的向用户征求授权 gitee授权登录接口测试 gitee进入修改资料 -&gt; 第三方应用 -&gt; 创建应用，然后根据文档操作即可。 Gitee OAuth 文档 GiteeUserVo12345678910@Datapublic class GiteeUserVo &#123; private String access_token; private String token_type; private long expires_in; private String refresh_token; private String scope; private long created_at; private String uid;&#125; MemberServiceImpl12345678910111213141516171819202122@Overridepublic MemberEntity giteeLogin(GiteeUserVo loginVo, JSONObject userInfoJson) &#123; // 判断当前社交用户是否曾注册过（根据uid判断） MemberEntity selectMember = baseMapper.selectOne(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;gitee_uid&quot;, loginVo.getGitee_uid())); if (selectMember != null) &#123; // 该用户已注册，更换令牌和过期时间 selectMember.setAccessToken(selectMember.getAccessToken()); selectMember.setExpiresIn(selectMember.getExpiresIn()); baseMapper.updateById(selectMember); return selectMember; &#125; else &#123; // 获取授权用户的信息存入自己的数据库 MemberEntity registMember = new MemberEntity(); registMember.setUsername((String) userInfoJson.get(&quot;name&quot;)); registMember.setLevelId(levelService.getDefaultLevel().getId()); registMember.setGiteeUid(userInfoJson.getString(&quot;id&quot;)); registMember.setAccessToken(loginVo.getAccess_token()); registMember.setExpiresIn(loginVo.getExpires_in()); baseMapper.insert(registMember); return registMember; &#125;&#125; MemberController1234567891011/** * gitee会员登录 */@PostMapping(&quot;/giteelogin&quot;)public R loginOAuth(@RequestBody GiteeUserVo loginVo, JSONObject userInfoJson) &#123; MemberEntity member = memberService.giteeLogin(loginVo, userInfoJson); if (member == null) &#123; return R.error(BizCodeEnum.LOGIN_FAILED_EXCEPTION.getCode(), BizCodeEnum.LOGIN_FAILED_EXCEPTION.getMsg()); &#125; return R.ok().put(&quot;member&quot;, member);&#125; MemberFeignService12345678@FeignClient(&quot;gulimall-member&quot;)public interface MemberFeignService &#123; /** * gitee会员登录 */ @PostMapping(&quot;/member/member/giteelogin&quot;) R loginOAuth(@RequestBody GiteeUserVo loginVo, JSONObject userInfoJson);&#125; OAuth2Controller12345678910111213141516171819202122232425262728293031323334@GetMapping(&quot;/oauth2/gitee/success&quot;)public String gitee(@RequestParam(&quot;code&quot;) String code, RedirectAttributes attributes) throws Exception &#123; // 根据code授权码获取token Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;grant_type&quot;, &quot;authorization_code&quot;); map.put(&quot;code&quot;, code); map.put(&quot;client_id&quot;, &quot;&quot;); map.put(&quot;redirect_uri&quot;, &quot;http://auth.gulimall.com/oauth2/gitee/success&quot;); map.put(&quot;client_secret&quot;, &quot;&quot;); HttpResponse response = HttpUtils.doPost(&quot;https://gitee.com&quot;, &quot;/oauth/token&quot;, &quot;post&quot;, new HashMap&lt;&gt;(), new HashMap&lt;&gt;(), map); // 根据token获取用户信息 if (response.getStatusLine().getStatusCode() == 200) &#123; // 获取成功 String json = EntityUtils.toString(response.getEntity()); GiteeUserVo giteeUserVo = JSON.parseObject(json, GiteeUserVo.class); // 如果该用户第一次进入，则自动生成账号，否则登录 HttpResponse userInfoResponse = HttpUtils.doPost(&quot;https://gitee.com&quot;, &quot;/api/v5/user&quot;, &quot;get&quot;, new HashMap&lt;&gt;(), new HashMap&lt;&gt;(), new HashMap&lt;String, String&gt;().put(&quot;access_token&quot;, giteeUserVo.getAccess_token())); if (userInfoResponse.getStatusLine().getStatusCode() == 200) &#123; JSONObject userInfoJson = JSON.parseObject(EntityUtils.toString(userInfoResponse.getEntity())); R r = memberFeignService.loginOAuth(giteeUserVo, userInfoJson); if (r.getCode() == 0) &#123; // 获得登录后的member对象 MemberEntityVo member = (MemberEntityVo) r.get(&quot;member&quot;); log.info(&quot;登陆成功，用户：&#123;&#125;&quot;, member.toString()); return &quot;redirect:http://gulimall.com&quot;; &#125; &#125; &#125; Map&lt;String, String&gt; errors = new HashMap&lt;String, String&gt;(); errors.put(&quot;msg&quot;, &quot;授权登录失败&quot;); attributes.addFlashAttribute(&quot;errors&quot;, errors); return &quot;redirect:http://auth.gulimall.com/login.html&quot;;&#125; TODO gitee根据token获取userInfo被拒绝了，405not allowed，不清楚为啥，但是postman就能行，可能和httpClient有关 TODO post请求不能多个requestbody，所以我把获取userinfo放到了memberservice中，只需要传一个giteeUserVo即可 认证服务 - 登录判断 使用session，如果不用session的话参考上一个项目，使用jwt token 分布式下的session分布式下session问题 分布式下session解决方法 session复制 客户端存储 hash一致性 统一存储 不同服务，子域session共享 SpringSession Spring Session - Spring Boot :: Spring Session 依赖 配置1234567&lt;dependencies&gt;&lt;!-- spring session --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1234spring.session.store-type=redis # Session store type.spring.redis.host=localhost # Redis server host.spring.redis.password= # Login password of the redis server.spring.redis.port=6379 # Redis server port. 12@EnableRedisHttpSession // 开启spring sessionpublic class GulimallAuthServerApplication &#123; 简单使用123456// r取出来的值为map类型，map -&gt; json -&gt; beanString memberJSON = JSONObject.toJSONString(r.get(&quot;member&quot;));MemberEntityVo memberEntityVo = JSON.parseObject(memberJSON, MemberEntityVo.class);log.info(&quot;登陆成功，用户：&#123;&#125;&quot;, memberJSON);// 保存用户信息至session,注意这里对象的类必须实现序列化，才能保存到redis中session.setAttribute(&quot;loginUser&quot;, memberEntityVo); Cannot deserialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: 清空redis 自定义SpringSession配置 用于放大作用域，使得跨域的时候还能使用session中的内容 放到common里 12345678910111213141516171819202122@Configuration@EnableRedisHttpSession // 开启spring sessionpublic class MySessionConfig &#123; /* * 配置cookie的相关信息：作用域和名字 */ @Bean public CookieSerializer cookieSerializer() &#123; DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer(); cookieSerializer.setDomainName(&quot;gulimall.com&quot;); cookieSerializer.setCookieName(&quot;GULIMALL_SESSION&quot;); return cookieSerializer; &#125; @Bean public RedisSerializer&lt;Object&gt; redisSerializer() &#123; GenericJackson2JsonRedisSerializer redisSerializer = new GenericJackson2JsonRedisSerializer(); return redisSerializer; &#125;&#125; 原理 @EnableRedisHttpSession导入RedisHttpSessionConfiguration配置 给容器中添加了一个组件SessionRepository ==&gt; RedisOperationsSessionRepository ==&gt; redis操作session。session的增删改查封装类 SessionRepositoryFilter ==&gt; Filter： session’存储过滤器；每个请求过来都必须经过filter 在request中存入SessionRepository request，response都被包装。SessionRepositoryRequestWrapper，SessionRepositoryResponseWrapper (装饰者模式) 放行filter放的是包装过的请求响应 获取session使用request.getSession() //即包装后的SessionRepositoryRequestWrapper wrappedRequest.getSession(); ==&gt; 是重写的方法，先获取SessionRepository ，从SessionRepository 中获取之前存入的session内容。 登录判断 记得把webConfig中的映射关了 123456789/* * 前往登录页前判断是否已经登录 */@GetMapping(&quot;/login.html&quot;)public String loginPage(HttpSession session) &#123; // 如果登陆过了就跳过 Object attribute = session.getAttribute(AuthServerConstant.LOGIN_USER); return attribute == null ? &quot;login&quot; : &quot;redirect:http://gulimall.com&quot;;&#125; TODO 这里要去别的模块重复spring session的操作（所以thymeleaf不行，这些都是抽取出来好） 单点登录 多系统下只需一次登录 开源框架 xxl-sso xxl-sso: 一个分布式单点登录框架。只需要登录一次就可以访问所有相互信任的应用系统。 拥有”轻量级、分布式、跨域、Cookie+Token均支持、Web+APP均支持”等特性；。现已开放源代码，开箱即用。 (gitee.com) 配置 打包：xxl-sso-master&gt;mvn clean package -Dmaven.skip.test=true 清楚包：xxl-sso-master&gt;mvn clean package -Dmaven.skip.test=true 启动服务：xxl-sso-master\\xxl-sso-server\\target&gt;java -jar xxl-sso-server-1.1.1-SNAPSHOT.jar 购物车环境搭建 模块 host template、静态资源 网关 端口、注册中心 数据模型分析 登录、未登录购物车（duck不必） 登录后会将临时购物车的数据合并到登录后的账号中 临时购物车的数据在浏览器重启后仍存在 采用redis CartItemVo123456789101112131415@Datapublic class CartItemVo &#123; private Long skuId; private Boolean check = true; private String title; private String image; private List&lt;String&gt; skuAttr; private BigDecimal price; private Integer count; private BigDecimal totalPrice; public BigDecimal getTotalPrice() &#123; return this.price.multiply(new BigDecimal(this.count)); &#125;&#125; CartVo1234567891011121314151617181920212223242526272829303132333435@Datapublic class CartVo &#123; private List&lt;CartItemVo&gt; items; private Integer countNum; // 商品总数 private Integer countType; // 商品类型数 private BigDecimal totalPrice; // 总原价格价-优惠价 private BigDecimal reduce = new BigDecimal(0); // 优惠价 public Integer getCountNum() &#123; int count = 0; if (items != null &amp;&amp; items.size() &gt; 0) &#123; for (CartItemVo item : items) &#123; count += item.getCount(); &#125; &#125; return count; &#125; public Integer getCountType() &#123; return items.size(); &#125; public BigDecimal getTotalPrice() &#123; BigDecimal price = new BigDecimal(0); if (items != null &amp;&amp; items.size() &gt; 0) &#123; for (CartItemVo item : items) &#123; if (item.getCheck()) &#123; price = price.add(item.getTotalPrice()); &#125; &#125; &#125; price = price.subtract(getReduce()); return price; &#125;&#125; ThreadLocal用户身份鉴别 同一个线程共享数据 CartWebConfig1234567891011@Configurationpublic class CartWebConfig implements WebMvcConfigurer &#123; /* * 添加拦截器 * 配置拦截地址 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new CartInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125; CartInterceptor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 判断登录状态，并封装传递给controller */@Componentpublic class CartInterceptor implements HandlerInterceptor &#123; public static ThreadLocal&lt;UserInfoTo&gt; threadLocal = new ThreadLocal&lt;&gt;(); /* * 在方法执行之前拦截 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; UserInfoTo userInfoTo = new UserInfoTo(); // 存入user-key Cookie[] cookies = request.getCookies(); if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie cookie : cookies) &#123; // 判断当前cookie是否为user-key，是则存入ThreadLocal if (cookie.getName().equals(AuthServerConstant.TEMP_USER_COOKIE_NAME)) &#123; userInfoTo.setUserKey(cookie.getValue()); // 当前cookie存在user-key userInfoTo.setAlreadySet(true); break; &#125; &#125; &#125; // 如果没有user-key，保存一个临时用户 if (StringUtils.isEmpty(userInfoTo.getUserKey())) &#123; String uuid = UUID.randomUUID().toString(); userInfoTo.setUserKey(uuid); &#125; // 如果登陆了存入userId MemberEntityVo loginUser = (MemberEntityVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER); if (loginUser != null) &#123; // 已登录 userInfoTo.setUserId(loginUser.getId()); &#125; // 将信息存入threadLocal threadLocal.set(userInfoTo); return true; &#125; /* * 业务执行之后 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // 只存一次cookie即可 if (!threadLocal.get().isAlreadySet()) &#123; // 保存一个cookie，存储user-key，时间一个月 Cookie cookie = new Cookie(AuthServerConstant.TEMP_USER_COOKIE_NAME, threadLocal.get().getUserKey()); cookie.setDomain(ServerConstant.COOKIE_SERVER_DOMAIN); cookie.setMaxAge(ServerConstant.COOKIE_MAX_AGE); response.addCookie(cookie); &#125; &#125;&#125; 添加商品SkuInfoFeignService12345678@FeignClient(&quot;gulimall-product&quot;)public interface SkuInfoFeignService &#123; @RequestMapping(&quot;/product/skuinfo/info/&#123;skuId&#125;&quot;) R info(@PathVariable(&quot;skuId&quot;) Long skuId); @RequestMapping(&quot;/product/skusaleattrvalue/list/&#123;skuId&#125;&quot;) List&lt;String&gt; getSkuSaleAttrList(@PathVariable(&quot;skuId&quot;) String skuId);&#125; SkuSaleAttrValueDao12345&lt;select id=&quot;getSkuSaleAttrList&quot; resultType=&quot;java.lang.String&quot;&gt; select concat(attr_name, &quot;:&quot;, attr_value) from gulimall_pms.pms_sku_sale_attr_value where sku_id = #&#123;skuId&#125;;&lt;/select&gt; CartController123456789101112131415@Controllerpublic class CartController &#123; @Autowired CartService cartService; /* * 添加商品到购物车 */ @GetMapping(&quot;/addToCart&quot;) public String addToCart(@RequestParam(&quot;skuId&quot;) Long skuId, @RequestParam(&quot;num&quot;) Integer num, Model model) &#123; CartItemVo cartItemVo = cartService.addToCart(skuId, num); model.addAttribute(&quot;item&quot;, cartItemVo); return &quot;success&quot;; &#125; CartServiceImpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Service@Slf4jpublic class CartServiceImpl implements CartService &#123; @Autowired StringRedisTemplate redisTemplate; @Autowired SkuInfoFeignService skuInfoFeignService; @Autowired ThreadPoolExecutor executor; /* * 添加商品 */ @Override public CartItemVo addToCart(Long skuId, Integer num) throws ExecutionException, InterruptedException &#123; BoundHashOperations&lt;String, Object, Object&gt; cartOptions = getCartOptions(); String existSku = (String) cartOptions.get(skuId.toString()); if (StringUtils.isEmpty(existSku)) &#123; CartItemVo cartItemVo = new CartItemVo(); // 当前购物城中没有该商品种类 CompletableFuture&lt;Void&gt; getSkuInfoTask = CompletableFuture.runAsync(() -&gt; &#123; // 远程调用查询当前sku信息 R r = skuInfoFeignService.getSkuInfo(skuId); if (r.getCode() == 0) &#123; SkuInfoTo skuInfo = r.getData(&quot;skuInfo&quot;, new TypeReference&lt;SkuInfoTo&gt;() &#123; &#125;); // 将商品添加到购物车 cartItemVo.setCount(num); cartItemVo.setImage(skuInfo.getSkuDefaultImg()); cartItemVo.setTitle(skuInfo.getSkuTitle()); cartItemVo.setPrice(skuInfo.getPrice()); cartItemVo.setSkuId(skuInfo.getSkuId()); &#125; else &#123; log.info(&quot;远程调用失败&quot;); &#125; &#125;, executor); CompletableFuture&lt;Void&gt; getAttrTask = CompletableFuture.runAsync(() -&gt; &#123; // 获取当前sku的组合信息? 这个难道不是前端传吗，离谱 cartItemVo.setSkuAttr(skuInfoFeignService.getSkuSaleAttrList(skuId)); &#125;, executor); CompletableFuture.allOf(getAttrTask, getSkuInfoTask).get(); cartOptions.put(skuId.toString(), JSON.toJSONString(cartItemVo)); return cartItemVo; &#125; else &#123; // 已经有该商品 CartItemVo cartItemVo = JSON.parseObject(existSku, CartItemVo.class); cartItemVo.setCount(cartItemVo.getCount() + num); cartOptions.put(skuId.toString(), JSON.toJSONString(cartItemVo)); return cartItemVo; &#125; &#125; /* * 从redis中获取该购物车 */ private BoundHashOperations&lt;String, Object, Object&gt; getCartOptions() &#123; String cartKey = &quot;&quot;; // redis中的购物车的key UserInfoTo userInfoTo = CartInterceptor.threadLocal.get(); // 判断是否登录 if (userInfoTo.getUserId() != null) &#123; // 已登录 cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserId(); &#125; else &#123; // 未登录 cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserKey(); &#125; return redisTemplate.boundHashOps(cartKey); &#125;&#125; 添加商品刷新防止多次添加CartController123456789101112131415161718192021/* * 添加商品到购物车 */@GetMapping(&quot;/addToCart&quot;)public String addToCart(@RequestParam(&quot;skuId&quot;) Long skuId, @RequestParam(&quot;num&quot;) Integer num, RedirectAttributes attributes) throws ExecutionException, InterruptedException &#123; CartItemVo cartItemVo = cartService.addToCart(skuId, num); // 使用RedirectAttributes，防止使用model（model是request域）后重定向数据丢失 // addAttribute能够取多次，addFlashAttribute只能取一次 attributes.addAttribute(&quot;skuId&quot;, skuId); // 防止页面刷新，所以到success页面应该是查操作，再过一个请求即可 return &quot;redirect:http://cart.gulimall.com/addToCartSuccess.html&quot;;&#125;// 跳转到成功页面@GetMapping(&quot;/addToCartSuccess.html&quot;)public String addToCartSuccessPage(@RequestParam(&quot;skuId&quot;) Long skuId, Model model) &#123; // 查询购物车中的skuId对应信息 CartItemVo cartItemVo = cartService.getCatItem(skuId); model.addAttribute(&quot;item&quot;, cartItemVo); return &quot;success&quot;;&#125; CartServiceImpl12345678910/* * 获取购物车商品信息 */@Overridepublic CartItemVo getCatItem(Long skuId) &#123; BoundHashOperations&lt;String, Object, Object&gt; cartOptions = getCartOptions(); String cartItemJSON = (String) cartOptions.get(skuId.toString()); CartItemVo cartItemVo = JSON.parseObject(cartItemJSON, CartItemVo.class); return cartItemVo;&#125; 获取、合并购物车cartListPage12345678@RequestMapping(&quot;/cart.html&quot;)public String cartListPage(Model model) throws ExecutionException, InterruptedException &#123; // 通过threadLocal获得当前用户信息 // UserInfoTo userInfoTo = CartInterceptor.threadLocal.get(); CartEntity cart = cartService.getCart(); model.addAttribute(&quot;cart&quot;, cart); return &quot;cartList&quot;;&#125; CartServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * 获得购物车信息 */@Overridepublic CartEntity getCart() throws ExecutionException, InterruptedException &#123; CartEntity cart = new CartEntity(); BoundHashOperations&lt;String, Object, Object&gt; cartFromRedis = getCartFromRedis(); // 判断是否登录 UserInfoTo userInfoTo = CartInterceptor.threadLocal.get(); List&lt;CartItemEntity&gt; cartItemByUserKey = getCartItem(CartConstant.CART_PREFIX + userInfoTo.getUserKey()); if (userInfoTo.getUserId() != null) &#123; // 已登录 // 合并购物车（使用addToCart带有同商品的判断） for (CartItemEntity cartItem : cartItemByUserKey) &#123; addToCart(cartItem.getSkuId(), cartItem.getCount()); &#125; List&lt;CartItemEntity&gt; cartItemByUserId = getCartItem(CartConstant.CART_PREFIX + userInfoTo.getUserId()); // redis中清空临时购物车信息 redisTemplate.delete(CartConstant.CART_PREFIX + userInfoTo.getUserKey()); // 返回购物车的信息 cart.setItems(cartItemByUserId); &#125; else &#123; // 未登录 // 返回临时购物车的信息 cart.setItems(cartItemByUserKey); &#125; return cart;&#125;/* * 根据xxx获取购物车商品list */private List&lt;CartItemEntity&gt; getCartItem(String cartKey) &#123; // 从redis中根据userId获得cartItem UserInfoTo userInfoTo = CartInterceptor.threadLocal.get(); BoundHashOperations&lt;String, Object, Object&gt; cartMap = redisTemplate.boundHashOps(cartKey); // 封装list List&lt;CartItemEntity&gt; cartItemList = cartMap.values().stream().map((cartItemObj) -&gt; &#123; return JSON.parseObject(cartItemObj.toString(), CartItemEntity.class); &#125;).collect(Collectors.toList()); return cartItemList;&#125;/* * 从redis中获取该购物车 */private BoundHashOperations&lt;String, Object, Object&gt; getCartFromRedis() &#123; String cartKey = &quot;&quot;; // redis中的购物车的key UserInfoTo userInfoTo = CartInterceptor.threadLocal.get(); // 判断是否登录 if (userInfoTo.getUserId() != null) &#123; // 已登录 cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserId(); &#125; else &#123; // 未登录 cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserKey(); &#125; return redisTemplate.boundHashOps(cartKey);&#125; 选中、改变数量、删除 这里最好用一个完整的VO+ajax CartController123456789101112131415161718192021222324/* * 更改购物车选中状态 */@PostMapping(&quot;/checkItem&quot;)public String checkItem(@RequestParam(&quot;skuId&quot;) Long skuId, @RequestParam(&quot;check&quot;) Integer check) &#123; cartService.checkItem(skuId, check); return &quot;redirect:http://cart.gulimall.com/cart.html&quot;;&#125;/* * 更改购物车商品数 */@GetMapping(&quot;/countItem&quot;)public String countItem(@RequestParam(&quot;skuId&quot;) Long skuId, @RequestParam(&quot;num&quot;) Integer num) &#123; cartService.countItem(skuId, num); return &quot;redirect:http://cart.gulimall.com/cart.html&quot;;&#125;/* * 更改购物车商品数 */@GetMapping(&quot;/deleteItem&quot;)public String deleteItem(@RequestParam(&quot;skuId&quot;) Long skuId) &#123; cartService.deleteItem(skuId); return &quot;redirect:http://cart.gulimall.com/cart.html&quot;;&#125; CartServiceImpl1234567891011121314151617181920212223242526272829303132333435/* * 修改商品check */@Overridepublic void checkItem(Long skuId, Integer check) &#123; CartItemEntity cartOneItem = getCartOneItem(skuId); cartOneItem.setCheck(check == 1); updateCartOneItem(cartOneItem);&#125;/* * 修改商品count */@Overridepublic void countItem(Long skuId, Integer num) &#123; CartItemEntity cartOneItem = getCartOneItem(skuId); cartOneItem.setCount(num); updateCartOneItem(cartOneItem);&#125;/* * redis删除商品 */@Overridepublic void deleteItem(Long skuId) &#123; BoundHashOperations&lt;String, Object, Object&gt; cartOptions = getCartFromRedis(); cartOptions.delete(skuId.toString());&#125;/* * 修改redis单个购物车商品信息 */@Overridepublic void updateCartOneItem(CartItemEntity cartItemEntity) &#123; BoundHashOperations&lt;String, Object, Object&gt; cartOptions = getCartFromRedis(); String json = JSON.toJSONString(cartItemEntity); cartOptions.put(cartItemEntity.getSkuId().toString(), json);&#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"微服务","slug":"微服务","permalink":"http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"【项目笔记】商城项目实战5","slug":"【项目笔记】商城项目实战5","date":"2021-11-13T05:53:21.523Z","updated":"2021-11-15T06:58:28.592Z","comments":true,"path":"2021/11/13/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-5/","link":"","permalink":"http://example.com/2021/11/13/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-5/","excerpt":"","text":"Typora typora11.16有毒，两天没了三次内容，已经写到了前端，不过前端也不想听了，反正cv就完事了 检索服务-页面渲染 吐了，CV 这一块真的是败笔 面包屑导航12345678910111213141516171819202122232425262728293031323334353637383940// 6 面包屑导航信息if (param.getAttrs() != null &amp;&amp; param.getAttrs().size() &gt; 0) &#123; List&lt;SearchResultVo.NavVo&gt; navVoList = param.getAttrs().stream().map(attr -&gt; &#123; // 分析每一个attr SearchResultVo.NavVo navVo = new SearchResultVo.NavVo(); String[] s = attr.split(&quot;_&quot;); // 远程调用product里的方法获得attrName(duck不必) AttrResponseTo attrResponseTo = productFeignService.attrResponseInfoFeign(Long.valueOf(s[0])); if (attrResponseTo != null) &#123; navVo.setNavName(attrResponseTo.getAttrName()); &#125; else &#123; navVo.setNavName(s[0]); &#125; navVo.setNavValue(s[1]); // 处理连接，如果是当前的查询条件，则去掉 String encode = null; try &#123; // 属性内容带空格的会被编码成+号，需要换回 encode = URLEncoder.encode(attr, &quot;UTF-8&quot;).replace(&quot;+&quot;, &quot;%20&quot;); &#125; catch (UnsupportedEncodingException ex) &#123; ex.printStackTrace(); &#125; String replace = param.get_queryString().replace(&quot;&amp;attrs=&quot; + encode, &quot;&quot;); navVo.setLink(&quot;http://search.gulimall.com/list.html?&quot; + replace); return navVo; &#125;).collect(Collectors.toList()); resultVo.setNavs(navVoList);&#125; // 6 品牌面包屑导航信息 if (param.getBrandId() != null &amp;&amp; param.getBrandId().size() &gt; 0) &#123; List&lt;SearchResultVo.NavVo&gt; navs = resultVo.getNavs(); SearchResultVo.NavVo navVo = new SearchResultVo.NavVo(); // 这里老师用远程调用，duck不必，result里都封装好了 navVo.setNavName(&quot;品牌&quot;); StringBuilder builder = new StringBuilder(); for (SearchResultVo.BrandVo brand : resultVo.getBrands()) &#123; builder.append(brand.getBrandName()).append(&quot;;&quot;); &#125; navVo.setNavValue(String.valueOf(builder)); &#125; 异步初始化线程的 4 种方式 继承 Thread 实现 Runnable 接口 实现 Callable 接口 + FutureTask （可以拿到返回结果， 可以处理异常） 线程池 方式 1 和方式 2： 主进程无法获取线程的运算结果。 不适合当前场景。方式 3： 主进程可以获取线程的运算结果， 但是不利于控制服务器中的线程资源。 可以导致服务器资源耗尽。方式 4： 通过如下两种方式初始化线程池Executors.newFiexedThreadPool(3); 或者new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit unit, workQueue, threadFactory, handler); 通过线程池性能稳定， 也可以获取执行结果， 并捕获异常。 但是， 在业务复杂情况下， 一个异步调用可能会依赖于另一个异步调用的执行结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ThreadTest &#123; // 单例模式，线程池只有一个 public static ExecutorService service = Executors.newFixedThreadPool(10); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;---------- main方法start ----------&quot;); /* * 1. 继承 Thread * 2. 实现 Runnable 接口 * 3. 实现 Callable 接口 + FutureTask （可以拿到返回结果， 可以处理异常） * 4. 线程池 */ // Thread1 thread1 = new Thread1(); // thread1.start(); // 启动线程 // Runnable1 runnable1 = new Runnable1(); // new Thread(runnable1).start(); // Callable1 callable1 = new Callable1(); // FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(callable1); // new Thread(integerFutureTask).start(); // // 阻塞等待，只有task执行完之后才能执行下面的语句 // System.out.println(integerFutureTask.get()); // 将所有的多线程异步任务都交给线程池执行,既能控制资源，也稳定 service.submit(new Runnable1()); System.out.println(&quot;---------- main方法end ----------&quot;); &#125; public static class Thread1 extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果：&quot; + i); &#125; &#125; public static class Runnable1 implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果：&quot; + i); &#125; &#125; public static class Callable1 implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果：&quot; + i); return i; &#125; &#125;&#125; 线程池线程池种类 newCachedThreadPool 创建一个可缓存线程池， 如果线程池长度超过处理需要， 可灵活回收空闲线程， 若无可回收， 则新建线程。 core为0，所有线程可回收 newFixedThreadPool 创建一个定长线程池， 可控制线程最大并发数， 超出的线程会在队列中等 core = max，max-core线程可回收 newScheduledThreadPool创建一个定长线程池， 支持定时及周期性任务执行。 newSingleThreadExecutor创建一个单线程化的线程池， 它只会用唯一的工作线程来执行任务， 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 示例12345678910111213141516171819202122232425262728293031public class ThreadTest &#123; // 单例模式，线程池只有一个 public static ExecutorService service = Executors.newFixedThreadPool(10); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; /* * 七大参数： * corePoolSize 核心线程数：线程池创建好以后就准备就绪的线程数,一直存在除非allowCoreThreadTimeOut * maximumPoolSize 最大线程数：控制资源 * keepAliveTime 存活时间：线程空闲时间大于指定时间，释放空闲线程（释放的线程是大于核心线程数的线程） * unit 时间单位 * BlockingQueue&lt;Runnable&gt; 阻塞队列：如果任务很多，多余任务将放在队列当中，只要有空闲线程，就会从队列中取出任务执行 * threadFactory 线程工厂 * RejectedExecutionHandler 拒绝策略：处理队列满了之后的操作 * * 工作顺序： * 1、 线程池创建， 准备好 core 数量的核心线程， 准备接受任务 * 2、 新的任务进来， 用 core 准备好的空闲线程执行。 * (1) 、 core 满了， 就将再进来的任务放入阻塞队列中。 空闲的 core 就会自己去阻塞队列获取任务执行 * (2) 、 阻塞队列满了， 就直接开新线程执行， 最大只能开到 max 指定的数量 * (3) 、 max 都执行好了。 Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自动销毁。 最终保持到 core 大小 * (4) 、 如果线程数开到了 max 的数量， 还有新任务进来， 就会使用 reject 指定的拒绝策略进行处理 * 3、 所有的线程创建都是由指定的 factory 创建的。 */ ThreadPoolExecutor executor = new ThreadPoolExecutor( 5, 200, 10, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100000), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); System.out.println(&quot;---------- main方法end ----------&quot;); &#125;&#125; 为什么使用线程池 CompletableFuture 异步编排 创建异步对象 CompletableFuture 提供了四个静态方法来创建一个异步操作 1、 runXxxx 都是没有返回结果的， supplyXxx 都是可以获取返回结果的2、 可以传入自定义的线程池， 否则就用默认的线程池； 1234567891011121314151617181920212223242526public class CompletableFutureTest &#123; // 单例模式，线程池只有一个 public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;---------- main方法start ----------&quot;); // CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123; // System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); // int i = 10 / 2; // System.out.println(&quot;运行结果：&quot; + i); // &#125;, executor); CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果：&quot; + i); return i; &#125;, executor); System.out.println(&quot;future结果：&quot; + future.get()); System.out.println(&quot;---------- main方法end ----------&quot;); &#125;&#125; 计算完成时回调方法、异常处理 whenComplete 可以处理正常和异常的计算结果， exceptionally 处理异常情况。 whenComplete 和 whenCompleteAsync 的区别 whenComplete： 是执行当前任务的线程执行继续执行 whenComplete 的任务 whenCompleteAsync： 是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。 方法不以 Async 结尾， 意味着 Action 使用相同的线程执行， 而 Async 可能会使用其他线程执行（如果是使用相同的线程池， 也可能会被同一个线程选中执行 12345678910111213141516171819202122public class CompletableFutureTest &#123; public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;---------- main方法start ----------&quot;); CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果：&quot; + i); return i; &#125;, executor).whenComplete((result, exception) -&gt; &#123; System.out.println(&quot;异步任务成功完成了...结果是：&quot; + result + &quot;；异常是：&quot; + exception); &#125;); System.out.println(&quot;future结果：&quot; + future.get()); System.out.println(&quot;---------- main方法end ----------&quot;); &#125;&#125; 12345678910111213141516171819202122232425public class CompletableFutureTest &#123; public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;---------- main方法start ----------&quot;); CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); int i = 10 / 0; System.out.println(&quot;运行结果：&quot; + i); return i; &#125;, executor).whenComplete((result, exception) -&gt; &#123; // 当future执行完之后执行回调函数，可以获得结果与异常 System.out.println(&quot;异步任务成功完成了...结果是：&quot; + result + &quot;；异常是：&quot; + exception); &#125;).exceptionally((exception) -&gt; &#123; // 用于处理异常 return 10; // 出现异常后，返回默认值 &#125;); System.out.println(&quot;future结果：&quot; + future.get()); System.out.println(&quot;---------- main方法end ----------&quot;); &#125;&#125; handle方法 和 complete 一样， 可对结果做最后的处理（可处理异常） ， 可改变返回值。 1234567891011121314151617181920212223242526272829public class CompletableFutureTest &#123; public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;---------- main方法start ----------&quot;); CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); int i = 10 / 0; System.out.println(&quot;运行结果：&quot; + i); return i; &#125;, executor).handle((result, exception) -&gt; &#123; // 既可以获得也可以处理 System.out.println(&quot;异步任务成功完成了...结果是：&quot; + result + &quot;；异常是：&quot; + exception); if (result != null) &#123; return result; &#125; if (exception != null) &#123; return 10; &#125; return 0; &#125;); System.out.println(&quot;future结果：&quot; + future.get()); System.out.println(&quot;---------- main方法end ----------&quot;); &#125; &#125; 线程串行化方法 thenApply 方法： 当一个线程依赖另一个线程时， 获取上一个任务返回的结果， 并返回当前任务的返回值。 thenAccept 方法： 消费处理结果。 接收任务的处理结果， 并消费处理， 无返回结果。 thenRun 方法： 只要上面的任务执行完成， 就开始执行 thenRun， 只是处理完任务后， 执行thenRun 的后续操作带有 Async 默认是异步执行的。 同之前。 以上都要前置任务成功完成。 Function&lt;? super T,? extends U&gt;T： 上一个任务返回结果的类型U： 当前任务的返回值类型 12345678910111213141516171819202122public class CompletableFutureTest &#123; public static ExecutorService executor = Executors.newFixedThreadPool(10); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;---------- main方法start ----------&quot;); CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;当前线程ID：&quot; + Thread.currentThread().getId()); int i = 10 / 2; System.out.println(&quot;运行结果：&quot; + i); return i; &#125;, executor).thenApplyAsync(result -&gt; &#123; System.out.println(&quot;任务二启动，上一次结果+&quot; + result); return result + 1; &#125;, executor); System.out.println(&quot;future结果：&quot; + future.get()); System.out.println(&quot;---------- main方法end ----------&quot;); &#125;&#125; 两任务组合 - 都要完成 两个任务必须都完成， 触发该任务。 thenCombine： 组合两个 future， 获取两个 future 的返回结果， 并返回当前任务的返回值thenAcceptBoth： 组合两个 future， 获取两个 future 任务的返回结果， 然后处理任务， 没有返回值。runAfterBoth： 组合两个 future， 不需要获取 future 的结果， 只需两个 future 处理完任务后，处理该任务。 123456789101112131415161718192021222324252627282930 CompletableFuture&lt;Object&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;任务1线程：&quot; + Thread.currentThread().getId()); int i = 10 / 4; System.out.println(&quot;任务1结束：&quot; ); return i; &#125;, executor); CompletableFuture&lt;Object&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;任务2线程：&quot; + Thread.currentThread().getId()); try &#123; Thread.sleep(3000); System.out.println(&quot;任务2结束：&quot; ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;Hello&quot;; &#125;, executor); future01.runAfterBothAsync(future02,()-&gt;&#123; System.out.println(&quot;任务3开始...&quot;); &#125;,executor);// void accept(T t, U u); future01.thenAcceptBothAsync(future02,(f1,f2)-&gt;&#123; System.out.println(&quot;任务3开始...之前的结果：&quot;+f1+&quot;--》&quot;+f2); &#125;,executor);//R apply(T t, U u); CompletableFuture&lt;String&gt; future = future01.thenCombineAsync(future02, (f1, f2) -&gt; &#123; return f1 + &quot;：&quot; + f2 + &quot; -&gt; Haha&quot;; &#125;, executor); 两任务组合 - 一个完成 当两个任务中， 任意一个 future 任务完成的时候， 执行任务。 applyToEither： 两个任务有一个执行完成， 获取它的返回值， 处理任务并有新的返回值。acceptEither： 两个任务有一个执行完成， 获取它的返回值， 处理任务， 没有新的返回值。runAfterEither： 两个任务有一个执行完成， 不需要获取 future 的结果， 处理任务， 也没有返回值。 1234567891011121314151617 /** * 两个任务，只要有一个完成，我们就执行任务3 * runAfterEitherAsync：不感知结果，自己没有返回值 * acceptEitherAsync：感知结果，自己没有返回值 * applyToEitherAsync：感知结果，自己有返回值 */// future01.runAfterEitherAsync(future02,()-&gt;&#123;// System.out.println(&quot;任务3开始...之前的结果：&quot;);// &#125;,executor); //void accept(T t);// future01.acceptEitherAsync(future02,(res)-&gt;&#123;// System.out.println(&quot;任务3开始...之前的结果：&quot;+res);// &#125;,executor);// CompletableFuture&lt;String&gt; future = future01.applyToEitherAsync(future02, res -&gt; &#123;// System.out.println(&quot;任务3开始...之前的结果：&quot; + res);// return res.toString() + &quot;-&gt;哈哈&quot;;// &#125;, executor); 多任务组合 allOf： 等待所有任务完成anyOf： 只要有一个任务完成 1234567891011121314151617181920212223242526272829 CompletableFuture&lt;String&gt; futureImg = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;查询商品的图片信息&quot;); return &quot;hello.jpg&quot;; &#125;,executor); CompletableFuture&lt;String&gt; futureAttr = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;查询商品的属性&quot;); return &quot;黑色+256G&quot;; &#125;,executor); CompletableFuture&lt;String&gt; futureDesc = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; Thread.sleep(3000); System.out.println(&quot;查询商品介绍&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;华为&quot;; &#125;,executor);// CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(futureImg, futureAttr, futureDesc); CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(futureImg, futureAttr, futureDesc); anyOf.get();//等待所有结果完成// System.out.println(&quot;main....end....&quot;+futureImg.get()+&quot;=&gt;&quot;+futureAttr.get()+&quot;=&gt;&quot;+futureDesc.get()); System.out.println(&quot;main....end....&quot;+anyOf.get()); &#125; 前台 - 商品详情环境搭建静态资源 存放到nginx -&gt; html -&gt; static 下对应文件夹 html放到对应模块resources -&gt; templates下 host 192.168.128.129 item.gulimall.com nacos 之前配置的*.gulimall.com即可 gateway123456789# -----------------------nginx，一定要放在最后，要不然/api/下的配置会被覆盖------------------------ id: gulimall_host_route uri: lb://gulimall-product predicates: - Host=gulimall.com,item.gulimall.com- id: gulimall_search_route uri: lb://gulimall-search predicates: - Host=search.gulimall.com 页面基本跳转1234&lt;!-- |内可直接放字符串| --&gt;&lt;a th:href=&quot;|http://item.gulimall.com/$&#123;product.skuId&#125;.html|&quot;&gt; &lt;img th:src=&quot;$&#123;product.skuImg&#125;&quot; class=&quot;dim&quot;&gt;&lt;/a&gt; controller12345678910111213141516@Controllerpublic class ItemController &#123; @Autowired SkuInfoService skuInfoService; /* * 展示当前对应skuId的信息 */ @GetMapping(&quot;/&#123;skuId&#125;.html&quot;) public String skuItem(@PathVariable(&quot;skuId&quot;) Long skuId, Model model) &#123; SkuItemVo skuItemVo = skuInfoService.getItemInfo(skuId); model.addAttribute(&quot;item&quot;, skuItemVo); return &quot;item&quot;; &#125;&#125; SkuItemVo12345678910111213141516171819202122232425262728293031323334353637383940414243@Datapublic class SkuItemVo &#123; // 1 获取sku基本信息，pms_sku_info SkuInfoEntity info; boolean hasStock = true; // 2 sku图片 pms_sku_images List&lt;SkuImagesEntity&gt; images; // 3 获得spu销售属性组合 List&lt;SkuItemSaleAttrVo&gt; saleAttr; // 4 spu销售属性介绍 SpuInfoDescEntity desp; // 5 spu规格参数 List&lt;SpuItemAttrGroupVo&gt; groupAttrs; @Data public static class SkuItemSaleAttrVo &#123; // 属性id private Long attrId; // 属性名 private String attrName; // 属性值 private List&lt;AttrValueWithSkuIdVo&gt; attrValues; &#125; @Data public static class SpuItemAttrGroupVo &#123; private String groupName; private List&lt;SpuItemBaseAttrVo&gt; attrs; &#125; @Data public static class SpuItemBaseAttrVo &#123; private String attrName; private String attrValue; &#125; @Data public static class AttrValueWithSkuIdVo &#123; private String attrValue; private String skuIds; &#125;&#125; 封装基本信息service1234567891011121314151617181920212223242526272829@Service(&quot;skuInfoService&quot;)public class SkuInfoServiceImpl extends ServiceImpl&lt;SkuInfoDao, SkuInfoEntity&gt; implements SkuInfoService &#123; /* * 获取skuInfo,用于详情页展示 */ @Override public SkuItemVo getItemInfo(Long skuId) &#123; SkuItemVo skuItemVo = new SkuItemVo(); // 1 获取sku基本信息，pms_sku_info SkuInfoEntity skuInfoEntity = getById(skuId); skuItemVo.setInfo(skuInfoEntity); Long spuId = skuInfoEntity.getSpuId(); Long catalogId = skuInfoEntity.getCatalogId(); // 2 sku图片 pms_sku_images List&lt;SkuImagesEntity&gt; skuImagesEntityList = skuImagesService.getBySkuId(skuId); skuItemVo.setImages(skuImagesEntityList); // 3 获得spu销售属性组合 // 4 spu销售属性介绍 spu_info_desc SpuInfoDescEntity spuInfoDescEntity = spuInfoDescService.getById(spuId); skuItemVo.setDesp(spuInfoDescEntity); // 5 spu规格参数 return skuItemVo; &#125;&#125; 封装spu规格参数service123// 5 spu规格参数 List&lt;SkuItemVo.SpuItemAttrGroupVo&gt; spuItemAttrGroupVoList = attrGroupService.getGroupWithAttrForSkuItem(spuId, catalogId); skuItemVo.setGroupAttrs(spuItemAttrGroupVoList); 12345678@Service(&quot;attrGroupService&quot;)public class AttrGroupServiceImpl extends ServiceImpl&lt;AttrGroupDao, AttrGroupEntity&gt; implements AttrGroupService &#123; @Override public List&lt;SkuItemVo.SpuItemAttrGroupVo&gt; getWithAttrForSkuItem(Long spuId, Long catalogId) &#123; return baseMapper.getWithAttrForSkuItem(spuId, catalogId); &#125;&#125; mapper 联表查询，自定义结果集，内部类使用$ 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.gulimall.product.dao.AttrGroupDao&quot;&gt; &lt;!-- resultMap 指定返回的结果集及其中元素 --&gt; &lt;resultMap id=&quot;spuItemAttrGroupVo&quot; type=&quot;com.atguigu.gulimall.product.vo.front.SkuItemVo$SpuItemAttrGroupVo&quot;&gt; &lt;result property=&quot;groupName&quot; column=&quot;attr_group_name&quot; /&gt; &lt;collection property=&quot;attrs&quot; ofType=&quot;com.atguigu.gulimall.product.vo.front.SkuItemVo$SpuItemBaseAttrVo&quot;&gt; &lt;result property=&quot;attrName&quot; column=&quot;attr_name&quot; /&gt; &lt;result property=&quot;attrValue&quot; column=&quot;attr_value&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getWithAttrForSkuItem&quot; resultMap=&quot;spuItemAttrGroupVo&quot;&gt; select ag.attr_group_id, ag.attr_group_name, aar.attr_id, pav.attr_name, pav.attr_value from gulimall_pms.pms_attr_group ag left join gulimall_pms.pms_attr_attrgroup_relation aar on aar.attr_group_id = ag.attr_group_id left join gulimall_pms.pms_product_attr_value pav on pav.attr_id = aar.attr_id where ag.catelog_id = #&#123;catalogId&#125; and pav.spu_id = #&#123;spuId&#125;; &lt;/select&gt;&lt;/mapper&gt; 封装spu销售属性service123// 3 获得spu销售属性组合List&lt;SkuItemVo.SkuItemSaleAttrVo&gt; skuItemSaleAttrVoList = skuSaleAttrValueService.getAttrBySpuId(skuId);skuItemVo.setSaleAttr(skuItemSaleAttrVoList); 12345678@Service(&quot;skuSaleAttrValueService&quot;)public class SkuSaleAttrValueServiceImpl extends ServiceImpl&lt;SkuSaleAttrValueDao, SkuSaleAttrValueEntity&gt; implements SkuSaleAttrValueService &#123; @Override public List&lt;SkuItemVo.SkuItemSaleAttrVo&gt; getAttrBySpuId(Long spuId) &#123; return baseMapper.getAttrBySpuId(spuId); &#125;&#125; mapper12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.gulimall.product.dao.SkuSaleAttrValueDao&quot;&gt; &lt;resultMap id=&quot;skuItemSaleAttrVo&quot; type=&quot;com.atguigu.gulimall.product.vo.front.SkuItemVo$SkuItemSaleAttrVo&quot;&gt; &lt;result property=&quot;attrId&quot; column=&quot;attr_id&quot; /&gt; &lt;result property=&quot;attrName&quot; column=&quot;attr_name&quot; /&gt; &lt;collection property=&quot;attrValues&quot; ofType=&quot;com.atguigu.gulimall.product.vo.front.SkuItemVo$AttrValueWithSkuIdVo&quot;&gt; &lt;result property=&quot;skuIds&quot; column=&quot;sku_ids&quot; /&gt; &lt;result property=&quot;attrValue&quot; column=&quot;attr_value&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getAttrBySpuId&quot; resultMap=&quot;skuItemSaleAttrVo&quot;&gt; select sav.attr_id, sav.attr_name, sav.attr_value, group_concat(distinct si.sku_id) sku_ids from gulimall_pms.pms_sku_info si left join gulimall_pms.pms_sku_sale_attr_value sav on sav.sku_id = si.sku_id where spu_id = #&#123;spuId&#125; group by sav.attr_id, sav.attr_name, sav.attr_value &lt;/select&gt;&lt;/mapper&gt; 这里最好起别名，要不然可能会封装不到 前端 自己看 异步编排优化外部配置 就是可以在配置文件中配置如下的属性 123456789// 需要引入依赖spring-boot-configuration-processor@ConfigurationProperties(prefix = &quot;gulimall.thread&quot;) // 外部化配置@Component@Datapublic class ThreadPoolConfigProperties &#123; private Integer coreSize; private Integer maxSize; private Integer keepAliveTime;&#125; 线程池配置1234567891011@Configuration// @EnableConfigurationProperties(ThreadPoolConfigProperties.class) //开启属性配置,这个注解和配置类的@Component注解二选一public class MyThreadConfig &#123; @Bean public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) &#123; return new ThreadPoolExecutor( pool.getCoreSize(), pool.getMaxSize(), pool.getKeepAliveTime(), TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(100000), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); &#125;&#125; service1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overridepublic SkuItemVo getItemInfo(Long skuId) throws ExecutionException, InterruptedException &#123; SkuItemVo skuItemVo = new SkuItemVo(); // 任务1，supplyAsync有返回值 CompletableFuture&lt;SkuInfoEntity&gt; infoFuture = CompletableFuture.supplyAsync(() -&gt; &#123; // 1 获取sku基本信息，pms_sku_info SkuInfoEntity skuInfoEntity = getById(skuId); skuItemVo.setInfo(skuInfoEntity); return skuInfoEntity; &#125;, executor); // 一下三个任务等任务1完成后才可执行，而且是并行的 CompletableFuture&lt;Void&gt; saleAttrFuture = infoFuture.thenAcceptAsync((skuInfoEntity) -&gt; &#123; // 3 获得spu销售属性组合 List&lt;SkuItemVo.SkuItemSaleAttrVo&gt; skuItemSaleAttrVoList = skuSaleAttrValueService.getAttrBySpuId(skuInfoEntity.getSpuId()); System.out.println(JSON.toJSONString(skuItemSaleAttrVoList)); skuItemVo.setSaleAttr(skuItemSaleAttrVoList); &#125;, executor); CompletableFuture&lt;Void&gt; descFuture = infoFuture.thenAcceptAsync((skuInfoEntity) -&gt; &#123; // 4 spu销售属性介绍 spu_info_desc SpuInfoDescEntity spuInfoDescEntity = spuInfoDescService.getById(skuInfoEntity.getSpuId()); skuItemVo.setDesp(spuInfoDescEntity); &#125;, executor); CompletableFuture&lt;Void&gt; groupAttrFuture = infoFuture.thenAcceptAsync((skuInfoEntity) -&gt; &#123; // 5 spu规格参数 List&lt;SkuItemVo.SpuItemAttrGroupVo&gt; spuItemAttrGroupVoList = attrGroupService.getGroupWithAttrForSkuItem(skuInfoEntity.getSpuId(), skuInfoEntity.getCatalogId()); skuItemVo.setGroupAttrs(spuItemAttrGroupVoList); &#125;, executor); // 任务2，该任务和任务1无关，所以和任务1并行即可，runAsync无返回值 CompletableFuture&lt;Void&gt; imageFuture = CompletableFuture.runAsync(() -&gt; &#123; // 2 sku图片 pms_sku_images List&lt;SkuImagesEntity&gt; skuImagesEntityList = skuImagesService.getBySkuId(skuId); skuItemVo.setImages(skuImagesEntityList); &#125;, executor); // 所有任务都完成后才返回 CompletableFuture.allOf(saleAttrFuture, descFuture, groupAttrFuture, imageFuture).get(); System.out.println(&quot;商品详情结果：&quot; + JSON.toJSONString(skuItemVo)); return skuItemVo;&#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"微服务","slug":"微服务","permalink":"http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"【项目笔记】商城项目实战4","slug":"【项目笔记】商城项目实战4","date":"2021-11-01T07:13:11.570Z","updated":"2021-11-13T05:53:11.936Z","comments":true,"path":"2021/11/01/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-4/","link":"","permalink":"http://example.com/2021/11/01/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-4/","excerpt":"","text":"SpringBoot整合ES-Rest-Client基础搭建模块 创建一个独立的module 依赖12345678910 &lt;properties&gt; &lt;!-- 覆盖springboot的默认版本，必须和client保持一致才行 --&gt; &lt;elasticsearch.version&gt;7.4.2&lt;/elasticsearch.version&gt; &lt;/properties&gt;&lt;!-- elasticsearch.client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.4.2&lt;/version&gt;&lt;/dependency&gt; 配置 nacos、springserver等 12spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848spring.application.name=gulimall-search 配置类123456789101112131415161718192021@Configurationpublic class GulimallElasticSearchConfig &#123; // request设置项 public static final RequestOptions COMMON_OPTIONS; static &#123; RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder(); // builder.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + TOKEN); // builder.setHttpAsyncResponseConsumerFactory( // new HttpAsyncResponseConsumerFactory // .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024)); COMMON_OPTIONS = builder.build(); &#125; // 注入RestHighLevelClient @Bean public RestHighLevelClient esRestClient() &#123; RestHighLevelClient client = new RestHighLevelClient( RestClient.builder( new HttpHost(&quot;192.168.128.129&quot;, 9200, &quot;http&quot;))); return client; &#125;&#125; TEST &amp; DEBUG error creating bean with name ‘‘DataSource’ 没有配置数据源，如果不需要就在application类上添加@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.atguigu.gulimall.gulimallsearch;import com.alibaba.fastjson.JSON;import com.atguigu.gulimall.gulimallsearch.config.GulimallElasticSearchConfig;import lombok.Data;import lombok.ToString;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.common.xcontent.XContentType;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.aggregations.AggregationBuilders;import org.elasticsearch.search.aggregations.Aggregations;import org.elasticsearch.search.aggregations.bucket.terms.Terms;import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;import org.elasticsearch.search.aggregations.metrics.Avg;import org.elasticsearch.search.aggregations.metrics.AvgAggregationBuilder;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.io.IOException;@RunWith(SpringRunner.class)@SpringBootTestpublic class GulimallSearchApplicationTests &#123; @Autowired private RestHighLevelClient client; /*\\ * 测试复杂检索 */ @Test public void complexSearch() throws IOException &#123; // 创建检索请求 SearchRequest searchRequest = new SearchRequest(); // 指定索引 searchRequest.indices(&quot;bank&quot;); // 指定检索条件 SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); /* * searchSourceBuilder.query(); * searchSourceBuilder.aggregation(); * searchSourceBuilder.from() * searchSourceBuilder.size() */ /* * searchSourceBuilder.query(QueryBuilders.matchAllQuery()); * searchSourceBuilder.query(QueryBuilders.matchPhraseQuery()); * searchSourceBuilder.query(QueryBuilders.matchQuery(&quot;address&quot;, &quot;mill&quot;)); */ /* * searchSourceBuilder.aggregation(AggregationBuilders.avg(&quot;&quot;).field(&quot;&quot;)); * searchSourceBuilder.aggregation(AggregationBuilders.terms(&quot;&quot;).field(&quot;&quot;).size(99)); * …… */ searchSourceBuilder.query(QueryBuilders.matchQuery(&quot;address&quot;, &quot;mill&quot;)); //1.2）、按照年龄的值分布进行聚合 TermsAggregationBuilder ageAgg = AggregationBuilders.terms(&quot;ageAgg&quot;).field(&quot;age&quot;).size(10); searchSourceBuilder.aggregation(ageAgg); //1.3）、计算平均薪资 AvgAggregationBuilder balanceAvg = AggregationBuilders.avg(&quot;balanceAvg&quot;).field(&quot;balance&quot;); searchSourceBuilder.aggregation(balanceAvg); System.out.println(&quot;检索条件: &quot; + searchSourceBuilder.toString()); // 指定检索条件对象 searchRequest.source(searchSourceBuilder); // 执行检索 SearchResponse response = client.search(searchRequest, GulimallElasticSearchConfig.COMMON_OPTIONS); // 分析结果; // 获得hit结果 SearchHits hits = response.getHits(); SearchHit[] hitsHits = hits.getHits(); for (SearchHit hit : hitsHits) &#123; String sourceAsString = hit.getSourceAsString(); Accout accout = JSON.parseObject(sourceAsString, Accout.class); System.out.println(&quot;accout：&quot; + accout); &#125; //获取这次检索到的分析信息； Aggregations aggregations = response.getAggregations();// for (Aggregation aggregation : aggregations.asList()) &#123;// System.out.println(&quot;当前聚合：&quot;+aggregation.getName());// &#125; Terms terms = aggregations.get(&quot;ageAgg&quot;); for (Terms.Bucket bucket : terms.getBuckets()) &#123; String keyAsString = bucket.getKeyAsString(); System.out.println(&quot;年龄：&quot; + keyAsString + &quot;==&gt;&quot; + bucket.getDocCount()); &#125; Avg balanceAvg1 = aggregations.get(&quot;balanceAvg&quot;); System.out.println(&quot;平均薪资：&quot; + balanceAvg1.getValue()); &#125; @ToString @Data static class Accout &#123; private int account_number; private int balance; private String firstname; private String lastname; private int age; private String gender; private String address; private String employer; private String email; private String city; private String state; &#125; /*\\ * 测试存储 */ @Test public void indexData() throws IOException &#123; // 创建indexRequest，传入index值 IndexRequest indexRequest = new IndexRequest(&quot;users&quot;); indexRequest.id(&quot;1&quot;); // 传入文档(jsonString格式) User user = new User(&quot;张三&quot;, &quot;男&quot;, 18); String jsonString = JSON.toJSONString(user); indexRequest.source(jsonString, XContentType.JSON); // 执行操作并获得响应数据 IndexResponse response = client.index(indexRequest, GulimallElasticSearchConfig.COMMON_OPTIONS); System.out.println(response); &#125; // 自定义类型 @Data static class User &#123; private String username; private String gender; private Integer age; public User(String username, String gender, Integer age) &#123; this.username = username; this.gender = gender; this.age = age; &#125; &#125; @Test public void contextLoads() &#123; System.out.println(client); &#125;&#125; 商品上架 商品系统—商品维护—SPU管理—上架 上架即将商品数据保存至ES中，只有上架的商品才能被全文检索。 SKU在ES中存储模型 检索会根据：SKU的标题、价格、销量、品牌、分类、商品规格等进行检索 模型设计需要花费一定心思，详见文档09、商城业务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;skuId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;spuId&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;skuTitle&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;skuPrice&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;skuImg&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false, &quot;doc_values&quot;: false &#125;, &quot;saleCount&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;hasStock&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;hotScore&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;brandId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;catalogId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;brandName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false, &quot;doc_values&quot;: false &#125;, &quot;brandImg&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false, &quot;doc_values&quot;: false &#125;, &quot;catalogName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false, &quot;doc_values&quot;: false &#125;, &quot;attrs&quot;: &#123; &quot;type&quot;: &quot;nested&quot;, &quot;properties&quot;: &#123; &quot;attrId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;attrName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false, &quot;doc_values&quot;: false &#125;, &quot;attrValue&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125; &#125; &#125;&#125; “index”:false“doc_values”:false 表示该冗余的字段不需要用于检索与聚合 检索服务回来表示，这个设置数据类型的步骤很重要，特别是nested这种 这里的模型必须修改，超级感谢一个大佬，文档很详细 检索服务 · 语雀 (yuque.com) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 查看原来的映射规则GET gulimall_product/_mapping# 修改为新的映射 并创建新的索引，下面进行数据迁移PUT /mall_product&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;skuId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;spuId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;skuTitle&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;skuPrice&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;skuImg&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;saleCount&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;hosStock&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;hotScore&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;brandId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;catalogId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;brandName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;brandImg&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;catalogName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;attrs&quot;: &#123; &quot;type&quot;: &quot;nested&quot;, &quot;properties&quot;: &#123; &quot;attrId&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;attrName&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;attrValue&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125; &#125; &#125; &#125; &#125;&#125;# 数据迁移POST _reindex&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;gulimall_product&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;mall_product&quot; &#125;&#125; gulimall-productSkuEsModel 写在common的to文件夹中，作为传输对象 12345678910111213141516171819202122232425262728293031323334353637@Datapublic class SkuEsModel &#123; private Long skuId; private Long spuId; private String skuTitle; private BigDecimal skuPrice; private String skuImg; private Long saleCount; private Boolean hasStock; private Long hotScore; private Long brandId; private Long catalogId; private String brandName; private String brandImg; private String catalogName; private List&lt;Attrs&gt; attrs; @Data public static class Attrs &#123; private Long attrId; private String attrName; private String attrValue; &#125;&#125; SkuHasStockTo12345@Datapublic class SkuHasStockTo &#123; private Long skuId; private Boolean hasStock;&#125; SpuInfoController123456789101112131415@RestController@RequestMapping(&quot;product/spuinfo&quot;)public class SpuInfoController &#123; @Autowired private SpuInfoService spuInfoService; /** * 商品上架，保存到ES中 */ @PostMapping(&quot;/&#123;spuId&#125;/up&#125;&quot;) public R spuUp(@PathVariable(&quot;spuId&quot;) Long spuId) &#123; spuInfoService.spuUp(spuId); return R.ok(); &#125;&#125; SpuInfoServiceImpl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 /* * 商品上架 */ @Override public void spuUp(Long spuId) &#123; // 将数据存入SkuEsModel对象当中 // 1 查出sku品牌和分类信息（不需要对每个sku都查询，所以放在stream外面） SpuInfoEntity spuInfoEntity = this.getById(spuId); BrandEntity brandEntity = brandService.getById(spuInfoEntity.getBrandId()); Long brandId = brandEntity.getBrandId(); String brandLogo = brandEntity.getLogo(); String brandName = brandEntity.getName(); CategoryEntity categoryEntity = categoryService.getById(spuInfoEntity.getCatalogId()); String categoryName = categoryEntity.getName(); // 2 查出sku的attr,并且是可以被全文检索的 List&lt;ProductAttrValueEntity&gt; baseAttrList = productAttrValueService.baseAttrListForSpu(spuId); List&lt;Long&gt; attrIdList = baseAttrList.stream().map(attr -&gt; &#123; return attr.getAttrId(); &#125;).collect(Collectors.toList()); // 根据查出的所有attr找出可以被全文检索的 List&lt;Long&gt; searchAttrIdList = attrService.getIdsCanSearch(attrIdList); // 使用SET集合方便判断是否存在指定id Set&lt;Long&gt; idSet = new HashSet&lt;&gt;(searchAttrIdList); List&lt;SkuEsModel.Attrs&gt; skuEsModelAttrsList = baseAttrList.stream().filter(attr -&gt; &#123; return idSet.contains(attr.getAttrId()); &#125;).map(attr -&gt; &#123; SkuEsModel.Attrs attrEntity = new SkuEsModel.Attrs(); BeanUtils.copyProperties(attr, attrEntity); return attrEntity; &#125;).collect(Collectors.toList()); // 3 查出当前spuid对应的sku信息 List&lt;SkuInfoEntity&gt; skuInfoEntities = skuInfoService.getSkuListBySpuId(spuId); Map&lt;Long, Boolean&gt; skuHasStockCollect = new HashMap&lt;&gt;(); try &#123; // 3.5 查出所有sku的是否有库存信息 List&lt;SkuHasStockTo&gt; skuHasStockList = wareFeignService.getSkuHasStockList(skuInfoEntities.stream().map(SkuInfoEntity::getSkuId).collect(Collectors.toList())); // 封装到map当中，可以直接查询对应key的value skuHasStockCollect = skuHasStockList.stream().collect(Collectors.toMap(SkuHasStockTo::getSkuId, item -&gt; item.getHasStock())); &#125; catch (Exception e) &#123; log.error(&quot;库存服务远程调用异常：原因&#123;&#125;&quot;, e); &#125; // 4 封装每个sku信息 Map&lt;Long, Boolean&gt; finalSkuHasStockCollect = skuHasStockCollect; List&lt;SkuEsModel&gt; upSku = skuInfoEntities.stream().map(skuInfo -&gt; &#123; SkuEsModel skuEsModel = new SkuEsModel(); BeanUtils.copyProperties(skuInfo, skuEsModel); skuEsModel.setSkuPrice(skuInfo.getPrice()); skuEsModel.setSkuImg(skuInfo.getSkuDefaultImg()); // 远程调用库存系统是否有库存 if (finalSkuHasStockCollect == null) &#123; skuEsModel.setHasStock(true); &#125; else &#123; skuEsModel.setHasStock(finalSkuHasStockCollect.get(skuInfo.getSkuId())); &#125; skuEsModel.setHotScore(0L); skuEsModel.setBrandId(brandId); skuEsModel.setBrandImg(brandLogo); skuEsModel.setBrandName(brandName); skuEsModel.setCatalogName(categoryName); skuEsModel.setAttrs(skuEsModelAttrsList); return skuEsModel; &#125;).collect(Collectors.toList()); // 5 发给ES R r = searchFeignService.productStatusUp(upSku); if (r.getCode() == 0) &#123; // 远程调用成功 // 修改spu的状态为上架 SpuInfoEntity spu = new SpuInfoEntity(); spu.setId(spuId); spu.setPublishStatus(ProductConstant.StatusEnum.SPU_UP.getCode()); this.updateById(spu); &#125; else &#123; // TODO 远程调用失败 &#125; &#125;&#125; WareFeignService12345678@FeignClient(&quot;gulimall-ware&quot;)public interface WareFeignService &#123; /* * 检查每个sku是否又库存 */ @PostMapping(&quot;/ware/waresku/hasstock&quot;) R getSkuHasStockList(@RequestBody List&lt;Long&gt; skuIdList);&#125; SearchFeignService12345@FeignClient(&quot;gulimall-search&quot;)public interface SearchFeignService &#123; @PostMapping(&quot;/search/save/product&quot;) R productStatusUp(@RequestBody List&lt;SkuEsModel&gt; skuEsModelList);&#125; AttrDao12345678910&lt;!-- 在指定的集合中找到所有可以别全文检索的 --&gt;&lt;select id=&quot;selectIdsWithSearchAttr&quot; resultType=&quot;java.lang.Long&quot;&gt; SELECT attr_id from gulimall_pms.pms_attr WHERE attr_id IN &lt;foreach collection=&quot;attrIdList&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; AND search_type = 1&lt;/select&gt; R 给R加上泛型，用于方便远程调用直接传输对应数据（别的方法也可以） 我不想写泛型，泛型也还是要加一个TO，直接传一个TO呗，我也不想知道R的其他信息 123456789101112public class R&lt;T&gt; extends HashMap&lt;String, Object&gt; &#123; private static final long serialVersionUID = 1L; private T data; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; gulimall-wareWareSkuController1234567891011121314@RestController@RequestMapping(&quot;ware/waresku&quot;)public class WareSkuController &#123; @Autowired private WareSkuService wareSkuService; /* * 检查每个sku是否又库存 */ @PostMapping(&quot;/hasstock&quot;) public List&lt;SkuHasStockTo&gt; getSkuHasStockList(@RequestBody List&lt;Long&gt; skuIdList) &#123; List&lt;SkuHasStockTo&gt; hasStock = wareSkuService.getSkuHasStockList(skuIdList); return hasStock; &#125;&#125; WareSkuServiceImpl123456789101112131415/* * 检查每个sku是否又库存 */@Overridepublic List&lt;SkuHasStockTo&gt; getSkuHasStockList(List&lt;Long&gt; skuIdList) &#123; List&lt;SkuHasStockTo&gt; voList = skuIdList.stream().map(skuId -&gt; &#123; SkuHasStockTo skuHasStockVo = new SkuHasStockTo(); Long count = baseMapper.getSkuStock(skuId); skuHasStockVo.setSkuId(skuId); // 可能没有库存返回null skuHasStockVo.setHasStock(count != null &amp;&amp; count &gt; 0); return skuHasStockVo; &#125;).collect(Collectors.toList()); return voList;&#125; WareSkuDao12345&lt;select id=&quot;getSkuStock&quot; resultType=&quot;java.lang.Long&quot;&gt; SELECT SUM(stock - stock_locked) FROM gulimall_wms.wms_ware_sku WHERE sku_id = #&#123;skuId&#125;;&lt;/select&gt; gulimall-searchElasticSearchController1234567891011121314151617181920@RestController@RequestMapping(&quot;/search&quot;)public class ElasticSearchController &#123; @Autowired ElasticSearchService searchService; /** * 上架商品 * * @param skuEsModelList * @return */ @PostMapping(&quot;/product&quot;) public R productStatusUp(@RequestBody List&lt;SkuEsModel&gt; skuEsModelList) &#123; searchService.productUp(skuEsModelList); return R.ok(); &#125;&#125; ElasticSearchServiceImpl123456789101112131415161718192021222324252627282930313233343536@Slf4j@Servicepublic class ElasticSearchServiceImpl implements ElasticSearchService &#123; @Autowired RestHighLevelClient client; /** * 上架商品 * * @param skuEsModelList * @return */ @Override public Boolean productUp(List&lt;SkuEsModel&gt; skuEsModelList) throws IOException &#123; // 创建索引 BulkRequest bulkRequest = new BulkRequest(); for (SkuEsModel skuEsModel : skuEsModelList) &#123; //构造保存请求 IndexRequest indexRequest = new IndexRequest(EsConstant.PRODUCT_INDEX); indexRequest.id(String.valueOf(skuEsModel.getSkuId())); indexRequest.source(JSON.toJSONString(skuEsModel), XContentType.JSON); // 保存请求添加到bulk中 bulkRequest.add(indexRequest); &#125; // 执行批量操作 BulkResponse bulk = client.bulk(bulkRequest, GulimallElasticSearchConfig.COMMON_OPTIONS); // TODO 如果有错误可以处理 boolean hasFailures = bulk.hasFailures(); List&lt;String&gt; collect = Arrays.stream(bulk.getItems()).map(item -&gt; &#123; return item.getId(); &#125;).collect(Collectors.toList()); log.error(&quot;商品上架信息：&#123;&#125;&quot;, collect); return hasFailures; &#125;&#125; DEBUG 懒得写，主要是hasFailures返回值得判断，以及远程调用返回值（使用TO就不会，R泛型需要修改） kibana -&gt; GET product/_search查看是否有数据 跟着做顺畅，但是还是要再看一遍然后自己做 商城首页整合themeleaf 震惊，竟然要用模板引擎，想念VUE的第一天 依赖123456&lt;!-- thymleaf模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置 关闭缓存等 所有前台的controller统一存放在web文件夹下，而后台在app当中 123springboot: thymeleaf: cache: false 静态资源 静态资源放在resources -&gt; static下，模板页面放在templates文件夹下即可 也可以修改resources location配置 引入dev-tools 热部署 依赖123456&lt;!-- dev tool --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 配置渲染一级分类 简直是文艺复兴了 以后thymeleaf的模板修改我就不PO了，麻烦 IndexController123456789101112131415@Controller // 不适用RESTControllerpublic class IndexController &#123; @Autowired CategoryService categoryService; @GetMapping(&#123;&quot;/&quot;, &quot;/index.html&quot;&#125;) public String indexPage(Model model) &#123; // 1 查出所有一级分类 List&lt;CategoryEntity&gt; categoryEntityList = categoryService.getLevel1List(); // thymeleaf已经有了默认前缀，定位到classpath:/resources/templates // 默认后缀 html model.addAttribute(&quot;categoryList&quot;, categoryEntityList); return &quot;index&quot;; &#125;&#125; CategoryServiceImpl12345678/** * 前台：渲染首页 */@Overridepublic List&lt;CategoryEntity&gt; getLevel1List() &#123; List&lt;CategoryEntity&gt; categoryEntityList = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, 0)); return categoryEntityList;&#125; index.html1234567891011&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;!--轮播主体内容--&gt; &lt;div class=&quot;header_main&quot;&gt; &lt;div class=&quot;header_banner&quot;&gt; &lt;div class=&quot;header_main_left&quot;&gt; &lt;ul&gt; &lt;li th:each=&quot;category : $&#123;categoryList&#125;&quot;&gt; &lt;a href=&quot;/static/#&quot; class=&quot;header_main_left_a&quot; th:attr=&quot;ctg-data=$&#123;category.catId&#125;&quot;&gt;&lt;b th:text=&quot;$&#123;category.name&#125;&quot;&gt;家用电器&lt;/b&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; 渲染子级分类CategoryFrontVo12345678910111213141516171819202122232425/* * 二级分类VO */@AllArgsConstructor@NoArgsConstructor@Datapublic class Catalog2Vo &#123; // 这个属性名要和前端需要的JSON对应 private String catalog1Id; // 一级父分类id private List&lt;Catalog3Vo&gt; catalog3List; // 三级分类（本vo为二级分类） private String id; private String name; /* * 三级分类VO */ @AllArgsConstructor @NoArgsConstructor @Data public static class Catalog3Vo &#123; private String catalog2Id; private String id; private String name; &#125;&#125; IndexController12345678910/* * 渲染二级、三级分类 * 这里的路径与catalogLoader.js中发送请求的路径一致 */@ResponseBody // 返回值以JSON方式返回，且不需要跳转页面@GetMapping(&quot;/index/catalog.json&quot;)public Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJson(Model model) &#123; Map&lt;String, List&lt;Catalog2Vo&gt;&gt; category = categoryService.getCatalogJson(); return category;&#125; CategoryServiceImpl1234567891011121314151617181920212223242526272829303132/* * 渲染二级、三级分类 */@Overridepublic Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJson() &#123; List&lt;CategoryEntity&gt; level1List = this.getLevel1List(); // 封装数据 Map&lt;String, List&lt;Catalog2Vo&gt;&gt; catalogMap = level1List.stream().collect(Collectors.toMap(k -&gt; &#123; return k.getCatId().toString(); &#125;, parent -&gt; &#123; // 将二级分类的内容封装到一级分类当中 List&lt;CategoryEntity&gt; children2List = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, parent.getCatId())); List&lt;Catalog2Vo&gt; catalog2VoList = null; if (children2List != null) &#123; catalog2VoList = children2List.stream().map(child2 -&gt; &#123; Catalog2Vo catalog2Vo = new Catalog2Vo(parent.getCatId().toString(), null, child2.getCatId().toString(), child2.getName()); // 封装三级分类信息 List&lt;CategoryEntity&gt; children3List = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, child2.getCatId())); if (children3List != null) &#123; List&lt;Catalog2Vo.Catalog3Vo&gt; catalog3VoList = children3List.stream().map(child3 -&gt; &#123; Catalog2Vo.Catalog3Vo catalog3Vo = new Catalog2Vo.Catalog3Vo(child2.getCatId().toString(), child3.getCatId().toString(), child3.getName()); return catalog3Vo; &#125;).collect(Collectors.toList()); catalog2Vo.setCatalog3List(catalog3VoList); &#125; return catalog2Vo; &#125;).collect(Collectors.toList()); &#125; return catalog2VoList; &#125;)); return catalogMap;&#125; 为啥老师这么喜欢嵌套？ 优化子级分类CategoryServiceImpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 渲染二级、三级分类 */@Overridepublic Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJson() &#123; /* * 优化 * 多次查询数据库 -》 一次查询 */ // 一次查询数据库，获得所有的分类 List&lt;CategoryEntity&gt; allCatList = baseMapper.selectList(null); // 获得一级分类 List&lt;CategoryEntity&gt; level1List = getCatListByParentCid(allCatList, 0L); // 封装数据 Map&lt;String, List&lt;Catalog2Vo&gt;&gt; catalogMap = level1List.stream().collect(Collectors.toMap(k -&gt; &#123; return k.getCatId().toString(); &#125;, parent -&gt; &#123; // 将二级分类的内容封装到一级分类当中 List&lt;CategoryEntity&gt; children2List = getCatListByParentCid(allCatList, parent.getCatId()); List&lt;Catalog2Vo&gt; catalog2VoList = null; if (children2List != null) &#123; catalog2VoList = children2List.stream().map(child2 -&gt; &#123; Catalog2Vo catalog2Vo = new Catalog2Vo(parent.getCatId().toString(), null, child2.getCatId().toString(), child2.getName()); // 封装三级分类信息 List&lt;CategoryEntity&gt; children3List = getCatListByParentCid(allCatList, child2.getCatId()); if (children3List != null) &#123; List&lt;Catalog2Vo.Catalog3Vo&gt; catalog3VoList = children3List.stream().map(child3 -&gt; &#123; Catalog2Vo.Catalog3Vo catalog3Vo = new Catalog2Vo.Catalog3Vo(child2.getCatId().toString(), child3.getCatId().toString(), child3.getName()); return catalog3Vo; &#125;).collect(Collectors.toList()); catalog2Vo.setCatalog3List(catalog3VoList); &#125; return catalog2Vo; &#125;).collect(Collectors.toList()); &#125; return catalog2VoList; &#125;)); return catalogMap;&#125;/* * 根据parentCid查询下级分类 */private List&lt;CategoryEntity&gt; getCatListByParentCid(List&lt;CategoryEntity&gt; allCatList, Long parentCid) &#123; // return baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, parent.getCatId())); List&lt;CategoryEntity&gt; collect = allCatList.stream().filter(categoryEntity -&gt; &#123; return categoryEntity.getParentCid().equals(parentCid); &#125;).collect(Collectors.toList()); return collect;&#125; 配置反向代理💡 正向代理：如科学上网，隐藏客户端信息 反向代理：屏蔽内网服务器信息，负载均衡访问 配置host C:\\Windows\\System32\\drivers\\etc\\host 文件添加上地址 使用switchHost软件可以快速应用方案 192.168.128.129/192.168.128.129:80(nginx默认地址) -&gt; gulimall.com 配置nginx 虚拟机外部挂载下的conf文件 /mydata/nginx/conf/nginx.conf /mydata/nginx/conf/conf.d/default.conf 可以先复制有份conf在配置 123456789101112131415161718http &#123;upstream gulimall&#123; server 192.168.128.1:88; &#125;&#125;server &#123; listen 80; server_name gulimall.com; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / &#123; # 需要配置header，添加上host，因为nginx转发代理给网关的时候会丢失许多信息 proxy_set_header Host $host; proxy_pass http://gulimall; &#125; TODO 转不了为什么？nginx可以访问到，但是nginx转发不到本机，我感觉还是proxy_pass配置的问题，但是我每个ip都试过了？ 我不理解：192.168.128.1:10000是可以的，http://192.168.128.129:5601也是可以的，虚拟机ping 192.168.128.1也是可以的？ 目测是本机 -&gt; 虚拟机nginx是成功的，但是nginx -&gt; 本机192.168.128.1:10000失败了 重点说明！！！以上问题已解决，是本机防火墙的原因，操作如下Windows 通过命令行关闭防火墙-百度经验 (baidu.com) 感谢：谷粒商城高级篇p139、p140Nginx反向代理，网关配置不生效解决_含雷的博客-CSDN博客（被ping通欺骗了，所以一开始排除了防火墙） 关掉本机的防火墙，虚拟机的nginx就能转发到本机了！！！ 配置网关12345# -----------------------nginx，一定要放在最后，要不然/api/下的配置会被覆盖------------------------ id: gulimall_host_route uri: lb://gulimall-product predicates: - Host=**.gulimall.com,gulimall.com 总结一下实现：虚拟机192.168.128.129 通过修改win的host文件，相当于gulimall.com，192.168.128.1:10000 是本机商品服务的地址，现在需要通过请求nginx，然后nginx代理网关，网关再转发给对应服务地址，所以在虚拟机的nginx中配置，请求192.168.128.129:80（nginx端口80），本来是请求虚拟机的nginx，然后nginx配置80端口代理地址192.168.128.1:88（即本机的网关地址），然后网关配置**.gulimall.com转发到gulimall-product服务实现。 本机请求 -&gt; 虚拟机nginx -&gt; 本机网关 -&gt; 本地服务地址 性能压测压力测试 具体介绍见课件04 Jmeter 正好测试课要写测试工具报告 详细见测试工具报告 性能监控堆内存与垃圾回收 详见P144 jvisualvm 命令行启动：jvisualvm 安装插件 visual gc（建议手动下载然后添加插件即可） 简单优化吞吐量 开启thymeleaf缓存，关闭日志打印，数据库添加索引 nginx动静分离 将静态资源存放在nginx里，所以静态请求直接从nginx里拿资源即可，不需要过网关到服务器Tomcat里拿 规定：/static/***下的所有请求由nginx直接返回 存放静态资源 将product服务的resource下的所有静态文件（static下）存放到nginx下的html文件夹下的static下（记录一下虚拟机移动文件 mv xxx xxx） 将html中的静态资源路径添加上/static/前缀 nginx配置 当访问/static下的资源时，要求nginx为我们请求nginx下的html文件夹下的static文件夹 123location /static &#123; root /usr/share/nginx/html; &#125; 如果请求出现403的问题需要修改nginx文件夹的权限 chmod -R 777 /mydata/nginx/html 缓存 1优化业务逻辑 —&gt; 2使用缓存 适用于访问量达、更新频率不高、及时性数据一致性要求不要的数据，极大提升系统性能 在开发中， 凡是放入缓存中的数据我们都应该指定过期时间， 使其可以在系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。 避免业务崩溃导致的数据永久不一致问题。 最直接的缓存：一个Map对象，是本地缓存在分布式下，一个服务存在多个服务器，就会产生多个缓存，可能数据不一致 缓存中间件：redis Redis依赖12345&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 使用spring-boot-starter的redis，版本由父项目统一管理 配置12345spring: redis: # redis地址 host: 192.168.128.129 port: 6379 测试123456789@Testpublic void redis() &#123; ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue(); // 保存 valueOperations.set(&quot;hello&quot;, &quot;hello_&quot; + UUID.randomUUID()); // 查询 String hello = valueOperations.get(&quot;hello&quot;); System.out.println(&quot;之前保存的数据是： &quot; + hello);&#125; 可视化工具 RDM、ARDM（后者好看） 优化分类业务CategoryServiceImpl12345678910111213141516171819/* * 渲染二级、三级分类(使用缓存) */@Overridepublic Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJson() &#123; String catalogJSON = redisTemplate.opsForValue().get(&quot;catalogJSON&quot;); if (StringUtils.isEmpty(catalogJSON)) &#123; // 缓存中没有 // 查询并封装 Map&lt;String, List&lt;Catalog2Vo&gt;&gt; catalogJsonFromDb = getCatalogJsonFromDb(); // 放入缓存 (注意存入JSON字符串) redisTemplate.opsForValue().set(&quot;catalogJSON&quot;, JSON.toJSONString(catalogJsonFromDb)); return catalogJsonFromDb; &#125; // 从缓存中拿数据 Map&lt;String, List&lt;Catalog2Vo&gt;&gt; result = JSON.parseObject(catalogJSON, new TypeReference&lt;Map&lt;String, List&lt;Catalog2Vo&gt;&gt;&gt;() &#123; &#125;); return result;&#125; 解决OutOfDirectMemoryError TODO 产生堆外内存溢出：OutOfDirectMemoryError 1）、springboot2.0以后默认使用lettuce作为操作redis的客户端。它使用netty进行网络通信。 2）、lettuce的bug导致netty堆外内存溢出 -Xmx300m；netty如果没有指定堆外内存，默认使用-Xmx300m 可以通过-Dio.netty.maxDirectMemory进行设置 解决方案：不能使用-Dio.netty.maxDirectMemory只去调大堆外内存。 1）、升级lettuce客户端。 2）、切换使用jedis 123456789101112131415161718&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 解决redis堆外内存溢出问题，升级lettuce的版本 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 缓存失效 缓存穿透 缓存穿透是指查询一个一定不存在的数据， 由于缓存是不命中， 将去查询数据库， 但是数据库也无此记录， 我们没有将这次查询的 null 写入缓存， 这将导致这个不存在的数据每次请求都要到存储层去查询， 失去了缓存的意义。 在流量大时， 可能 DB 就挂掉了， 要是有人利用不存在的 key 频繁攻击我们的应用， 这就是漏洞。 解决：缓存空结果、 并且设置短的过期时间。 缓存雪崩 缓存雪崩是指在我们设置缓存时采用了相同的过期时间， 导致缓存在某一时刻同时失效， 请求全部转发到 DB， DB 瞬时压力过重雪崩。 解决：原有的失效时间基础上增加一个随机值， 比如 1-5 分钟随机， 这样每一个缓存的过期时间的重复率就会降低， 就很难引发集体失效的事件。 缓存击穿 对于一些设置了过期时间的 key， 如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据 这个时候， 需要考虑一个问题： 如果这个 key 在大量请求同时进来前正好失效， 那么所有对这个 key 的数据查询都落到 db， 我们称为缓存击穿。 解决：加锁 Spring Cache 依赖12345&lt;!-- spring cache简化缓存开发 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 配置 CacheAutoConfiguration 自动导入 RedisAutoConfiguration，内含 RedisCacheManager 缓存管理器 12345678spring: # 缓存 cache: type: redis # redis redis: host: 192.168.128.129 port: 6379 注解 @Cachable：将数据保存到缓存 @CacheEvict：将数据从缓存删除 @CachePut：保存（不影响方法执行） @Caching：组合多个缓存操作 @CacheConfig：在类级别共享相同配置 @EnableCaching：在启动类上，开启缓存 实现12345678910111213141516171819202122/** * 修改(级联更新，连表更新) */@Caching(evict = &#123; @CacheEvict(cacheNames = &quot;category&quot;, key = &quot;&#x27;level1Category1&#x27;&quot;), // 删除缓存 @CacheEvict(cacheNames = &quot;category&quot;, key = &quot;&#x27;level1Category2&#x27;&quot;)&#125;)@Override@Transactionalpublic void updateDetail(CategoryEntity category) &#123; this.updateById(category); categoryBrandRelationService.updateCategory(category.getCatId(), category.getName());&#125;/** * 前台：渲染首页，一级分类 */@Cacheable(&#123;&quot;category&quot;&#125;) // @Cacheable(缓存分区名)，如果缓存中有则该方法不会被调用，否则会调用方法并将结果放入缓存@Overridepublic List&lt;CategoryEntity&gt; getLevel1List() &#123; List&lt;CategoryEntity&gt; categoryEntityList = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, 0)); return categoryEntityList;&#125; 自定义配置 默认 key默认自动生成，名字为 分区名::SimpleKey [] 缓存的value值默认使用jdk序列化机制，将序列化后的数据保存到redis 默认ttl时间 -1s 自定义 指定key：接收SpEL表达式（官网文档有解释各种写法） 1@Cacheable(cacheNames = &#123;&quot;category&quot;&#125;, key = &quot;&#x27;level1Category&#x27;&quot;) 指定存活时间：单位为毫秒 1234cache: type: redis redis: time-to-live: 1000 指定JSON序列化 1234567891011121314151617181920212223242526272829303132/* * 自定义配置spring cache */@Configuration@EnableCaching@EnableConfigurationProperties(CacheProperties.class)public class MyCacheConfig &#123; @Bean RedisCacheConfiguration redisCacheConfiguration(CacheProperties cacheProperties) &#123; RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig(); // 设置自定义配置，使用JSON序列化机制保存value config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())); config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); // 引入配置文件的配置 // CacheProperties.Redis redisProperties = cacheProperties.getRedis(); // if (redisProperties.getTimeToLive() != null) &#123; // config = config.entryTtl(redisProperties.getTimeToLive()); // &#125; // if (redisProperties.getKeyPrefix() != null) &#123; // config = config.prefixKeysWith(redisProperties.getKeyPrefix()); // &#125; // if (!redisProperties.isCacheNullValues()) &#123; // config = config.disableCachingNullValues(); // &#125; // if (!redisProperties.isUseKeyPrefix()) &#123; // config = config.disableKeyPrefix(); // &#125; // TODO 这里我一引入就会导致缓存用不了？ return config; &#125;&#125; 分布式锁 RedisTemplates实现分布式锁演进 原子性：指事务的不可分割性，一个事务的所有操作要么不间断地全部被执行，要么一个也没有执行 代码实现1234567891011121314151617181920212223242526272829303132333435363738public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonFromDbWithRedisLock() &#123;//1、 占分布式锁。 去 redis 占坑String uuid = UUID.randomUUID().toString();Boolean lock =redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;,uuid,300,TimeUnit.SECONDS);if(lock)&#123;System.out.println(&quot;获取分布式锁成功...&quot;);//加锁成功... 执行业务//2、 设置过期时间， 必须和加锁是同步的， 原子的//redisTemplate.expire(&quot;lock&quot;,30,TimeUnit.SECONDS);Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb;try&#123;dataFromDb = getDataFromDb();&#125;finally &#123;String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] thenreturn redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;//删除锁Long lock1 = redisTemplate.execute(newDefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList(&quot;lock&quot;), uuid);&#125; //获取值对比+对比成功删除=原子操作 lua 脚本解锁// String lockValue = redisTemplate.opsForValue().get(&quot;lock&quot;);// if(uuid.equals(lockValue))&#123;// //删除我自己的锁// redisTemplate.delete(&quot;lock&quot;);//删除锁// &#125;return dataFromDb;&#125;else &#123;//加锁失败...重试。 synchronized ()//休眠 100ms 重试System.out.println(&quot;获取分布式锁失败...等待重试&quot;);try&#123;Thread.sleep(200);&#125;catch (Exception e)&#123;&#125; return getCatalogJsonFromDbWithRedisLock();//自旋的方式&#125;&#125; Redisson Redisson 是架设在 Redis 基础上的一个 Java 驻内存数据网格（In-Memory Data Grid） 。 充分的利用了 Redis 键值数据库提供的一系列优势， 基于 Java 实用工具包中常用接口， 为使用者提供了一系列具有分布式特性的常用工具类。 使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力， 大大降低了设计和研发大规模分布式系统的难度。 同时结合各富特色的分布式服务， 更进一步简化了分布式环境中程序相互之间的协作。 官方文档： https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95 依赖123456&lt;!-- reddisson --&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt;&lt;/dependency&gt; 程序化配置1234567891011121314@Configurationpublic class MyRedissonConfig &#123; /* * 所有对redisson的使用都是通过client对象 */ @Bean(destroyMethod = &quot;shutdown&quot;) public RedissonClient redisson() throws IOException &#123; // 创建配置 Config config = new Config(); // 单redis节点模式 config.useSingleServer().setAddress(&quot;redis://192.168.128.129:6379&quot;); return Redisson.create(config); &#125;&#125; 前台-检索服务搭建页面环境 需要向虚拟机传输文件，所有还是用xshel好使，教程在p122 静态资源 css,img等资源放在nginx的html文件夹下 index.html放在项目resource下的templates文件夹下（注意这里index名字改为list，因为首页搜索发请求地址就是search.gulimall.com/list.html host配置 使用SwitchHost 192.168.128.129 gulimall.com192.168.128.129 search.gulimall.com nginx配置 添加server_name对应host即可 server_name gulimall.com *.gulimall.com; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location /static &#123; root /usr/share/nginx/html; &#125; location / &#123; proxy_set_header Host $host; proxy_pass http://gulimall; &#125; gateway配置123456789# -----------------------nginx，一定要放在最后，要不然/api/下的配置会被覆盖------------------------ id: gulimall_host_route uri: lb://gulimall-product predicates: - Host=gulimall.com- id: gulimall_search_route uri: lb://gulimall-search predicates: - Host=search.gulimall.com 根据之前nginx配置中的proxy_set_header Host $host，网关能根据host来选择不同的服务 list.html里面有很多路径错误，记得修改一下 修改一下发起请求的请求路径 检索模型分析查询参数模型 12345678910111213141516171819/** * 封装页面所有可能传递过来的条件 */@Datapublic class SearchParamVo &#123; private String keyword; // 全文匹配关键字 private Long catalog3Id; // 三级分类id /** * sort=saleCount_asc/desc * sort=skuPrice_asc/desc * sort=hotScore_asc/desc */ private String sort; // 排序条件 private Integer hasStock; // 是否有货 private String skuPrice; // 价格区间 private List&lt;Long&gt; brandId; // 品牌id 可多选 private List&lt;String&gt; attrs; // 按照属性进行筛选 private Integer pageNum; // 页码&#125; 返回结果模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 检索返回数据模型 */@Datapublic class SearchResultVo &#123; private List&lt;SkuEsModel&gt; products; //sku在elasticsearch中的模型 // 分页信息 private Integer pageNum; // 当前页码 private Long total; // 总记录数 private Integer totalPages; // 总页码 private List&lt;BrandVo&gt; brands; // 当前查询到的所有涉及到的品牌 private List&lt;CatalogVo&gt; catalogs; // 当前查询到的所有涉及到的分类 private List&lt;AttrVo&gt; attrs; // 当前查询到的所有涉及到的属性 /** * 内部类，品牌信息 */ @Data public static class BrandVo &#123; private Long brandId; private String brandName; private String brandImg; &#125; /** * 内部类，属性信息 */ @Data public static class AttrVo &#123; private Long attrId; private String attrName; private List&lt;String&gt; attrValue; &#125; /** * 内部类，分类信息 */ @Data public static class CatalogVo &#123; private Long catalogId; private String catalogName; &#125;&#125; 检索DSL测试 TODO P177、P178 十分劝退，头疼 SearchRequest查询、排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133@Servicepublic class MallSearchServiceImpl implements MallSearchService &#123; @Autowired private RestHighLevelClient client; /* * 根据keyword检索所有商品 */ @Override public SearchResultVo search(SearchParamVo searchParamVo) &#123; // 准备检索请求 SearchRequest searchRequest = buildSearchRequest(searchParamVo); try &#123; // 执行检索请求 SearchResponse response = client.search(searchRequest, GulimallElasticSearchConfig.COMMON_OPTIONS); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 分析响应数据并封装 SearchResult searchResult = buildSearchResult(); return null; &#125; /* * 创建检索结果 */ private SearchResult buildSearchResult() &#123; return null; &#125; /* * 创建检索请求 */ private SearchRequest buildSearchRequest(SearchParamVo param) &#123; // 指定检索条件,详见dsl.json SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); // 查询：模糊匹配，过滤（按照属性、分类、品牌、价格区间、库存） // 1 query -&gt; bool 开始 BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 1.1 bool -&gt; must 模糊匹配 // must -&gt; match if (!StringUtils.isEmpty(param.getKeyword())) &#123; MatchQueryBuilder matchQuery = QueryBuilders.matchQuery(&quot;skuTitle&quot;, param.getKeyword()); boolQuery.must(matchQuery); &#125; // 1.2 bool -&gt; filter 过滤 // filter -&gt; 第一个term 按照分类过滤 if (param.getCatalog3Id() != null) &#123; TermQueryBuilder termQuery = QueryBuilders.termQuery(&quot;catalogId&quot;, param.getCatalog3Id()); boolQuery.filter(termQuery); &#125; // filter -&gt; 第二个terms 按照品牌过滤 if (param.getBrandId() != null) &#123; TermsQueryBuilder termsQuery = QueryBuilders.termsQuery(&quot;brandId&quot;, param.getBrandId()); boolQuery.filter(termsQuery); &#125; // filter -&gt; 第三个nested 按照属性过滤 if (param.getAttrs() != null &amp;&amp; param.getAttrs().size() &gt; 0) &#123; // 操作每一个attr(每一个attr都有一个nested) for (String attrStr : param.getAttrs()) &#123; // nested -&gt; query -&gt; bool BoolQueryBuilder nestedBool = QueryBuilders.boolQuery(); // 页面提交格式：attr = 1_5寸:8寸 String[] strings = attrStr.split(&quot;_&quot;); String attrId = strings[0]; String[] attrValues = strings[1].split(&quot;:&quot;); // bool -&gt; must -&gt; term、terms nestedBool.must(QueryBuilders.termQuery(&quot;attrs.attrId&quot;, attrId)); nestedBool.must(QueryBuilders.termsQuery(&quot;attrs.attrValue&quot;, attrValues)); boolQuery.filter(QueryBuilders.nestedQuery(&quot;attrs&quot;, nestedBool, ScoreMode.None)); &#125; &#125; // filter -&gt; 第四个term 按照库存过滤 if (param.getHasStock() != null) &#123; TermQueryBuilder termQuery = QueryBuilders.termQuery(&quot;hasStock&quot;, param.getHasStock() == 1); boolQuery.filter(termQuery); &#125; else &#123; TermQueryBuilder termQuery = QueryBuilders.termQuery(&quot;hasStock&quot;, true); boolQuery.filter(termQuery); &#125; // filter -&gt; 第四个range 按照价格区间过滤 if (!StringUtils.isEmpty(param.getSkuPrice())) &#123; RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(&quot;skuPrice&quot;); String[] priceRange = param.getSkuPrice().split(&quot;_&quot;); if (param.getSkuPrice().startsWith(&quot;_&quot;)) &#123; // _xxx, 小于 rangeQuery.lte(priceRange[1]); &#125; else if (param.getSkuPrice().endsWith(&quot;_&quot;)) &#123; // xxx_, 大于 rangeQuery.gte(priceRange[0]); &#125; else &#123; // 区间 rangeQuery.gte(priceRange[0]).lte(priceRange[1]); &#125; boolQuery.filter(rangeQuery); &#125; searchSourceBuilder.query(boolQuery); // 排序、分页、高亮 // 2 sort if (!StringUtils.isEmpty(param.getSort())) &#123; String sort = param.getSort(); String[] sortValue = sort.split(&quot;_&quot;); searchSourceBuilder.sort(sortValue[0], SortOrder.fromString(sortValue[1])); &#125; // 2 from sieze if (param.getPageNum() != null) &#123; searchSourceBuilder.from((param.getPageNum() - 1) * EsConstant.PAGE_SIZE); &#125; else &#123; searchSourceBuilder.from(0); &#125; searchSourceBuilder.size(EsConstant.PAGE_SIZE); // 2 highlight if (!StringUtils.isEmpty(param.getKeyword())) &#123; searchSourceBuilder.highlighter(new HighlightBuilder().field(&quot;skuTitle&quot;).preTags(&quot;&lt;b style=&#x27;color:red&#x27;&gt;&quot;).postTags(&quot;&lt;/b&gt;&quot;)); &#125; // TODO 聚合分析 // 3 aggs String s = searchSourceBuilder.toString(); System.out.println(&quot;构建的DSL：&quot; + s); // 创建request，指定索引、检索条件 SearchRequest searchRequest = new SearchRequest(new String[]&#123;EsConstant.PRODUCT_INDEX&#125;, searchSourceBuilder); return searchRequest; &#125;&#125; 聚合12345678910111213141516171819202122// 聚合分析// 3 aggs// 3.1 品牌聚合TermsAggregationBuilder brand_agg = AggregationBuilders.terms(&quot;brand_agg&quot;).field(&quot;brandId&quot;).size(EsConstant.BRAND_SIZE);// 3.1 子聚合brand_agg.subAggregation(AggregationBuilders.terms(&quot;brand_img_agg&quot;).field(&quot;brandImg&quot;).size(1));brand_agg.subAggregation(AggregationBuilders.terms(&quot;brand_name_agg&quot;).field(&quot;brandName&quot;).size(1));searchSourceBuilder.aggregation(brand_agg);// 3.2 分类聚合TermsAggregationBuilder catalog_agg = AggregationBuilders.terms(&quot;catalog_agg&quot;).field(&quot;catalogId&quot;).size(EsConstant.CATALOG_SIZE);// 3.2 子聚合catalog_agg.subAggregation(AggregationBuilders.terms(&quot;catalog_name_agg&quot;).field(&quot;catalogName&quot;).size(1));searchSourceBuilder.aggregation(catalog_agg);// 3.3 属性聚合NestedAggregationBuilder attr_agg = AggregationBuilders.nested(&quot;attr_agg&quot;, &quot;attrs&quot;);// 3.3 子聚合TermsAggregationBuilder attr_id_agg = AggregationBuilders.terms(&quot;attr_id_agg&quot;).field(&quot;attrs.attrId&quot;);// 3.3 子子聚合attr_id_agg.subAggregation(AggregationBuilders.terms(&quot;attr_name_agg&quot;).field(&quot;attrs.attrName&quot;).size(1));attr_id_agg.subAggregation(AggregationBuilders.terms(&quot;attr_value_agg&quot;).field(&quot;attrs.attrValue&quot;).size(50));attr_agg.subAggregation(attr_id_agg);searchSourceBuilder.aggregation(attr_agg); 注意：如果使用文档的es模型映射规则，会有问题，详见本文档的商品上架的模型分析 SearchResult1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 创建检索结果 */ private SearchResultVo buildSearchResult(SearchResponse response, SearchParamVo param) &#123; SearchResultVo resultVo = new SearchResultVo(); SearchHits hits = response.getHits(); // 1 封装商品 List&lt;SkuEsModel&gt; skuList = new ArrayList&lt;&gt;(); if (hits.getHits() != null &amp;&amp; hits.getHits().length &gt; 0) &#123; for (SearchHit hit : hits.getHits()) &#123; // 获得hit中的resource，json转为对象 SkuEsModel sku = JSON.parseObject(hit.getSourceAsString(), SkuEsModel.class); // 是否高亮 if (!StringUtils.isEmpty(param.getKeyword())) &#123; HighlightField highlightField = hit.getHighlightFields().get(&quot;skuTitle&quot;); String highlight = highlightField.getFragments()[0].toString(); sku.setSkuTitle(highlight); &#125; skuList.add(sku); &#125; &#125; resultVo.setProducts(skuList); // 2 封装属性聚合信息 List&lt;SearchResultVo.AttrVo&gt; attrVoList = new ArrayList&lt;&gt;(); // 获得聚合 ParsedNested attr_agg = response.getAggregations().get(&quot;attr_agg&quot;); ParsedLongTerms attr_id_agg = attr_agg.getAggregations().get(&quot;attr_id_agg&quot;); for (Terms.Bucket bucket : attr_id_agg.getBuckets()) &#123; SearchResultVo.AttrVo attrVo = new SearchResultVo.AttrVo(); // 封装id，在聚合中 attrVo.setAttrId(Long.valueOf(String.valueOf(bucket.getKeyAsNumber()))); // 封装name，在子聚合中 ParsedStringTerms attr_name_agg = bucket.getAggregations().get(&quot;attr_name_agg&quot;); attrVo.setAttrName(attr_name_agg.getBuckets().get(0).getKeyAsString()); // 封装valueList，在子聚合中 List&lt;String&gt; attrValue = new ArrayList&lt;&gt;(); ParsedStringTerms attr_value_agg = bucket.getAggregations().get(&quot;attr_value_agg&quot;); for (Terms.Bucket aggBucket : attr_value_agg.getBuckets()) &#123; attrValue.add(aggBucket.getKeyAsString()); &#125; attrVo.setAttrValue(attrValue); attrVoList.add(attrVo); &#125; resultVo.setAttrs(attrVoList); // 3 封装品牌聚合信息 List&lt;SearchResultVo.BrandVo&gt; brandVoList = new ArrayList&lt;&gt;(); // 获得聚合 ParsedLongTerms brand_agg = response.getAggregations().get(&quot;brand_agg&quot;); // 根据brandId有许多个bucket for (Terms.Bucket bucket : brand_agg.getBuckets()) &#123; // 封装brandId，在聚合中 SearchResultVo.BrandVo brandVo = new SearchResultVo.BrandVo(); brandVo.setBrandId(Long.valueOf(bucket.getKeyAsString())); // 封装brandName\\brandImg，在子聚合中 ParsedStringTerms brand_name_agg = bucket.getAggregations().get(&quot;brand_name_agg&quot;); brandVo.setBrandName(brand_name_agg.getBuckets().get(0).getKeyAsString()); ParsedStringTerms brand_img_agg = bucket.getAggregations().get(&quot;brand_img_agg&quot;); brandVo.setBrandImg(brand_img_agg.getBuckets().get(0).getKeyAsString()); brandVoList.add(brandVo); &#125; resultVo.setBrands(brandVoList); // 4 封装分类聚合信息 List&lt;SearchResultVo.CatalogVo&gt; catalogVoList = new ArrayList&lt;&gt;(); // 获得聚合 ParsedLongTerms catalog_agg = response.getAggregations().get(&quot;catalog_agg&quot;); // 根据catelogId有许多个bucket for (Terms.Bucket bucket : catalog_agg.getBuckets()) &#123; // 封装CatalogId，在聚合中 SearchResultVo.CatalogVo catalogVo = new SearchResultVo.CatalogVo(); catalogVo.setCatalogId(Long.valueOf(bucket.getKeyAsString())); // 封装CatalogName，在子聚合中 ParsedStringTerms catalog_name_agg = bucket.getAggregations().get(&quot;catalog_name_agg&quot;); catalogVo.setCatalogName(catalog_name_agg.getBuckets().get(0).getKeyAsString()); catalogVoList.add(catalogVo); &#125; resultVo.setCatalogs(catalogVoList); // 5 封装分页信息 long total = hits.getTotalHits().value; resultVo.setTotal(total); resultVo.setTotalPages((int) ((total + EsConstant.PRODUCT_PAGE_SIZE - 1) / EsConstant.PRODUCT_PAGE_SIZE)); resultVo.setPageNum(param.getPageNum()); return resultVo; &#125; wc，typora有毒，两天没了三次内容，而且未保存内容草稿也没用，东西都没了，我吐了，可能是内容太多了，新开一个","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"微服务","slug":"微服务","permalink":"http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"【学习笔记】ElasticSearch","slug":"【学习笔记】ElasticSearch","date":"2021-10-31T07:43:26.867Z","updated":"2021-11-01T07:09:40.533Z","comments":true,"path":"2021/10/31/xue-xi-bi-ji-elasticsearch/","link":"","permalink":"http://example.com/2021/10/31/xue-xi-bi-ji-elasticsearch/","excerpt":"","text":"ES基础概念 [Elasticsearch Guide 7.15] | Elastic 文档 Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，是目前全文搜索引擎的首选。 mysql更适用于数据量小的CRUD，而Elasticsearch适用于大数据。 对ES的所有操作只需要使用rest请求即可完成 基础概念 index 索引 动词：相当于insert 名词：相当于Database Type 类型 相当于Table Document 文档 JSON格式，相当于表中的内容 倒排索引 分词：将整句拆分为单词 检索：查询词都出现在哪个记录当中 相关性得分：基于一定算法算哪个权重更高 Docker安装ES和可视化工具安装 docker pull elasticsearch:7.4.2 docker pull kibana:7.4.2 配置 mkdir -p /mydata/elasticsearch/configmkdir -p /mydata/elasticsearch/data echo “http.host: 0.0.0.0” &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml docker run –name elasticsearch -p 9200:9200 -p 9300:9300 -e “discovery.type=single-node” -e ES_JAVA_OPTS=”-Xms64m -Xmx128m” -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.4.2 chmod -R 777 /mydata/elasticsearch/ 保证权限 docker run –name kibana -e ELASTICSEARCH_HOSTS=http://192.168.128.129:9200 -p 5601:5601 -d kibana:7.4.2http://192.168.56.10:9200 为虚拟机地址 访问 http://192.168.128.129:9200/ 访问不了的执行上述保证权限的命令 http://192.168.128.129:5601/ kibana可能要等一会才能启动，刷新就行 基础请求格式查询 _cat 保存、更新文档 保存一个数据， 保存在哪个索引的哪个类型下， 指定用哪个唯一标识 在 customer 索引下的 external 类型下保存 1 号数据，数据使用JSON格式 PUT customer/external/1 { “name”: “John Doe” } PUT 和 POST 都可以，POST 新增。POST如果不指定 id， 会自动生成 id。如果指定 id （并且该id存在）就会修改这个数据， 并新增版本号。PUT可以新增可以修改。PUT 必须指定 id； 由于 PUT 需要指定 id， 我们一般都用来做修改操作，不指定 id 会报错。 查询文档 GET /customer/external/1 更新文档 乐观锁 PUT /customer/external/1?if_seq_no=1&amp;if_primary_term=1{ “name”: “John Doe 1” } 这里将if判断seq_no和primary_term 更新文档 POST customer/external/1/_update{ “doc”: { “name”: “John Doew” }}PUT 操作和POST不带update，总会将数据重新保存并增加 version 版本；POST 带_update，对比元数据如果一样就不进行任何操作，文档 version不增加 对于大并发更新， 不带 update；对于大并发查询偶尔更新， 带 update；对比更新， 重新计算分配规则。 删除文档、索引 DELETE customer/external/1 DELETE customer 没有删除类型，新版本type不建议了 bulk 批量 API POSTMAN里面测不了，去kibana -&gt; dev tools bulk API 以此按顺序执行所有的 action（动作） 。 如果一个单个的动作因任何原因而失败，它将继续处理它后面剩余的动作。 当 bulk API 返回时， 它将提供每个动作的状态（与发送的顺序相同） ， 所以您可以检查是否一个指定的动作是不是失败了。 导入测试数据 感谢评论区，好人一生平安：es测试数据.json · 坐看云起时/common_content - Gitee.com POST /bank/account/_bulk 进阶SearchAPI ES 支持两种基本方式检索 : 一个是通过使用 REST request URI 发送搜索参数（uri+检索参数） 另一个是通过使用 REST request body 来发送它们（uri+请求体） QueryDSL基本语法格式 返回特定字段 match 匹配查询 address.keyword 表示精确匹配，必须匹配为完整字段，如果使用match_phrase则匹配包含完整字段的即可 match_phrase 短语匹配 multi_match 多字段匹配 bool 复合查询 filter 结果过滤 must not、filter 不会计算相关性得分，must、should会 term 和 match 一样。 匹配某个属性的值。 全文检索字段用 match， 其他非 text 字段匹配用 term。 aggregations 执行聚合 聚合提供了从数据中分组和提取数据的能力。 最简单的聚合方法大致等于 SQL GROUPBY 和 SQL 聚合函数。 在 Elasticsearch 中， 您有执行搜索返回 hits（ 命中结果） ， 并且同时返回聚合结果， 把一个响应中的所有 hits（ 命中结果） 分隔开的能力。 这是非常强大且有效的，您可以执行查询和多个聚合， 并且在一次使用中得到各自的（ 任何一个的） 返回结果， 使用一次简洁和简化的 API 来避免网络往返。 Mapping字段类型 映射 Mapping 是用来定义一个文档（ document） ， 以及它所包含的属性（ field） 是如何存储和索引的 分词 安装 http://192.168.128.129:80/ 即可访问linux的nginx Elasticsearch-Rest-Client 官方RestClient，封装了ES操作 [Java High Level REST Client | Java REST Client 7.15] | Elastic","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://example.com/tags/ElasticSearch/"}]},{"title":"【项目笔记】商城项目实战3","slug":"【项目笔记】商城项目实战3","date":"2021-10-28T04:09:39.860Z","updated":"2021-10-31T07:37:23.326Z","comments":true,"path":"2021/10/28/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-3/","link":"","permalink":"http://example.com/2021/10/28/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-3/","excerpt":"","text":"Controller三个注释（获取值） @RequestBody请求体中的JSON @RequestParam是url?后跟的键值对 @PathVariable是REST风格url中的{}变量 Object划分 配置服务内存 终于你也有今天啊老师，内存终于不够了吧 RunConfigurations -&gt; xxx application -&gt; environment -&gt; Vm opinion -&gt; 设置-Xmx100m，最大100m 平台属性—规格参数（后端）新增AttrRequestVo 使用自定义的VO对象用于封装数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.gulimall.product.vo;import lombok.Data;/** * 用于封装请求数据和响应数据 * 不需要添加上与sql相关的注解 */@Datapublic class AttrVo &#123; /** * 属性id */ private Long attrId; /** * 属性名 */ private String attrName; /** * 是否需要检索[0-不需要，1-需要] */ private Integer searchType; /** * 属性图标 */ private String icon; /** * 可选值列表[用逗号分隔] */ private String valueSelect; /** * 属性类型[0-销售属性，1-基本属性，2-既是销售属性又是基本属性] */ private Integer attrType; /** * 启用状态[0 - 禁用，1 - 启用] */ private Long enable; /** * 所属分类 */ private Long catelogId; /** * 快速展示【是否展示在介绍上；0-否 1-是】，在sku中仍然可以调整 */ private Integer showDesc; /* * 分组ID */ private Long attrGroupId;&#125; AttrController123456789101112131415@RestController@RequestMapping(&quot;product/attr&quot;)public class AttrController &#123; @Autowired private AttrService attrService; /** * 保存,这里使用自定义的Vo对象 */ @RequestMapping(&quot;/save&quot;) //@RequiresPermissions(&quot;product:attr:save&quot;) public R save(@RequestBody AttrVo attr) &#123; attrService.saveAttr(attr); return R.ok(); &#125;&#125; AttrServiceImpl12345678910111213141516171819202122@Service(&quot;attrService&quot;)public class AttrServiceImpl extends ServiceImpl&lt;AttrDao, AttrEntity&gt; implements AttrService &#123; @Autowired AttrAttrgroupRelationDao relationDao; /** * 保存规格参数，连表 */ @Override @Transactional // 事务 public void saveAttr(AttrVo attr) &#123; // 1、保存到attr表 AttrEntity attrEntity = new AttrEntity(); // 使用BeanUtil封装对应属性 BeanUtils.copyProperties(attr, attrEntity); this.save(attrEntity); // 2、保存到relation表 AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity(); relationEntity.setAttrId(attrEntity.getAttrId());// 注意这里要使用attrEntity，因为使用attr是没有id的（没有添加mybatis的注解，所以没有自动生成id） relationEntity.setAttrGroupId(attr.getAttrGroupId()); relationDao.insert(relationEntity); &#125;&#125; 查询分页AttrResponseVo 原来可以使用继承的写法，学到了 1234567891011@Datapublic class AttrResponseVo extends AttrEntity &#123; /* * 分类名 */ private String catelogName; /* * 分组名 */ private String groupName;&#125; AttrController123456789101112131415@RestController@RequestMapping(&quot;product/attr&quot;)public class AttrController &#123; @Autowired private AttrService attrService; /** * 列表 */ @RequestMapping(&quot;/base/list/&#123;catelogId&#125;&quot;) public R baseAttrList(@RequestParam Map&lt;String, Object&gt; params, @PathVariable(&quot;catelogId&quot;) Long catelogId) &#123; PageUtils page = attrService.queryBaseAttrPage(params, catelogId); return R.ok().put(&quot;page&quot;, page); &#125;&#125; AttrServiceImpl 带新增的两个属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Service(&quot;attrService&quot;)public class AttrServiceImpl extends ServiceImpl&lt;AttrDao, AttrEntity&gt; implements AttrService &#123; @Autowired AttrAttrgroupRelationDao relationDao; /** * 查询attr表分页 * * @param params * @param catelogId * @return */ @Override public PageUtils queryBaseAttrPage(Map&lt;String, Object&gt; params, Long catelogId) &#123; QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;(); if (catelogId != 0) &#123; queryWrapper.eq(&quot;catelog_id&quot;, catelogId); &#125; String key = (String) params.get(&quot;key&quot;); if (!StringUtils.isEmpty(key)) &#123; // and拼接，因为可能id为0所以已经含有了一个eq条件 queryWrapper.and((wrapper) -&gt; &#123; wrapper.eq(&quot;attr_id&quot;, key).or().like(&quot;attr_name&quot;, key); &#125;); &#125; // 获得分页对象 IPage&lt;AttrEntity&gt; page = this.page( new Query&lt;AttrEntity&gt;().getPage(params), queryWrapper ); // 同时还要添加上attrResponseVo中多的两个属性 // 但是不能直接连表查询，数据量太大了。（两表叉乘笛卡尔积） // 所以先获取到分页后获取查询到的数据,再重新处理 PageUtils pageUtils = new PageUtils(page); List&lt;AttrEntity&gt; records = page.getRecords(); List&lt;AttrResponseVo&gt; responseVoList = records.stream().map((attrEntity) -&gt; &#123; AttrResponseVo responseVo = new AttrResponseVo(); // 先复制基本属性 BeanUtils.copyProperties(attrEntity, responseVo); // 再加入新的两个属性 CategoryEntity categoryEntity = categoryDao.selectById(attrEntity.getCatelogId()); if (categoryEntity != null) &#123; responseVo.setCatelogName(categoryEntity.getName()); &#125; AttrAttrgroupRelationEntity relationEntity = relationDao.selectOne(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attrEntity.getAttrId())); if (relationEntity != null) &#123; responseVo.setGroupName(attrGroupDao.selectById(relationEntity.getAttrGroupId()).getAttrGroupName()); &#125; return responseVo; &#125;).collect(Collectors.toList()); // 重新设置结果集 pageUtils.setList(responseVoList); return pageUtils; &#125;&#125; 查询回显AttrResoponseVo12345678910111213141516171819@Datapublic class AttrResponseVo extends AttrEntity &#123; /* * 分类名 */ private String catelogName; /* * 分组名 */ private String groupName; /* * 分类完整路径 */ private Long[] catelogPath; /* * 分组ID */ private Long attrGroupId;&#125; AttrController1234567891011121314@RestController@RequestMapping(&quot;product/attr&quot;)public class AttrController &#123; @Autowired private AttrService attrService; /** * 信息,返回AttrResponseVo对象属性 */ @RequestMapping(&quot;/info/&#123;attrId&#125;&quot;) public R attrResponseInfo(@PathVariable(&quot;attrId&quot;) Long attrId) &#123; AttrResponseVo attr = attrService.getResponseAttrInfo(attrId); return R.ok().put(&quot;attr&quot;, attr); &#125; AttrServiceImpl1234567891011121314151617181920212223242526272829303132@Service(&quot;attrService&quot;)public class AttrServiceImpl extends ServiceImpl&lt;AttrDao, AttrEntity&gt; implements AttrService &#123; /** * 获取信息,返回AttrResponseVo对象属性，带catelogPath完整路径 */ @Override public AttrResponseVo getResponseAttrInfo(Long attrId) &#123; AttrResponseVo responseVo = new AttrResponseVo(); AttrEntity attrEntity = this.getById(attrId); BeanUtils.copyProperties(attrEntity, responseVo); // 额外的属性 // 设置GroupName需要从relation表中查出groupid AttrAttrgroupRelationEntity relationEntity = relationDao.selectOne(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attrEntity.getAttrId())); if (relationEntity != null) &#123; responseVo.setAttrGroupId(relationEntity.getAttrGroupId()); // 设置GroupName属性 AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(relationEntity.getAttrGroupId()); if (attrGroupEntity != null) &#123; responseVo.setGroupName(attrGroupEntity.getAttrGroupName()); &#125; &#125; // 设置CatelogPath属性,直接从分类服务中拿方法 Long[] categoryPath = categoryService.findCategoryPath(attrEntity.getCatelogId()); responseVo.setCatelogPath(categoryPath); // 设置CatelogName属性 CategoryEntity categoryEntity = categoryDao.selectById(attrEntity.getCatelogId()); if (categoryEntity != null) &#123; responseVo.setCatelogName(categoryEntity.getName()); &#125; return responseVo; &#125;&#125; 修改AttrController 需要用AttrRequestVo 12345678/** * 修改 */@RequestMapping(&quot;/update&quot;)public R update(@RequestBody AttrRequestVo attr) &#123; attrService.updateAttr(attr); return R.ok();&#125; AttrServiceImpl12345678910111213141516171819202122/** * 修改,使用AttrRequestVo */@Override@Transactionalpublic void updateAttr(AttrRequestVo attr) &#123; // 修改基本表 AttrEntity attrEntity = new AttrEntity(); BeanUtils.copyProperties(attr, attrEntity); this.updateById(attrEntity); // 修改/新增relation表 AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity(); relationEntity.setAttrGroupId(attr.getAttrGroupId()); relationEntity.setAttrId(attr.getAttrId()); // 这里主要判断relation表中是否存在对应attr属性id的数据（即表中是否存入对应属性对应分组，如果没有对应分组，那么需要执行插入语句而不是修改语句） Integer count = relationDao.selectCount(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attr.getAttrId())); if (count &gt; 0) &#123; relationDao.update(relationEntity, new UpdateWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attr.getAttrId())); &#125; else &#123; relationDao.insert(relationEntity); &#125;&#125; 平台属性—销售属性（后端） 规格参数和销售属性其实就是attr属性中attrType的不同，所以controller还是同一个，只是请求地址中片段不同，只需要在requestMapping中获得参数判断一下即可， 常量类 在common模块中写一个类，里面写各种枚举 1234567891011public class ProductConstant &#123; public enum AttrEnum &#123; ATTR_TYPE_BASE(1, &quot;基本属性&quot;), ATTR_TYPE_SALE(0, &quot;销售属性&quot;); private int code; private String msg; AttrEnum(int code, String msg) &#123; this.code = code; this.msg = msg; &#125; &#125;&#125; AttrController12345678910111213141516171819202122232425262728@RestController@RequestMapping(&quot;product/attr&quot;)public class AttrController &#123; @Autowired private AttrService attrService; /** * 信息,返回AttrResponseVo对象属性 */ @RequestMapping(&quot;/info/&#123;attrId&#125;&quot;) public R attrResponseInfo(@PathVariable(&quot;attrId&quot;) Long attrId) &#123; AttrResponseVo attr = attrService.getResponseAttrInfo(attrId); return R.ok().put(&quot;attr&quot;, attr); &#125; /** * 条件查询分页列表,返回AttrResponseVo对象属性 * attrType 用于判断是销售属性还是基本属性（详见文档） */ @GetMapping(&quot;/&#123;attrType&#125;/list/&#123;catelogId&#125;&quot;) public R attrResponseList(@RequestParam Map&lt;String, Object&gt; params, @PathVariable(&quot;attrType&quot;) String attrType, @PathVariable(&quot;catelogId&quot;) Long catelogId) &#123; PageUtils page = attrService.queryBaseAttrPage(params, catelogId,attrType); return R.ok().put(&quot;page&quot;, page); &#125;&#125; AttrService12345678910111213141516171819202122232425262728293031323334353637/** * 条件查询attr表分页 * * @param params * @param catelogId * @param attrType * @return */@Overridepublic PageUtils queryBaseAttrPage(Map&lt;String, Object&gt; params, Long catelogId, String attrType) &#123; // 这里判断attrType，用于查询是规格参数还是销售属性 QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;AttrEntity&gt;().eq(&quot;attr_type&quot;, &quot;base&quot;.equalsIgnoreCase(attrType) ? 1 : 0); if (catelogId != 0) &#123; queryWrapper.eq(&quot;catelog_id&quot;, catelogId); &#125; /** * 保存规格参数，连表 */ @Override @Transactional // 事务 public void saveAttr(AttrRequestVo attr) &#123; // 1、保存到attr表 AttrEntity attrEntity = new AttrEntity(); // 使用BeanUtil封装对应属性 BeanUtils.copyProperties(attr, attrEntity); this.save(attrEntity); // 2、保存到relation表 // 判断是否是销售属性，如果不是那么不需要添加到relation表 if (attr.getAttrType() == ProductConstant.AttrEnum.ATTR_TYPE_BASE.getCode()) &#123; AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity(); relationEntity.setAttrId(attrEntity.getAttrId()); // 注意这里要使用attrEntity，因为使用attr是没有id的（没有添加mybatis的注解，所以没有自动生成id） relationEntity.setAttrGroupId(attr.getAttrGroupId()); relationDao.insert(relationEntity); &#125; &#125; &#125; 平台属性—属性分组（后端）查询关联 分组和属性多对多，需要关联表 AttrGroupController12345678910111213141516171819202122@RestController@RequestMapping(&quot;product/attrgroup&quot;)public class AttrGroupController &#123; @Autowired private AttrGroupService attrGroupService; @Autowired private CategoryService categoryService; @Autowired private AttrService attrService; /** * 获得对应分组Id的属性 * * @param attrgroupId * @return */ @GetMapping(&quot;/&#123;attrgroupId&#125;/attr/relation&quot;) public R attrRelationList(@PathVariable(&quot;attrgroupId&quot;) String attrgroupId) &#123; List&lt;AttrEntity&gt; list = attrService.getRelationAttr(attrgroupId); return R.ok().put(&quot;data&quot;, list); &#125;&#125; AttrService123456789101112131415/** * 获得对应分组Id的基本属性（规格参数） * * @param attrgroupId * @return */@Overridepublic List&lt;AttrEntity&gt; getRelationAttr(String attrgroupId) &#123; List&lt;AttrAttrgroupRelationEntity&gt; relationList = relationDao.selectList(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_group_id&quot;, attrgroupId)); List&lt;Long&gt; idList = relationList.stream().map((relationEntity) -&gt; &#123; return relationEntity.getAttrId(); &#125;).collect(Collectors.toList()); Collection&lt;AttrEntity&gt; attrEntities = this.listByIds(idList); return (List&lt;AttrEntity&gt;) attrEntities;&#125; 删除关联AttrGroupRelationVo12345@Datapublic class AttrGroupRelationVo &#123; private Long attrId; private Long attrGroupId;&#125; AttrGroupController12345678/** * 删除关联 */@RequestMapping(&quot;/attr/relation/delete&quot;)public R deleteRelation(AttrGroupRelationVo[] vos) &#123; attrService.deleteRelation(vos); return R.ok();&#125; AttrGroupService1234567891011121314151617/** * 删除关联 * * @param vos */@Overridepublic void deleteRelation(AttrGroupRelationVo[] vos) &#123; // relationDao.delete(new QueryWrapper&lt;&gt;().eq(&quot;attr_id&quot;, attrId).eq(&quot;attr_group_id&quot;, groupId)) // Vos-&gt;relation对象集合 List&lt;AttrAttrgroupRelationEntity&gt; collect = Arrays.asList(vos).stream().map((vo) -&gt; &#123; AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity(); BeanUtils.copyProperties(vo, relationEntity); return relationEntity; &#125;).collect(Collectors.toList()); relationDao.deleteBatchRelation(collect);&#125; AttrAttrGroupRelationDao12345@Mapperpublic interface AttrAttrgroupRelationDao extends BaseMapper&lt;AttrAttrgroupRelationEntity&gt; &#123; void deleteBatchRelation(@Param(&quot;entities&quot;) List&lt;AttrAttrgroupRelationEntity&gt; entities);&#125; 12345678&lt;delete id=&quot;deleteBatchRelation&quot;&gt; DELETE FROM gulimall_pms.pms_attr_attrgroup_relation WHERE &lt;foreach collection=&quot;entities&quot; item=&quot;item&quot; separator=&quot; OR &quot;&gt; (attr_id = #&#123;item.attrId&#125; AND attr_group_id = #&#123;item.attrGroupId&#125;) &lt;/foreach&gt;&lt;/delete&gt; 查询未关联属性AttrGroupController1234567891011/** * 获得对应分组Id没有关联的属性 * * @param attrgroupId * @return */@GetMapping(&quot;/&#123;attrgroupId&#125;/noattr/relation&quot;)public R attrNoRelationList(@PathVariable(&quot;attrgroupId&quot;) String attrgroupId, @RequestParam Map&lt;String, Object&gt; params) &#123; PageUtils pageUtils = attrService.getNoRelationAttr(params, attrgroupId); return R.ok().put(&quot;page&quot;, pageUtils);&#125; AttrService123456789101112131415161718192021222324252627282930313233343536/** * 获得对应分组Id没有关联的属性 * * @param params * @param attrgroupId * @return */@Overridepublic PageUtils getNoRelationAttr(Map&lt;String, Object&gt; params, String attrgroupId) &#123; // 当前分组只能关联自己所属分类里面的属性 AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrgroupId); Long catelogId = attrGroupEntity.getCatelogId(); // 当前分组只能关联没有被别的分组引用的属性 // 获得当前分类下的其他分组 List&lt;AttrGroupEntity&gt; groupEntities = attrGroupDao.selectList(new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId).ne(&quot;attr_group_id&quot;, attrgroupId)); List&lt;Long&gt; groupIdList = groupEntities.stream().map((item) -&gt; &#123; return item.getAttrGroupId(); &#125;).collect(Collectors.toList()); // 获得其他分组中对应的属性id List&lt;AttrAttrgroupRelationEntity&gt; relationEntities = relationDao.selectList(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().in(&quot;attr_group_id&quot;, groupIdList)); List&lt;Long&gt; attrIdList = relationEntities.stream().map((item) -&gt; &#123; return item.getAttrId(); &#125;).collect(Collectors.toList()); // 从当前分类的所有属性中取出上述属性 QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;AttrEntity&gt;().eq(&quot;catelog_id&quot;, catelogId).notIn(&quot;attr_id&quot;, attrIdList); // 模糊查询判断 String key = (String) params.get(&quot;key&quot;); if (!StringUtils.isEmpty(key)) &#123; queryWrapper.and((wrapper) -&gt; &#123; wrapper.eq(&quot;attr_id&quot;, key).or().like(&quot;attr_name&quot;, key); &#125;); &#125; IPage&lt;AttrEntity&gt; iPage = this.page(new Query&lt;AttrEntity&gt;().getPage(params), queryWrapper); PageUtils pageUtils = new PageUtils(iPage); return pageUtils;&#125; TODO：这里有个很奇怪的地方，我修改一下关联的话，属性中的所属分组也会改变？ 哦我傻了，这俩个就是对应的功能 添加关联AttrGroupController1234567891011/** * 新建关联 * * @param vos * @return */@PostMapping(&quot;/attr/relation&quot;)public R addRelation(@RequestBody List&lt;AttrGroupRelationVo&gt; vos) &#123; relationService.saveBatch(vos); return R.ok();&#125; AttrGroupService1234567891011121314/** * 批量保存 * * @param vos */@Overridepublic void saveBatch(List&lt;AttrGroupRelationVo&gt; vos) &#123; List&lt;AttrAttrgroupRelationEntity&gt; relationEntityList = vos.stream().map((vo) -&gt; &#123; AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity(); BeanUtils.copyProperties(vo, relationEntity); return relationEntity; &#125;).collect(Collectors.toList()); this.saveBatch(relationEntityList);&#125; 商品维护—发布商品（后端）获取用户等级配置网关application.yml 详见文档，需要member模块中的功能，之前还没有配过该模块的网关配置，配置一下即可 123456789101112spring: cloud: gateway: routes: # member会员配置 - id: member_route uri: lb://gulimall-member predicates: - Path=/api/member/** # 实现转发 filters: - RewritePath=/api/(?&lt;segment&gt;.*),/$\\&#123;segment&#125; 页面模板 原本renren-generator生成的时候就有了，直接复制到前端src文件夹下即可 然后就好了，基本的增删改查 获得分类关联的品牌BrandVo12345@Datapublic class BrandVo &#123; private Long brandId; private String brandName;&#125; CategoryBrandRelationController123456789101112131415161718192021222324@RestController@RequestMapping(&quot;product/categorybrandrelation&quot;)public class CategoryBrandRelationController &#123; @Autowired private CategoryBrandRelationService relationService; /** * 获取分类关联的所有品牌列表 */ @GetMapping(&quot;/brand/list&quot;) public R relationListByBrand(@RequestParam(&quot;catId&quot;) Long catId) &#123; List&lt;BrandEntity&gt; brandEntities = relationService.getBrandsByCatId(catId); // 先获得brandEntity，在转换成Vo List&lt;BrandVo&gt; list = brandEntities.stream().map((item) -&gt; &#123; BrandVo brandVo = new BrandVo(); // 这里属性名没有对应，所以需要手动设置 brandVo.setBrandId(item.getBrandId()); brandVo.setBrandName(item.getName()); return brandVo; &#125;).collect(Collectors.toList()); return R.ok().put(&quot;data&quot;, list); &#125;&#125; 为什么这里不直接使用relation对象的原因是，为了重用，如果后面还有业务需要获得更多的brand信息，需要用到brandEntity CategoryBrandRelationServiceImpl123456789101112131415/** * 根据catId查询关联的所有品牌的所有信息 * * @param catId * @return */@Overridepublic List&lt;BrandEntity&gt; getBrandsByCatId(Long catId) &#123; List&lt;CategoryBrandRelationEntity&gt; relationList = baseMapper.selectList(new QueryWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;catelog_id&quot;, catId)); List&lt;BrandEntity&gt; collect = relationList.stream().map(relationEntity -&gt; &#123; Long brandId = relationEntity.getBrandId(); return brandService.getById(brandId); &#125;).collect(Collectors.toList()); return collect;&#125; 获取分类关联的分组和属性 分类：手机手表…… 分组：主体，基本信息，其他信息 属性：尺寸，颜色 属性从属于分组，分组从属于分类（多对一），分类和品牌多对多 AttrGroupWithAttrsVo12345678910111213141516171819202122232425262728293031@Datapublic class AttrGroupWithAttrsVo &#123; /** * 分组id */ private Long attrGroupId; /** * 组名 */ private String attrGroupName; /** * 排序 */ private Integer sort; /** * 描述 */ private String descript; /** * 组图标 */ private String icon; /** * 所属分类id */ private Long catelogId; /** * 该分组下的所有属性 */ private List&lt;AttrEntity&gt; attrs;&#125; AttrGroupController1234567891011public class AttrGroupController &#123; /** * 获得对应分类Id关联的分组和属性 */ @GetMapping(&quot;/&#123;catelogId&#125;/withattr&quot;) public R getAttrGroupWithAttr(@PathVariable(&quot;catelogId&quot;) Long catelogId, @RequestParam Map&lt;String, Object&gt; params) &#123; // 查出分组 // 查出属性 List&lt;AttrGroupWithAttrsVo&gt; list = attrGroupService.getWithAttrByCatelogId(catelogId); return R.ok().put(&quot;data&quot;, list); &#125; AttrGroupService1234567891011121314151617/** * 获得对应分类Id关联的分组和属性 */@Overridepublic List&lt;AttrGroupWithAttrsVo&gt; getWithAttrByCatelogId(Long catelogId) &#123; // 查询分组 List&lt;AttrGroupEntity&gt; attrGroupList = this.list(new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId)); List&lt;AttrGroupWithAttrsVo&gt; collect = attrGroupList.stream().map(attrGroupEntity -&gt; &#123; AttrGroupWithAttrsVo attrGroupWithAttrsVo = new AttrGroupWithAttrsVo(); BeanUtils.copyProperties(attrGroupEntity, attrGroupWithAttrsVo); // 查询所有属性 List&lt;AttrEntity&gt; attrList = attrService.getRelationAttr(attrGroupEntity.getAttrGroupId()); attrGroupWithAttrsVo.setAttrs(attrList); return attrGroupWithAttrsVo; &#125;).collect(Collectors.toList()); return collect;&#125; 新增商品Vo 准备一个Vo接收JSON数据，使用BEJSON网站下的转java实体类工具，然后下载即可 真不戳！ SpuInfoController1234567891011121314151617@RestController@RequestMapping(&quot;product/spuinfo&quot;)public class SpuInfoController &#123; @Autowired private SpuInfoService spuInfoService; /** * 保存 */ @RequestMapping(&quot;/save&quot;) //@RequiresPermissions(&quot;product:spuinfo:save&quot;) public R save(@RequestBody SpuSaveVo spuSaveVo) &#123; // spuInfoService.save(spuInfo); spuInfoService.saveSpuVo(spuSaveVo); return R.ok(); &#125;&#125; 远程服务 因为涉及到coupon模块，需要远程调用 开启服务 @EnableDiscoveryClient // 被调用服务application上，开启nacos注册@EnableFeignClients(basePackages = “com.atguigu.gulimall.product.feign”) //feign TO : 由于两个服务之间需要公用一种对象，使用TO传输对象，可以写在common公共模块中 编写接口 远程服务接口123456789101112@FeignClient(&quot;gulimall-coupon&quot;) // 声明调用的服务public interface CouponFeignService &#123; /** * 1 先将远程电调用服务方法的对象转为JSON * 2 请求coupon服务中的save请求，JSON存放在请求体中 * 3 收到请求，将请求体中的JSON转为请求方法的参数 * （@ResponseBody方JSON和对象能够互相转换） */ @PostMapping(&quot;/coupon/spubounds/save&quot;) R saveSpuBound(@RequestBody SpuBoundTo spuBoundTo);&#125; SpuInfoServiceImpl 因为这个商品Vo涉及表众多，还有关联到远程调用，所以代码量较长。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130@Service(&quot;spuInfoService&quot;)public class SpuInfoServiceImpl extends ServiceImpl&lt;SpuInfoDao, SpuInfoEntity&gt; implements SpuInfoService &#123; @Autowired SpuInfoDescService spuInfoDescService; @Autowired SpuImagesService spuImagesService; @Autowired ProductAttrValueService productAttrValueService; @Autowired AttrService attrService; @Autowired SkuInfoService skuInfoService; @Autowired SkuImagesService skuImagesService; @Autowired SkuSaleAttrValueService skuSaleAttrValueService; @Autowired CouponFeignService couponFeignService; /** * 保存saveSpuVoInfo，前端接收的一个对象，涉及多个表 * * @param spuSaveVo */ @Transactional @Override public void saveSpuVoInfo(SpuSaveVo spuSaveVo) &#123; // 保存spu info: spu_info SpuInfoEntity spuInfoEntity = new SpuInfoEntity(); BeanUtils.copyProperties(spuSaveVo, spuInfoEntity); spuInfoEntity.setCreateTime(new Date()); spuInfoEntity.setUpdateTime(new Date()); this.save(spuInfoEntity); // 保存spu info_desc: spu_info_desc List&lt;String&gt; decrypts = spuSaveVo.getDecript(); SpuInfoDescEntity spuInfoDescEntity = new SpuInfoDescEntity(); spuInfoDescEntity.setSpuId(spuInfoEntity.getId()); // 保存之后会将id自动封装到infoEntity spuInfoDescEntity.setDecript(String.join(&quot;,&quot;, decrypts)); // 使用，拼接 spuInfoDescService.save(spuInfoDescEntity); // 保存spu images: spu_images List&lt;String&gt; images = spuSaveVo.getImages(); List&lt;SpuImagesEntity&gt; spuImagesList = images.stream().map(image -&gt; &#123; SpuImagesEntity spuImagesEntity = new SpuImagesEntity(); spuImagesEntity.setSpuId(spuInfoEntity.getId()); spuImagesEntity.setImgUrl(image); return spuImagesEntity; &#125;).collect(Collectors.toList()); spuImagesService.saveBatch(spuImagesList); // 保存spu product_attr_value: product_attr_valu List&lt;BaseAttrs&gt; baseAttrs = spuSaveVo.getBaseAttrs(); List&lt;ProductAttrValueEntity&gt; collect = baseAttrs.stream().map(attr -&gt; &#123; ProductAttrValueEntity attrValueEntity = new ProductAttrValueEntity(); attrValueEntity.setAttrId(attr.getAttrId()); attrValueEntity.setSpuId(spuInfoEntity.getId()); attrValueEntity.setAttrName(attrService.getById(attr.getAttrId()).getAttrName()); attrValueEntity.setAttrValue(attr.getAttrValues()); attrValueEntity.setQuickShow(attr.getShowDesc()); return attrValueEntity; &#125;).collect(Collectors.toList()); productAttrValueService.saveBatch(collect); // 保存spu 积分信息: sms_spu_bounds // 保存sku对应sku_info: sku_info、sku_images、sku_sale_attr_value、sms_sku_ladder、sms_sku_full_reduction、sms_member_price List&lt;Skus&gt; skus = spuSaveVo.getSkus(); if (skus != null &amp;&amp; skus.size() &gt; 0) &#123; skus.forEach(sku -&gt; &#123; // 1 保存基本信息 SkuInfoEntity skuInfoEntity = new SkuInfoEntity(); BeanUtils.copyProperties(sku, skuInfoEntity); skuInfoEntity.setBrandId(spuInfoEntity.getBrandId()); skuInfoEntity.setCatalogId(spuInfoEntity.getCatalogId()); skuInfoEntity.setSaleCount(0L); skuInfoEntity.setSpuId(spuInfoEntity.getId()); String defaultImg = &quot;&quot;; for (Images img : sku.getImages()) &#123; // 这里用for而不是foreach，注意看报错的原因，lamda表达式中的变量要final if (img.getDefaultImg() == 1) &#123; defaultImg = img.getImgUrl(); &#125; &#125; skuInfoEntity.setSkuDefaultImg(defaultImg); skuInfoService.save(skuInfoEntity); Long skuId = skuInfoEntity.getSkuId(); // 必须是保存完之后才能获得 // 2 保存图片 List&lt;SkuImagesEntity&gt; skuImagesList = sku.getImages().stream().map(img -&gt; &#123; SkuImagesEntity skuImagesEntity = new SkuImagesEntity(); skuImagesEntity.setSkuId(skuId); skuImagesEntity.setImgUrl(img.getImgUrl()); skuImagesEntity.setDefaultImg(img.getDefaultImg()); return skuImagesEntity; &#125;).collect(Collectors.toList()); skuImagesService.saveBatch(skuImagesList); // 3 保存属性 List&lt;Attr&gt; attrList = sku.getAttr(); List&lt;SkuSaleAttrValueEntity&gt; skuSaleAttrValueList = attrList.stream().map(attr -&gt; &#123; SkuSaleAttrValueEntity skuSaleAttrValueEntity = new SkuSaleAttrValueEntity(); BeanUtils.copyProperties(attr, skuSaleAttrValueEntity); skuSaleAttrValueEntity.setSkuId(skuId); return skuSaleAttrValueEntity; &#125;).collect(Collectors.toList()); skuSaleAttrValueService.saveBatch(skuSaleAttrValueList); // 以下需要远程服务 // 4 保存优惠 Bounds bounds = spuSaveVo.getBounds(); SpuBoundTo spuBoundTo = new SpuBoundTo(); BeanUtils.copyProperties(bounds, spuBoundTo); spuBoundTo.setSpuId(spuInfoEntity.getId()); R saveSpuBound = couponFeignService.saveSpuBound(spuBoundTo); if (saveSpuBound.getCode() != 0) &#123; log.error(&quot;远程保存spu积分信息失败&quot;); &#125; // 5 保存满减 SkuReductionTo skuReductionTo = new SkuReductionTo(); BeanUtils.copyProperties(sku, skuReductionTo); skuReductionTo.setSkuId(skuId); R saveSkuReduction = couponFeignService.saveSkuReduction(skuReductionTo); if (saveSkuReduction.getCode() != 0) &#123; log.error(&quot;远程保存spu积满减信息失败&quot;); &#125; &#125;); &#125; &#125;&#125; SkuFullReductionServiceImpl123456789101112131415161718192021222324252627282930313233@Service(&quot;skuFullReductionService&quot;)public class SkuFullReductionServiceImpl extends ServiceImpl&lt;SkuFullReductionDao, SkuFullReductionEntity&gt; implements SkuFullReductionService &#123; @Autowired SkuLadderService skuLadderService; @Autowired MemberPriceService memberPriceService; @Override public void saveSkuReduction(SkuReductionTo skuReductionTo) &#123; // 保存ladder SkuLadderEntity skuLadderEntity = new SkuLadderEntity(); skuLadderEntity.setSkuId(skuReductionTo.getSkuId()); skuLadderEntity.setFullCount(skuReductionTo.getFullCount()); skuLadderEntity.setDiscount(skuReductionTo.getDiscount()); skuLadderEntity.setAddOther(skuReductionTo.getCountStatus()); skuLadderService.save(skuLadderEntity); // 保存满减 SkuFullReductionEntity skuFullReductionEntity = new SkuFullReductionEntity(); BeanUtils.copyProperties(skuReductionTo, skuFullReductionEntity); this.save(skuFullReductionEntity); // 保存会员价格 List&lt;MemberPriceTo&gt; memberPriceToList = skuReductionTo.getMemberPrice(); List&lt;MemberPriceEntity&gt; memberPriceList = memberPriceToList.stream().map(memberPriceTo -&gt; &#123; MemberPriceEntity memberPriceEntity = new MemberPriceEntity(); memberPriceEntity.setSkuId(skuReductionTo.getSkuId()); memberPriceEntity.setMemberLevelId(memberPriceTo.getId()); memberPriceEntity.setMemberLevelName(memberPriceTo.getName()); memberPriceEntity.setMemberPrice(memberPriceTo.getPrice()); memberPriceEntity.setAddOther(1); return memberPriceEntity; &#125;).collect(Collectors.toList()); memberPriceService.saveBatch(memberPriceList); &#125;&#125; debug &amp; test 妈耶一次成功有点开心 TODO: 失败的情况没有编写 商品维护—SPU管理（后端）时间戳格式化1234spring: jackson: # 时间戳格式化 date-format: yyyy-MM-dd HH:mm:ss SPU待条件检索123456789/** * 列表 */@RequestMapping(&quot;/list&quot;)//@RequiresPermissions(&quot;product:spuinfo:list&quot;)public R list(@RequestParam Map&lt;String, Object&gt; params) &#123; PageUtils page = spuInfoService.queryPageByCondition(params); return R.ok().put(&quot;page&quot;, page);&#125; 123456789101112131415161718192021222324252627282930313233/* *待条件查询 */@Overridepublic PageUtils queryPageByCondition(Map&lt;String, Object&gt; params) &#123; QueryWrapper&lt;SpuInfoEntity&gt; wrapper = new QueryWrapper&lt;&gt;(); String key = (String) params.get(&quot;key&quot;); if (!StringUtils.isEmpty(key)) &#123; wrapper.and((w) -&gt; &#123; w.eq(&quot;id&quot;, key).or().like(&quot;spu_name&quot;, key); &#125;); &#125; String status = (String) params.get(&quot;status&quot;); if (!StringUtils.isEmpty(status)) &#123; wrapper.eq(&quot;publish_status&quot;, status); &#125; String brandId = (String) params.get(&quot;brandId&quot;); if (!StringUtils.isEmpty(brandId)) &#123; wrapper.eq(&quot;brand_id&quot;, brandId); &#125; String catelogId = (String) params.get(&quot;catelogId&quot;); if (!StringUtils.isEmpty(catelogId)) &#123; wrapper.eq(&quot;catalog_id&quot;, catelogId); &#125; IPage&lt;SpuInfoEntity&gt; page = this.page( new Query&lt;SpuInfoEntity&gt;().getPage(params), wrapper ); return new PageUtils(page);&#125; SKU检索1234567891011121314@RestController@RequestMapping(&quot;product/skuinfo&quot;)public class SkuInfoController &#123; @Autowired private SkuInfoService skuInfoService; /** * 列表 */ @RequestMapping(&quot;/list&quot;) //@RequiresPermissions(&quot;product:skuinfo:list&quot;) public R list(@RequestParam Map&lt;String, Object&gt; params) &#123; PageUtils page = skuInfoService.queryPageByCondition(params); return R.ok().put(&quot;page&quot;, page); &#125; 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic PageUtils queryPageByCondition(Map&lt;String, Object&gt; params) &#123; QueryWrapper&lt;SkuInfoEntity&gt; wrapper = new QueryWrapper&lt;&gt;(); String key = (String) params.get(&quot;key&quot;); if (!StringUtils.isEmpty(key)) &#123; wrapper.and((w) -&gt; &#123; w.eq(&quot;sku_id&quot;, key).or().like(&quot;sku_name&quot;, key); &#125;); &#125; String brandId = (String) params.get(&quot;brandId&quot;); if (!StringUtils.isEmpty(brandId)) &#123; wrapper.eq(&quot;brand_id&quot;, brandId); &#125; String catelogId = (String) params.get(&quot;catelogId&quot;); if (!StringUtils.isEmpty(catelogId)) &#123; wrapper.eq(&quot;catalog_id&quot;, catelogId); &#125; String min = (String) params.get(&quot;min&quot;); if (!StringUtils.isEmpty(min)) &#123; wrapper.ge(&quot;price&quot;, min); &#125; String max = (String) params.get(&quot;max&quot;); if (!StringUtils.isEmpty(max)) &#123; try &#123; BigDecimal bigDecimal = new BigDecimal(max); if (bigDecimal.compareTo(new BigDecimal(0)) == 1) &#123; wrapper.le(&quot;price&quot;, max); &#125; &#125; catch (Exception e) &#123; &#125; &#125; IPage&lt;SkuInfoEntity&gt; page = this.page( new Query&lt;SkuInfoEntity&gt;().getPage(params), wrapper ); return new PageUtils(page);&#125; 库存系统—仓库维护（后端） 仓库相关表：gulimall_wms_xxx 服务：ware 服务基础搭建 application.yml中配置nacos、application name 注解开启nacos（@EnableDiscoveryClient）（com.alibaba.nacos.api.exception.NacosException: java.lang.reflect.InvocationTargetException这个报错是因为没有配置bootstrap） 配置日志 1234# 用于输出日志logging: level: com.atguigu: debug 配置网关 配置mybatis分页插件 获得仓库列表带条件 修改一下原来的queryPage即可，添加上condition 12345678910111213141516171819/** * 模糊查询 * @param params * @return */@Overridepublic PageUtils queryPageByCondition(Map&lt;String, Object&gt; params) &#123; QueryWrapper&lt;WareInfoEntity&gt; wrapper = new QueryWrapper&lt;&gt;(); String key = (String) params.get(&quot;key&quot;); if (!StringUtils.isEmpty(key)) &#123; // and拼接，因为可能id为0所以已经含有了一个eq条件 wrapper.eq(&quot;id&quot;, key).or().like(&quot;name&quot;, key).or().like(&quot;address&quot;, key); &#125; IPage&lt;WareInfoEntity&gt; page = this.page( new Query&lt;WareInfoEntity&gt;().getPage(params), wrapper ); return new PageUtils(page);&#125; 库存系统—商品库存（后端）获得库存列表带条件 同样 库存系统—采购需求（后端）获得需求列表带条件 同样 获得未领取的采购单列表 将多个采购需求合并到一个采购单当中（并且该采购单未被领取） PurchaseController123456789101112131415@RestController@RequestMapping(&quot;ware/purchase&quot;)public class PurchaseController &#123; @Autowired private PurchaseService purchaseService; /** * 获取所有未被领取（或新建）的采购单 */ @RequestMapping(&quot;/unreceive/list&quot;) //@RequiresPermissions(&quot;ware:purchase:list&quot;) public R unreceiveList(@RequestParam Map&lt;String, Object&gt; params) &#123; PageUtils page = purchaseService.queryPageUnreceive(params); return R.ok().put(&quot;page&quot;, page); &#125; PurchaseServiceImpl1234567891011121314151617@Service(&quot;purchaseService&quot;)public class PurchaseServiceImpl extends ServiceImpl&lt;PurchaseDao, PurchaseEntity&gt; implements PurchaseService &#123; /** * 获取所有未被领取（或新建）的采购单 */ @Override public PageUtils queryPageUnreceive(Map&lt;String, Object&gt; params) &#123; QueryWrapper&lt;PurchaseEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;status&quot;, 0).or().eq(&quot;status&quot;, 1); IPage&lt;PurchaseEntity&gt; page = this.page( new Query&lt;PurchaseEntity&gt;().getPage(params), queryWrapper ); return new PageUtils(page); &#125; 合并采购单 如果前端没有传递采购单的id那么就新建一个采购单 WareConstant1234567891011121314151617181920212223242526272829303132333435public class WareConstant &#123; public enum PurchaseStatusEnum &#123; CREATED(0, &quot;新建&quot;), ASSIGN(1, &quot;已分配&quot;), RECEIVE(2, &quot;已领取&quot;), FINISHED(3, &quot;已完成&quot;), HASERROR(4, &quot;异常&quot;); private int code; private String msg; PurchaseStatusEnum(int code, String msg) &#123; this.code = code; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public String getMsg() &#123; return msg; &#125; &#125; public enum PurchaseDetailStatusEnum &#123; CREATED(0, &quot;新建&quot;), ASSIGN(1, &quot;已分配&quot;), BUYYING(2, &quot;正在采购&quot;), FINISHED(3, &quot;已完成&quot;), HASERROR(4, &quot;异常&quot;); private int code; private String msg; PurchaseDetailStatusEnum(int code, String msg) &#123; this.code = code; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public String getMsg() &#123; return msg; &#125; &#125;&#125; MergeVo12345678/** * 合并采购单请求对象 */@Datapublic class MergeVo &#123; private Long purchaseId; private List&lt;Long&gt; items;&#125; PurchaseController1234567891011121314@RestController@RequestMapping(&quot;ware/purchase&quot;)public class PurchaseController &#123; @Autowired private PurchaseService purchaseService; /** * 合并采购单 */ @PostMapping(&quot;/merge&quot;) public R merge(@RequestBody MergeVo mergeVo) &#123; //@RequestBody请求体中的JSON，@RequestParam是url?后跟的键值对，@PathVariable是REST风格url中的&#123;&#125;变量 purchaseService.mergePurchase(mergeVo); return R.ok() &#125; PurchaseServiceImpl1234567891011121314151617181920212223242526/** * 合并采购单 */@Transactional@Overridepublic void mergePurchase(MergeVo mergeVo) &#123; Long purchaseId = mergeVo.getPurchaseId(); if (purchaseId == null) &#123; // 没有采购单id，那么需要新建 PurchaseEntity purchaseEntity = new PurchaseEntity(); purchaseEntity.setStatus(WareConstant.PurchaseStatusEnum.CREATED.getCode()); this.save(purchaseEntity); purchaseId = purchaseEntity.getId(); &#125; List&lt;Long&gt; items = mergeVo.getItems(); Long finalPurchaseId = purchaseId; // 将采购需求id集合对应对象修改状态和采购单id List&lt;PurchaseDetailEntity&gt; detailEntities = items.stream().map(detailId -&gt; &#123; PurchaseDetailEntity detailEntity = new PurchaseDetailEntity(); detailEntity.setId(detailId); detailEntity.setPurchaseId(finalPurchaseId); detailEntity.setStatus(WareConstant.PurchaseDetailStatusEnum.ASSIGN.getCode()); return detailEntity; &#125;).collect(Collectors.toList()); detailService.updateBatchById(detailEntities);&#125; 领取采购单PurchaseController1234567891011121314@RestController@RequestMapping(&quot;ware/purchase&quot;)public class PurchaseController &#123; @Autowired private PurchaseService purchaseService; /** * 领取采购单 */ @PostMapping(&quot;/received&quot;) public R received(@RequestBody List&lt;Long&gt; ids) &#123; purchaseService.receivedByIds(ids); return R.ok(); &#125; PurchaseServiceImpl1234567891011121314151617181920212223242526272829/** * 领取采购单 */ @Override public void receivedByIds(List&lt;Long&gt; ids) &#123; // 判断是否为新建或者已分配（给当前用户，但是这里涉及权限） // 改变采购单状态 List&lt;PurchaseEntity&gt; purchaseEntityList = ids.stream().map(id -&gt; &#123; return this.getById(id); &#125;).filter(item -&gt; &#123; Integer status = item.getStatus(); return (status == WareConstant.PurchaseStatusEnum.ASSIGN.getCode()) || status == WareConstant.PurchaseStatusEnum.CREATED.getCode(); &#125;).map(purchaseEntity -&gt; &#123; purchaseEntity.setStatus(WareConstant.PurchaseStatusEnum.RECEIVE.getCode()); return purchaseEntity; &#125;).collect(Collectors.toList()); this.updateBatchById(purchaseEntityList); // 改变采购项状态 purchaseEntityList.forEach(purchaseEntity -&gt; &#123; List&lt;PurchaseDetailEntity&gt; detailEntityList = detailService.list(new QueryWrapper&lt;PurchaseDetailEntity&gt;().eq(&quot;purchase_id&quot;, purchaseEntity.getId())); List&lt;PurchaseDetailEntity&gt; list = detailEntityList.stream().map(detail -&gt; &#123; PurchaseDetailEntity detailEntity = new PurchaseDetailEntity(); detailEntity.setId(detail.getId()); detailEntity.setStatus(WareConstant.PurchaseDetailStatusEnum.ASSIGN.getCode()); return detailEntity; &#125;).collect(Collectors.toList()); detailService.updateBatchById(list); &#125;); &#125; 完成采购 自动修改对应采购内容的库存数 PurchaseDoneItemVo123456789/** * 完成采购单的请求item */@Datapublic class PurchaseDoneItemVo &#123; private Long itemId; private Integer status; private String reason;&#125; PurchaseFinishedVo123456789101112@Datapublic class PurchaseFinishedVo &#123; /* *采购单id */ @NotNull private Long id; /* *采购项 */ private List&lt;PurchaseDoneItemVo&gt; items;&#125; PurchaseController1234567891011121314@RestController@RequestMapping(&quot;ware/purchase&quot;)public class PurchaseController &#123; @Autowired private PurchaseService purchaseService; /** * 完成采购单 */ @PostMapping(&quot;/done&quot;) public R finish(@RequestBody PurchaseFinishedVo finishedVo) &#123; purchaseService.finishPurchase(finishedVo); return R.ok(); &#125; PurchaseServiceImpl12345678910111213141516171819202122232425262728293031323334353637/** * 完成采购单 */@Overridepublic void finishPurchase(PurchaseFinishedVo finishedVo) &#123; // 1 改变采购项状态 boolean purchaseFinished = true; List&lt;PurchaseDetailEntity&gt; updatedDetailList = new ArrayList&lt;&gt;(); List&lt;PurchaseDoneItemVo&gt; doneItemVoList = finishedVo.getItems(); for (PurchaseDoneItemVo doneItemVo : doneItemVoList) &#123; PurchaseDetailEntity detailEntity = new PurchaseDetailEntity(); if (doneItemVo.getStatus() == WareConstant.PurchaseDetailStatusEnum.HASERROR.getCode()) &#123; // 如果有一个采购项异常，则采购单状态未完成 purchaseFinished = false; &#125; else &#123; // 3 将成功采购的采购项修改库存信息 PurchaseDetailEntity detail = detailService.getById(doneItemVo.getItemId()); wareSkuService.addStock(detail.getSkuId(), detail.getWareId(), detail.getSkuNum()); &#125; // TODO 判断采购数是否完成 detailEntity.setStatus(doneItemVo.getStatus()); detailEntity.setId(doneItemVo.getItemId()); updatedDetailList.add(detailEntity); &#125; detailService.updateBatchById(updatedDetailList); // 2 改变采购单状态(所有采购项都完成后才可完成，否则为异常) PurchaseEntity purchaseEntity = new PurchaseEntity(); purchaseEntity.setId(finishedVo.getId()); if (purchaseFinished) &#123; purchaseEntity.setStatus(WareConstant.PurchaseStatusEnum.FINISHED.getCode()); &#125; else &#123; purchaseEntity.setStatus(WareConstant.PurchaseStatusEnum.HASERROR.getCode()); &#125; this.updateById(purchaseEntity);&#125; WareSkuServiceImpl12345678910111213141516/* *将成功采购的采购项修改库存信息 */@Overridepublic void addStock(Long skuId, Long wareId, Integer skuNum) &#123; // 判断是否有该库存，没有则新增 Integer count = baseMapper.selectCount(new QueryWrapper&lt;WareSkuEntity&gt;().eq(&quot;sku_id&quot;, skuId).eq(&quot;ware_id&quot;, wareId)); if (count == 0) &#123; WareSkuEntity wareSkuEntity = new WareSkuEntity(); wareSkuEntity.setSkuId(skuId); wareSkuEntity.setWareId(wareId); wareSkuEntity.setStock(skuNum); baseMapper.insert(wareSkuEntity); &#125; else baseMapper.addStock(skuId, wareId, skuNum);&#125; WareSkuDao1234567&lt;!-- 将成功采购的采购项修改库存信息 --&gt;&lt;update id=&quot;addStock&quot;&gt; UPDATE gulimall_wms.wms_ware_sku SET stock = stock + #&#123;skuNum&#125; WHERE sku_id = #&#123;skuId&#125; AND ware_id = #&#123;wareId&#125;&lt;/update&gt; 商品维护—SKU规格维护（后端） 这是一个按钮触发的页面，具体解决方案如下 谷粒商城踩坑汇总（分布式基础（全栈开发篇）） - 大厨无盐煮 - 博客园 (cnblogs.com) 获取1234567891011121314151617@RestController@RequestMapping(&quot;product/attr&quot;)public class AttrController &#123; @Autowired private AttrService attrService; @Autowired private ProductAttrValueService valueService; /** * 查出商品的规格属性 */ @GetMapping(&quot;/base/listforspu/&#123;spuId&#125;&quot;) public R baseAttrListForSpu(@PathVariable(&quot;spuId&quot;) Long spuId) &#123; List&lt;ProductAttrValueEntity&gt; data = valueService.baseAttrListForSpu(spuId); return R.ok().put(&quot;data&quot;, data); &#125; 123456@Service(&quot;productAttrValueService&quot;)public class ProductAttrValueServiceImpl extends ServiceImpl&lt;ProductAttrValueDao, ProductAttrValueEntity&gt; implements ProductAttrValueService &#123; @Override public List&lt;ProductAttrValueEntity&gt; baseAttrListForSpu(Long spuId) &#123; return baseMapper.selectList(new QueryWrapper&lt;ProductAttrValueEntity&gt;().eq(&quot;spu_id&quot;, spuId)); &#125; 修改123456789101112@RestController@RequestMapping(&quot;product/attr&quot;)public class AttrController &#123; /** * 修改,使用AttrRequestVo */ @PostMapping(&quot;/update/&#123;spuId&#125;&quot;) public R updateSpuAttr(@PathVariable(&quot;spuId&quot;) String spuId, @RequestBody List&lt;ProductAttrValueEntity&gt; entities) &#123; valueService.updateSpuAttr(spuId, entities); return R.ok(); &#125; 12345678910111213/** * 修改SPU的ATTr */@Transactional@Overridepublic void updateSpuAttr(Long spuId, List&lt;ProductAttrValueEntity&gt; entities) &#123; baseMapper.delete(new QueryWrapper&lt;ProductAttrValueEntity&gt;().eq(&quot;spu_id&quot;, spuId)); List&lt;ProductAttrValueEntity&gt; collect = entities.stream().map(item -&gt; &#123; item.setSpuId(spuId); return item; &#125;).collect(Collectors.toList()); this.saveBatch(collect);&#125; 分布式基础篇—完结撒花🎉","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"微服务","slug":"微服务","permalink":"http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"【项目笔记】商城项目实战2","slug":"【项目笔记】商城项目实战2","date":"2021-10-16T09:37:06.885Z","updated":"2021-10-30T07:35:19.902Z","comments":true,"path":"2021/10/16/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-2/","link":"","permalink":"http://example.com/2021/10/16/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-2/","excerpt":"","text":"品牌管理（后台） 商品系统下的品牌管理，数据库表对应product-brand 使用逆向工程 先使用人人快速开发平台，系统管理—&gt;菜单管理—&gt;添加菜单 使用renren-generator逆向生成工程（之前已经做过了） 复制粘贴其中resource下的modules文件夹下的视图模板（我qiao这么棒的吗） 视图模板这里可以先把权限管理删除（v-if=”isAuth”），或者去index.js中的isAuth方法返回TRUE 增删改查都写好了（还可以这样我qiao） 关闭语法检查 build -&gt; webpack.base.conf.js -&gt; createLintingRule方法中注释即可 ？我发现我注释掉之后会报错，所以还是用我之前那个方法 优化列显示开关按钮element-ui组件 按钮事件 绑定change事件 注意showStatus在数据库中是int类型，所以需要判断转换一下（但是直接把Switch的active-value换成10就不用再转换了） 123456789101112131415161718&lt;el-table-column prop=&quot;showStatus&quot; header-align=&quot;center&quot; align=&quot;center&quot; label=&quot;显示状态&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-switch v-model=&quot;scope.row.showStatus&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot; :active-value=&quot;1&quot; :inactive-value=&quot;0&quot; @change=&quot;updateBrandStatus(scope.row)&quot; &gt; &lt;/el-switch&gt; &lt;/template&gt; &lt;/el-table-column&gt; 12345678910111213141516171819 methods: &#123; // 改变状态 updateBrandStatus(data) &#123; console.log(&quot;当前scope.row：&quot;, data); // 解构 let &#123; brandId, showStatus &#125; = data; // 发送请求修改状态 this.$http(&#123; url: this.$http.adornUrl(&quot;/product/brand/update&quot;), method: &quot;post&quot;, data: this.$http.adornData(&#123; brandId, showStatus &#125;, false) &#125;).then((&#123; data &#125;) =&gt; &#123; this.$message(&#123; type: &quot;success&quot;, message: &quot;状态更新成功&quot; &#125;); &#125;); &#125;,&#125; 云存储服务（文件上传前后端） 老样子阿里云OSS，这里使用了子用户AK 文档：安装 (aliyun.com) AliyunOSS依赖12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;3.10.2&lt;/version&gt;&lt;/dependency&gt; 上传文件 下面是官网文档的demo 12345678910111213141516// yourEndpoint填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。String endpoint = &quot;yourEndpoint&quot;;// 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。String accessKeyId = &quot;yourAccessKeyId&quot;;String accessKeySecret = &quot;yourAccessKeySecret&quot;;// 创建OSSClient实例。OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);// 填写本地文件的完整路径。如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。InputStream inputStream = new FileInputStream(&quot;D:\\\\localpath\\\\examplefile.txt&quot;);// 依次填写Bucket名称（例如examplebucket）和Object完整路径（例如exampledir/exampleobject.txt）。Object完整路径中不能包含Bucket名称。ossClient.putObject(&quot;examplebucket&quot;, &quot;exampledir/exampleobject.txt&quot;, inputStream);// 关闭OSSClient。ossClient.shutdown(); 子用户 AK进入后创建子用户，然后分配权限（现在用到的权限就AliyunOSSFullAccess，用于读写） SpringCloudAlibabaOSS 直接用 文档：spring-cloud-alibaba-component/README.md at master · ylh23y/spring-cloud-alibaba-component (github.com) 依赖12345&lt;!-- springclcloud alibaba oss --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml12345678spring: cloud: # oss配置 alicloud: access-key: secret-key: oss: endpoint: 服务端签名后上传（后端） 文档：服务端签名后直传 (aliyun.com) 创建第三方服务模块 创建专门的模块third-party 将上述的依赖改到这个第三方服务的模块中 依赖123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;com.atguigu.gulimall&lt;/groupId&gt; &lt;artifactId&gt;gulimall-common&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;exclusions&gt; &lt;!-- 不使用数据库，要不然还要配置 --&gt; &lt;exclusion&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- springclcloud alibaba oss --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;/artifactId&gt;&lt;/dependency&gt; 配置nacos bootstrap.properties中配置 123456#nacos注册和配置spring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.config.namespace=925cc47f-8b1d-4756-ba4d-c8da28f784c9spring.cloud.nacos.config.ext-config[0].data-id=oss.ymlspring.cloud.nacos.config.ext-config[0].group=DEFAULT_GROUPspring.cloud.nacos.config.ext-config[0].refresh=true 配置alicloud 在application.yml中，也可以在nacos配置中心配 12345678910111213141516171819spring: cloud: # nacos nacos: discovery: server-addr: 127.0.0.1:8848 # oss配置 alicloud: access-key: secret-key: oss: endpoint: bucket: application: name: gulimall-third-partyserver: port: 30000 单元测试123456789101112131415@RunWith(SpringRunner.class)@SpringBootTestpublic class GulimallThirdPartyApplicationTests &#123; @Autowired OSSClient ossClient; @Test public void aliyunOssTest() throws FileNotFoundException &#123; InputStream inputStream = new FileInputStream(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\谷粒电商\\\\1\\\\docs\\\\pics\\\\6a1b2703a9ed8737.jpg&quot;); // 依次填写Bucket名称（例如examplebucket）和Object完整路径（例如exampledir/exampleobject.txt）。Object完整路径中不能包含Bucket名称。 ossClient.putObject(&quot;lh-demo-gulimall&quot;, &quot;test2.jpg&quot;, inputStream); // 关闭OSSClient。 ossClient.shutdown(); System.out.println(&quot;上传完成&quot;); &#125;&#125; 编写OSSController 这里有一个点要注意，自动注入OSS接口，而不是OSSClient实现类 见P63，debug几秒钟绝了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RestControllerpublic class OssController &#123; // 这里debug好快啊，不愧是老师， // OSS接口，OSSClient是实现类已经写好的，要自动注入接口 @Autowired OSS ossClient; @Value(&quot;$&#123;spring.cloud.alicloud.oss.endpoint&#125;&quot;) private String endpoint; @Value(&quot;$&#123;spring.cloud.alicloud.oss.bucket&#125;&quot;) private String bucket; @Value(&quot;$&#123;spring.cloud.alicloud.access-key&#125;&quot;) private String accessId; @RequestMapping(&quot;/oss/policy&quot;) public R policy() &#123; String host = &quot;https://&quot; + bucket + &quot;.&quot; + endpoint; // host的格式为 bucketname.endpoint // callbackUrl为上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。 // String callbackUrl = &quot;http://88.88.88.88:8888&quot;; // 以当前日期分类 String format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date()); String dir = format + &quot;/&quot;; // 用户上传文件时指定的前缀。 Map&lt;String, String&gt; respMap = null; try &#123; long expireTime = 30; long expireEndTime = System.currentTimeMillis() + expireTime * 1000; Date expiration = new Date(expireEndTime); // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。 PolicyConditions policyConds = new PolicyConditions(); policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000); policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir); String postPolicy = ossClient.generatePostPolicy(expiration, policyConds); byte[] binaryData = postPolicy.getBytes(&quot;utf-8&quot;); String encodedPolicy = BinaryUtil.toBase64String(binaryData); String postSignature = ossClient.calculatePostSignature(postPolicy); respMap = new LinkedHashMap&lt;String, String&gt;(); respMap.put(&quot;accessid&quot;, accessId); respMap.put(&quot;policy&quot;, encodedPolicy); respMap.put(&quot;signature&quot;, postSignature); respMap.put(&quot;dir&quot;, dir); respMap.put(&quot;host&quot;, host); respMap.put(&quot;expire&quot;, String.valueOf(expireEndTime / 1000)); // respMap.put(&quot;expire&quot;, formatISO8601Date(expiration)); &#125; catch (Exception e) &#123; // Assert.fail(e.getMessage()); System.out.println(e.getMessage()); &#125; finally &#123; ossClient.shutdown(); &#125; return R.ok().put(&quot;data&quot;, respMap); &#125;&#125; 然后就可以通过访问localhost:30000/oss/policy获取签名等数据 配置网关application.yml123456789101112spring: cloud: gateway: routes: - id: third_party_route uri: lb://gulimall-third-party predicates: - Path=/api/thirdparty/** # 实现转发 filters: # localhost:88/api/thirdparty/oss/policy -&gt; localhost:30000/oss/policy - RewritePath=/api/thirdparty/(?&lt;segment&gt;.*),/$\\&#123;segment&#125; 文件上传（前端） 资料里有封装好的模板，放入component，将其中el-upload中action属性值改为oss bucket的域名 vue 使用上述组件 注意这里component里面的名字要和import对应，要不然不报错还显示不出来问题（差点吓死我） 1234567&lt;el-form-item label=&quot;品牌logo地址&quot; prop=&quot;logo&quot;&gt; &lt;singleUpload v-model=&quot;dataForm.logo&quot;&gt; &lt;/singleUpload&gt;&lt;/el-form-item&gt;&lt;script&gt;import singleUpload from &quot;@/components/upload/singleUpload&quot;;export default &#123; components: &#123; singleUpload &#125;, 开启跨域 OSS控制台里进入bucket，创建规则 测试 OK，主要实现可以去看组件里的实现 表单数据校验（前端）优化列表显示 logo显示图片 表单校验 使用element-ui的表单验证，自定义校验规则 12345678910&lt;el-form-item label=&quot;检索首字母&quot; prop=&quot;firstLetter&quot;&gt; &lt;el-input v-model=&quot;dataForm.firstLetter&quot; placeholder=&quot;检索首字母&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;排序&quot; prop=&quot;sort&quot;&gt; &lt;!-- v-model.number只允许输入数字类型 --&gt; &lt;el-input v-model.number=&quot;dataForm.sort&quot; placeholder=&quot;排序&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; 1234567891011121314151617181920212223242526272829303132333435363738data() &#123; return &#123; dataRule: &#123; firstLetter: [ &#123; // 自定义验证规则，使用validator，后跟箭头函数定义规则，也可以写到data中 validator: (rule, value, callback) =&gt; &#123; if (value === &quot;&quot;) &#123; callback(new Error(&quot;首字母必须填写&quot;)); &#125; else if (!/^[a-zA-Z]$/.test(value)) &#123; // 使用正则表达式判断是否为a-z A-Z callback(new Error(&quot;首字母必须a-z或者A-Z之间的单个字母&quot;)); &#125; else &#123; callback(); &#125; &#125;, trigger: &quot;blur&quot; &#125; ], sort: [ &#123; validator: (rule, value, callback) =&gt; &#123; if (value === &quot;&quot;) &#123; callback(new Error(&quot;排序字段必须填写&quot;)); &#125; else if (!Number.isInteger(value)) &#123; callback(new Error(&quot;请输入数字值&quot;)); &#125; else if (value &lt; 0) &#123; callback(new Error(&quot;排序字段必须大于0&quot;)); &#125; else &#123; callback(); &#125; &#125;, trigger: &quot;blur&quot; &#125; ] &#125; &#125;; &#125;, 表单数据校验（后端）普通校验Bean校验注解 校验规则 @xxx javax.validation.constraints下的注解，用于定义校验规则 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Data@TableName(&quot;pms_brand&quot;)public class BrandEntity implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 品牌id */ @TableId private Long brandId; /** * 品牌名 */ @NotEmpty // 验证规则，String类型非空 @NotBlank(message = &quot;品牌名不能为空&quot;) // 验证规则，至少包含一个非空字符，msg为出错时的提示信息 private String name; /** * 品牌logo地址 */ @NotEmpty @URL(message = &quot;LOGO必须是合法的URL地址&quot;) // 验证规则，必须是url private String logo; /** * 介绍 */ @NotEmpty private String descript; /** * 显示状态[0-不显示；1-显示] */ @NotNull // 验证规则，Integer类型非空 private Integer showStatus; /** * 检索首字母 */ @NotEmpty @Pattern(regexp = &quot;/^[a-zA-Z]$/&quot;, message = &quot;检索字母必须是a-z或者A-Z中的单个字母&quot;) // 使用自定义校验规则，可以写正则表达式 private String firstLetter; /** * 排序 */ @NotEmpty @Min(value = 0) // 验证规则，最小不能小于value private Integer sort;&#125; Controller校验注解 开启校验 @Valid 开启校验 123456789101112131415@RestController@RequestMapping(&quot;product/brand&quot;)public class BrandController &#123; @Autowired private BrandService brandService; /** * 保存 */ @RequestMapping(&quot;/save&quot;) //@RequiresPermissions(&quot;product:brand:save&quot;) public R save(@Valid @RequestBody BrandEntity brand) &#123; brandService.save(brand); return R.ok(); &#125;&#125; 获取校验结果 BindingResult result封装了紧跟着的对象的校验结果 123456789101112131415161718192021/** * 保存 */@RequestMapping(&quot;/save&quot;)//BindingResult result封装了紧跟着的对象的校验结果public R save(@Valid @RequestBody BrandEntity brand, BindingResult result) &#123; // 判断校验是否出错 if (result.hasErrors()) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 获取校验结果并且封装到map result.getFieldErrors().forEach((fieldError) -&gt; &#123; String message = fieldError.getDefaultMessage(); String fieldName = fieldError.getField(); map.put(fieldName, message); &#125;); return R.error(400, &quot;递交的数据不合法&quot;).put(&quot;data&quot;, map); &#125; else &#123; brandService.save(brand); return R.ok(); &#125;&#125; 这个写法可以使用统一异常处理类解决 JSR303分组校验 设想brandId，有两种情况：一是新增，二是修改。当新增的时候我们不需要传入id，而修改的时候需要，那这个时候就需要用到分组校验。 编写接口 使用valid中的注解，里面有一个属性group用于分组，后跟接口类型（只是用于标识区别，接口中不比写代码） Bean校验注释 带分组12345678910111213/** * 品牌id */@NotNull(message = &quot;修改必须指定id&quot;, groups = &#123;UpdateGroup.class&#125;)@Null(message = &quot;新增不能指定id&quot;, groups = &#123;AddGroup.class&#125;)@TableIdprivate Long brandId; /** * 品牌名 */@NotEmpty // 验证规则，String类型非空@NotBlank(message = &quot;品牌名不能为空&quot;,, groups = &#123;AddGroup.class, UpdateGroup.class&#125;) // 验证规则，至少包含一个非空字符，msg为出错时的提示信息private String name; 没有指定group的默认不校验（如果是使用了@Validated({XXX.class})分组校验的情况下） Controller校验注释 带分组12345678910/** * 保存 */@RequestMapping(&quot;/save&quot;)//BindingResult result封装了紧跟着的对象的校验结果public R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand) &#123; // 使用统一异常处理，当有异常的时候直接抛出异常即可 brandService.save(brand); return R.ok();&#125; 自定义校验注解依赖123456&lt;!-- validation --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt;&lt;/dependency&gt; 配置文件ValidationMessages.properties1com.atguigu.common.valid.ListValue.message=必须提交指定的值 别的也可以写在这里面 自定义校验器ListValueConstraintValidator12345678910111213141516171819202122/** * 自定义校验器 */// ConstraintValidator接口《校验注解名，字段名》public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue, Integer&gt; &#123; private Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); @Override public void initialize(ListValue constraintAnnotation) &#123; int[] vals = constraintAnnotation.vals(); for (int val : vals) &#123; set.add(val); &#125; &#125; // 判断是否校验成功(是否包含在注解的val值中) @Override public boolean isValid(Integer value, ConstraintValidatorContext context) &#123; return set.contains(value); &#125;&#125; 自定义校验注解ListValue12345678910111213141516@Documented@Constraint(validatedBy = &#123;ListValueConstraintValidator.class&#125;) // 放入自定义校验器@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)@Retention(RUNTIME)public @interface ListValue &#123; // 需要从配置文件中获取 String message() default &quot;&#123;com.atguigu.common.valid.ListValue.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; int[] vals() default &#123;&#125;;&#125; Bean注解123456/** * 显示状态[0-不显示；1-显示] */@NotNull(message = &quot;必须指定显示状态[0-不显示；1-显示]&quot;, groups = &#123;AddGroup.class, UpdateGroup.class&#125;) // 验证规则，Integer类型非空@ListValue(vals = &#123;0, 1&#125;, groups = &#123;AddGroup.class&#125;)// 自定义验证规则，必须为0或1private Integer showStatus; controller注解12345678910/** * 保存 */@RequestMapping(&quot;/save&quot;)//BindingResult result封装了紧跟着的对象的校验结果public R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand) &#123; // 使用统一异常处理，当有异常的时候直接抛出异常即可 brandService.save(brand); return R.ok();&#125; 统一异常处理 上述不同结果不同返回，可以使用统一异常处理解决重复代码的编写问题 统一异常处理类 使用两个注解@RestControllerAdvice+@ExceptionHandler 123456789101112131415161718192021/** * 统一异常处理 */@ResponseBody@Slf4j // 日志@RestControllerAdvice(basePackages = &quot;com.atguigu.gulimall.product.controller&quot;)// 标志这是一个REST风格的ControllerAdvice，即增强的controller，可以用于全局异常处理，后跟需要处理的包名public class GulimallExceptionControllerAdvice &#123; @ExceptionHandler(value = MethodArgumentNotValidException.class) // 异常处理，value为指定处理的异常 public R handleValidException(MethodArgumentNotValidException e) &#123; log.error(&quot;数据校验有误&#123;&#125;,异常类型&#123;&#125;&quot;, e.getMessage(), e.getClass()); // 用于测试，先写Exception然后主动出错,就可以获得异常的类型 Map&lt;String, String&gt; errorMap = new HashMap&lt;&gt;(); BindingResult bindingResult = e.getBindingResult(); bindingResult.getFieldErrors().forEach((item) -&gt; &#123; errorMap.put(item.getField(), item.getDefaultMessage()); &#125;); return R.error(400, &quot;数据校验有误&quot;).put(&quot;data&quot;, errorMap); &#125; &#125; 则controller中的方法不再需要进行判断，出现异常后统一抛出给这个类处理 系统错误码（枚举） 可以写一个枚举，放在common里面 1234567891011121314151617181920212223/** * 枚举，错误码 */public enum BizCodeEnum &#123; UNKNOWN_EXCEPTION(10000, &quot;系统未知异常&quot;), VALID_EXCEPTION(10001, &quot;参数格式校验失败&quot;); private Integer code; private String msg; BizCodeEnum(int code, String msg) &#123; this.code = code; this.msg = msg; &#125; public Integer getCode() &#123; return code; &#125; public String getMsg() &#123; return msg; &#125;&#125; 统一异常处理类（使用错误码）12345678910111213141516171819202122232425/** * 统一异常处理 */@ResponseBody@Slf4j // 日志@RestControllerAdvice(basePackages = &quot;com.atguigu.gulimall.product.controller&quot;)// 标志这是一个REST风格的ControllerAdvice，即增强的controller，可以用于全局异常处理，后跟需要处理的包名public class GulimallExceptionControllerAdvice &#123; @ExceptionHandler(value = MethodArgumentNotValidException.class) // 异常处理，value为指定处理的异常 public R handleValidException(MethodArgumentNotValidException e) &#123; log.error(&quot;数据校验有误&#123;&#125;,异常类型&#123;&#125;&quot;, e.getMessage(), e.getClass()); // 用于测试，先写Exception然后主动出错,就可以获得异常的类型 Map&lt;String, String&gt; errorMap = new HashMap&lt;&gt;(); BindingResult bindingResult = e.getBindingResult(); bindingResult.getFieldErrors().forEach((item) -&gt; &#123; errorMap.put(item.getField(), item.getDefaultMessage()); &#125;); return R.error(BizCodeEnum.VALID_EXCEPTION.getCode(), BizCodeEnum.VALID_EXCEPTION.getMsg()).put(&quot;data&quot;, errorMap); &#125; @ExceptionHandler(value = Throwable.class) public R handleException(Throwable throwable) &#123; return R.error(BizCodeEnum.UNKNOWN_EXCEPTION.getCode(), BizCodeEnum.UNKNOWN_EXCEPTION.getMsg()); &#125;&#125; 属性分组（前后端）SKU &amp; SPU &amp; 规则参数 &amp; 销售属性 SPU： Standard Product Unit（标准化产品单元）是商品信息聚合的最小单位， 是一组可复用、 易检索的标准化信息的集合， 该集合描述了一个产品的特性。 SKU： Stock Keeping Unit（库存量单位）即库存进出计量的基本单元， 可以是以件， 盒， 托盘等为单位。 SKU 这是对于大型连锁超市DC（配送中心） 物流管理的一个必要的方法。 现在已经被引申为产品统一编号的简称， 每种产品均对应有唯一的 SKU 号。 每个分类下的商品共享规格参数， 与销售属性。 只是有些商品不一定要用这个分类下全部的属性； 属性是以三级分类组织起来的 规格参数中有些是可以提供检索的 规格参数也是基本属性， 他们具有自己的分组 属性的分组也是以三级分类组织起来的 属性名确定的， 但是值是每一个商品不同来决定的 数据库设计 P70 前端基础搭建创建menu 人人快速开发平台 —》系统管理 —》菜单管理 —》添加菜单 抽取三级分类 把category中显示的部分拿出来，放到单独的vue中，然后在需要使用的vue中import组件，并且在component中声明，然后直接使用组件名标签即可 逆向工程 生成attrgroup放到布局的右边，左边放三级分类 VUE父子组件传递数据子组件-&gt;父组件 使用事件机制，子组件给父组件发送时间并携带数据 123456789101112131415161718&lt;template&gt; &lt;el-tree @node-click=&quot;nodeClick&quot; &gt; &lt;/el-tree&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; // 节点点击事件 nodeClick(data, node, component) &#123; // 向父组件发送时间 this.$emit(&quot;tree-node-click&quot;, data, node, component); &#125; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920&lt;!-- --&gt;&lt;template&gt; &lt;div class=&quot;&quot;&gt; &lt;el-row :gutter=&quot;20&quot;&gt; &lt;el-col :span=&quot;6&quot; &gt;&lt;category @tree-node-click=&quot;nodeClick&quot;&gt;&lt;/category &gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; // 子组件事件响应 nodeClick(data, node, component) &#123; console.log(&quot;父组件捕获事件并获取数据：&quot;, data, node, component); &#125;, &#125;&#125;;&lt;/script&gt; 获取分类属性分组（后端）AttrGroupController123456789/** * 列表 */@RequestMapping(&quot;/list/&#123;catelogId&#125;&quot;)//@RequiresPermissions(&quot;product:attrgroup:list&quot;)public R list(@RequestParam Map&lt;String, Object&gt; params, @PathVariable Long catelogId) &#123; PageUtils page = attrGroupService.queryPage(params, catelogId); return R.ok().put(&quot;page&quot;, page);&#125; AttrGroupServiceImpl1234567891011121314151617181920@Overridepublic PageUtils queryPage(Map&lt;String, Object&gt; params, Long catelogId) &#123; if (catelogId == 0) &#123; // 未指定分类 IPage&lt;AttrGroupEntity&gt; page = this.page(new Query&lt;AttrGroupEntity&gt;().getPage(params), new QueryWrapper&lt;&gt;()); return new PageUtils(page); &#125; else &#123; // key是检索条件，已经封装好的 String key = (String) params.get(&quot;key&quot;); QueryWrapper&lt;AttrGroupEntity&gt; wrapper = new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId); // 如果有key,那么再加上and条件，条件中判断如下 if (!StringUtils.isEmpty(key)) &#123; wrapper.and((obj) -&gt; &#123; obj.eq(&quot;attr_group_id&quot;, key).or().like(&quot;attr_group_name&quot;, key); &#125;); &#125; IPage&lt;AttrGroupEntity&gt; page = this.page(new Query&lt;AttrGroupEntity&gt;().getPage(params), wrapper); return new PageUtils(page); &#125;&#125; 新增、修改分组 &amp; 级联选择器 当字段为空时不返回空值123456/** * 子分类 */@JsonInclude(JsonInclude.Include.NON_EMPTY) // 当该字段不为空时才返回字段kv@TableField(exist = false) // 表示该属性在数据表中不存在private List&lt;CategoryEntity&gt; children; 新增分组 /#/product-attrgroup 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;template&gt; &lt;el-dialog :title=&quot;!dataForm.attrGroupId ? &#x27;新增&#x27; : &#x27;修改&#x27;&quot; :close-on-click-modal=&quot;false&quot; :visible.sync=&quot;visible&quot; &gt; &lt;el-form :model=&quot;dataForm&quot; :rules=&quot;dataRule&quot; ref=&quot;dataForm&quot; @keyup.enter.native=&quot;dataFormSubmit()&quot; label-width=&quot;80px&quot; &gt; &lt;el-form-item label=&quot;组名&quot; prop=&quot;attrGroupName&quot;&gt; &lt;el-input v-model=&quot;dataForm.attrGroupName&quot; placeholder=&quot;组名&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;排序&quot; prop=&quot;sort&quot;&gt; &lt;el-input v-model=&quot;dataForm.sort&quot; placeholder=&quot;排序&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;描述&quot; prop=&quot;descript&quot;&gt; &lt;el-input v-model=&quot;dataForm.descript&quot; placeholder=&quot;描述&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;组图标&quot; prop=&quot;icon&quot;&gt; &lt;el-input v-model=&quot;dataForm.icon&quot; placeholder=&quot;组图标&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;所属分类id&quot; prop=&quot;catelogId&quot;&gt; &lt;el-cascader v-model=&quot;dataForm.catelogIds&quot; :options=&quot;categorys&quot; :props=&quot;props&quot; &gt;&lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;visible = false&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dataFormSubmit()&quot;&gt;确定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; categorys: [], props: &#123; value: &quot;catId&quot;, label: &quot;name&quot;, children: &quot;children&quot; &#125;, visible: false, dataForm: &#123; attrGroupId: 0, attrGroupName: &quot;&quot;, sort: &quot;&quot;, descript: &quot;&quot;, icon: &quot;&quot;, catelogIds: [], catelogId: 0 &#125;, dataRule: &#123; attrGroupName: [ &#123; required: true, message: &quot;组名不能为空&quot;, trigger: &quot;blur&quot; &#125; ], sort: [&#123; required: true, message: &quot;排序不能为空&quot;, trigger: &quot;blur&quot; &#125;], descript: [ &#123; required: true, message: &quot;描述不能为空&quot;, trigger: &quot;blur&quot; &#125; ], icon: [&#123; required: true, message: &quot;组图标不能为空&quot;, trigger: &quot;blur&quot; &#125;], catelogId: [ &#123; required: true, message: &quot;所属分类id不能为空&quot;, trigger: &quot;blur&quot; &#125; ] &#125; &#125;; &#125;, created() &#123; this.getMenus(); &#125;, methods: &#123; // 获取所有分类 getMenus() &#123; this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/list/tree&quot;), method: &quot;get&quot; &#125;).then((&#123; data &#125;) =&gt; &#123; console.log(data); // 这里data使用了解构 this.categorys = data.data; &#125;); &#125;, init(id) &#123; this.dataForm.attrGroupId = id || 0; this.visible = true; this.$nextTick(() =&gt; &#123; this.$refs[&quot;dataForm&quot;].resetFields(); if (this.dataForm.attrGroupId) &#123; this.$http(&#123; url: this.$http.adornUrl( `/product/attrgroup/info/$&#123;this.dataForm.attrGroupId&#125;` ), method: &quot;get&quot;, params: this.$http.adornParams() &#125;).then((&#123; data &#125;) =&gt; &#123; if (data &amp;&amp; data.code === 0) &#123; this.dataForm.attrGroupName = data.attrGroup.attrGroupName; this.dataForm.sort = data.attrGroup.sort; this.dataForm.descript = data.attrGroup.descript; this.dataForm.icon = data.attrGroup.icon; this.dataForm.catelogId = data.attrGroup.catelogId; &#125; &#125;); &#125; &#125;); &#125;, // 表单提交 dataFormSubmit() &#123; this.$refs[&quot;dataForm&quot;].validate(valid =&gt; &#123; if (valid) &#123; this.$http(&#123; url: this.$http.adornUrl( `/product/attrgroup/$&#123; !this.dataForm.attrGroupId ? &quot;save&quot; : &quot;update&quot; &#125;` ), method: &quot;post&quot;, data: this.$http.adornData(&#123; attrGroupId: this.dataForm.attrGroupId || undefined, attrGroupName: this.dataForm.attrGroupName, sort: this.dataForm.sort, descript: this.dataForm.descript, icon: this.dataForm.icon, catelogId: this.dataForm.catelogIds[ this.dataForm.catelogIds.length - 1 ] &#125;) &#125;).then((&#123; data &#125;) =&gt; &#123; if (data &amp;&amp; data.code === 0) &#123; this.$message(&#123; message: &quot;操作成功&quot;, type: &quot;success&quot;, duration: 1500, onClose: () =&gt; &#123; this.visible = false; this.$emit(&quot;refreshDataList&quot;); &#125; &#125;); &#125; else &#123; this.$message.error(data.msg); &#125; &#125;); &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt; 非数据库中的字段@TableField(exist = false)12345/** * 所属分类id的完整路径 */@TableField(exist = false) // 不是数据库中存在的字段private Long[] catelogPath; 级联选择器回显（后端） 用于搜索分类的完整路径然后回显给级联选择器 12345678910111213141516171819@RestController@RequestMapping(&quot;product/attrgroup&quot;)public class AttrGroupController &#123; /** * 信息 */ @RequestMapping(&quot;/info/&#123;attrGroupId&#125;&quot;) //@RequiresPermissions(&quot;product:attrgroup:info&quot;) public R info(@PathVariable(&quot;attrGroupId&quot;) Long attrGroupId) &#123; AttrGroupEntity attrGroup = attrGroupService.getById(attrGroupId); Long catelogId = attrGroup.getCatelogId(); // 获取完整分类路径（前端所需） Long[] path = categoryService.findCategoryPath(catelogId); attrGroup.setCatelogPath(path); return R.ok().put(&quot;attrGroup&quot;, attrGroup); &#125;&#125; 1234567891011121314151617@Overridepublic Long[] findCategoryPath(Long catelogId) &#123; List&lt;Long&gt; path = new ArrayList&lt;&gt;(); List&lt;Long&gt; parentPath = findParentPath(catelogId, path); // 这里需要逆序一下（因为是倒着找的） Collections.reverse(parentPath); return parentPath.toArray(new Long[0]);&#125;private List&lt;Long&gt; findParentPath(Long catelogId, List&lt;Long&gt; path) &#123; path.add(catelogId); CategoryEntity byId = this.getById(catelogId); if (byId.getParentCid() != 0) &#123; findParentPath(byId.getParentCid(), path); &#125; return path;&#125; 级联选择器回显（前端）123456789101112131415161718192021222324252627init(id) &#123; this.dataForm.attrGroupId = id || 0; this.visible = true; // $nextTick当组件完全渲染完成之后调用 this.$nextTick(() =&gt; &#123; this.$refs[&quot;dataForm&quot;].resetFields(); if (this.dataForm.attrGroupId) &#123; this.$http(&#123; url: this.$http.adornUrl( `/product/attrgroup/info/$&#123;this.dataForm.attrGroupId&#125;` ), method: &quot;get&quot;, params: this.$http.adornParams() &#125;).then((&#123; data &#125;) =&gt; &#123; if (data &amp;&amp; data.code === 0) &#123; this.dataForm.attrGroupName = data.attrGroup.attrGroupName; this.dataForm.sort = data.attrGroup.sort; this.dataForm.descript = data.attrGroup.descript; this.dataForm.icon = data.attrGroup.icon; this.dataForm.catelogId = data.attrGroup.catelogId; // 当前catlog的完整路径 this.dataForm.catelogPath = data.attrGroup.catelogPath; &#125; &#125;); &#125; &#125;); &#125;, 123456789// 新增 / 修改addOrUpdateHandle(id) &#123; this.addOrUpdateVisible = true; // $nextTick当组件完全渲染完成之后调用 this.$nextTick(() =&gt; &#123; // 调用addOrUpdate组件中的init函数 this.$refs.addOrUpdate.init(id); &#125;);&#125;, 123456789&lt;!-- @closed=&quot;dialogClose&quot; 对话框关闭回调事件 --&gt;&lt;el-dialog :title=&quot;!dataForm.attrGroupId ? &#x27;新增&#x27; : &#x27;修改&#x27;&quot; :close-on-click-modal=&quot;false&quot; :visible.sync=&quot;visible&quot; @closed=&quot;dialogClose&quot;&gt; 123456methods: &#123; // 关闭对话框清空数据 dialogClose() &#123; this.dataForm.catelogPath = []; &#125;,&#125; 品牌管理页面 之前页面完善一下 MyBatis-Plus分页插件 写法与版本有关，注意官网文档 1234567891011121314151617181920212223package com.atguigu.gulimall.product.config;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;@Configuration // 配置类@EnableTransactionManagement // 开启事务功能@MapperScan(&quot;com.atguigu.gulimall.product.dao&quot;)public class MybatisPlusConfig &#123; // 引入分页插件（注意这里是旧版本，如果版本较新需要自行去官网查看最新写法） @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false paginationInterceptor.setOverflow(true); // 设置最大单页限制数量，默认 500 条，-1 不受限制 paginationInterceptor.setLimit(1000); return paginationInterceptor; &#125;&#125; 模糊查询 去page对象中添加querywrapper即可 1234567891011121314151617@Service(&quot;brandService&quot;)public class BrandServiceImpl extends ServiceImpl&lt;BrandDao, BrandEntity&gt; implements BrandService &#123; @Override public PageUtils queryPage(Map&lt;String, Object&gt; params) &#123; QueryWrapper&lt;BrandEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;(); // 模糊查询 String key = (String) params.get(&quot;key&quot;); if (!StringUtils.isEmpty(key)) &#123; queryWrapper.eq(&quot;brand_id&quot;, key).or().like(&quot;name&quot;, key); &#125; IPage&lt;BrandEntity&gt; page = this.page( new Query&lt;BrandEntity&gt;().getPage(params), queryWrapper ); return new PageUtils(page); &#125;&#125; 品牌分类关联 一个品牌可能做多种产品，所以需要关联 实现查询关联列表和新增关联 数据表 抽取出来一个category_brand_relation表，因为是多对多的关系 查询、新增品牌关联（后端）123456789101112131415161718192021222324@RestController@RequestMapping(&quot;product/categorybrandrelation&quot;)public class CategoryBrandRelationController &#123; @Autowired private CategoryBrandRelationService categoryBrandRelationService; /** * 获取品牌关联的所有分类列表 */ @GetMapping(&quot;/catelog/list&quot;) public R relationList(@RequestParam(&quot;brandId&quot;) Long brandId) &#123; List&lt;CategoryBrandRelationEntity&gt; data = categoryBrandRelationService.list( new QueryWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;brand_id&quot;, brandId)); return R.ok().put(&quot;data&quot;, data); &#125; /** * 保存品牌关联的所有分类 */ @PostMapping(&quot;/save&quot;) public R save(@RequestBody CategoryBrandRelationEntity categoryBrandRelation) &#123; categoryBrandRelationService.mySave(categoryBrandRelation); return R.ok(); &#125;&#125; 12345678910111213141516171819202122@Service(&quot;categoryBrandRelationService&quot;)public class CategoryBrandRelationServiceImpl extends ServiceImpl&lt;CategoryBrandRelationDao, CategoryBrandRelationEntity&gt; implements CategoryBrandRelationService &#123; @Autowired BrandDao brandDao; @Autowired CategoryDao categoryDao; /** * 保存品牌关联的所有分类 */ @Override public void mySave(CategoryBrandRelationEntity categoryBrandRelation) &#123; Long brandId = categoryBrandRelation.getBrandId(); Long catelogId = categoryBrandRelation.getCatelogId(); // 查询对应name BrandEntity brandEntity = brandDao.selectById(brandId); categoryBrandRelation.setBrandName(brandEntity.getName()); CategoryEntity categoryEntity = categoryDao.selectById(catelogId); categoryBrandRelation.setCatelogName(categoryEntity.getName()); // 保存 baseMapper.insert(categoryBrandRelation); &#125;&#125; 连表修改 例如修改品牌信息，不仅要修改brand表，还有修改category_brand_relation等相关表 1234567891011121314151617@Service(&quot;brandService&quot;)public class BrandServiceImpl extends ServiceImpl&lt;BrandDao, BrandEntity&gt; implements BrandService &#123; /** * 修改品牌信息相关所有表的信息 * * @param brand */ @Override public void updateDetail(BrandEntity brand) &#123; this.updateById(brand); if (!StringUtils.isEmpty(brand.getName())) &#123; // 更新其他关联表中的数据 categoryBrandRelationService.updateBrand(brand.getBrandId(), brand.getName()); &#125; // TODO 更新其他关联表 &#125;&#125; 12345678910111213141516@Service(&quot;categoryBrandRelationService&quot;)public class CategoryBrandRelationServiceImpl extends ServiceImpl&lt;CategoryBrandRelationDao, CategoryBrandRelationEntity&gt; implements CategoryBrandRelationService &#123; /** * 由于brand信息的更新，所以需要更新关联数据 * * @param brandId * @param name */ @Override public void updateBrand(Long brandId, String name) &#123; CategoryBrandRelationEntity entity = new CategoryBrandRelationEntity(); entity.setBrandName(name); entity.setBrandId(brandId); this.update(entity, new UpdateWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;brand_id&quot;, brandId)); &#125;&#125; 修改分类信息也是如此，只不过换了一种写法，写在了Mapper中 1234567891011@Service(&quot;categoryService&quot;)public class CategoryServiceImpl extends ServiceImpl&lt;CategoryDao, CategoryEntity&gt; implements CategoryService &#123;/** * 修改(级联更新，连表更新) */@Overridepublic void updateDetail(CategoryEntity category) &#123; this.updateById(category); categoryBrandRelationService.updateCategory(category.getCatId(), category.getName());&#125;&#125; 1234567891011121314@Service(&quot;categoryBrandRelationService&quot;)public class CategoryBrandRelationServiceImpl extends ServiceImpl&lt;CategoryBrandRelationDao, CategoryBrandRelationEntity&gt; implements CategoryBrandRelationService &#123; /** * 由于catogory信息的更新，所以需要更新关联数据 * * @param catId * @param name */ @Override public void updateCategory(Long catId, String name) &#123; baseMapper.updateCategory(catId, name); &#125;&#125; 1234@Mapperpublic interface CategoryBrandRelationDao extends BaseMapper&lt;CategoryBrandRelationEntity&gt; &#123; void updateCategory(@Param(&quot;catId&quot;) Long catId, @Param(&quot;name&quot;) String name);&#125; 123456&lt;!-- 由于catogory信息的更新，所以需要更新关联数据 --&gt;&lt;update id=&quot;updateCategory&quot;&gt; UPDATE gulimall_pms.pms_category_brand_relation SET catelog_name = #&#123;name&#125; WHERE catelog_id = #&#123;catId&#125;&lt;/update&gt;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"微服务","slug":"微服务","permalink":"http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"【项目笔记】商城项目实战1","slug":"【项目笔记】商城项目实战1","date":"2021-10-08T11:50:17.125Z","updated":"2021-10-29T06:37:34.579Z","comments":true,"path":"2021/10/08/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-1/","link":"","permalink":"http://example.com/2021/10/08/xiang-mu-bi-ji-shang-cheng-xiang-mu-shi-zhan-1/","excerpt":"","text":"分布式基础概念微服务 基于业务边界进行服务微化拆分，各个服务器独立部署运行。 集群&amp;分布式&amp;节点 集群是个物理形态，分布式是个工作方式。 分布式是指将不同的业务分布在不同的地方，集群是指将几台服务器集中在一起实现同一业务。 分布式中的每个节点（集群中的一个服务器），都可以做集群，然而集群不一定就是分布式的。 远程调用 在分布式系统中，各个服务可能处于不同主机，但是服务之间不可避免的需要相互调用，即远程调用。 在spring-cloud中使用HTTP+JSON的方式完成远程调用。 负载均衡 在分布式系统中，A服务需要调用B服务，且B服务存在于多台机器中，A服务调用任意一个服务器均可完成功能。但是为了使得每一个服务器不要太忙或者太闲，可以使用负载均衡的调用每一个服务器。 常见的负载均衡算法如下： 轮询：按顺序，知道最后一个，然后循环。 最小连接：有限选择连接数最少（压力最小）的服务器。 散列：根据请求源的IP的散列（HASH）来选择要转发的服务器。 服务注册、发现&amp;注册中心 服务上线后在注册中心注册，从而使得其他服务器或者人能够感知其存在与状态 配置中心 每一个服务器都含有大量的配置，并且每个服务可能部署在多台机器上，所以经常需要变更配置，就可以使用配置中心来集中管理微服务的配置信息。 服务熔断&amp;服务降级 在微服务架构中，微服务之间通过网络进行通讯，当一个服务不可用的时候可能造成雪崩效应。为防止这样的情况，必须要有容错机制来保护服务。 服务熔断：设置服务的超时时间，当被调用的服务经常失败到达某个阈值，我们可以开启断路保护机制，使得后来的请求不再去调用这个服务，而是本地直接返回默认的数据。 服务降级：在运维期间，当系统处于高峰期，系统资源紧张，可以让非核心业务降级运行，即某些服务不处理或者简单处理。 API网关 抽象了微服务中都需要的公共功能，同时提供了客户端负载均衡、服务熔断、统一认证、限流流控、日志统计等功能。 微服务架构图 微服务划分图 Linux虚拟机环境搭建 之前的项目已经搭建的差不多了 相关命令 win： ipconfig ping 192.168.128.129 linux： ip addr ping 10.67.99.2 docker： 我的挂载文件地址都在mydata中 docker images 当前所有镜像 docker ps 当前正在运行的容器 docker start xxx 启动容器 docker exec -it mysql /bin/bash docker exec -it redis redis-cli whereis [容器名] 查看当前进入的容器文件的地址 docker update redis –restart=always 自动重启容器 exit mysql： mysql -u root -p 访问mysql redis： keys * 项目前后端基础搭建 后面回来得我表示，从一开始直接复制一样的版本号！！！ 基础服务模块 注意每个服务模块，先导入web和openfeign 数据库 每个服务都需要独立的数据库 注意这里sql文件不要直接导入，可能导出的时候格式设置和现在不符合（创建的数据库字符编码为utf8mb4）,直接导入会中文乱码，用记事本打开后再粘贴运行。 人人开源模板 人人开源 (gitee.com) renren-fast（后端）renren-fast-vue（前端）renren-generator（生成器） renren-fast renren-fast clone后放到父模块中，记得在父模块的pom文件中写入model。 运行db文件夹中的对应sql 修改resources下的配置文件 application-dev.yml中的druid数据源信息 renren-fast-vue clone后用vscode打开 npm install（注意先把package.json中sass的版本改为4.14以上，因为npm的版本为14，两者版本有所对应，详见👉Vue解决报错9_人人开源renren-fast-vue执行npm install报错解决(sass的版本太低而node的版本太高导致）_xiaosi的博客-CSDN博客，奇怪的是package-lock.json中的版本为4.14.1，然而package中却是4.13.1） npm run dev，妈耶run了一下试试，就开了一个服务，内存已经85%了 可以在.eslintignore中添加*.js和*.vue用于忽略语法检查 renren-generator clone，导入到后端项目中，记得在父模块的pom文件中写入model。 配置application.yml中的数据源配置（注意数据库名的编写） 配置generator.properties中的生成数据配置（注意模块名、表前缀即可） 运行application打开页面点击生成代码（如果一直在读取说明配置信息有误） 将压缩包中的main文件放入对应模块src文件夹 去renren-fast模块中的common文件夹中复制报错所需要的类 common模块 承接上文，反正就是修修补补 controller中的@RequiresPermissions注释可以通过修改generator的controller template（所以说为什么不能一开始就把模板修改了） 当前项目结构 整合mybatis-plus依赖 由于common模块中已经导入了mybatis-plus依赖，所以需要使用只需要导入common模块即可 同时需要在common中导入mysql驱动 配置 配置datasource、mapper地址、mybatis-plus等，最好使用yml格式 application.yml123456789101112131415161718192021# mysqlspring: datasource: #type: com.alibaba.druid.pool.DruidDataSource #MySQL配置 driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.128.129:3306/gulimall_pms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai username: root password: root# mappermybatis-plus: # mapper.xml地址 mapper-locations: classpath:/mapper/**/*.xml # 主键自增 global-config: db-config: id-type: auto #服务器（注意不能配置成一样的）server: port: 7000 classpath*表示不仅扫描本模块下的类路径，还包括引入的其他依赖的类路径 GulimallProductApplication1234567@MapperScan(&quot;com.atguigu.gulimall.product.dao&quot;) // mapper包扫描@SpringBootApplicationpublic class GulimallProductApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GulimallProductApplication.class, args); &#125;&#125; 单元测试✅123456789101112@RunWith(SpringRunner.class) // 记得加，而且要引入Junit和springboot-starter-test依赖@SpringBootTestclass GulimallProductApplicationTests &#123; @Autowired BrandService brandService; @Test void contextLoads() &#123; BrandEntity be = new BrandEntity(); be.setName(&quot;huawei&quot;); brandService.save(be); &#125;&#125; 前端调用api接口请求地址配置 注意去static-&gt;config-&gt;index.js中配置服务地址 123456789101112131415/** * 开发环境 */; (function () &#123; window.SITE_CONFIG = &#123;&#125;; // api接口请求地址(88为网关配置的端口号,api为自定义规则)，注意最后不要有/ window.SITE_CONFIG[&#x27;baseUrl&#x27;] = &#x27;http://localhost:88/api&#x27;; // cdn地址 = 域名 + 版本号 window.SITE_CONFIG[&#x27;domain&#x27;] = &#x27;./&#x27;; // 域名 window.SITE_CONFIG[&#x27;version&#x27;] = &#x27;&#x27;; // 版本号(年月日时分) window.SITE_CONFIG[&#x27;cdnUrl&#x27;] = window.SITE_CONFIG.domain + window.SITE_CONFIG.version;&#125;)(); 网关配置 写在application.yml中，千万注意缩进 解决renren-fase验证码 因为修改了端口号，但是renren-fast登录时候的验证码是在她本来的端口8080才能获取，所以需要让网关发现renren-fast 改变如localhost:88/api/captcha -&gt; localhost:8080/renren-fast/captcha 先给renren-fast把nacos配好（注册中心和配置中心的都可以配） 编写网关配置如下 123456789101112131415spring: cloud: gateway: routes: - id: admin_route # lb负载均衡，自动查询服务名为renren-fast的服务器，从而自动获得其ip:port uri: lb://renren-fast predicates: # 匹配所有以api开头的前端请求地址 - Path=/api/** # 实现转发 filters: # 注意这里的写法，segment这一部分整体不变，然后别的地方进行替换 # localhost:88/api/xxx -&gt; localhost:8080/renren-fast/xxx - RewritePath=/api/(?&lt;segment&gt;.*),/renren-fast/$\\&#123;segment&#125; 还要开启跨域 解决跨域 在网关当中写一个config类统一配置跨域，可 12345678910111213141516171819202122package com.atguigu.gulimall.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.reactive.CorsWebFilter;import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;@Configurationpublic class GulimallCorsConfiguration &#123; @Bean // 加入到spring容器中直接使用 public CorsWebFilter crosWebFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); // 配置跨域 corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.setAllowCredentials(true); // 是否允许携带cookie // path为需要跨域的地址，corsConfiguration为跨域配置 source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); return new CorsWebFilter(source); &#125;&#125; 这里说明一下，一个login（methods为OPTION表示预见请求）已经通过了 第二是真实请求，携带了请求数据等 这里测试还是失败的原因是renren-fast自己已经配置过了跨域，两次跨域=没跨，把renren-fast的config文件夹下的CorsConfig注释掉即可 分布式组件 spring-cloud-alibaba nacos：注册中心配置中心 Sentinel：服务容错（限流、降级、熔断） Seata：分布式事务解决方案 spring-cloud： Ribbon：负载均衡 Feign：声明式HTTP客户端（远程服务） Gateway：API网关 Sleuth：调用链监控 spring-cloud和spring-boot版本对应 https://start.spring.io/actuator/info 版本说明 · alibaba/spring-cloud-alibaba Wiki (github.com) 这个版本一定要对应起来 nacos注册中心依赖 common模块即可 123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- ******************** spring-cloud ******************** --&gt; &lt;!-- nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- ******************** spring-cloud版本管理 ******************** --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 配置nacos地址 注意需要使用的服务就需要在application中配置 1234567891011121314151617# mysqlspring: datasource: #type: com.alibaba.druid.pool.DruidDataSource #MySQL配置 driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.128.129:3306/gulimall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai username: root password: root #nacos地址 cloud: nacos: discovery: server-addr: 127.0.0.1:8848 # 服务名 application: name: gulimall-coupon 注解开启12345678@MapperScan(&quot;com.atguigu.gulimall.coupon.dao&quot;) // mapper包扫描@SpringBootApplication@EnableDiscoveryClient // nacospublic class GulimallCouponApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GulimallCouponApplication.class, args); &#125;&#125; 可视化界面 http://127.0.0.1:8848/nacos Feign远程服务依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 服务接口 feign文件夹下写一个接口，在接口中提供声明需要被调用的服务的controller中的对应方法，并且把映射地址改为全地址，并且为接口添加@FeignClient注释，value为需要调用的服务的服务名。 注解开启 在调用服务的启动类上添加注解@EnableFeignClients(basepackages=”接口地址”) (被调用的服务需要在开启nacos注册发现) nacos配置中心依赖1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 在resources文件夹下的bootstrap.properties文件中配置Nacos Config元数据（一定得是bootstrap） ！！！一定要在bootstrap.properties中配置 1234567# 当前应用名spring.application.name=gulimall-coupon# nacos配置中心的地址spring.cloud.nacos.config.server-addr=127.0.0.1:8848# nacos配置中心使用的命名空间（如果是自定义的填写对应id）和组spring.cloud.nacos.config.namespace=d066b643-6689-4ed1-967d-585be9a3b121spring.cloud.nacos.config.group=dev 配置中心 在配置中心的配置列表中新建配置，DataID为服务名.properties（如果是要加载application.properties的话），然后可以粘贴上配置内容 注意这里测试了一下，还是把版本都和课件对应上比较好，要不然会有很多问题。 注解开启 在对应controller中@RefreshScope，当配置中心的配置值改变的时候，对应服务中的配置值也会改变 1234567891011121314151617@RefreshScope // 开启配置中心动态获取配置@RestController@RequestMapping(&quot;coupon/coupon&quot;)public class CouponController &#123; @Value(&quot;$&#123;coupon.user.name&#125;&quot;)// 从配置文件中获取值 private String name; @Value(&quot;$&#123;coupon.user.age&#125;&quot;) private String age; /** * test配置中心 */ @RequestMapping(&quot;/test&quot;) //@RequiresPermissions(&quot;coupon:coupon:list&quot;) public R test() &#123; return R.ok().put(&quot;name&quot;, name).put(&quot;age&quot;, age); &#125;&#125; 多配置集 12345678910111213# nacos配置中心使用的命名空间（如果是自定义的填写对应id）和组spring.cloud.nacos.config.namespace=d066b643-6689-4ed1-967d-585be9a3b121spring.cloud.nacos.config.group=dev# 多配置集spring.cloud.nacos.config.ext-config[0].data-id=datasource.ymlspring.cloud.nacos.config.ext-config[0].group=devspring.cloud.nacos.config.ext-config[0].refresh=truespring.cloud.nacos.config.ext-config[1].data-id=mybatis.ymlspring.cloud.nacos.config.ext-config[1].group=devspring.cloud.nacos.config.ext-config[1].refresh=truespring.cloud.nacos.config.ext-config[2].data-id=others.ymlspring.cloud.nacos.config.ext-config[2].group=devspring.cloud.nacos.config.ext-config[2].refresh=true 其他 命名空间：用于配置隔离，可以通过在bootstrap.properties配置文件修改从而修改对应内容 不同的生产环节下使用不同命名空间隔离 不同微服务之间隔离 配置集：所有的配置的集合 配置集ID：即nacos中的Data ID 配置分组：即nacos中的group，也可以隔离 Gateway网关模块 创建Gateway模块，记得引入common，在父模块中添加model 启动类上加如下 12@EnableDiscoveryClient //nacos@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;) 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件application.properties 123456#nacos注册中心spring.cloud.nacos.discovery.server-addr=127.0.0.1.8848#应用名spring.application.name=gulimall-gateway#服务端口号server.port=12000 网关配置12345678910111213spring: cloud: gateway: routes: - id: test_route uri: https://www.baidu.com predicates: - Query=url,baidu - id: qq_route uri: https://www.qq.com predicates: - Query=url,qq url为转发的地址，predicates断言为判断条件（详见官网），以上的意思为当uri中有一个key value对应url=baidu、url=qq，则进行跳转。 测试地址：http://localhost:88/?url=baidu 接口文档1、分页请求参数 - 谷粒商城 - 易文档 (easydoc.net) 商品服务 - 三级分类（后台） product模块，category相关 nacos配置application.yml123456789101112# mysqlspring: # nacos 注册中心 cloud: nacos: discovery: # nacos地址 server-addr: 127.0.0.1:8848 # 服务名 application: name: gulimall-product bootstrap.properties123456# 当前应用名spring.application.name=gulimall-product# nacos配置中心的地址spring.cloud.nacos.config.server-addr=127.0.0.1:8848# nacos配置中心使用的命名空间（如果是自定义的填写对应id）和组spring.cloud.nacos.config.namespace=415d4381-f509-4bb6-8ad8-c0497e20d904 网关配置 这里坑很多，顺序，还有缩进，还有断言匹配还有转发的写法 123456789101112131415161718192021222324spring: cloud: gateway: routes: - id: product_route uri: lb://gulimall-product predicates: - Path=/api/product/** # 实现转发 filters: # localhost:88/api/product/xxx -&gt; localhost:10000/product/xxx - RewritePath=/api/(?&lt;segment&gt;.*),/$\\&#123;segment&#125; # 注意顺序，高精度的在前 - id: admin_route # lb负载均衡，自动查询服务名为renren-fast的服务器，从而自动获得其ip:port uri: lb://renren-fast predicates: # 匹配所有以api开头的前端请求地址 - Path=/api/** # 实现转发 filters: # 注意这里的写法，segment这一部分整体不变，然后别的地方进行替换 # localhost:88/api/xxx -&gt; localhost:8080/renren-fast/xxx - RewritePath=/api/(?&lt;segment&gt;.*),/renren-fast/$\\&#123;segment&#125; 递归树形结构查询所有分类（后端）CategoryEntity123456789@Data@TableName(&quot;pms_category&quot;)public class CategoryEntity implements Serializable &#123; /** * 子分类 */ @TableField(exist = false) // 表示该属性在数据表中不存在 private List&lt;CategoryEntity&gt; children;&#125; CategoryController12345678910111213141516@RestController@RequestMapping(&quot;product/category&quot;)public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 分页查询所有分类，并且以树形结构组合 */ @RequestMapping(&quot;/list/tree&quot;) public R listWithTree() &#123; List&lt;CategoryEntity&gt; list = categoryService.listWithTree(); return R.ok().put(&quot;data&quot;, list); &#125;&#125; CategoryServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445@Service(&quot;categoryService&quot;)public class CategoryServiceImpl extends ServiceImpl&lt;CategoryDao, CategoryEntity&gt; implements CategoryService &#123; /** * 分页查询所有分类，并且以树形结构组合 * * @return */ @Override public List&lt;CategoryEntity&gt; listWithTree() &#123; // 1、查出所有分类 List&lt;CategoryEntity&gt; categories = baseMapper.selectList(null); // 2、组装树形结构 // 流式、过滤、map映射、排序、递归、lambda List&lt;CategoryEntity&gt; level1Menus = categories.stream().filter((categoryEntity) -&gt; &#123; return categoryEntity.getParentCid() == 0; &#125;).map(categoryEntity -&gt; &#123; categoryEntity.setChildren(getChildrens(categoryEntity, categories)); return categoryEntity; &#125;).sorted((ce1, ce2) -&gt; &#123; return (ce1.getSort() == null ? 0 : ce1.getSort()) - (ce2.getSort() == null ? 0 : ce2.getSort()); &#125;).collect(Collectors.toList()); return level1Menus; &#125; /** * 递归查询所有子分类 * * @param father * @param entityList * @return */ private List&lt;CategoryEntity&gt; getChildrens(CategoryEntity father, List&lt;CategoryEntity&gt; entityList) &#123; List&lt;CategoryEntity&gt; childList = entityList.stream().filter((categoryEntity) -&gt; &#123; // 取出每一个entity，判断其是否符合，符合的留下 return categoryEntity.getParentCid() == father.getCatId(); &#125;).map(categoryEntity -&gt; &#123; // 取出每一个entity，为其设置children（使用递归） categoryEntity.setChildren(getChildrens(categoryEntity, entityList)); return categoryEntity; &#125;).sorted((ce1, ce2) -&gt; &#123; // 这里防止getSort()返回null，然后根据sort权重排序 return (ce1.getSort() == null ? 0 : ce1.getSort()) - (ce2.getSort() == null ? 0 : ce2.getSort()); &#125;).collect(Collectors.toList()); return childList; &#125;&#125; 上来就放了个大招，java8的新特性 显示所有分类（前端）路由配置 启动renrenfast和renrenfase-vue 系统管理 -&gt; 菜单管理 -&gt; 添加目录和菜单（我的妈呀可视化操作这也太棒了吧） 路径中填写/会被替换成-，所以可以根据这个对应src-&gt;views-&gt;modules下的路径 即http://localhost:8001/#/product-category对应文件夹src-&gt;views-&gt;modules-&gt;product-&gt;category.vue vue页面 renren-fast-vue\\src\\views\\modules\\product\\category.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 商品管理-分类维护 --&gt;&lt;template&gt; &lt;el-tree :data=&quot;menus&quot; :props=&quot;defaultProps&quot; @node-click=&quot;handleNodeClick&quot; &gt;&lt;/el-tree&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123;&#125;, data() &#123; return &#123; menus: [], defaultProps: &#123; children: &quot;children&quot;, // 子节点属性 label: &quot;name&quot; //显示的属性 &#125; &#125;; &#125;, methods: &#123; // 获取所有分类 getMenus() &#123; this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/list/tree&quot;), method: &quot;get&quot; &#125;).then((&#123; data &#125;) =&gt; &#123; // 这里data使用了解构 console.log(&quot;调用api获得菜单数据&quot; + data.data); this.menus = data.data; &#125;); &#125; &#125;, created() &#123; this.getMenus(); &#125;,&#125;;&lt;/script&gt; 删除分类（后端）逻辑删除 在application.yml中配置 1234567891011# mybatismybatis-plus: # mapper.xml地址 mapper-locations: classpath:/mapper/**/*.xml global-config: db-config: # 主键自增 id-type: auto # 逻辑删除 logic-delete-value: 0 logic-not-delete-value: 1 在对应实体类的字段上添加注解@TableLogic 123456789@Data@TableName(&quot;pms_category&quot;)public class CategoryEntity implements Serializable &#123; /** * 逻辑删除 */ @TableLogic(value = &quot;1&quot;, delval = &quot;0&quot;) private Integer showStatus;&#125; CategoryController12345678910111213141516@RestController@RequestMapping(&quot;product/category&quot;)public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 删除分类，判断是否被其他引用 */ @PostMapping(&quot;/delete&quot;) //@RequiresPermissions(&quot;product:category:delete&quot;) public R deleteWithoutUse(@RequestBody Long[] catIds) &#123; // 检查当前删除的菜单是否被其他的地方引用 categoryService.removeByIdsWithoutUse(Arrays.asList(catIds)); return R.ok(); &#125;&#125; CategoryServiceImpl12345678910111213@Service(&quot;categoryService&quot;)public class CategoryServiceImpl extends ServiceImpl&lt;CategoryDao, CategoryEntity&gt; implements CategoryService &#123; /** * 删除分类，判断是否被其他引用 * * @param asList */ @Override public void removeByIdsWithoutUse(List&lt;Long&gt; asList) &#123; //TODO 检查是否被其他的东西引用 baseMapper.deleteBatchIds(asList); &#125;&#125; 删除分类（前端）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!-- 商品管理-分类维护 --&gt;&lt;template&gt; &lt;!-- ====================== 分类树形结构显示 开始 ====================== --&gt; &lt;!-- node-key=&quot;catId&quot; 其值为节点数据中的一个字段名 :expand-on-click-node=&quot;false&quot; 表示设置展开节点的点击位置，FALSE只有当点击箭头的时候才展开 :default-expanded-keys=&quot;[2, 3]&quot; 表示默认展开的节点 --&gt; &lt;el-tree node-key=&quot;catId&quot; show-checkbox :data=&quot;menus&quot; :props=&quot;defaultProps&quot; :expand-on-click-node=&quot;false&quot; :default-expanded-keys=&quot;expandedKey&quot; &gt; &lt;!-- ====================== 操作按钮 开始 ====================== --&gt; &lt;!-- 使用slot添加可操作性按钮 --&gt; &lt;!-- node为每一个节点对象（不和后端中entity对应，而是element自定义的），data为该节点的数据 --&gt; &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;&#123; node, data &#125;&quot;&gt; &lt;span&gt;&#123;&#123; node.label &#125;&#125;&lt;/span&gt; &lt;span&gt; &lt;!-- 这里需要有所判断是否显示对应按钮 --&gt; &lt;el-button v-if=&quot;node.level &lt;= 2&quot; type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;() =&gt; append(data)&quot; &gt; Append &lt;/el-button&gt; &lt;el-button v-if=&quot;node.childNodes.length == 0&quot; type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;() =&gt; remove(node, data)&quot; &gt; Delete &lt;/el-button&gt; &lt;/span&gt; &lt;/span&gt; &lt;!-- ====================== 操作按钮 结束 ====================== --&gt; &lt;/el-tree&gt; &lt;!-- ====================== 分类树形结构显示 结束 ====================== --&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123;&#125;, data() &#123; return &#123; menus: [], // 菜单列表 defaultProps: &#123; children: &quot;children&quot;, // 子节点属性 label: &quot;name&quot; // 显示的属性 &#125;, expandedKey: [] // 默认展开的节点 &#125;; &#125;, methods: &#123; // 按钮操作 append(data) &#123;&#125;, remove(node, data) &#123; var ids = [data.catId]; this.$confirm(`确定删除【$&#123;data.name&#125;】菜单吗?`, &quot;提示&quot;, &#123; confirmButtonText: &quot;确定&quot;, cancelButtonText: &quot;取消&quot;, type: &quot;warning&quot; &#125;) .then(() =&gt; &#123; // 调用API this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/delete&quot;), method: &quot;post&quot;, data: this.$http.adornData(ids, false) &#125;).then((&#123; data &#125;) =&gt; &#123; if (data &amp;&amp; data.code === 0) &#123; this.$message(&#123; message: &quot;删除成功&quot;, type: &quot;success&quot;, duration: 800, onClose: () =&gt; &#123; // 刷新列表 this.getMenus(); // 展开父节点位置(这里的id对应node-key绑定的属性名) this.expandedKey = [node.parent.data.catId]; &#125; &#125;); &#125; else &#123; this.$message.error(data.msg); &#125; &#125;); &#125;) .catch(() =&gt; &#123;&#125;); &#125; &#125;,&#125;;&lt;/script&gt; 添加分类（后端） 已有 添加分类（前端）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!-- 商品管理-分类维护 --&gt;&lt;template&gt; &lt;div&gt; &lt;!-- ====================== 分类树形结构显示 开始 ====================== --&gt; &lt;!-- node-key=&quot;catId&quot; 其值为节点数据中的一个字段名 :expand-on-click-node=&quot;false&quot; 表示设置展开节点的点击位置，FALSE只有当点击箭头的时候才展开 :default-expanded-keys=&quot;[2, 3]&quot; 表示默认展开的节点 --&gt; &lt;el-tree node-key=&quot;catId&quot; show-checkbox :data=&quot;menus&quot; :props=&quot;defaultProps&quot; :expand-on-click-node=&quot;false&quot; :default-expanded-keys=&quot;expandedKey&quot; &gt; &lt;!-- ====================== 操作按钮 开始 ====================== --&gt; &lt;!-- 使用slot添加可操作性按钮 --&gt; &lt;!-- node为每一个节点对象（不和后端中entity对应，而是element自定义的），data为该节点的数据 --&gt; &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;&#123; node, data &#125;&quot;&gt; &lt;span&gt;&#123;&#123; node.label &#125;&#125;&lt;/span&gt; &lt;span&gt; &lt;!-- 这里需要有所判断是否显示对应按钮 --&gt; &lt;el-button v-if=&quot;node.level &lt;= 2&quot; type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;() =&gt; append(data)&quot; &gt; Append &lt;/el-button&gt; &lt;el-button v-if=&quot;node.childNodes.length == 0&quot; type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;() =&gt; remove(node, data)&quot; &gt; Delete &lt;/el-button&gt; &lt;/span&gt; &lt;/span&gt; &lt;!-- ====================== 操作按钮 结束 ====================== --&gt; &lt;/el-tree&gt; &lt;!-- ====================== 分类树形结构显示 结束 ====================== --&gt; &lt;!-- ====================== 添加分类的对话框 开始 ====================== --&gt; &lt;el-dialog title=&quot;添加分类菜单&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; center &gt; &lt;el-form :model=&quot;category&quot;&gt; &lt;el-form-item label=&quot;分类名&quot;&gt; &lt;el-input v-model=&quot;category.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addCategory()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- ====================== 添加分类的对话框 结束 ====================== --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123;&#125;, data() &#123; return &#123; menus: [], // 菜单列表 defaultProps: &#123; // 菜单树属性 children: &quot;children&quot;, // 子节点属性 label: &quot;name&quot; // 显示的属性 &#125;, expandedKey: [], // 默认展开的节点 dialogVisible: false, // 是否打开添加分类的对话框 category: &#123; name: &quot;&quot;, parentCid: 0, catLevel: 0, showStatus: 1, sort: 0 &#125; // 菜单对象 &#125;; &#125;, methods: &#123; // 添加分类菜单 addCategory() &#123; // 调用api this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/save&quot;), method: &quot;post&quot;, data: this.$http.adornData(this.category, false) &#125;) .then((&#123; data &#125;) =&gt; &#123; this.$message(&#123; message: &quot;保存成功&quot;, type: &quot;success&quot; &#125;); // 关闭对话框 this.dialogVisible = false; // 刷新列表 this.getMenus(); // 展开父节点位置数组(这里的id对应node-key绑定的属性名) this.expandedKey = [this.category.parentCid]; &#125;) .catch(result =&gt; &#123; this.$message(&#123; message: &quot;保存失败&quot;, type: &quot;error&quot; &#125;); &#125;); &#125;, // 打开添加菜单对话框 append(data) &#123; this.dialogVisible = true; // 初始化category对象 this.category.name = &quot;&quot;; this.category.parentCid = data.catId; this.category.catLevel = data.catLevel * 1 + 1; &#125;, &#125;&#125;;&lt;/script&gt; 修改分类（后端） 已有 修改分类（前端） 实现简单地信息修改，包括name，icon，productUnit 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;!-- 商品管理-分类维护 --&gt;&lt;template&gt; &lt;div&gt; &lt;!-- ====================== 分类树形结构显示 开始 ====================== --&gt; &lt;!-- ====================== 操作按钮 开始 ====================== --&gt; &lt;!-- 使用slot添加可操作性按钮 --&gt; &lt;!-- node为每一个节点对象（不和后端中entity对应，而是element自定义的），data为该节点的数据 --&gt; &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;&#123; node, data &#125;&quot;&gt; &lt;span&gt;&#123;&#123; node.label &#125;&#125;&lt;/span&gt; &lt;span&gt; &lt;el-button type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;openDialogWithInfo(data)&quot;&gt; 修改 &lt;/el-button&gt; &lt;/span&gt; &lt;/span&gt; &lt;!-- ====================== 操作按钮 结束 ====================== --&gt; &lt;/el-tree&gt; &lt;!-- ====================== 分类树形结构显示 结束 ====================== --&gt; &lt;!-- ====================== 添加分类的对话框 开始 ====================== --&gt; &lt;el-dialog :title=&quot;dialogTitle&quot; :visible.sync=&quot;dialogVisible&quot; :close-on-click-modal=&quot;false&quot; width=&quot;30%&quot; &gt; &lt;el-form :model=&quot;category&quot;&gt; &lt;el-form-item label=&quot;分类名&quot;&gt; &lt;el-input v-model=&quot;category.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;图表&quot;&gt; &lt;el-input v-model=&quot;category.icon&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;计量单位&quot;&gt; &lt;el-input v-model=&quot;category.productUnit&quot; autocomplete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addOrUpdate()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- ====================== 添加分类的对话框 结束 ====================== --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123;&#125;, data() &#123; return &#123; menus: [], // 菜单列表 defaultProps: &#123; // 菜单树属性 children: &quot;children&quot;, // 子节点属性 label: &quot;name&quot; // 显示的属性 &#125;, expandedKey: [], // 默认展开的节点 dialogVisible: false, // 是否打开添加分类的对话框 dialogType: &quot;&quot;, // 对话框用于添加还是修改 dialogTitle: &quot;&quot;, // 对话框标题 category: &#123; name: &quot;&quot;, catId: null, parentCid: 0, catLevel: 0, showStatus: 1, sort: 0, icon: &quot;&quot;, productUnit: &quot;&quot; &#125; // 菜单对象 &#125;; &#125;, methods: &#123; // 打开添加菜单对话框 openDialog(data) &#123; this.dialogVisible = true; this.dialogType = &quot;add&quot;; this.dialogTitle = &quot;添加分类&quot;; // 初始化category对象 this.category.catId = null; this.category.name = &quot;&quot;; this.category.parentCid = data.catId; this.category.icon = &quot;&quot;; this.category.productUnit = &quot;&quot;; this.category.catLevel = data.catLevel * 1 + 1; &#125;, // 打开修改菜单对话框 openDialogWithInfo(data) &#123; this.dialogVisible = true; this.dialogType = &quot;update&quot;; this.dialogTitle = &quot;修改分类&quot;; // 调用接口获取对应id的信息，并初始化category对象 this.$http(&#123; url: this.$http.adornUrl(`/product/category/info/$&#123;data.catId&#125;`), method: &quot;get&quot; &#125;).then((&#123; data &#125;) =&gt; &#123; this.category.catId = data.data.catId; // 只修改这几个值 this.category.name = data.data.name; this.category.icon = data.data.icon; this.category.productUnit = data.data.productUnit; // 用于修改完之后展开父菜单 this.category.parentCid = data.data.parentCid; &#125;); &#125;, // 对话框确定按钮判断 addOrUpdate() &#123; if (this.dialogType == &quot;update&quot;) &#123; this.updateCategory(); &#125; else if (this.dialogType == &quot;add&quot;) &#123; this.addCategory(); &#125; &#125;, // 修改分类菜单 updateCategory() &#123; // 使用解构 var &#123; catId, name, icon, productUnit &#125; = this.category; this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/update&quot;), method: &quot;post&quot;, // 不能直接发送this.category对象,而是重新封装需要修改的对象 data: this.$http.adornData(&#123; catId, name, icon, productUnit &#125;, false) &#125;).then((&#123; data &#125;) =&gt; &#123; this.$message(&#123; message: &quot;修改成功&quot;, type: &quot;success&quot; &#125;); // 关闭对话框 this.dialogVisible = false; // 刷新列表 this.getMenus(); // 展开父节点位置数组(这里的id对应node-key绑定的属性名) this.expandedKey = [this.category.parentCid]; &#125;); &#125;, &#125;&#125;;&lt;/script&gt; 拖拽修改分类（后端）12345678/** * 批量修改 */@RequestMapping(&quot;/update/sort&quot;)public R updateSort(@RequestBody CategoryEntity[] category) &#123; categoryService.updateBatchById(Arrays.asList(category)); return R.ok();&#125; 拖拽修改分类（前端） el-tree 开启draggable即可，allow-drop判断 这一part值得重复观看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406&lt;!-- 商品管理-分类维护 --&gt;&lt;template&gt; &lt;div&gt; &lt;el-switch v-model=&quot;draggable&quot; active-text=&quot;开启拖拽排序&quot; inactive-text=&quot;关闭拖拽排序&quot; &gt; &lt;/el-switch&gt; &lt;el-button v-if=&quot;draggable&quot; @click=&quot;batchSave&quot;&gt; 批量保存 &lt;/el-button&gt; &lt;!-- ====================== 分类树形结构显示 开始 ====================== --&gt; &lt;!-- node-key=&quot;catId&quot; 其值为节点数据中的一个字段名 :expand-on-click-node=&quot;false&quot; 表示设置展开节点的点击位置，FALSE只有当点击箭头的时候才展开 :default-expanded-keys=&quot;[2, 3]&quot; 表示默认展开的节点 draggable 开启可拖拽的方式 --&gt; &lt;el-tree node-key=&quot;catId&quot; show-checkbox :data=&quot;menus&quot; :props=&quot;defaultProps&quot; :expand-on-click-node=&quot;false&quot; :default-expanded-keys=&quot;expandedKey&quot; :draggable=&quot;draggable&quot; :allow-drop=&quot;allowDrop&quot; @node-drop=&quot;handleDrop&quot; &gt; &lt;!-- ====================== 操作按钮 开始 ====================== --&gt; &lt;!-- 使用slot添加可操作性按钮 --&gt; &lt;!-- node为每一个节点对象（不和后端中entity对应，而是element自定义的），data为该节点的数据 --&gt; &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;&#123; node, data &#125;&quot;&gt; &lt;span&gt;&#123;&#123; node.label &#125;&#125;&lt;/span&gt; &lt;span&gt; &lt;!-- 这里需要有所判断是否显示对应按钮 --&gt; &lt;el-button v-if=&quot;node.level &lt;= 2&quot; type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;openDialog(data)&quot; &gt; 添加 &lt;/el-button&gt; &lt;el-button type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;openDialogWithInfo(data)&quot;&gt; 修改 &lt;/el-button&gt; &lt;el-button v-if=&quot;node.childNodes.length == 0&quot; type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;remove(node, data)&quot; &gt; 删除 &lt;/el-button&gt; &lt;/span&gt; &lt;/span&gt; &lt;!-- ====================== 操作按钮 结束 ====================== --&gt; &lt;/el-tree&gt; &lt;!-- ====================== 分类树形结构显示 结束 ====================== --&gt; &lt;!-- ====================== 添加分类的对话框 开始 ====================== --&gt; &lt;el-dialog :title=&quot;dialogTitle&quot; :visible.sync=&quot;dialogVisible&quot; :close-on-click-modal=&quot;false&quot; width=&quot;30%&quot; &gt; &lt;el-form :model=&quot;category&quot;&gt; &lt;el-form-item label=&quot;分类名&quot;&gt; &lt;el-input v-model=&quot;category.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;图表&quot;&gt; &lt;el-input v-model=&quot;category.icon&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;计量单位&quot;&gt; &lt;el-input v-model=&quot;category.productUnit&quot; autocomplete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addOrUpdate()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- ====================== 添加分类的对话框 结束 ====================== --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123;&#125;, data() &#123; return &#123; menus: [], // 菜单列表 defaultProps: &#123; // 菜单树属性 children: &quot;children&quot;, // 子节点属性 label: &quot;name&quot; // 显示的属性 &#125;, expandedKey: [], // 默认展开的节点 dialogVisible: false, // 是否打开添加分类的对话框 dialogType: &quot;&quot;, // 对话框用于添加还是修改 dialogTitle: &quot;&quot;, // 对话框标题 category: &#123; name: &quot;&quot;, catId: null, parentCid: 0, catLevel: 0, showStatus: 1, sort: 0, icon: &quot;&quot;, productUnit: &quot;&quot; &#125;, // 菜单对象 pCid: 0, maxLevel: 0, // 用于记录子节点最深深度 updateNodes: [], //所有需要修改的节点 draggable: false // 可否拖拽 &#125;; &#125;, created() &#123; this.getMenus(); &#125;, methods: &#123; batchSave() &#123; this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/update/sort&quot;), method: &quot;post&quot;, data: this.$http.adornData(this.updateNodes, false) &#125;) .then((&#123; data &#125;) =&gt; &#123; this.$message(&#123; message: &quot;菜单顺序修改成功&quot;, type: &quot;success&quot; &#125;); // 刷新,初始化 this.updateNodes = []; this.maxLevel = 0; this.getMenus(); this.expandedKey = [this.pCid]; this.pCid = 0; &#125;) .catch(() =&gt; &#123; this.$message(&#123; message: &quot;菜单顺序修改失败&quot;, type: &quot;error&quot; &#125;); &#125;); &#125;, // 修改子节点的层级 updateNodesChildLevel(node) &#123; if (node.childNodes.length &gt; 0) &#123; for (let i = 0; i &lt; node.childNodes.length; i++) &#123; this.updateNodes.push(&#123; catId: node.childNodes[i].data.catId, catLevel: node.childNodes[i].level &#125;); this.updateNodesChildLevel(node.childNodes[i]); &#125; &#125; &#125;, // 拖拽成功触发 handleDrop(draggingNode, dropNode, dropType, ev) &#123; // 获取最新节点的父节点id(真实数据库中的id,而不是node的id)和顺序和层级 let pCid = 0; let siblings = null; if (dropType == &quot;inner&quot;) &#123; pCid = dropNode.data.catId; siblings = dropNode.childNodes; &#125; else &#123; pCid = dropNode.parent.data.catId == undefined ? 0 : dropNode.parent.data.catId; siblings = dropNode.parent.childNodes; &#125; //对兄弟节点排序，获得当前的顺序 for (let i = 0; i &lt; siblings.length; i++) &#123; // 先判断当前遍历到的节点是不是被拖拽的节点，是的话需要修改他的pCid if (siblings[i].data.catId == draggingNode.data.catId) &#123; // 判断层级是否改变 if (siblings[i].level != draggingNode.level) &#123; // 字节点的层级也要改变 this.updateNodesChildLevel(siblings[i]); this.updateNodes.push(&#123; catId: siblings[i].data.catId, sort: i, parentCid: pCid, catLevel: siblings[i].level &#125;); &#125; else &#123; this.updateNodes.push(&#123; catId: siblings[i].data.catId, sort: i, parentCid: pCid &#125;); &#125; &#125; else &#123; // 需要修改的商品对象，放入updateNodes this.updateNodes.push(&#123; catId: siblings[i].data.catId, sort: i &#125;); &#125; &#125; this.pCid = pCid; console.log(&quot;this.updateNodes:&quot;, this.updateNodes); // 调用api // this.$http(&#123; // url: this.$http.adornUrl(&quot;/product/category/update/sort&quot;), // method: &quot;post&quot;, // data: this.$http.adornData(this.updateNodes, false) // &#125;) // .then((&#123; data &#125;) =&gt; &#123; // this.$message(&#123; // message: &quot;菜单顺序修改成功&quot;, // type: &quot;success&quot; // &#125;); // // 刷新,初始化 // this.updateNodes = []; // this.maxLevel = 0; // this.getMenus(); // this.expandedKey = [pCid]; // &#125;) // .catch(() =&gt; &#123; // this.$message(&#123; // message: &quot;菜单顺序修改失败&quot;, // type: &quot;error&quot; // &#125;); // &#125;); &#125;, // 判断是否被拖拽放置（这里要注意层级和深度） allowDrop(draggingNode, dropNode, type) &#123; // 当前被拖动到的节点的最大深度（因为可能拖家带口）+拖动到的节点的层数 &lt;= 3即可 // 求当前子节点最大层级 console.log(&quot;draggingNode:&quot;, draggingNode); this.countNodeLevel(draggingNode); // 注意这里，需要用子节点的最大层级-当前被拖动的节点的层级+1，获得的值就是被拖动整体的最大深度 console.log(&quot;maxLevel:&quot; + this.maxLevel); console.log(&quot;draggingNode.level:&quot; + draggingNode.level); let deep = this.maxLevel - draggingNode.level + 1; console.log(&quot;deep:&quot; + deep); this.maxLevel = 0; // 注意这里要判断type: 前后中（因为elementui他的设计就是这样，两个node是指拖拽后有位置关系的两个节点，type是返回的两个node之间的关系，） if (type == &quot;inner&quot;) &#123; console.log(&quot;dropNode.level:&quot; + dropNode.level); return deep + dropNode.level &lt;= 3; &#125; else &#123; console.log(&quot;dropNode.parent.level:&quot; + dropNode.parent.level); return deep + dropNode.parent.level &lt;= 3; &#125; &#125;, // 递归查找最深子节点，记录在this.maxLevel中 countNodeLevel(node) &#123; // 如果有子节点 if (node.childNodes != null &amp;&amp; node.childNodes.length &gt; 0) &#123; // 遍历递归 for (let i = 0; i &lt; node.childNodes.length; i++) &#123; if (node.childNodes[i].level &gt; this.maxLevel) &#123; this.maxLevel = node.childNodes[i].level; &#125; // 注意这里maxLevel放在data中，要不然递归拿不到 this.countNodeLevel(node.childNodes[i]); &#125; &#125; else &#123; // 没有子节点 this.maxLevel = node.level; &#125; &#125;, // 获取所有分类 getMenus() &#123; this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/list/tree&quot;), method: &quot;get&quot; &#125;).then((&#123; data &#125;) =&gt; &#123; console.log(data); // 这里data使用了解构 this.menus = data.data; &#125;); &#125;, // 打开添加菜单对话框 openDialog(data) &#123; this.dialogVisible = true; this.dialogType = &quot;add&quot;; this.dialogTitle = &quot;添加分类&quot;; // 初始化category对象 this.category.catId = null; this.category.name = &quot;&quot;; this.category.parentCid = data.catId; this.category.icon = &quot;&quot;; this.category.productUnit = &quot;&quot;; this.category.catLevel = data.catLevel * 1 + 1; &#125;, // 打开修改菜单对话框 openDialogWithInfo(data) &#123; this.dialogVisible = true; this.dialogType = &quot;update&quot;; this.dialogTitle = &quot;修改分类&quot;; // 调用接口获取对应id的信息，并初始化category对象 this.$http(&#123; url: this.$http.adornUrl(`/product/category/info/$&#123;data.catId&#125;`), method: &quot;get&quot; &#125;).then((&#123; data &#125;) =&gt; &#123; this.category.catId = data.data.catId; // 只修改这几个值 this.category.name = data.data.name; this.category.icon = data.data.icon; this.category.productUnit = data.data.productUnit; // 用于修改完之后展开父菜单 this.category.parentCid = data.data.parentCid; &#125;); &#125;, // 对话框确定按钮判断 addOrUpdate() &#123; if (this.dialogType == &quot;update&quot;) &#123; this.updateCategory(); &#125; else if (this.dialogType == &quot;add&quot;) &#123; this.addCategory(); &#125; &#125;, // 修改分类菜单 updateCategory() &#123; // 使用解构 var &#123; catId, name, icon, productUnit &#125; = this.category; this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/update&quot;), method: &quot;post&quot;, // 不能直接发送this.category对象,而是重新封装需要修改的对象 data: this.$http.adornData(&#123; catId, name, icon, productUnit &#125;, false) &#125;).then((&#123; data &#125;) =&gt; &#123; this.$message(&#123; message: &quot;修改成功&quot;, type: &quot;success&quot; &#125;); // 关闭对话框 this.dialogVisible = false; // 刷新列表 this.getMenus(); // 展开父节点位置数组(这里的id对应node-key绑定的属性名) this.expandedKey = [this.category.parentCid]; &#125;); &#125;, // 添加分类菜单 addCategory() &#123; // 调用api this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/save&quot;), method: &quot;post&quot;, data: this.$http.adornData(this.category, false) &#125;) .then((&#123; data &#125;) =&gt; &#123; this.$message(&#123; message: &quot;保存成功&quot;, type: &quot;success&quot; &#125;); // 关闭对话框 this.dialogVisible = false; // 刷新列表 this.getMenus(); // 展开父节点位置数组(这里的id对应node-key绑定的属性名) this.expandedKey = [this.category.parentCid]; &#125;) .catch(result =&gt; &#123; this.$message(&#123; message: &quot;保存失败&quot;, type: &quot;error&quot; &#125;); &#125;); &#125;, // 删除对应菜单 remove(node, data) &#123; var ids = [data.catId]; this.$confirm(`确定删除【$&#123;data.name&#125;】菜单吗?`, &quot;提示&quot;, &#123; confirmButtonText: &quot;确定&quot;, cancelButtonText: &quot;取消&quot;, type: &quot;warning&quot; &#125;) .then(() =&gt; &#123; // 调用API this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/delete&quot;), method: &quot;post&quot;, data: this.$http.adornData(ids, false) &#125;) .then((&#123; data &#125;) =&gt; &#123; this.$message(&#123; message: &quot;删除成功&quot;, type: &quot;success&quot; &#125;); // 刷新列表 this.getMenus(); // 展开父节点位置(这里的id对应node-key绑定的属性名) this.expandedKey = [node.parent.data.catId]; &#125;) .catch(result =&gt; &#123; this.$message(&#123; message: &quot;删除失败&quot;, type: &quot;error&quot; &#125;); &#125;); &#125;) .catch(() =&gt; &#123;&#125;); &#125; &#125;&#125;;&lt;/script&gt; TODO : 当前bug，如果层级3的菜单拖拽到层级2后失踪，应该和pcid有关（拖拽至层级1有效） 层级2无子节点拖拽到层级2后失踪（不过看起来后台数据库没问题呀？） TODO：这个bug被后来的批量保存改正了，反正都批量保存了，也有问题了 批量删除分类（前端） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 &lt;div&gt; &lt;el-button type=&quot;danger&quot; @click=&quot;batchDelete&quot;&gt;批量删除&lt;/el-button&gt; &lt;!-- ====================== 分类树形结构显示 开始 ====================== --&gt; &lt;!-- node-key=&quot;catId&quot; 其值为节点数据中的一个字段名 :expand-on-click-node=&quot;false&quot; 表示设置展开节点的点击位置，FALSE只有当点击箭头的时候才展开 :default-expanded-keys=&quot;[2, 3]&quot; 表示默认展开的节点 draggable 开启可拖拽的方式‘ ref 可以从this.$refs中获取到该对应组件 --&gt; &lt;el-tree node-key=&quot;catId&quot; show-checkbox :data=&quot;menus&quot; :props=&quot;defaultProps&quot; :expand-on-click-node=&quot;false&quot; :default-expanded-keys=&quot;expandedKey&quot; :draggable=&quot;draggable&quot; :allow-drop=&quot;allowDrop&quot; @node-drop=&quot;handleDrop&quot; ref=&quot;menuTree&quot; &gt; &lt;script&gt;export default &#123; methods: &#123; // 批量删除 batchDelete() &#123; let catIds = []; // 获取当前选中的节点 let checkedNodes = this.$refs.menuTree.getCheckedNodes(); // console.log(checkedNodes); // 遍历所有被选中的节点 for (let i = 0; i &lt; checkedNodes.length; i++) &#123; catIds.push(checkedNodes[i].catId); &#125; // 发送请求 this.$confirm(`确定批量删除【$&#123;catIds&#125;】菜单吗?`, &quot;提示&quot;, &#123; confirmButtonText: &quot;确定&quot;, cancelButtonText: &quot;取消&quot;, type: &quot;warning&quot; &#125;) .then(() =&gt; &#123; // 调用API this.$http(&#123; url: this.$http.adornUrl(&quot;/product/category/delete&quot;), method: &quot;post&quot;, data: this.$http.adornData(catIds, false) &#125;) .then((&#123; data &#125;) =&gt; &#123; this.$message(&#123; message: &quot;批量删除成功&quot;, type: &quot;success&quot; &#125;); // 刷新列表 this.getMenus(); &#125;) .catch(result =&gt; &#123; this.$message(&#123; message: &quot;批量删除失败&quot;, type: &quot;error&quot; &#125;); &#125;); &#125;) .catch(() =&gt; &#123;&#125;); &#125;,&#125;&#125;&lt;/script&gt;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"微服务","slug":"微服务","permalink":"http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"【项目笔记】在线教育项目实战7","slug":"【项目笔记】在线教育项目实战7","date":"2021-10-05T07:16:37.992Z","updated":"2021-10-07T09:44:59.733Z","comments":true,"path":"2021/10/05/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-7/","link":"","permalink":"http://example.com/2021/10/05/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-7/","excerpt":"","text":"统计分析后台（后端+前端）环境搭建 老样子 生成统计数据（后端） 注意，要查询什么数据要在对应模块中查询，然后在统计模块远程调用获取 被调用方controller12345678910111213@RestController@RequestMapping(&quot;/educenter/member&quot;)@CrossOriginpublic class UcenterMemberController &#123; @Autowired private UcenterMemberService memberService; // 查询特定天的注册人数 @GetMapping(&quot;countRegister/&#123;day&#125;&quot;) public Integer countRegister(@PathVariable String day) &#123; Integer count = memberService.countRegister(day); return count; &#125;&#125; 被调用方service12345// 查询特定天的注册人数@Overridepublic Integer countRegister(String day) &#123; return baseMapper.countRegisterByDay(day);&#125; 被调用方mapper12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.educenter.mapper.UcenterMemberMapper&quot;&gt; &lt;!-- 查询特定天的注册人数 --&gt; &lt;select id=&quot;countRegisterByDay&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT COUNT(*) FROM ucenter_member uc WHERE DATE(uc.gmt_create) = #&#123;day&#125; &lt;/select&gt;&lt;/mapper&gt; 远程调用接口1234567@Component@FeignClient(&quot;service-ucenter&quot;)public interface UcenterClient &#123; // 查询特定天的注册人数 @GetMapping(&quot;/educenter/member/countRegister/&#123;day&#125;&quot;) public Integer countRegister(@PathVariable(&quot;day&quot;) String day);&#125; 调用方controller123456789101112131415@RestController@RequestMapping(&quot;/staservice/sta&quot;)@CrossOriginpublic class StatisticsDailyController &#123; @Autowired private StatisticsDailyService staService; // 统计特定天的注册人数 @PostMapping(&quot;countRegister/&#123;day&#125;&quot;) public R countRegister(@PathVariable String day) &#123; staService.countRegister(day); return R.ok(); &#125;&#125; 调用方service1234567891011121314151617181920212223242526@Servicepublic class StatisticsDailyServiceImpl extends ServiceImpl&lt;StatisticsDailyMapper, StatisticsDaily&gt; implements StatisticsDailyService &#123; @Autowired private UcenterClient ucenterClient; @Override public void countRegister(String day) &#123; // 先删除相同日期的记录 QueryWrapper&lt;StatisticsDaily&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;date_calculated&quot;, day); baseMapper.delete(wrapper); // 获得指定日期的统计数 Integer count = ucenterClient.countRegister(day); // 把统计数据添加到统计表当中 StatisticsDaily statisticsDaily = new StatisticsDaily(); statisticsDaily.setRegisterNum(count); statisticsDaily.setDateCalculated(day); // 一下是一些随机数 statisticsDaily.setVideoViewNum(RandomUtils.nextInt(100, 200)); statisticsDaily.setLoginNum(RandomUtils.nextInt(100, 200)); statisticsDaily.setCourseNum(RandomUtils.nextInt(100, 200)); // 插入数据库 baseMapper.insert(statisticsDaily); &#125;&#125; 生成统计数据（前端）router12345678910111213141516171819202122// 统计分析模块 &#123; path: &#x27;/sta&#x27;, component: Layout, redirect: &#x27;/sta/create&#x27;, name: &#x27;统计分析&#x27;, meta: &#123; title: &#x27;统计分析&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;create&#x27;, name: &#x27;生成数据&#x27;, component: () =&gt; import(&#x27;@/views/statistics/create&#x27;), meta: &#123; title: &#x27;生成数据&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;show&#x27;, name: &#x27;图表显示&#x27;, component: () =&gt; import(&#x27;@/views/statistics/show&#x27;), meta: &#123; title: &#x27;图表显示&#x27;, icon: &#x27;tree&#x27; &#125; &#125; ] &#125;, api1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; // 统计指定日期的注册数 createCountRegister(day) &#123; return request(&#123; url: `/staservice/sta/countRegister/$&#123;day&#125;`, method: &#x27;post&#x27; &#125;) &#125;&#125; vue模板与方法1&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item label=&quot;日期&quot;&gt; &lt;!-- 这里绑定了day --&gt; &lt;el-date-picker v-model=&quot;day&quot; type=&quot;date&quot; placeholder=&quot;选择要统计的日期&quot; value-format=&quot;yyyy-MM-dd&quot; /&gt; &lt;/el-form-item&gt; &lt;el-button :disabled=&quot;btnDisabled&quot; type=&quot;primary&quot; @click=&quot;create()&quot; &gt;生成&lt;/el-button &gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import staApi from &#x27;@/api/statistics&#x27; export default &#123; data() &#123; return &#123; day: &#x27;&#x27;, btnDisabled: false &#125; &#125;, created() &#123;&#125;, methods: &#123; create() &#123; staApi.createCountRegister(this.day).then(result =&gt; &#123; // 提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;生成数据成功!&#x27; &#125;) // 跳转到图表显示页面 this.$router.push(&#123; path: &#x27;/sta/show&#x27; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 定时任务 在固定时候自动执行程序 配置 在启动类上添加注解@EnableScheduling 1@EnableScheduling // 使用自动任务public class StatisticsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StatisticsApplication.class, args); &#125;&#125; 定时任务类 使用cron表达式，设置执行规则 1@Componentpublic class ScheduledTask &#123; @Autowired private StatisticsDailyService staService; // 0/5 * * * * ?表示每隔5秒执行一次这个方法 @Scheduled(cron = &quot;0/5 * * * * ?&quot;) public void task1() &#123; System.out.println(&quot;**************task1执行了..&quot;); &#125; //在每天凌晨1点，把前一天数据进行数据查询添加 @Scheduled(cron = &quot;0 0 1 * * ?&quot;) public void task2() &#123; staService.countRegister(DateUtil.formatDate(DateUtil.addDays(new Date(), -1))); &#125;&#125; 日期工具类1public class DateUtil &#123; private static final String dateFormat = &quot;yyyy-MM-dd&quot;; /** * 格式化日期 * * @param date * @return */ public static String formatDate(Date date) &#123; SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); return sdf.format(date); &#125; /** * 在日期date上增加amount天 。 * * @param date 处理的日期，非null * @param amount 要加的天数，可能为负数 */ public static Date addDays(Date date, int amount) &#123; Calendar now =Calendar.getInstance(); now.setTime(date); now.set(Calendar.DATE,now.get(Calendar.DATE)+amount); return now.getTime(); &#125; public static void main(String[] args) &#123; System.out.println(DateUtil.formatDate(new Date())); System.out.println(DateUtil.formatDate(DateUtil.addDays(new Date(), -1))); &#125;&#125; 统计分析图表显示（后端+前端） 使用echarts 后端controller1// echatrts图表显示@GetMapping(&quot;showChartData/&#123;type&#125;/&#123;begin&#125;/&#123;end&#125;&quot;)public R getChartData(@PathVariable String begin, @PathVariable String end, @PathVariable String type) &#123; Map&lt;String, Object&gt; map = staService.getChartData(type, begin, end); return R.ok().data(map);&#125; service1// echatrts图表显示@Overridepublic Map&lt;String, Object&gt; getChartData(String type, String begin, String end) &#123; // 指定日期范围 QueryWrapper&lt;StatisticsDaily&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(&quot;date_calculated&quot;, begin, end); // 这里要求前端的传递的value和表中对应字段值相同，select指定查询列 wrapper.select(&quot;date_calculated&quot;, type); List&lt;StatisticsDaily&gt; staDataList = baseMapper.selectList(wrapper); //前端要求数组json结构，对应后端java代码是list集合 //创建两个list集合，一个日期list，一个数量list List&lt;String&gt; dateList = new ArrayList&lt;&gt;(); List&lt;Integer&gt; numList = new ArrayList&lt;&gt;(); //遍历查询所有数据list集合，进行封装 for (int i = 0; i &lt; staDataList.size(); i++) &#123; StatisticsDaily daily = staDataList.get(i); //封装日期list集合 dateList.add(daily.getDateCalculated()); //封装对应选择的数量 switch (type) &#123; case &quot;login_num&quot;: numList.add(daily.getLoginNum()); break; case &quot;register_num&quot;: numList.add(daily.getRegisterNum()); break; case &quot;video_view_num&quot;: numList.add(daily.getVideoViewNum()); break; case &quot;course_num&quot;: numList.add(daily.getCourseNum()); break; default: break; &#125; &#125; //把封装之后两个list集合放到map集合，进行返回 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;dateList&quot;, dateList); map.put(&quot;numList&quot;, numList); return map;&#125; 前端引入npm依赖 npm install –save &#x65;&#x63;&#x68;&#97;&#114;&#116;&#115;&#64;&#52;&#46;&#x31;&#x2e;&#48; api 这里没有使用RequestBody传递对象，而是直接前端调用的时候传递对象取对应值 1// 获得图表数据 getChartData(searchObj) &#123; return request(&#123; url: `/staservice/sta/getChartData/$&#123;searchObj.type&#125;/$&#123;searchObj.begin&#125;/$&#123;searchObj.end&#125;`, method: &#x27;get&#x27; &#125;) &#125; vue模板和方法1&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-select v-model=&quot;searchObj.type&quot; clearable placeholder=&quot;请选择&quot;&gt; &lt;el-option label=&quot;学员登录数统计&quot; value=&quot;login_num&quot; /&gt; &lt;el-option label=&quot;学员注册数统计&quot; value=&quot;register_num&quot; /&gt; &lt;el-option label=&quot;课程播放数统计&quot; value=&quot;video_view_num&quot; /&gt; &lt;el-option label=&quot;每日课程数统计&quot; value=&quot;course_num&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;searchObj.begin&quot; type=&quot;date&quot; placeholder=&quot;选择开始日期&quot; value-format=&quot;yyyy-MM-dd&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;searchObj.end&quot; type=&quot;date&quot; placeholder=&quot;选择截止日期&quot; value-format=&quot;yyyy-MM-dd&quot; /&gt; &lt;/el-form-item&gt; &lt;el-button :disabled=&quot;btnDisabled&quot; type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;showChart()&quot; &gt;查询&lt;/el-button &gt; &lt;/el-form&gt; &lt;div class=&quot;chart-container&quot;&gt; &lt;div id=&quot;chart&quot; class=&quot;chart&quot; style=&quot;height: 500px; width: 100%&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import echarts from &#x27;echarts&#x27; import staApi from &#x27;@/api/statistics&#x27; export default &#123; data() &#123; return &#123; searchObj: &#123;&#125;, btnDisabled: false, xData: [], yData: [] &#125; &#125;, methods: &#123; showChart() &#123; staApi.getChartData(this.searchObj).then(result =&gt; &#123; this.yData = result.data.numList this.xData = result.data.dateList // 调用下面生成图表的方法，改变值 this.setChart() &#125;) &#125;, // 默认显示图表方法 setChart() &#123; // 基于准备好的dom，初始化echarts实例 this.chart = echarts.init(document.getElementById(&#x27;chart&#x27;)) // console.log(this.chart) // 指定图表的配置项和数据 var option = &#123; title: &#123; text: &#x27;数据统计&#x27; &#125;, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, dataZoom: [ &#123; show: true, height: 30, xAxisIndex: [0], bottom: 30, start: 10, end: 80, handleIcon: &#x27;path://M306.1,413c0,2.2-1.8,4-4,4h-59.8c-2.2,0-4-1.8-4-4V200.8c0-2.2,1.8-4,4-4h59.8c2.2,0,4,1.8,4,4V413z&#x27;, handleSize: &#x27;110%&#x27;, handleStyle: &#123; color: &#x27;#d3dee5&#x27; &#125;, textStyle: &#123; color: &#x27;#fff&#x27; &#125;, borderColor: &#x27;#90979c&#x27; &#125;, &#123; type: &#x27;inside&#x27;, show: true, height: 15, start: 1, end: 35 &#125; ], // x轴是类目轴（离散数据）,必须通过data设置类目数据 xAxis: &#123; type: &#x27;category&#x27;, data: this.xData &#125;, // y轴是数据轴（连续数据） yAxis: &#123; type: &#x27;value&#x27; &#125;, // 系列列表。每个系列通过 type 决定自己的图表类型 series: [ &#123; // 系列中的数据内容数组 data: this.yData, // 折线图 type: &#x27;line&#x27; &#125; ] &#125; this.chart.setOption(option) &#125; &#125; &#125;&lt;/script&gt; Canal数据同步 将远程数据库中的数据同步到本地数据库中，一般实际中项目有很多个数据库（比如说统计分析专门一个数据库），其与远程服务调用调用的区别是，该同步耦合度低，效率更高。 linux配置与开启 linux中需要安装mysql（本地Windows也需要mysql） 创建数据库表（结构需要一样） linux中docker中使用mysql一些常见命令 su root docker ps docker start mysql docker exec -it mysql bash mysql -u root -p 可以使用命令行，也可以直接用配好的Navicat（实战5中配置redis的时候已经配置好了mysql） exit docker stop CONTAINER ID 创建数据库表 数据库guli，表test_canal 注意结构需要一样 mysql开启binlog 开启并进入mysql show variables like ‘log_bin’; 查询是否开启binlog 修改my.cnf（如果使用docker，那么要去挂载的目录下修改），具体如下篇文章 https://www.freebytes.net/it/java/dokcer-mysql-binlog.htmlz 这里花了大概半个小时吧，还是个人博客文章靠谱，那些CSDN的文章都是炒来炒去的，这篇文章很清楚地讲了你挂载的目录是前半部分（我看CSDN那些文章总以为是配置挂载的时候的后半部分，所以弄了好久都没有用，看了这篇文章几分钟就解决了） 安装并配置canal linux中下载然后解压 具体配置见视频 开启canal即可，进入bin文件夹下sh startup.sh 客户端代码编写 创建模块 引入依赖123456789101112131415161718192021222324252627 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件12345678910111213# 服务端口server.port=10000# 服务名spring.application.name=canal-client# 环境设置：dev、test、prodspring.profiles.active=dev# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789 canal客户端类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197@Componentpublic class CanalClient &#123; //sql队列 private Queue&lt;String&gt; SQL_QUEUE = new ConcurrentLinkedQueue&lt;&gt;(); @Resource private DataSource dataSource; /** * canal入库方法 */ public void run() &#123; CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(&quot;192.168.128.129&quot;, 11111), &quot;example&quot;, &quot;&quot;, &quot;&quot;); int batchSize = 1000; try &#123; connector.connect(); connector.subscribe(&quot;.*\\\\..*&quot;); connector.rollback(); try &#123; while (true) &#123; //尝试从master那边拉去数据batchSize条记录，有多少取多少 Message message = connector.getWithoutAck(batchSize); long batchId = message.getId(); int size = message.getEntries().size(); if (batchId == -1 || size == 0) &#123; Thread.sleep(1000); &#125; else &#123; dataHandle(message.getEntries()); &#125; connector.ack(batchId); //当队列里面堆积的sql大于一定数值的时候就模拟执行 if (SQL_QUEUE.size() &gt;= 1) &#123; executeQueueSql(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; connector.disconnect(); &#125; &#125; /** * 模拟执行队列里面的sql语句 */ public void executeQueueSql() &#123; int size = SQL_QUEUE.size(); for (int i = 0; i &lt; size; i++) &#123; String sql = SQL_QUEUE.poll(); System.out.println(&quot;[sql]----&gt; &quot; + sql); this.execute(sql.toString()); &#125; &#125; /** * 数据处理 * * @param entrys */ private void dataHandle(List&lt;Entry&gt; entrys) throws InvalidProtocolBufferException &#123; for (Entry entry : entrys) &#123; if (EntryType.ROWDATA == entry.getEntryType()) &#123; RowChange rowChange = RowChange.parseFrom(entry.getStoreValue()); EventType eventType = rowChange.getEventType(); if (eventType == EventType.DELETE) &#123; saveDeleteSql(entry); &#125; else if (eventType == EventType.UPDATE) &#123; saveUpdateSql(entry); &#125; else if (eventType == EventType.INSERT) &#123; saveInsertSql(entry); &#125; &#125; &#125; &#125; /** * 保存更新语句 * * @param entry */ private void saveUpdateSql(Entry entry) &#123; try &#123; RowChange rowChange = RowChange.parseFrom(entry.getStoreValue()); List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList(); for (RowData rowData : rowDatasList) &#123; List&lt;Column&gt; newColumnList = rowData.getAfterColumnsList(); StringBuffer sql = new StringBuffer(&quot;update &quot; + entry.getHeader().getTableName() + &quot; set &quot;); for (int i = 0; i &lt; newColumnList.size(); i++) &#123; sql.append(&quot; &quot; + newColumnList.get(i).getName() + &quot; = &#x27;&quot; + newColumnList.get(i).getValue() + &quot;&#x27;&quot;); if (i != newColumnList.size() - 1) &#123; sql.append(&quot;,&quot;); &#125; &#125; sql.append(&quot; where &quot;); List&lt;Column&gt; oldColumnList = rowData.getBeforeColumnsList(); for (Column column : oldColumnList) &#123; if (column.getIsKey()) &#123; //暂时只支持单一主键 sql.append(column.getName() + &quot;=&quot; + column.getValue()); break; &#125; &#125; SQL_QUEUE.add(sql.toString()); &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125; /** * 保存删除语句 * * @param entry */ private void saveDeleteSql(Entry entry) &#123; try &#123; RowChange rowChange = RowChange.parseFrom(entry.getStoreValue()); List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList(); for (RowData rowData : rowDatasList) &#123; List&lt;Column&gt; columnList = rowData.getBeforeColumnsList(); StringBuffer sql = new StringBuffer(&quot;delete from &quot; + entry.getHeader().getTableName() + &quot; where &quot;); for (Column column : columnList) &#123; if (column.getIsKey()) &#123; //暂时只支持单一主键 sql.append(column.getName() + &quot;=&quot; + column.getValue()); break; &#125; &#125; SQL_QUEUE.add(sql.toString()); &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125; /** * 保存插入语句 * * @param entry */ private void saveInsertSql(Entry entry) &#123; try &#123; RowChange rowChange = RowChange.parseFrom(entry.getStoreValue()); List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList(); for (RowData rowData : rowDatasList) &#123; List&lt;Column&gt; columnList = rowData.getAfterColumnsList(); StringBuffer sql = new StringBuffer(&quot;insert into &quot; + entry.getHeader().getTableName() + &quot; (&quot;); for (int i = 0; i &lt; columnList.size(); i++) &#123; sql.append(columnList.get(i).getName()); if (i != columnList.size() - 1) &#123; sql.append(&quot;,&quot;); &#125; &#125; sql.append(&quot;) VALUES (&quot;); for (int i = 0; i &lt; columnList.size(); i++) &#123; sql.append(&quot;&#x27;&quot; + columnList.get(i).getValue() + &quot;&#x27;&quot;); if (i != columnList.size() - 1) &#123; sql.append(&quot;,&quot;); &#125; &#125; sql.append(&quot;)&quot;); SQL_QUEUE.add(sql.toString()); &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125; /** * 入库 * * @param sql */ public void execute(String sql) &#123; Connection con = null; try &#123; if (null == sql) return; con = dataSource.getConnection(); QueryRunner qr = new QueryRunner(); int row = qr.execute(con, sql); System.out.println(&quot;update: &quot; + row); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; DbUtils.closeQuietly(con); &#125; &#125;&#125; 启动类123456789101112131415@SpringBootApplicationpublic class CanalApplication implements CommandLineRunner &#123; @Resource private CanalClient canalClient; public static void main(String[] args) &#123; SpringApplication.run(CanalApplication.class, args); &#125; @Override public void run(String... strings) throws Exception &#123; //项目启动，执行canal客户端监听 canalClient.run(); &#125;&#125; 测试 TODO，这里application启动失败，去canal的log里看，说连接mysql的ip失败了，原因是address already in use, 然后我改了重启还是这个原因，本来没有被占用的端口启动了之后就被占用了，但是canal还是启动失败，就离谱， 总之原因是canal没有启动，address already in use 还是没解决，放弃了（我不理解！！！） SpringCloud微服务Gateway网关概念 微服务架构之下不同的微服务有不同的网络地址，外部客户端需要调用多个服务的接口才能完成一个业务需求，但是如果直接让客户端与各个服务器通信，会出现许多问题，所以这些问题需要借助API网关解决。 网关是结余客户端和服务端之间的之间层，所有外部请求都会先经过API网关这一层，所以网关实现安全，性能，监控等操作。 就是之前的nginx的增强版 创建模块 创建模块infrastructure，子模块api_gateway 依赖12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;common_utils&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--服务调用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 配置服务按如下配置即可 也可以使用YAML格式，更方便不用写下标 12345678910111213141516171819202122# 服务端口server.port=8222# 服务名spring.application.name=service-gateway# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#使用服务发现路由spring.cloud.gateway.discovery.locator.enabled=true#设置路由idspring.cloud.gateway.routes[0].id=service-acl#设置路由的uri lb://nacos注册服务名称spring.cloud.gateway.routes[0].uri=lb://service-acl#设置路由断言,代理servicerId为auth-service的/auth/路径spring.cloud.gateway.routes[0].predicates=Path=/*/acl/**#配置service-edu服务spring.cloud.gateway.routes[1].id=service-eduspring.cloud.gateway.routes[1].uri=lb://service-eduspring.cloud.gateway.routes[1].predicates=Path=/eduservice/**#配置service-edu服务spring.cloud.gateway.routes[2].id=service-msmspring.cloud.gateway.routes[2].uri=lb://service-msmspring.cloud.gateway.routes[2].predicates=Path=/edumsm/** 启动类1234567@SpringBootApplication@EnableDiscoveryClient //nacospublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 测试：使用网关的端口号即可访问已配置的微服务OK 跨域问题 在网关中统一开启跨域，cv一下固定config、filter、handler 注意controller中的跨域注解不能有，要不然两次跨域抵消 权限管理（后端）![07 权限管理需求](https://gitee.com/ReRia/images/raw/master/img/07 权限管理需求.png) 环境搭建模块 service_acl，spring_security 依赖1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;spring_security&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 整合接口 直接CV好家伙，好像是因为太复杂了吧，没事下个项目自己做 获取所有菜单 递归，构建树形结构（注意菜单可能有多级结构（之前做过两级的）） entity 注意这个实体类的属性，使用了递归存储children 1234567891011121314151617181920public class Permission implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = &quot;编号&quot;) @TableId(value = &quot;id&quot;, type = IdType.ID_WORKER_STR) private String id; @ApiModelProperty(value = &quot;所属上级&quot;) private String pid; @ApiModelProperty(value = &quot;层级&quot;) @TableField(exist = false) private Integer level; @ApiModelProperty(value = &quot;下级&quot;) @TableField(exist = false) private List&lt;Permission&gt; children; &#125; controller12345678910111213@RestController@RequestMapping(&quot;/admin/acl/permission&quot;)public class PermissionController &#123; @Autowired private PermissionService permissionService; //获取全部菜单 @ApiOperation(value = &quot;查询所有菜单&quot;) @GetMapping public R indexAllPermission() &#123; List&lt;Permission&gt; list = permissionService.queryAllMenuGuli(); return R.ok().data(&quot;children&quot;,list); &#125;&#125; service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//获取全部菜单@Overridepublic List&lt;Permission&gt; queryAllMenuGuli() &#123; //1 查询菜单表所有数据 QueryWrapper&lt;Permission&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.orderByDesc(&quot;id&quot;); List&lt;Permission&gt; permissionList = baseMapper.selectList(wrapper); //2 把查询所有菜单list集合按照要求进行封装 List&lt;Permission&gt; resultList = bulidPermission(permissionList); return resultList;&#125;//把返回所有菜单list集合进行封装的方法public static List&lt;Permission&gt; bulidPermission(List&lt;Permission&gt; permissionList) &#123; //创建list集合，用于数据最终封装 List&lt;Permission&gt; finalNode = new ArrayList&lt;&gt;(); //把所有菜单list集合遍历，得到顶层菜单 pid=0菜单，设置level是1 for(Permission permissionNode : permissionList) &#123; //得到顶层菜单 pid=0菜单 if(&quot;0&quot;.equals(permissionNode.getPid())) &#123; //设置顶层菜单的level是1 permissionNode.setLevel(1); //根据顶层菜单，向里面进行查询子菜单，封装到finalNode里面 finalNode.add(selectChildren(permissionNode,permissionList)); &#125; &#125; return finalNode;&#125;private static Permission selectChildren(Permission permissionNode, List&lt;Permission&gt; permissionList) &#123; //1 因为向一层菜单里面放二层菜单，二层里面还要放三层，把对象初始化 permissionNode.setChildren(new ArrayList&lt;Permission&gt;()); //2 遍历所有菜单list集合，进行判断比较，比较id和pid值是否相同 for(Permission it : permissionList) &#123; //判断 id和pid值是否相同 if(permissionNode.getId().equals(it.getPid())) &#123; //当前level=父菜单的level值+1 int level = permissionNode.getLevel()+1; it.setLevel(level); //如果children为空，进行初始化操作 //if(permissionNode.getChildren() == null) &#123; // permissionNode.setChildren(new ArrayList&lt;Permission&gt;()); //&#125; //把查询出来的子菜单放到父菜单里面 permissionNode.getChildren().add(selectChildren(it,permissionList)); &#125; &#125; return permissionNode;&#125; 测试 SwaggerConfig类中有一行代码需要注释才能测试,，表示路径中有这个关键字则不让测试，可以注释掉这行代码也可以修改controller的路径 1234567891011@Bean public Docket webApiConfig() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;webApi&quot;) .apiInfo(webApiInfo()) .select() // .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;))) .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;))) .build(); &#125; 删除菜单 递归删除，删除上级菜单下级菜单也要同时删除 controller123456@ApiOperation(value = &quot;递归删除菜单&quot;)@DeleteMapping(&quot;remove/&#123;id&#125;&quot;)public R remove(@PathVariable String id) &#123; permissionService.removeChildByIdGuli(id); return R.ok();&#125; service123456789101112131415161718192021222324252627//============递归删除菜单==================================@Overridepublic void removeChildByIdGuli(String id) &#123; //1 创建list集合，用于封装所有删除菜单id值 List&lt;String&gt; idList = new ArrayList&lt;&gt;(); //2 向idList集合设置删除菜单id this.selectPermissionChildById(id, idList); //把当前id封装到list里面 idList.add(id); baseMapper.deleteBatchIds(idList);&#125;//2 根据当前菜单id，查询菜单里面子菜单id，封装到list集合private void selectPermissionChildById(String id, List&lt;String&gt; idList) &#123; //查询菜单里面子菜单id QueryWrapper&lt;Permission&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;pid&quot;, id); wrapper.select(&quot;id&quot;); List&lt;Permission&gt; childIdList = baseMapper.selectList(wrapper); //把childIdList里面菜单id值获取出来，封装idList里面，做递归查询 childIdList.stream().forEach(item -&gt; &#123; //封装idList里面 idList.add(item.getId()); //递归查询 this.selectPermissionChildById(item.getId(), idList); &#125;);&#125; 角色分配权限controller123456@ApiOperation(value = &quot;给角色分配权限&quot;)@PostMapping(&quot;/doAssign&quot;)public R doAssign(String roleId,String[] permissionId) &#123; permissionService.saveRolePermissionRealtionShipGuli(roleId,permissionId); return R.ok();&#125; service12345678910111213141516171819//=========================给角色分配菜单=======================@Overridepublic void saveRolePermissionRealtionShipGuli(String roleId, String[] permissionIds) &#123; //roleId角色id //permissionId菜单id 数组形式 //1 创建list集合，用于封装添加数据 List&lt;RolePermission&gt; rolePermissionList = new ArrayList&lt;&gt;(); //遍历所有菜单数组 for (String perId : permissionIds) &#123; //RolePermission对象 RolePermission rolePermission = new RolePermission(); rolePermission.setRoleId(roleId); rolePermission.setPermissionId(perId); //封装到list集合 rolePermissionList.add(rolePermission); &#125; //添加到角色菜单关系表 rolePermissionService.saveBatch(rolePermissionList);&#125; SpringSecurity介绍 spring-security实现功能如下： 用户认证：用户登录时查询数据库验证用户名和密码 用户授权：登录之后给予用户对应的权限和操作功能 spring-security本质上是filter，对请求进行过滤： 基于session，则对cookie中的sessionid进行解析找到服务器存储的session信息然后判断当前用户是否符合请求的要求 基于token，则解析出token然后将当前请求加入到spring-security管理的权限信息当中 认证和授权实现思路 如果系统的模块众多，每个模块都需要就行授权与认证，所以我们选择基于token的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前请求是否有权限访问 整合依赖1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;common_utils&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Security依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 项目结构 测试 妈耶太吓人了幸好我备份了（为啥git不先讲），试了下整合，菜单栏还是显示不出来，先恢复了，以后再试 Nacos配置管理Git版本管理 创建本地git仓库：idea -&gt; VCS -&gt; Create Git Repository 将文件加到本地仓库：idea -&gt; 父项目名 -&gt; 右键 -&gt; git -&gt; add 添加远程仓库地址：idea -&gt; 父项目名 -&gt; 右键 -&gt; git -&gt; git remotes 将文件提交至远程仓库：commit 上传：push","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战6","slug":"【项目笔记】在线教育项目实战6","date":"2021-10-02T04:51:33.699Z","updated":"2021-10-05T07:14:17.776Z","comments":true,"path":"2021/10/02/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-6/","link":"","permalink":"http://example.com/2021/10/02/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-6/","excerpt":"","text":"前台讲师列表和详情（后端+前端）讲师分页列表（后端）controller1234567891011121314151617@RestController@RequestMapping(&quot;/eduservice/teacherfront&quot;)@CrossOriginpublic class TeacherController &#123; @Autowired private EduTeacherService teacherService; // 分页查询讲师列表 @GetMapping(&quot;getTeacherFront/&#123;pageNo&#125;/&#123;limit&#125;&quot;) public R getTeacherFront(@PathVariable Long limit, @PathVariable Long pageNo) &#123; // 创建page对象 Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(pageNo, limit); // 调用方法实现分类 Map&lt;String, Object&gt; map = teacherService.getTeacherFront(pageTeacher); // 返回分页所有数据 return R.ok().data(map); &#125;&#125; service123456789101112131415161718192021222324@Servicepublic class EduTeacherServiceImpl extends ServiceImpl&lt;EduTeacherMapper, EduTeacher&gt; implements EduTeacherService &#123; @Override @Cacheable(key = &quot;&#x27;indexTeacherList&#x27;&quot;, value = &quot;teacher&quot;) // redis public List&lt;EduTeacher&gt; getIndexList() &#123; return baseMapper.selectIndexList(); &#125; // 分页查询讲师列表 @Override public Map&lt;String, Object&gt; getTeacherFront(Page&lt;EduTeacher&gt; pageTeacher) &#123; QueryWrapper wrapper = new QueryWrapper&lt;&gt;(); wrapper.orderByDesc(&quot;id&quot;); baseMapper.selectPage(pageTeacher, wrapper); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;records&quot;, pageTeacher.getRecords()); map.put(&quot;total&quot;, pageTeacher.getTotal()); map.put(&quot;size&quot;, pageTeacher.getSize()); map.put(&quot;current&quot;, pageTeacher.getCurrent()); map.put(&quot;pages&quot;, pageTeacher.getPages()); map.put(&quot;hasNext&quot;, pageTeacher.hasNext()); map.put(&quot;hasPrevious&quot;, pageTeacher.hasPrevious()); return map; &#125;&#125; 讲师分页列表（前端）api12345678910import request from &#x27;@/utils/request&#x27;export default &#123; // 讲师分页列表 getTeacherList(pageNo, limit) &#123; return request(&#123; url: `/eduservice/teacherfront/getTeacherFront/$&#123;pageNo&#125;/$&#123;limit&#125;`, method: &#x27;get&#x27;, &#125;) &#125;&#125; vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- 讲师列表 开始 --&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title all-teacher-title&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;全部讲师&lt;/span&gt; &lt;/h2&gt; &lt;section class=&quot;c-tab-title&quot;&gt; &lt;a id=&quot;subjectAll&quot; title=&quot;全部&quot; href=&quot;#&quot;&gt;全部&lt;/a&gt; &lt;/section&gt; &lt;/header&gt; &lt;section class=&quot;c-sort-box unBr&quot;&gt; &lt;div&gt; &lt;!-- /无数据提示 开始--&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;listMap.total == 0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot; &gt;没有相关数据，小编正在努力整理中...&lt;/span &gt; &lt;/section&gt; &lt;!-- /无数据提示 结束--&gt; &lt;article class=&quot;i-teacher-list&quot; v-if=&quot;listMap.total &gt; 0&quot;&gt; &lt;ul class=&quot;of&quot;&gt; &lt;li v-for=&quot;teacher in listMap.records&quot; :key=&quot;teacher.id&quot;&gt; &lt;section class=&quot;i-teach-wrap&quot;&gt; &lt;div class=&quot;i-teach-pic&quot;&gt; &lt;a :href=&quot;&#x27;/teacehr/&#x27;+teacher.id&quot; :title=&quot;teacher.name&quot; target=&quot;_blank&quot;&gt; &lt;img :src=&quot;teacher.avatar&quot; alt /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mt10 hLh30 txtOf tac&quot;&gt; &lt;a :href=&quot;&#x27;/teacehr/&#x27;+teacher.id&quot; :title=&quot;teacher.name&quot; target=&quot;_blank&quot; class=&quot;fsize18 c-666&quot; &gt;&#123;&#123; teacher.name &#125;&#125;&lt;/a &gt; &lt;/div&gt; &lt;div class=&quot;hLh30 txtOf tac&quot;&gt; &lt;span class=&quot;fsize14 c-999&quot;&gt;&#123;&#123; teacher.intro &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;mt15 i-q-txt&quot;&gt; &lt;p class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; teacher.career &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- /讲师列表 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import teacherApi from &#x27;@/api/teacher&#x27; export default &#123; // 这个页面模板没有使用element-ui的分页条，所以写法有所变化 // 使用异步调用（this.$route.param == params获取url中的参数值） // 该方法只调用一次 asyncData(&#123; params, error &#125;) &#123; return teacherApi.getTeacherList(1, 8).then(result =&gt; &#123; // 这里是赋值的简写方式 return &#123; listMap: result.data.data &#125; &#125;) &#125; &#125;&lt;/script&gt; 分页条1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- 公共分页 开始 --&gt; &lt;div&gt; &lt;div class=&quot;paging&quot;&gt; &lt;!-- undisable这个class是否存在，取决于数据属性hasPrevious --&gt; &lt;a :class=&quot;&#123; undisable: !listMap.hasPrevious &#125;&quot; href=&quot;#&quot; title=&quot;首页&quot; @click.prevent=&quot;gotoPage(1)&quot; &gt;首页&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !listMap.hasPrevious &#125;&quot; href=&quot;#&quot; title=&quot;前一页&quot; @click.prevent=&quot;gotoPage(listMap.current - 1)&quot; &gt;&amp;lt;&lt;/a &gt; &lt;a v-for=&quot;page in listMap.pages&quot; :key=&quot;page&quot; :class=&quot;&#123; current: listMap.current == page, undisable: listMap.current == page, &#125;&quot; :title=&quot;&#x27;第&#x27; + page + &#x27;页&#x27;&quot; href=&quot;#&quot; @click.prevent=&quot;gotoPage(page)&quot; &gt;&#123;&#123; page &#125;&#125;&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !listMap.hasNext &#125;&quot; href=&quot;#&quot; title=&quot;后一页&quot; @click.prevent=&quot;gotoPage(listMap.current + 1)&quot; &gt;&amp;gt;&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !listMap.hasNext &#125;&quot; href=&quot;#&quot; title=&quot;末页&quot; @click.prevent=&quot;gotoPage(listMap.pages)&quot; &gt;末页&lt;/a &gt; &lt;div class=&quot;clear&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 公共分页 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import teacherApi from &#x27;@/api/teacher&#x27; export default &#123; methods: &#123; // 分页切换 gotoPage(page) &#123; teacherApi.getTeacherList(page, 8).then(result =&gt; &#123; this.listMap = result.data.data &#125;) &#125; &#125; &#125;&lt;/script&gt; 讲师详情（后端）123456789// 讲师详情@GetMapping(&quot;getTeacherInfoFront/&#123;teacherId&#125;&quot;)public R getTeacherInfoFront(@PathVariable String teacherId) &#123; EduTeacher teacherInfo = teacherService.getById(teacherId); QueryWrapper wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;teacher_id&quot;, teacherId); List&lt;EduCourse&gt; courseList = courseService.list(wrapper); return R.ok().data(&quot;teacherInfo&quot;, teacherInfo).data(&quot;courseList&quot;, courseList);&#125; 讲师详情（前端）api1234567// 讲师详情getTeacherInfo(teacherId) &#123; return request(&#123; url: `/eduservice/teacherfront/getTeacherInfoFront/$&#123;teacherId&#125;`, method: &#x27;get&#x27;, &#125;)&#125; vue 注意NUXT的动态变量的页面为_xxx.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- 讲师介绍 开始 --&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;讲师介绍&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;t-infor-wrap&quot;&gt; &lt;!-- 讲师基本信息 --&gt; &lt;section class=&quot;fl t-infor-box c-desc-content&quot;&gt; &lt;div class=&quot;mt20 ml20&quot;&gt; &lt;section class=&quot;t-infor-pic&quot;&gt; &lt;img :src=&quot;teacherInfo.avatar&quot; /&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30&quot;&gt; &lt;span class=&quot;fsize24 c-333&quot; &gt;&#123;&#123; teacherInfo.name &#125;&#125;&amp;nbsp;&#123;&#123; teacherInfo.level === 1 ? &quot;高级讲师&quot; : &quot;首席讲师&quot; &#125;&#125;&lt;/span &gt; &lt;/h3&gt; &lt;section class=&quot;mt10&quot;&gt; &lt;span class=&quot;t-tag-bg&quot;&gt;&#123;&#123; teacherInfo.career &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;t-infor-txt&quot;&gt; &lt;p class=&quot;mt20&quot;&gt; &#123;&#123; teacherInfo.intro &#125;&#125; &lt;/p&gt; &lt;/section&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;section class=&quot;mt30&quot;&gt; &lt;div&gt; &lt;header class=&quot;comm-title all-teacher-title c-course-content&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;主讲课程&lt;/span&gt; &lt;/h2&gt; &lt;section class=&quot;c-tab-title&quot;&gt; &lt;a href=&quot;javascript: void(0)&quot;&gt;&amp;nbsp;&lt;/a&gt; &lt;/section&gt; &lt;/header&gt; &lt;!-- /无数据提示 开始--&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;courseList.length == 0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot; &gt;没有相关数据，小编正在努力整理中...&lt;/span &gt; &lt;/section&gt; &lt;!-- /无数据提示 结束--&gt; &lt;article class=&quot;comm-course-list&quot; v-if=&quot;courseList.length &gt; 0&quot;&gt; &lt;ul class=&quot;of&quot;&gt; &lt;li v-for=&quot;course in courseList&quot; :key=&quot;course.id&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;course-img&quot;&gt; &lt;img :src=&quot;course.cover&quot; class=&quot;img-responsive&quot; /&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;开始学习&quot; target=&quot;_blank&quot; class=&quot;comm-btn c-btn-1&quot; &gt;开始学习&lt;/a &gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a href=&quot;#&quot; :title=&quot;course.title&quot; target=&quot;_blank&quot; class=&quot;course-title fsize18 c-333&quot; &gt;&#123;&#123; course.title &#125;&#125;&lt;/a &gt; &lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- /讲师介绍 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import teacherApi from &#x27;@/api/teacher&#x27; export default &#123; asyncData(&#123; params, error &#125;) &#123; // 注意这里的params后跟的名字要和vue文件名对应（所以他是只能传一个参数吗？） return teacherApi.getTeacherInfo(params.id).then(result =&gt; &#123; return &#123; teacherInfo: result.data.data.teacherInfo, courseList: result.data.data.courseList &#125; &#125;) &#125; &#125;&lt;/script&gt; 前台课程列表和详情（后端+前端）课程列表（后端）vo类1234567891011121314151617181920212223@Datapublic class CourseFrontVo &#123; @ApiModelProperty(value = &quot;课程名称&quot;) private String title; @ApiModelProperty(value = &quot;讲师id&quot;) private String teacherId; @ApiModelProperty(value = &quot;一级类别id&quot;) private String subjectParentId; @ApiModelProperty(value = &quot;二级类别id&quot;) private String subjectId; @ApiModelProperty(value = &quot;销量排序&quot;) private String buyCountSort; @ApiModelProperty(value = &quot;最新时间排序&quot;) private String gmtCreateSort; @ApiModelProperty(value = &quot;价格排序&quot;) private String priceSort;&#125; controller12345678910111213141516@RestController@CrossOrigin@RequestMapping(&quot;/eduservice/coursefront&quot;)public class CourseController &#123; @Autowired private EduCourseService courseService; // 条件查询带分页 @PostMapping(&quot;getCourseList/&#123;pageNo&#125;/&#123;limit&#125;&quot;) public R getCourseListCondition(@PathVariable Long limit, @PathVariable Long pageNo, @RequestBody(required = false) CourseFrontVo courseFrontVo) &#123; Page&lt;EduCourse&gt; pageCourse = new Page&lt;&gt;(pageNo, limit); Map&lt;String, Object&gt; map = courseService.getCOurseFrontList(pageCourse, courseFrontVo); return R.ok().data(map); &#125; &#125; service12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic Map&lt;String, Object&gt; getCourseFrontList(Page&lt;EduCourse&gt; pageCourse, CourseFrontVo courseFrontVo) &#123; QueryWrapper wrapper = new QueryWrapper(); // 判断条件是否为空 if (!StringUtils.isEmpty(courseFrontVo.getSubjectParentId())) &#123; wrapper.eq(&quot;subject_parent_id&quot;, courseFrontVo.getSubjectParentId()); &#125; if (!StringUtils.isEmpty(courseFrontVo.getSubjectId())) &#123; wrapper.eq(&quot;subject_id&quot;, courseFrontVo.getSubjectId()); &#125; if (!StringUtils.isEmpty(courseFrontVo.getBuyCountSort())) &#123; wrapper.orderByDesc(&quot;buy_count&quot;); &#125; if (!StringUtils.isEmpty(courseFrontVo.getGmtCreateSort())) &#123; //最新 wrapper.orderByDesc(&quot;gmt_create&quot;); &#125; if (!StringUtils.isEmpty(courseFrontVo.getPriceSort())) &#123;//价格 wrapper.orderByDesc(&quot;price&quot;); &#125; baseMapper.selectPage(pageCourse, wrapper); List&lt;EduCourse&gt; records = pageCourse.getRecords(); long current = pageCourse.getCurrent(); long pages = pageCourse.getPages(); long size = pageCourse.getSize(); long total = pageCourse.getTotal(); boolean hasNext = pageCourse.hasNext();//下一页 boolean hasPrevious = pageCourse.hasPrevious();//上一页 //把分页数据获取出来，放到map集合 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;items&quot;, records); map.put(&quot;current&quot;, current); map.put(&quot;pages&quot;, pages); map.put(&quot;size&quot;, size); map.put(&quot;total&quot;, total); map.put(&quot;hasNext&quot;, hasNext); map.put(&quot;hasPrevious&quot;, hasPrevious); //map返回 return map;&#125; 课程列表（前端）api12345678910111213141516171819import request from &#x27;@/utils/request&#x27;export default &#123; // 讲师分页列表 getCourseList(pageNo, limit, queryCourse) &#123; return request(&#123; url: `/eduservice/coursefront/getCourseList/$&#123;pageNo&#125;/$&#123;limit&#125;`, method: &#x27;post&#x27;, data: queryCourse &#125;) &#125;, // 课程分类列表 getSubjectList() &#123; return request(&#123; url: `/eduservice/subject/getAllSubjects`, method: &#x27;get&#x27; &#125;)&#125;&#125; vue 这一块内容挺多的，有二级联动查询，有分页条，有条件排序等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- /课程列表 开始 --&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;全部课程&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;section class=&quot;c-sort-box&quot;&gt; &lt;section class=&quot;c-s-dl&quot;&gt; &lt;dl&gt; &lt;dt&gt; &lt;span class=&quot;c-999 fsize14&quot;&gt;课程类别&lt;/span&gt; &lt;/dt&gt; &lt;dd class=&quot;c-s-dl-li&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li&gt; &lt;a title=&quot;全部&quot; href=&quot;#&quot;&gt;全部&lt;/a&gt; &lt;/li&gt; &lt;li v-for=&quot;(item, index) in subjectNestedList&quot; :key=&quot;index&quot; :class=&quot;&#123; active: oneIndex == index &#125;&quot; &gt; &lt;a :title=&quot;item.title&quot; href=&quot;#&quot; @click=&quot;searchOne(item.id, index)&quot; &gt;&#123;&#123; item.title &#125;&#125;&lt;/a &gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;span class=&quot;c-999 fsize14&quot;&gt;&lt;/span&gt; &lt;/dt&gt; &lt;dd class=&quot;c-s-dl-li&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li v-for=&quot;(item, index) in subSubjectList&quot; :key=&quot;index&quot; :class=&quot;&#123; active: twoIndex == index &#125;&quot; &gt; &lt;a :title=&quot;item.title&quot; href=&quot;#&quot; @click=&quot;searchTwo(item.id, index)&quot; &gt;&#123;&#123; item.title &#125;&#125;&lt;/a &gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;div class=&quot;js-wrap&quot;&gt; &lt;section class=&quot;fr&quot;&gt; &lt;span class=&quot;c-ccc&quot;&gt; &lt;i class=&quot;c-master f-fM&quot;&gt;1&lt;/i&gt;/ &lt;i class=&quot;c-666 f-fM&quot;&gt;1&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;fl&quot;&gt; &lt;ol class=&quot;js-tap clearfix&quot;&gt; &lt;li :class=&quot;&#123; &#x27;current bg-orange&#x27;: buyCountSort != &#x27;&#x27; &#125;&quot;&gt; &lt;a title=&quot;销量&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchBuyCount()&quot; &gt;销量 &lt;span :class=&quot;&#123; hide: buyCountSort == &#x27;&#x27; &#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123; &#x27;current bg-orange&#x27;: gmtCreateSort != &#x27;&#x27; &#125;&quot;&gt; &lt;a title=&quot;最新&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchGmtCreate()&quot; &gt;最新 &lt;span :class=&quot;&#123; hide: gmtCreateSort == &#x27;&#x27; &#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123; &#x27;current bg-orange&#x27;: priceSort != &#x27;&#x27; &#125;&quot;&gt; &lt;a title=&quot;价格&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchPrice()&quot; &gt;价格&amp;nbsp; &lt;span :class=&quot;&#123; hide: priceSort == &#x27;&#x27; &#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;/div&gt; &lt;div class=&quot;mt40&quot;&gt; &lt;!-- /无数据提示 开始--&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;data.total == 0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot; &gt;没有相关数据，小编正在努力整理中...&lt;/span &gt; &lt;/section&gt; &lt;!-- /无数据提示 结束--&gt; &lt;article v-if=&quot;data.total &gt; 0&quot; class=&quot;comm-course-list&quot;&gt; &lt;ul class=&quot;of&quot; id=&quot;bna&quot;&gt; &lt;li v-for=&quot;item in data.items&quot; :key=&quot;item.id&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;course-img&quot;&gt; &lt;img :src=&quot;item.cover&quot; class=&quot;img-responsive&quot; :alt=&quot;item.title&quot; /&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a :href=&quot;&#x27;/course/&#x27; + item.id&quot; title=&quot;开始学习&quot; class=&quot;comm-btn c-btn-1&quot; &gt;开始学习&lt;/a &gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a :href=&quot;&#x27;/course/&#x27; + item.id&quot; :title=&quot;item.title&quot; class=&quot;course-title fsize18 c-333&quot; &gt;&#123;&#123; item.title &#125;&#125;&lt;/a &gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span v-if=&quot;Number(item.price) === 0&quot; class=&quot;fr jgTag bg-green&quot; &gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot;&gt;9634人学习&lt;/i&gt; | &lt;i class=&quot;c-999 f-fA&quot;&gt;9634评论&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;!-- 公共分页 开始 --&gt; &lt;div&gt; &lt;div class=&quot;paging&quot;&gt; &lt;!-- undisable这个class是否存在，取决于数据属性hasPrevious --&gt; &lt;a :class=&quot;&#123; undisable: !data.hasPrevious &#125;&quot; href=&quot;#&quot; title=&quot;首页&quot; @click.prevent=&quot;gotoPage(1)&quot; &gt;首&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !data.hasPrevious &#125;&quot; href=&quot;#&quot; title=&quot;前一页&quot; @click.prevent=&quot;gotoPage(data.current - 1)&quot; &gt;&amp;lt;&lt;/a &gt; &lt;a v-for=&quot;page in data.pages&quot; :key=&quot;page&quot; :class=&quot;&#123; current: data.current == page, undisable: data.current == page, &#125;&quot; :title=&quot;&#x27;第&#x27; + page + &#x27;页&#x27;&quot; href=&quot;#&quot; @click.prevent=&quot;gotoPage(page)&quot; &gt;&#123;&#123; page &#125;&#125;&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !data.hasNext &#125;&quot; href=&quot;#&quot; title=&quot;后一页&quot; @click.prevent=&quot;gotoPage(data.current + 1)&quot; &gt;&amp;gt;&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !data.hasNext &#125;&quot; href=&quot;#&quot; title=&quot;末页&quot; @click.prevent=&quot;gotoPage(data.pages)&quot; &gt;末&lt;/a &gt; &lt;div class=&quot;clear&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- /课程列表 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import courseApi from &#x27;@/api/course&#x27; export default &#123; data() &#123; return &#123; page: 1, // 当前页 data: &#123;&#125;, // 课程列表 subjectNestedList: [], // 一级分类列表 subSubjectList: [], // 二级分类列表 queryObj: &#123;&#125;, // 查询表单对象 oneIndex: -1, twoIndex: -1, buyCountSort: &#x27;&#x27;, gmtCreateSort: &#x27;&#x27;, priceSort: &#x27;&#x27; &#125; &#125;, created() &#123; // 课程第一次查询 this.initCourseFirst() // 一级分类显示 this.initSubject() &#125;, methods: &#123; // 1 查询第一页数据 initCourseFirst() &#123; courseApi.getCourseList(1, 8, this.queryObj).then(response =&gt; &#123; this.data = response.data.data &#125;) &#125;, // 2 查询所有一级分类 initSubject() &#123; courseApi.getSubjectList().then(response =&gt; &#123; this.subjectNestedList = response.data.data.list &#125;) &#125;, // 3 分页切换的方法 gotoPage(page) &#123; courseApi.getCourseList(page, 8, this.queryObj).then(response =&gt; &#123; this.data = response.data.data &#125;) &#125;, // 4 点击某个一级分类，查询对应二级分类 searchOne(subjectParentId, index) &#123; // 把传递index值赋值给oneIndex,为了active样式生效 this.oneIndex = index this.twoIndex = -1 this.queryObj.subjectId = &#x27;&#x27; this.subSubjectList = [] // 把一级分类点击id值，赋值给queryObj this.queryObj.subjectParentId = subjectParentId // 点击某个一级分类进行条件查询 this.gotoPage(1) // 拿着点击一级分类id 和 所有一级分类id进行比较， // 如果id相同，从一级分类里面获取对应的二级分类 for (let i = 0; i &lt; this.subjectNestedList.length; i++) &#123; // 获取每个一级分类 var oneSubject = this.subjectNestedList[i] // 比较id是否相同 if (subjectParentId == oneSubject.id) &#123; // 从一级分类里面获取对应的二级分类 this.subSubjectList = oneSubject.children &#125; &#125; &#125;, // 5 点击某个二级分类实现查询 searchTwo(subjectId, index) &#123; // 把index赋值,为了样式生效 this.twoIndex = index // 把二级分类点击id值，赋值给queryObj this.queryObj.subjectId = subjectId // 点击某个二级分类进行条件查询 this.gotoPage(1) &#125;, // 6 根据销量排序 searchBuyCount() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &#x27;1&#x27; this.gmtCreateSort = &#x27;&#x27; this.priceSort = &#x27;&#x27; // 把值赋值到queryObj this.queryObj.buyCountSort = this.buyCountSort this.queryObj.gmtCreateSort = this.gmtCreateSort this.queryObj.priceSort = this.priceSort // 调用方法查询 this.gotoPage(1) &#125;, // 7 最新排序 searchGmtCreate() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &#x27;&#x27; this.gmtCreateSort = &#x27;1&#x27; this.priceSort = &#x27;&#x27; // 把值赋值到queryObj this.queryObj.buyCountSort = this.buyCountSort this.queryObj.gmtCreateSort = this.gmtCreateSort this.queryObj.priceSort = this.priceSort // 调用方法查询 this.gotoPage(1) &#125;, // 8 价格排序 searchPrice() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &#x27;&#x27; this.gmtCreateSort = &#x27;&#x27; this.priceSort = &#x27;1&#x27; // 把值赋值到queryObj this.queryObj.buyCountSort = this.buyCountSort this.queryObj.gmtCreateSort = this.gmtCreateSort this.queryObj.priceSort = this.priceSort // 调用方法查询 this.gotoPage(1) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .active &#123; background: #bdbdbd; &#125; .hide &#123; display: none; &#125; .show &#123; display: block; &#125;&lt;/style&gt; 课程详情（后端）vo类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 课程基础信息VO */@Datapublic class CourseFrontInfoVo &#123; private String id; @ApiModelProperty(value = &quot;课程标题&quot;) private String title; @ApiModelProperty(value = &quot;课程销售价格，设置为0则可免费观看&quot;) private BigDecimal price; @ApiModelProperty(value = &quot;总课时&quot;) private Integer lessonNum; @ApiModelProperty(value = &quot;课程封面图片路径&quot;) private String cover; @ApiModelProperty(value = &quot;销售数量&quot;) private Long buyCount; @ApiModelProperty(value = &quot;浏览数量&quot;) private Long viewCount; @ApiModelProperty(value = &quot;课程简介&quot;) private String description; @ApiModelProperty(value = &quot;讲师ID&quot;) private String teacherId; @ApiModelProperty(value = &quot;讲师姓名&quot;) private String teacherName; @ApiModelProperty(value = &quot;讲师资历,一句话说明讲师&quot;) private String intro; @ApiModelProperty(value = &quot;讲师头像&quot;) private String avatar; @ApiModelProperty(value = &quot;课程一级类别ID&quot;) private String subjectLevelOneId; @ApiModelProperty(value = &quot;类别一级名称&quot;) private String subjectLevelOne; @ApiModelProperty(value = &quot;课程二级类别ID&quot;) private String subjectLevelTwoId; @ApiModelProperty(value = &quot;类别二级名称&quot;) private String subjectLevelTwo;&#125; controller1234567// 课程详情信息@GetMapping(&quot;getCourseInfo/&#123;courseId&#125;&quot;)public R getCourseInfo(@PathVariable String courseId) &#123; CourseFrontInfoVo courseInfo = courseService.getBaseCourseInfo(courseId); List&lt;ChapterVo&gt; chapterList = chapterService.getChapterVideoByCourseId(courseId); return R.ok().data(&quot;courseInfo&quot;, courseInfo).data(&quot;chapterList&quot;, chapterList);&#125; service12345// 根据课程id查询课程基本信息以及其章节列表@Overridepublic CourseFrontInfoVo getBaseCourseInfo(String courseId) &#123; return baseMapper.getBaseCourseInfo(courseId);&#125; mapper12345678910111213141516171819202122232425&lt;!-- 根据课程id查询课程基本信息 --&gt;&lt;select id=&quot;getBaseCourseInfo&quot; resultType=&quot;com.atguigu.eduservice.entity.frontVo.CourseFrontInfoVo&quot;&gt; select ec.id, ec.title, ec.price, ec.cover, ec.lesson_num AS lessonNum, ec.buy_count AS buyCount, ec.view_count AS viewCount, ecd.description, et.id AS teacherId, et.name AS teacherName, et.intro, et.avatar, es1.id AS subjectLevelOneId, es1.title AS subjectLevelOne, es2.id AS subjectLevelTwoId, es2.title AS subjectLevelTwo from edu_course ec left join edu_course_description ecd on ec.id = ecd.id left join edu_teacher et on ec.teacher_id = et.id left join edu_subject es1 on ec.subject_parent_id = es1.id left join edu_subject es2 on ec.subject_id = es2.id where ec.id = #&#123;courseId&#125;&lt;/select&gt; 课程详情（前端）api1234567// 获得课程信息getCourseInfo(courseId) &#123; return request(&#123; url: `/eduservice/coursefront/getCourseInfo/$&#123;courseId&#125;`, method: &#x27;get&#x27; &#125;)&#125; vue 注意这里的简介显示，需要使用v-html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- /课程详情 开始 --&gt; &lt;section class=&quot;container&quot;&gt; &lt;!-- 这里是一个面包屑导航 --&gt; &lt;section class=&quot;path-wrap txtOf hLh30&quot;&gt; &lt;a href=&quot;#&quot; title class=&quot;c-999 fsize14&quot;&gt;首页&lt;/a&gt; \\ &lt;a href=&quot;#&quot; title class=&quot;c-999 fsize14&quot;&gt;&#123;&#123; courseInfo.subjectLevelOne &#125;&#125;&lt;/a&gt; \\ &lt;span class=&quot;c-333 fsize14&quot;&gt;&#123;&#123; courseInfo.subjectLevelTwo &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;div&gt; &lt;article class=&quot;c-v-pic-wrap&quot; style=&quot;height: 357px&quot;&gt; &lt;section class=&quot;p-h-video-box&quot; id=&quot;videoPlay&quot;&gt; &lt;img :src=&quot;courseInfo.cover&quot; :alt=&quot;courseInfo.title&quot; class=&quot;dis c-v-pic&quot; /&gt; &lt;/section&gt; &lt;/article&gt; &lt;aside class=&quot;c-attr-wrap&quot;&gt; &lt;section class=&quot;ml20 mr15&quot;&gt; &lt;h2 class=&quot;hLh30 txtOf mt15&quot;&gt; &lt;span class=&quot;c-fff fsize24&quot;&gt;&#123;&#123; courseInfo.title &#125;&#125;&lt;/span&gt; &lt;/h2&gt; &lt;section class=&quot;c-attr-jg&quot;&gt; &lt;span class=&quot;c-fff&quot;&gt;价格：&lt;/span&gt; &lt;b class=&quot;c-yellow&quot; style=&quot;font-size: 24px&quot; &gt;￥&#123;&#123; courseInfo.price &#125;&#125;&lt;/b &gt; &lt;/section&gt; &lt;section class=&quot;c-attr-mt c-attr-undis&quot;&gt; &lt;span class=&quot;c-fff fsize14&quot; &gt;主讲： &#123;&#123; courseInfo.teacherName &#125;&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span &gt; &lt;/section&gt; &lt;section class=&quot;c-attr-mt of&quot;&gt; &lt;span class=&quot;ml10 vam&quot;&gt; &lt;em class=&quot;icon18 scIcon&quot;&gt;&lt;/em&gt; &lt;a class=&quot;c-fff vam&quot; title=&quot;收藏&quot; href=&quot;#&quot;&gt;收藏&lt;/a&gt; &lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;c-attr-mt&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;立即观看&quot; class=&quot;comm-btn c-btn-3&quot;&gt;立即观看&lt;/a&gt; &lt;/section&gt; &lt;/section&gt; &lt;/aside&gt; &lt;aside class=&quot;thr-attr-box&quot;&gt; &lt;ol class=&quot;thr-attr-ol clearfix&quot;&gt; &lt;li&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;aside&gt; &lt;span class=&quot;c-fff f-fM&quot;&gt;购买数&lt;/span&gt; &lt;br /&gt; &lt;h6 class=&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123; courseInfo.buyCount &#125;&#125;&lt;/h6&gt; &lt;/aside&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;aside&gt; &lt;span class=&quot;c-fff f-fM&quot;&gt;课时数&lt;/span&gt; &lt;br /&gt; &lt;h6 class=&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123; courseInfo.lessonNum &#125;&#125;&lt;/h6&gt; &lt;/aside&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;aside&gt; &lt;span class=&quot;c-fff f-fM&quot;&gt;浏览数&lt;/span&gt; &lt;br /&gt; &lt;h6 class=&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123; courseInfo.viewCount &#125;&#125;&lt;/h6&gt; &lt;/aside&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- /课程封面介绍 --&gt; &lt;div class=&quot;mt20 c-infor-box&quot;&gt; &lt;article class=&quot;fl col-7&quot;&gt; &lt;section class=&quot;mr30&quot;&gt; &lt;div class=&quot;i-box&quot;&gt; &lt;div&gt; &lt;section id=&quot;c-i-tabTitle&quot; class=&quot;c-infor-tabTitle c-tab-title&quot;&gt; &lt;a name=&quot;c-i&quot; class=&quot;current&quot; title=&quot;课程详情&quot;&gt;课程详情&lt;/a&gt; &lt;/section&gt; &lt;/div&gt; &lt;article class=&quot;ml10 mr10 pt20&quot;&gt; &lt;div&gt; &lt;h6 class=&quot;c-i-content c-infor-title&quot;&gt; &lt;span&gt;课程介绍&lt;/span&gt; &lt;/h6&gt; &lt;div class=&quot;course-txt-body-wrap&quot;&gt; &lt;section class=&quot;course-txt-body&quot;&gt; &lt;!-- 由于当初编写的时候使用的富文本编辑器，所以这里显示要使用v-html --&gt; &lt;p v-html=&quot;courseInfo.description&quot;&gt; &#123;&#123; courseInfo.description &#125;&#125; &lt;/p&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /课程介绍 --&gt; &lt;div class=&quot;mt50&quot;&gt; &lt;h6 class=&quot;c-g-content c-infor-title&quot;&gt; &lt;span&gt;课程大纲&lt;/span&gt; &lt;/h6&gt; &lt;section class=&quot;mt20&quot;&gt; &lt;div class=&quot;lh-menu-wrap&quot;&gt; &lt;menu id=&quot;lh-menu&quot; class=&quot;lh-menu mt10 mr10&quot;&gt; &lt;ul&gt; &lt;!-- 文件目录 --&gt; &lt;li class=&quot;lh-menu-stair&quot; v-for=&quot;chapter in chapterList&quot; :key=&quot;chapter.id&quot; &gt; &lt;a href=&quot;javascript: void(0)&quot; :title=&quot;chapter.title&quot; class=&quot;current-1&quot; &gt; &lt;em class=&quot;lh-menu-i-1 icon18 mr10&quot;&gt;&lt;/em &gt;&#123;&#123; chapter.title &#125;&#125; &lt;/a&gt; &lt;ol class=&quot;lh-menu-ol&quot; style=&quot;display: block&quot;&gt; &lt;li class=&quot;lh-menu-second ml30&quot; v-for=&quot;video in chapter.children&quot; :key=&quot;video.id&quot; &gt; &lt;a href=&quot;#&quot; :title=&quot;video.title&quot;&gt; &lt;span class=&quot;fr&quot;&gt; &lt;i class=&quot;free-icon vam mr10&quot;&gt;免费试听&lt;/i&gt; &lt;/span&gt; &lt;em class=&quot;lh-menu-i-2 icon16 mr5&quot;&gt;&amp;nbsp;&lt;/em &gt;&#123;&#123;video.title&#125;&#125; &lt;/a&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/menu&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /课程大纲 --&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/article&gt; &lt;aside class=&quot;fl col-3&quot;&gt; &lt;div class=&quot;i-box&quot;&gt; &lt;div&gt; &lt;section class=&quot;c-infor-tabTitle c-tab-title&quot;&gt; &lt;a title href=&quot;javascript:void(0)&quot;&gt;主讲讲师&lt;/a&gt; &lt;/section&gt; &lt;section class=&quot;stud-act-list&quot;&gt; &lt;ul style=&quot;height: auto&quot;&gt; &lt;li&gt; &lt;div class=&quot;u-face&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img :src=&quot;courseInfo.avatar&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;section class=&quot;hLh30 txtOf&quot;&gt; &lt;a class=&quot;c-333 fsize16 fl&quot; href=&quot;#&quot;&gt;&#123;&#123; courseInfo.teacherName &#125;&#125;&lt;/a&gt; &lt;/section&gt; &lt;section class=&quot;hLh20 txtOf&quot;&gt; &lt;span class=&quot;c-999&quot;&gt;&#123;&#123; courseInfo.intro &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- /课程详情 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import courseApi from &#x27;@/api/course&#x27; export default &#123; asyncData(&#123; params, error &#125;) &#123; return courseApi.getCourseInfo(params.id).then(result =&gt; &#123; return &#123; courseInfo: result.data.data.courseInfo, chapterList: result.data.data.chapterList &#125; &#125;) &#125; &#125;&lt;/script&gt; TODO：里面还有一些跳转还要完善 视频播放器 阿里云视频播放器，使用播放凭证播放 注意这里要写到service_vod模块，因为是和阿里云视频相关 后端controller12345678910111213// 根据视频id获取视频凭证@GetMapping(&quot;getPlayAuth/&#123;id&#125;&quot;)public R getPlayAuth(@PathVariable String id) throws ClientException &#123; // 创建初始化对象 DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET); // 创建获取凭证的request和response GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); request.setVideoId(id); // 调用方法获得凭证 GetVideoPlayAuthResponse acsResponse = client.getAcsResponse(request); String playAuth = acsResponse.getPlayAuth(); return R.ok().data(&quot;playAuth&quot;, playAuth);&#125; 前端 先去修改a标签的href值 :href=&quot;&#39;/video_player/&#39; + video.videoSourceId&quot; target=&quot;_blank&quot; 然后前端在pages文件夹下编写一个动态路由的vue视图，可以命名为_vid.vue，里面编写播放器的模板，这里还专门写了一个video的布局layout，cv即可 layout1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div class=&quot;guli-player&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;谷粒学院&quot;&gt; &lt;img class=&quot;logo&quot; src=&quot;~/assets/img/logo.png&quot; lt=&quot;谷粒学院&quot;&gt; &lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;nuxt/&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;html,body&#123; height:100%;&#125;&lt;/style&gt;&lt;style scoped&gt;.head &#123; height: 50px; position: absolute; top: 0; left: 0; width: 100%;&#125;.head .logo&#123; height: 50px; margin-left: 10px;&#125;.body &#123; position: absolute; top: 50px; left: 0; right: 0; bottom: 0; overflow: hidden;&#125;&lt;/style&gt; api12345678910import request from &#x27;@/utils/request&#x27;export default &#123; getPlayAuth(id) &#123; return request(&#123; url: `/eduvod/video/getPlayAuth/$&#123;id&#125;`, method: &#x27;get&#x27;, &#125;) &#125;,&#125; vue视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;!-- 阿里云视频播放器样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://g.alicdn.com/de/prismplayer/2.8.1/skins/default/aliplayer-min.css&quot; &gt; &lt;!-- 阿里云视频播放器脚本 --&gt; &lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://g.alicdn.com/de/prismplayer/2.8.1/aliplayer-min.js&quot; /&gt; &lt;!-- 定义播放器dom --&gt; &lt;div id=&quot;J_prismPlayer&quot; class=&quot;prism-player&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import vod from &#x27;@/api/vod&#x27;export default &#123; layout: &#x27;video&#x27;,//应用video布局 asyncData(&#123; params, error &#125;) &#123; return vod.getPlayAuth(params.vid) .then(response =&gt; &#123; return &#123; playAuth: response.data.data.playAuth, vid: params.vid &#125; &#125;) &#125;, mounted() &#123; //页面渲染之后 created new Aliplayer(&#123; id: &#x27;J_prismPlayer&#x27;, vid: this.vid, // 视频id playauth: this.playAuth, // 播放凭证 encryptType: &#x27;1&#x27;, // 如果播放加密视频，则需设置encryptType=1，非加密视频无需设置此项 width: &#x27;100%&#x27;, height: &#x27;500px&#x27;, // 以下可选设置 cover: &#x27;http://guli.shop/photo/banner/1525939573202.jpg&#x27;, // 封面 qualitySort: &#x27;asc&#x27;, // 清晰度排序 mediaType: &#x27;video&#x27;, // 返回音频还是视频 autoplay: false, // 自动播放 isLive: false, // 直播 rePlay: false, // 循环播放 preload: true, controlBarVisibility: &#x27;hover&#x27;, // 控制条的显示方式：鼠标悬停 useH5Prism: true, // 播放器类型：html5 &#125;, function(player) &#123; console.log(&#x27;播放器创建成功&#x27;) &#125;) &#125;&#125;&lt;/script&gt; 更多功能 阿里云Aliplayer播放器 (alicdn.com) 详见文档 视频评论（后端+前端） 具体实现分析： 创建课程评论表 创建后端接口 分页查询对应课程评论 添加评论 课程评论内容：输入，调用接口 课程id：进入详情页面就可以查询到课程id 用户id：根据cookie中的token查询用户信息 远程调用（edu -&gt; ucenter） 订单与支付（后端+前端） 创建子模块service_order, application.proerties里大差不差 代码生成器常规操作 后端基础搭建启动类 这个模块需要调用edu和UCenter模块中的方法查询课程和用户信息 12345678910@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@MapperScan(&quot;com.atguigu.eduorder.mapper&quot;)@EnableDiscoveryClient // nacos注册@EnableFeignClients // 使用Feignpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 依赖 微信支付接口的依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 生成订单（后端）OrderController1234567891011121314151617@RestController@RequestMapping(&quot;/eduorder/order&quot;)@CrossOriginpublic class OrderController &#123; @Autowired private OrderService orderService; // 生成订单方法 @PostMapping(&quot;createOrder/&#123;courseId&#125;&quot;) public R createOrder(@PathVariable String courseId, HttpServletRequest request) &#123; // 创建订单返回订单号 String memberId = JwtUtils.getMemberIdByJwtToken(request); String orderNo = orderService.createOrder(courseId, memberId); return R.ok().data(&quot;orderNo&quot;, orderNo); &#125; &#125; 实体类 注意这里要额外写一个vo类用于远程调用的时候返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)@ApiModel(value = &quot;UcenterMember对象&quot;, description = &quot;会员表&quot;)public class UcenterMemberForOrder implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = &quot;会员id&quot;) @TableId(value = &quot;id&quot;, type = IdType.ID_WORKER_STR) private String id; @ApiModelProperty(value = &quot;微信openid&quot;) private String openid; @ApiModelProperty(value = &quot;手机号&quot;) private String mobile; @ApiModelProperty(value = &quot;密码&quot;) private String password; @ApiModelProperty(value = &quot;昵称&quot;) private String nickname; @ApiModelProperty(value = &quot;性别 1 女，2 男&quot;) private Integer sex; @ApiModelProperty(value = &quot;年龄&quot;) private Integer age; @ApiModelProperty(value = &quot;用户头像&quot;) private String avatar; @ApiModelProperty(value = &quot;用户签名&quot;) private String sign; @ApiModelProperty(value = &quot;是否禁用 1（true）已禁用， 0（false）未禁用&quot;) private Boolean isDisabled; @ApiModelProperty(value = &quot;逻辑删除 1（true）已删除， 0（false）未删除&quot;) @TableLogic private Boolean isDeleted; @ApiModelProperty(value = &quot;创建时间&quot;) @TableField(fill = FieldFill.INSERT) private Date gmtCreate; @ApiModelProperty(value = &quot;更新时间&quot;) @TableField(fill = FieldFill.INSERT_UPDATE) private Date gmtModified;&#125; 这个实体类和UCenterMember无差别，但是放在了common模块当中，所以不同模块中的controller都可以使用该类 另一个课程相关实体类与这个类似，放在common模块中即可 UcenterMemberController 编写一个被远程调用的方法，通过id获取用户信息 12345678910111213141516@RestController@RequestMapping(&quot;/educenter/member&quot;)@CrossOriginpublic class UcenterMemberController &#123; @Autowired private UcenterMemberService memberService; // 根据用户id获取用户信息 @GetMapping(&quot;getUserInfoOrder/&#123;id&#125;&quot;) public UcenterMemberForOrder getUserInfoOrder(@PathVariable String id) &#123; // 注意这里的返回类型不要R，而是另一个统一类型 UcenterMember member = memberService.getById(id); UcenterMemberForOrder memberForOrder = new UcenterMemberForOrder(); BeanUtils.copyProperties(member, memberForOrder); return memberForOrder; &#125;&#125; CourseFrontController123456789101112131415@RestController@CrossOrigin@RequestMapping(&quot;/eduservice/coursefront&quot;)public class CourseController &#123; @Autowired private EduCourseService courseService; // 根据课程id查询课程信息 @GetMapping(&quot;getCourseInfoOrder/&#123;id&#125;&quot;) public CourseForOrder getCourseInfoOrder(@PathVariable String id) &#123; CourseInfoVo course = courseService.getCourseInfoById(id); CourseForOrder courseForOrder = new CourseForOrder(); BeanUtils.copyProperties(course, courseForOrder); return courseForOrder; &#125;&#125; 远程调用配置接口1234567@Component@FeignClient(&quot;service-edu&quot;)public interface EduClient &#123; // 根据课程id查询课程信息 @GetMapping(&quot;/eduservice/coursefront/getCourseInfoOrder/&#123;id&#125;&quot;) public CourseForOrder getCourseInfoOrder(@PathVariable(&quot;id&quot;) String id);&#125; 1234567@Component@FeignClient(&quot;service-ucenter&quot;)public interface UcenterClient &#123; // 根据用户id获取用户信息 @GetMapping(&quot;/educenter/member/getUserInfoOrder/&#123;id&#125;&quot;) public UcenterMemberForOrder getUserInfoOrder(@PathVariable(&quot;id&quot;) String id);&#125; OrderService1234567891011121314151617181920212223242526272829303132@Servicepublic class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Order&gt; implements OrderService &#123; @Autowired private EduClient eduClient; @Autowired private UcenterClient ucenterClient; // 生成订单 @Override public String createOrder(String courseId, String memberId) &#123; // 远程调用获取用户信息 UcenterMemberForOrder userInfoOrder = ucenterClient.getUserInfoOrder(memberId); // 远程调用获取课程信息 CourseForOrder courseInfoOrder = eduClient.getCourseInfoOrder(courseId); // 添加到数据库 Order order = new Order(); order.setOrderNo(OrderNoUtil.getOrderNo());//订单号 order.setCourseId(courseId); //课程id order.setCourseTitle(courseInfoOrder.getTitle()); order.setCourseCover(courseInfoOrder.getCover()); order.setTeacherName(courseInfoOrder.getTeacherName()); order.setTotalFee(courseInfoOrder.getPrice()); order.setMemberId(memberId); order.setMobile(userInfoOrder.getMobile()); order.setNickname(userInfoOrder.getNickname()); order.setStatus(0); //订单状态（0：未支付 1：已支付） order.setPayType(1); //支付类型 ，微信1 baseMapper.insert(order); //返回订单号 return order.getOrderNo(); &#125;&#125; 查询订单（后端）12345678// 根据订单id查询订单信息@GetMapping(&quot;getOrderInfo/&#123;orderNo&#125;&quot;)public R getOrderInfo(@PathVariable String orderNo) &#123; QueryWrapper&lt;Order&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_no&quot;, orderNo); Order order = orderService.getOne(wrapper); return R.ok().data(&quot;orderInfo&quot;, order);&#125; 生成订单（前端）api123456789101112131415161718import request from &#x27;@/utils/request&#x27;export default &#123; // 生成订单 createOrder(courseId) &#123; return request(&#123; url: `/eduorder/order/createOrder/$&#123;courseId&#125;`, method: &#x27;get&#x27;, &#125;) &#125;, // 查询订单信息 getOrderInfo(orderNo) &#123; return request(&#123; url: `/eduorder/order/getOrderInfo/$&#123;orderNo&#125;`, method: &#x27;get&#x27;, &#125;) &#125;&#125; 课程详情页面跳转123456789methods: &#123; // 创建订单 createOrder() &#123; orderApi.createOrder(this.courseId).then(result =&gt; &#123; // 返回订单号 跳转页面 this.$router.push(&#123; path: &#x27;/order/&#x27; + result.data.data.orderNo &#125;) &#125;) &#125;&#125; 动态路由页面模板 创建一个动态路由页面，_ono.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;div class=&quot;Page Confirm&quot;&gt; &lt;div class=&quot;Title&quot;&gt; &lt;h1 class=&quot;fl f18&quot;&gt;订单确认&lt;/h1&gt; &lt;img src=&quot;~/assets/img/cart_setp2.png&quot; class=&quot;fr&quot; /&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;form name=&quot;flowForm&quot; id=&quot;flowForm&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;table class=&quot;GoodList&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th class=&quot;name&quot;&gt;商品&lt;/th&gt; &lt;th class=&quot;price&quot;&gt;原价&lt;/th&gt; &lt;th class=&quot;priceNew&quot;&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody&gt; &lt;!-- &lt;tr&gt; &lt;td colspan=&quot;3&quot; class=&quot;Title red f18 fb&quot;&gt;&lt;p&gt;限时折扣&lt;/p&gt;&lt;/td&gt; &lt;/tr&gt; --&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot; class=&quot;teacher&quot;&gt;讲师：&#123;&#123; order.teacherName &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;good&quot;&gt; &lt;td class=&quot;name First&quot;&gt; &lt;a target=&quot;_blank&quot; :href=&quot;&#x27;https://localhost:3000/course/&#x27; + order.courseId&quot; &gt; &lt;img :src=&quot;order.courseCover&quot; /&gt;&lt;/a&gt; &lt;div class=&quot;goodInfo&quot;&gt; &lt;input type=&quot;hidden&quot; class=&quot;ids ids_14502&quot; value=&quot;14502&quot; /&gt; &lt;a target=&quot;_blank&quot; :href=&quot;&#x27;https://localhost:3000/course/&#x27; + order.courseId&quot; &gt;&#123;&#123; order.courseTitle &#125;&#125;&lt;/a &gt; &lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;price&quot;&gt; &lt;p&gt; ￥&lt;strong&gt;&#123;&#123; order.totalFee &#125;&#125;&lt;/strong&gt; &lt;/p&gt; &lt;!-- &lt;span class=&quot;discName red&quot;&gt;限时8折&lt;/span&gt; --&gt; &lt;/td&gt; &lt;td class=&quot;red priceNew Last&quot;&gt; ￥&lt;strong&gt;&#123;&#123; order.totalFee &#125;&#125;&lt;/strong&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;Billing tr&quot; colspan=&quot;3&quot;&gt; &lt;div class=&quot;tr&quot;&gt; &lt;p&gt; 共 &lt;strong class=&quot;red&quot;&gt;1&lt;/strong&gt; 件商品，合计&lt;span class=&quot;red f20&quot; &gt;￥&lt;strong&gt;&#123;&#123; order.totalFee &#125;&#125;&lt;/strong&gt;&lt;/span &gt; &lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;Finish&quot;&gt; &lt;div class=&quot;fr&quot; id=&quot;AgreeDiv&quot;&gt; &lt;label for=&quot;Agree&quot; &gt;&lt;p class=&quot;on&quot;&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;我已阅读并同意&lt;a href=&quot;javascript:&quot; target=&quot;_blank&quot; &gt;《谷粒学院购买协议》&lt;/a &gt; &lt;/p&gt;&lt;/label &gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div class=&quot;Main fl&quot;&gt; &lt;div class=&quot;fl&quot;&gt; &lt;a :href=&quot;&#x27;/course/&#x27; + order.courseId&quot;&gt;返回课程详情页&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;fr&quot;&gt; &lt;p&gt; 共 &lt;strong class=&quot;red&quot;&gt;1&lt;/strong&gt; 件商品，合计&lt;span class=&quot;red f20&quot; &gt;￥&lt;strong id=&quot;AllPrice&quot;&gt;&#123;&#123; order.totalFee &#125;&#125;&lt;/strong&gt;&lt;/span &gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;input name=&quot;score&quot; value=&quot;0&quot; type=&quot;hidden&quot; id=&quot;usedScore&quot; /&gt; &lt;button class=&quot;fr redb&quot; type=&quot;button&quot; id=&quot;submitPay&quot; @click=&quot;toPay()&quot;&gt; 去支付 &lt;/button&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ordersApi from &#x27;@/api/order&#x27; export default &#123; methods: &#123;&#125; &#125;&lt;/script&gt; 方法12345678asyncData(&#123; params, error &#125;) &#123; return ordersApi.getOrderInfo(params.ono) .then(response =&gt; &#123; return &#123; orderInfo: response.data.data.orderInfo &#125; &#125;) &#125;, 测试 这里一直在调试，发现我的courseInfo对象为null，debug了一会发现是courseController当中的被远程调用的方法中，返回的对象vo类内的值不一致，导致BeanUtils赋值的时候赋值不了，然后改一下重启就行 生成支付二维码（后端） 好家伙又要企业认证 controller1234567891011121314@RestController@RequestMapping(&quot;/eduorder/pay-log&quot;)public class PayLogController &#123; @Autowired private PayLogService logService; // 生成微信支付二维码 @GetMapping(&quot;createNative/&#123;orderNo&#125;&quot;) public R createNative(@PathVariable String orderNo) &#123; Map&lt;String, Object&gt; map = logService.createNative(orderNo); return R.ok().data(map); &#125; &#125; service主要业务逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class PayLogServiceImpl extends ServiceImpl&lt;PayLogMapper, PayLog&gt; implements PayLogService &#123; @Autowired private OrderService orderService; // 生成微信支付二维码 @Override public Map&lt;String, Object&gt; createNative(String orderNo) &#123; try &#123; // 根据订单号查询订单信息 QueryWrapper&lt;Order&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_no&quot;, orderNo); Order order = orderService.getOne(wrapper); // 使用map设置生成二维码所需的参数 Map&lt;String, String&gt; m = new HashMap(); m.put(&quot;appid&quot;, &quot;wx74862e0dfcf69954&quot;); m.put(&quot;mch_id&quot;, &quot;1558950191&quot;); m.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); m.put(&quot;body&quot;, order.getCourseTitle()); //课程标题 m.put(&quot;out_trade_no&quot;, orderNo); //订单号 m.put(&quot;total_fee&quot;, order.getTotalFee().multiply(new BigDecimal(&quot;100&quot;)).longValue() + &quot;&quot;); m.put(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;); m.put(&quot;notify_url&quot;, &quot;http://guli.shop/api/order/weixinPay/weixinNotify\\n&quot;); m.put(&quot;trade_type&quot;, &quot;NATIVE&quot;); // 发送httpclient请求，传递参数xml格式 HttpClient client = new HttpClient(&quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;); //设置xml格式的参数 client.setXmlParam(WXPayUtil.generateSignedXml(m, &quot;T6m9iK73b0kn9g5v426MKfHQH7X8rKwb&quot;)); client.setHttps(true); //执行post请求发送 client.post(); // 得到请求返回结果 String xml = client.getContent(); Map&lt;String, String&gt; resultMap = WXPayUtil.xmlToMap(xml); //最终返回数据 的封装 Map map = new HashMap(); map.put(&quot;out_trade_no&quot;, orderNo); map.put(&quot;course_id&quot;, order.getCourseId()); map.put(&quot;total_fee&quot;, order.getTotalFee()); map.put(&quot;result_code&quot;, resultMap.get(&quot;result_code&quot;)); //返回二维码操作状态码 map.put(&quot;code_url&quot;, resultMap.get(&quot;code_url&quot;)); //二维码地址 return map; &#125; catch (Exception e) &#123; throw new GuliException(20001, &quot;生成二维码失败&quot;); &#125; &#125;&#125; 查询支付状态（后端）controller123456789101112131415// 查询订单支付状态@GetMapping(&quot;getPayStatus/&#123;orderNo&#125;&quot;)public R getPayStatus(@PathVariable String orderNo) &#123; Map&lt;String, String&gt; map = logService.getPayStatus(orderNo); if (map == null) &#123; return R.error().message(&quot;支付出错了&quot;); &#125; if (map.get(&quot;trade_state&quot;).equals(&quot;SUCCESS&quot;)) &#123; logService.updateOrderStatus(map); return R.ok(); &#125; // 特定返回码，前端有拦截器判断 return R.ok().code(25000).message(&quot;支付中……&quot;);&#125; service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 查询订单支付状态@Overridepublic Map&lt;String, String&gt; getPayStatus(String orderNo) &#123; try &#123; //1、封装参数 Map&lt;String, String&gt; m = new HashMap&lt;&gt;(); m.put(&quot;appid&quot;, &quot;wx74862e0dfcf69954&quot;); m.put(&quot;mch_id&quot;, &quot;1558950191&quot;); m.put(&quot;out_trade_no&quot;, orderNo); m.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); //2 发送httpclient HttpClient client = new HttpClient(&quot;https://api.mch.weixin.qq.com/pay/orderquery&quot;); client.setXmlParam(WXPayUtil.generateSignedXml(m, &quot;T6m9iK73b0kn9g5v426MKfHQH7X8rKwb&quot;)); client.setHttps(true); client.post(); //3 得到请求返回内容 String xml = client.getContent(); //6、转成Map再返回 return WXPayUtil.xmlToMap(xml); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125;//添加支付记录和更新订单状态@Overridepublic void updateOrderStatus(Map&lt;String, String&gt; map) &#123; //从map获取订单号 String orderNo = map.get(&quot;out_trade_no&quot;); //根据订单号查询订单信息 QueryWrapper&lt;Order&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_no&quot;, orderNo); Order order = orderService.getOne(wrapper); //更新订单表订单状态 if (order.getStatus().intValue() == 1) &#123; // 已经支付过了 return; &#125; order.setStatus(1);//1代表已经支付 orderService.updateById(order); //向支付表添加支付记录 PayLog payLog = new PayLog(); payLog.setOrderNo(orderNo); //订单号 payLog.setPayTime(new Date()); //订单完成时间 payLog.setPayType(1);//支付类型 1微信 payLog.setTotalFee(order.getTotalFee());//总金额(分) payLog.setTradeState(map.get(&quot;trade_state&quot;));//支付状态 payLog.setTransactionId(map.get(&quot;transaction_id&quot;)); //流水号 payLog.setAttr(JSONObject.toJSONString(map)); baseMapper.insert(payLog);&#125; 支付（前端）api1234567891011121314// 生成二维码 createNative(orderNo) &#123; return request(&#123; url: `/eduorder/paylog/createNative/$&#123;orderNo&#125;`, method: &#x27;get&#x27;, &#125;) &#125;, // 查询订单状态 getPayStatus(orderNo) &#123; return request(&#123; url: `/eduorder/paylog/getPayStatus/$&#123;orderNo&#125;`, method: &#x27;get&#x27;, &#125;) &#125;, 跳转至页面方法1234// 去支付toPay() &#123; this.$router.push(&#123; path: &#x27;/pay/&#x27; + this.orderInfo.orderNo &#125;)&#125; 动态路由模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class=&quot;cart py-container&quot;&gt; &lt;!--主内容--&gt; &lt;div class=&quot;checkout py-container pay&quot;&gt; &lt;div class=&quot;checkout-tit&quot;&gt; &lt;h4 class=&quot;fl tit-txt&quot;&gt; &lt;span class=&quot;success-icon&quot;&gt;&lt;/span &gt;&lt;span class=&quot;success-info&quot; &gt;订单提交成功，请您及时付款！订单号：&#123;&#123; payObj.out_trade_no &#125;&#125;&lt;/span &gt; &lt;/h4&gt; &lt;span class=&quot;fr&quot; &gt;&lt;em class=&quot;sui-lead&quot;&gt;应付金额：&lt;/em &gt;&lt;em class=&quot;orange money&quot;&gt;￥&#123;&#123; payObj.total_fee &#125;&#125;&lt;/em&gt;&lt;/span &gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;checkout-steps&quot;&gt; &lt;div class=&quot;fl weixin&quot;&gt;微信支付&lt;/div&gt; &lt;div class=&quot;fl sao&quot;&gt; &lt;p class=&quot;red&quot;&gt;请使用微信扫一扫。&lt;/p&gt; &lt;div class=&quot;fl code&quot;&gt; &lt;!-- &lt;img id=&quot;qrious&quot; src=&quot;~/assets/img/erweima.png&quot; alt=&quot;&quot;&gt; --&gt; &lt;!-- &lt;qriously value=&quot;weixin://wxpay/bizpayurl?pr=R7tnDpZ&quot; :size=&quot;338&quot;/&gt; --&gt; &lt;qriously :value=&quot;payObj.code_url&quot; :size=&quot;338&quot; /&gt; &lt;div class=&quot;saosao&quot;&gt; &lt;p&gt;请使用微信扫一扫&lt;/p&gt; &lt;p&gt;扫描二维码支付&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;!-- &lt;p&gt;&lt;a href=&quot;pay.html&quot; target=&quot;_blank&quot;&gt;&gt; 其他支付方式&lt;/a&gt;&lt;/p&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import orderApi from &#x27;@/api/order&#x27; export default &#123; asyncData(&#123; params, error &#125;) &#123; return orderApi.createNatvie(params.pid).then(response =&gt; &#123; return &#123; payObj: response.data.data &#125; &#125;) &#125;, data() &#123; return &#123; timer1: &#x27;&#x27; &#125; &#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 注意这里需要安装vue-qriously组件 response拦截器12345678910111213141516171819202122232425262728// http response 拦截器service.interceptors.response.use( response =&gt; &#123; //debugger if (response.data.code == 28004) &#123; console.log(&quot;response.data.resultCode是28004&quot;) // 返回 错误代码-1 清除ticket信息并跳转到登录页面 //debugger window.location.href=&quot;/login&quot; return &#125;else&#123; if (response.data.code !== 20000) &#123; //25000：订单支付中，不做任何提示 if(response.data.code != 25000) &#123; Message(&#123; message: response.data.message || &#x27;error&#x27;, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;) &#125; &#125; else &#123; return response; &#125; &#125; &#125;, error =&gt; &#123; return Promise.reject(error.response) // 返回接口返回的错误信息&#125;); 调用方法 这里需要用到response拦截器，后端支付中的返回码为25000，需要根据返回码判断是否支付成功 1234567891011121314151617181920212223242526272829data() &#123; return &#123; timer1: &#x27;&#x27; &#125;&#125;,// 注意这里不适用created，因为使用了异步初始化数据，mounted在页面渲染完成后执行mounted() &#123; this.timer1 = setInterval(() =&gt; &#123; this.getPayStatus(this.payObj.out_trade_no) &#125;, 3000)&#125;,methods: &#123; // 每隔一段时间查询订单状态 getPayStatus(orderNo) &#123; orderApi.getPayStatus(this.orderNo).then(result =&gt; &#123; if (result.data.success) &#123; // 清除定时器 clearInterval(this.timer1) // 提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;支付成功!&#x27; &#125;) // 跳转至课程详情页面 this.$router.push(&#123; path: &#x27;/course/&#x27; + this.payObj.course_id &#125;) &#125; &#125;) &#125;&#125; 测试 测了一次，没跳转但是状态改了，懒得测了，不想花钱 debug了一下，发现后端没啥问题，也执行了，付钱了之后也返回了R.ok，但是前端就是显示result为undefined，不理解 课程信息显示完善 免费和不免费，是否购买等页面显示需要区别 查询用户购买课程信息方法1234567891011// 根绝用户id和课程id查询 用户课程支付情况@GetMapping(&quot;getUserCourseStatus/&#123;cid&#125;/&#123;uid&#125;&quot;)public boolean getUserCourseStatus(@PathVariable String cid, @PathVariable String uid) &#123; QueryWrapper&lt;Order&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;course_id&quot;, cid); wrapper.eq(&quot;member_id&quot;, uid); wrapper.eq(&quot;status&quot;, 1); int count = orderService.count(wrapper); // 已经支付完成 return count &gt; 0;&#125; 需要修改课程详情接口的返回值，加上课程的支付状态（远程调用上述方法） 配置接口123456789// fallback = &quot;实现类的class&quot;，熔断器@FeignClient(name = &quot;service-order&quot;)// 调用服务（服务名），这里的服务名要和对应服务的配置文件中的spring.application.name对应@Componentpublic interface orderClient &#123; // 根绝用户id和课程id查询 用户课程支付情况 @GetMapping(&quot;/eduorder/order/getUserCourseStatus/&#123;cid&#125;/&#123;uid&#125;&quot;) public boolean getUserCourseStatus(@PathVariable(&quot;cid&quot;) String cid, @PathVariable(&quot;uid&quot;) String uid);&#125; 远程调用123456789101112131415161718@RestController@CrossOrigin@RequestMapping(&quot;/eduservice/coursefront&quot;)public class CourseController &#123; @Autowired private EduCourseService courseService; @Autowired private OrderClient orderClient; // 课程详情信息+课程支付状态（远程调用） @GetMapping(&quot;getCourseInfo/&#123;courseId&#125;&quot;) public R getCourseInfo(@PathVariable String courseId, HttpServletRequest request) &#123; CourseFrontInfoVo courseInfo = courseService.getBaseCourseInfo(courseId); List&lt;ChapterVo&gt; chapterList = chapterService.getChapterVideoByCourseId(courseId); // 根据课程用户id查询订单状态 boolean status = orderClient.getUserCourseStatus(courseId, JwtUtils.getMemberIdByJwtToken(request)); return R.ok().data(&quot;courseInfo&quot;, courseInfo).data(&quot;chapterList&quot;, chapterList).data(&quot;isBuy&quot;, status); &#125;&#125; 前端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;section class=&quot;c-attr-mt&quot; v-if=&quot;isBuy || Number(courseInfo.price === 0)&quot; &gt; &lt;a href=&quot;#&quot; title=&quot;立即观看&quot; class=&quot;comm-btn c-btn-3&quot; @click=&quot;createOrder()&quot; &gt;立即观看&lt;/a &gt; &lt;/section&gt; &lt;section class=&quot;c-attr-mt&quot; v-else&gt; &lt;a href=&quot;#&quot; title=&quot;立即购买&quot; class=&quot;comm-btn c-btn-3&quot; @click=&quot;createOrder()&quot; &gt;立即购买&lt;/a &gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import courseApi from &#x27;@/api/course&#x27; import orderApi from &#x27;@/api/order&#x27; export default &#123; // asyncData(&#123; params, error &#125;) &#123; // return courseApi.getCourseInfo(params.id).then(result =&gt; &#123; // return &#123; // courseInfo: result.data.data.courseInfo, // chapterList: result.data.data.chapterList, // courseId: params.id // &#125; // &#125;) // &#125;, asyncData(&#123; params, error &#125;) &#123; return &#123; courseId: params.id &#125; &#125;, data() &#123; return &#123; courseInfo: &#123;&#125;, chapterList: [], isBuy: false &#125; &#125;, created() &#123; // 这里不适用异步调用，而是created this.initCourseInfo() &#125;, methods: &#123; // 查询课程详情信息 initCourseInfo() &#123; courseApi.getCourseInfo(this.courseId).then(result =&gt; &#123; (this.courseInfo = result.data.data.courseInfo), (this.chapterList = result.data.data.chapterList), (this.isBuy = result.data.data.isBuy) &#125;) &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战5","slug":"【项目笔记】在线教育项目实战5","date":"2021-09-28T09:24:35.305Z","updated":"2021-10-02T04:40:15.713Z","comments":true,"path":"2021/09/28/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-5/","link":"","permalink":"http://example.com/2021/09/28/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-5/","excerpt":"","text":"这里开始是前台部分 搭建项目前台环境 使用服务端渲染技术NuxtJS框架 ![02 搭建项目前台环境（nuxt）](https://gitee.com/ReRia/images/raw/master/img/02 搭建项目前台环境（nuxt）.png) 搭建NuxtJS 先赋值template至工作区 修改.eslintrc.js（复制后台的即可） 修改package.json，必须修改其中的name,version,decription,author等 修改nuxt.config.js 安装依赖npm install 测试运行npm run dev NUXT目录结构 资源目录 assets用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。 组件目录 components用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。 布局目录 layouts用于组织应用的布局组件。 default.vue：设置头尾信息 页面目录 pages用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。 插件目录 plugins用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。 nuxt.config.js 文件nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。 引入基础资源和默认头尾视图 Nuxt本身基于vue，但是没有引入element-ui，所以需要引入 这里还引入了其他需要的资源，直接cv即可 assets layout -&gt; default.vue pages -&gt; index.vue default.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;template&gt; &lt;div class=&quot;in-wrap&quot;&gt; &lt;!-- 公共头引入 --&gt; &lt;header id=&quot;header&quot;&gt; &lt;section class=&quot;container&quot;&gt; &lt;h1 id=&quot;logo&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;谷粒学院&quot;&gt; &lt;img src=&quot;~/assets/img/logo.png&quot; width=&quot;100%&quot; alt=&quot;谷粒学院&quot; /&gt; &lt;/a&gt; &lt;/h1&gt; &lt;div class=&quot;h-r-nsl&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;!-- 固定路由 --&gt; &lt;router-link to=&quot;/&quot; tag=&quot;li&quot; active-class=&quot;current&quot; exact&gt; &lt;a&gt;首页&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/course&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;课程&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/teacher&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;名师&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/article&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;文章&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/qa&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;问答&lt;/a&gt; &lt;/router-link&gt; &lt;/ul&gt; &lt;!-- / nav --&gt; &lt;ul class=&quot;h-r-login&quot;&gt; &lt;li v-if=&quot;!loginInfo.id&quot; id=&quot;no-login&quot;&gt; &lt;a href=&quot;/login&quot; title=&quot;登录&quot;&gt; &lt;em class=&quot;icon18 login-icon&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;vam ml5&quot;&gt;登录&lt;/span&gt; &lt;/a&gt; | &lt;a href=&quot;/register&quot; title=&quot;注册&quot;&gt; &lt;span class=&quot;vam ml5&quot;&gt;注册&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li v-if=&quot;loginInfo.id&quot; id=&quot;is-login-one&quot; class=&quot;mr10&quot;&gt; &lt;a id=&quot;headerMsgCountId&quot; href=&quot;#&quot; title=&quot;消息&quot;&gt; &lt;em class=&quot;icon18 news-icon&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;/a&gt; &lt;q class=&quot;red-point&quot; style=&quot;display: none&quot;&gt;&amp;nbsp;&lt;/q&gt; &lt;/li&gt; &lt;li v-if=&quot;loginInfo.id&quot; id=&quot;is-login-two&quot; class=&quot;h-r-user&quot;&gt; &lt;a href=&quot;/ucenter&quot; title&gt; &lt;img :src=&quot;loginInfo.avatar&quot; width=&quot;30&quot; height=&quot;30&quot; class=&quot;vam picImg&quot; alt /&gt; &lt;span id=&quot;userName&quot; class=&quot;vam disIb&quot;&gt;&#123;&#123; loginInfo.nickname &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;javascript:void(0);&quot; title=&quot;退出&quot; @click=&quot;logout()&quot; class=&quot;ml5&quot; &gt;退出&lt;/a &gt; &lt;/li&gt; &lt;!-- /未登录显示第1 li；登录后显示第2，3 li --&gt; &lt;/ul&gt; &lt;aside class=&quot;h-r-search&quot;&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;label class=&quot;h-r-s-box&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入你想学的课程&quot; name=&quot;queryCourse.courseName&quot; value /&gt; &lt;button type=&quot;submit&quot; class=&quot;s-btn&quot;&gt; &lt;em class=&quot;icon18&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;/button&gt; &lt;/label&gt; &lt;/form&gt; &lt;/aside&gt; &lt;/div&gt; &lt;aside class=&quot;mw-nav-btn&quot;&gt; &lt;div class=&quot;mw-nav-icon&quot;&gt;&lt;/div&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;/header&gt; &lt;!-- /公共头引入 --&gt; &lt;nuxt /&gt; &lt;!-- 公共底引入 --&gt; &lt;footer id=&quot;footer&quot;&gt; &lt;section class=&quot;container&quot;&gt; &lt;div class&gt; &lt;h4 class=&quot;hLh30&quot;&gt; &lt;span class=&quot;fsize18 f-fM c-999&quot;&gt;友情链接&lt;/span&gt; &lt;/h4&gt; &lt;ul class=&quot;of flink-list&quot;&gt; &lt;li&gt; &lt;a href=&quot;http://www.atguigu.com/&quot; title=&quot;尚硅谷&quot; target=&quot;_blank&quot; &gt;尚硅谷&lt;/a &gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;b-foot&quot;&gt; &lt;section class=&quot;fl col-7&quot;&gt; &lt;section class=&quot;mr20&quot;&gt; &lt;section class=&quot;b-f-link&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;关于我们&quot; target=&quot;_blank&quot;&gt;关于我们&lt;/a&gt;| &lt;a href=&quot;#&quot; title=&quot;联系我们&quot; target=&quot;_blank&quot;&gt;联系我们&lt;/a&gt;| &lt;a href=&quot;#&quot; title=&quot;帮助中心&quot; target=&quot;_blank&quot;&gt;帮助中心&lt;/a&gt;| &lt;a href=&quot;#&quot; title=&quot;资源下载&quot; target=&quot;_blank&quot;&gt;资源下载&lt;/a&gt;| &lt;span&gt;服务热线：010-56253825(北京) 0755-85293825(深圳)&lt;/span&gt; &lt;span&gt;Email：info@atguigu.com&lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;b-f-link mt10&quot;&gt; &lt;span&gt;©2018课程版权均归谷粒学院所有 京ICP备17055252号&lt;/span&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;aside class=&quot;fl col-3 tac mt15&quot;&gt; &lt;section class=&quot;gf-tx&quot;&gt; &lt;span&gt; &lt;img src=&quot;~/assets/img/wx-icon.png&quot; alt /&gt; &lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;gf-tx&quot;&gt; &lt;span&gt; &lt;img src=&quot;~/assets/img/wb-icon.png&quot; alt /&gt; &lt;/span&gt; &lt;/section&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/footer&gt; &lt;!-- /公共底引入 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#x27;~/assets/css/reset.css&#x27; import &#x27;~/assets/css/theme.css&#x27; import &#x27;~/assets/css/global.css&#x27; import &#x27;~/assets/css/web.css&#x27; export default &#123; &#125;&lt;/script&gt; index.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;template&gt; &lt;div&gt; &lt;!-- 幻灯片 开始 --&gt; &lt;div v-swiper:mySwiper=&quot;swiperOption&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div v-for=&quot;banner in bannerList&quot; :key=&quot;banner.id&quot; class=&quot;swiper-slide&quot; style=&quot;background: #040b1b&quot; &gt; &lt;a target=&quot;_blank&quot; :href=&quot;banner.linkUrl&quot;&gt; &lt;img :src=&quot;banner.imageUrl&quot; :alt=&quot;banner.title&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination swiper-pagination-white&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev swiper-button-white&quot; slot=&quot;button-prev&quot; &gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next swiper-button-white&quot; slot=&quot;button-next&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 幻灯片 结束 --&gt; &lt;div id=&quot;aCoursesList&quot;&gt; &lt;!-- 网校课程 开始 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;热门课程&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;comm-course-list&quot;&gt; &lt;ul class=&quot;of&quot; id=&quot;bna&quot;&gt; &lt;li v-for=&quot;course in courseList&quot; :key=&quot;course.id&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;course-img&quot;&gt; &lt;img :src=&quot;course.cover&quot; class=&quot;img-responsive&quot; :alt=&quot;course.title&quot; /&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;开始学习&quot; class=&quot;comm-btn c-btn-1&quot; &gt;开始学习&lt;/a &gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a href=&quot;#&quot; :title=&quot;course.title&quot; class=&quot;course-title fsize18 c-333&quot; &gt;&#123;&#123; course.title &#125;&#125;&lt;/a &gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span class=&quot;fr jgTag bg-green&quot; v-if=&quot;Number(course.price) === 0&quot; &gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot;&gt;9634人学习&lt;/i&gt; | &lt;i class=&quot;c-999 f-fA&quot;&gt;9634评论&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;section class=&quot;tac pt20&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;全部课程&quot; class=&quot;comm-btn c-btn-2&quot;&gt;全部课程&lt;/a&gt; &lt;/section&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /网校课程 结束 --&gt; &lt;!-- 网校名师 开始 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;名师大咖&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;i-teacher-list&quot;&gt; &lt;ul class=&quot;of&quot;&gt; &lt;li v-for=&quot;teacher in teacherList&quot; :key=&quot;teacher.id&quot;&gt; &lt;section class=&quot;i-teach-wrap&quot;&gt; &lt;div class=&quot;i-teach-pic&quot;&gt; &lt;a href=&quot;/teacher/1&quot; :title=&quot;teacher.name&quot;&gt; &lt;img :alt=&quot;teacher.name&quot; :src=&quot;teacher.avatar&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mt10 hLh30 txtOf tac&quot;&gt; &lt;a href=&quot;/teacher/1&quot; :title=&quot;teacher.name&quot; class=&quot;fsize18 c-666&quot; &gt;&#123;&#123; teacher.name &#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;hLh30 txtOf tac&quot;&gt; &lt;span class=&quot;fsize14 c-999&quot;&gt;&#123;&#123; teacher.career &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;mt15 i-q-txt&quot;&gt; &lt;p class=&quot;c-999 f-fA&quot;&gt; &#123;&#123; teacher.intro &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;section class=&quot;tac pt20&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;全部讲师&quot; class=&quot;comm-btn c-btn-2&quot;&gt;全部讲师&lt;/a&gt; &lt;/section&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /网校名师 结束 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 轮播图组件 本项目需要用到一个轮播图组件awesome-swiper（这里使用3.1.3版本） 安装 npm install vue-awesome-swiper@3.1.3 配置 在 plugins 文件夹下新建文件 nuxt-swiper-plugin.js 123import Vue from &#x27;vue&#x27;import VueAwesomeSwiper from &#x27;vue-awesome-swiper/dist/ssr&#x27;Vue.use(VueAwesomeSwiper) 在 nuxt.config.js 文件中配置插件 12345678910module.exports = &#123; // some nuxt config... // awesome-swiper插件配置引入 plugins: [ &#123; src: &#x27;~/plugins/nuxt-swiper-plugin.js&#x27;, ssr: false &#125; ], css: [ &#x27;swiper/dist/css/swiper.css&#x27; ]&#125; axios依赖与封装 npm install axios 创建utils -&gt; request.js 注意这里的baseURL要与nginx对应 1234567import axios from &#x27;axios&#x27;// 创建axios实例const service = axios.create(&#123; baseURL: &#x27;http://localhost:9001&#x27;, // api的base_url timeout: 20000 // 请求超时时间&#125;)export default service element-ui安装 npm install element-ui 配置 plugins -&gt; nuxt-swiper-plugin.js 12345678import Vue from &#x27;vue&#x27;import VueAwesomeSwiper from &#x27;vue-awesome-swiper/dist/ssr&#x27;import VueQriously from &#x27;vue-qriously&#x27;import ElementUI from &#x27;element-ui&#x27; //element-ui的全部组件import &#x27;element-ui/lib/theme-chalk/index.css&#x27;//element-ui的cssVue.use(ElementUI) //使用elementUIVue.use(VueQriously)Vue.use(VueAwesomeSwiper) 测试 必看注意，直接启动的话eslint语法检查十分严格，类似于空格是2个就不能是4个，所以要把严格检查关闭 解决vue/cli3.0 语法验证规则 ESLint: Expected indentation of 2 spaces but found 4. (indent) - 走看看 (zoukankan.com) 仔细参考上述文章内容，注意两个步骤都要执行才行（弄了我十几分钟有点烦躁，好在解决了） 首页基础搭建讲师和课程视图模板搭建固定路由 注意default.js中设置了头导航的固定路由，所以需要在pages文件夹下创建对应的视图 注意其中的router-link（即路由导航），其中的to对应的地址就是视图的地址，值为文件夹的路径，to会自动找到pages文件夹下对应名字的文件夹中的index.vue 按照这个思路创建对应视图即可，然后复制资料中已经有的视图模板 动态路由 动态路由编写有一定的规范 例如需要根据id查询一条记录，需要在对应pages的文件夹下创建_id.vue文件，（必须是以下划线开头，参数名为下划线后面的文件名） 创建视图 根据上述条件创建即可，然后内容模板cv即可 当前项目结构 后端环境搭建创建子模块 service_cms 创建并编写配置文件application.properties 注意这里的DataSource配置，如果不对可能会报springboot找不到bean的错误 123456789101112131415161718192021222324252627# 服务端口server.port=8004# 服务名spring.application.name=service-cms# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/atguigu/educms/mapper/xml/*.xmlspring.redis.host=192.168.44.132spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle=5spring.redis.lettuce.pool.min-idle=0#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 这里记得去nginx.conf里配置一下 创建数据库表 导入资料的sql文件即可 编写启动类123456789@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@MapperScan(&quot;com.atguigu.educms.mapper&quot;)@EnableDiscoveryClient // nacos注册public class CmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CmsApplication.class, args); &#125;&#125; 代码生成器 老样子改一下就行 生成之后跨域注释加一下、mapperscan加一下、配置文件中扫描mapper.xml路径加一下 一些实体类字段的注释也要加一下，比如说自动添加和逻辑删除 123@MapperScan(&quot;com.atguigu.educms.mapper&quot;)public class CmsApplication &#123;&#125; 1234@CrossOriginpublic class CrmBannerController &#123;&#125; 12#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/atguigu/educms/mapper/xml/*.xml 当前项目结构 首页轮播图（后端） 后台应该也有轮播图的管理模块，所以需要两个bannerController 编写BannerAdminController 用于后台的banner管理接口，TODO：前端页面自己写（我选择不写使用swagger测试嘿嘿😙） 1234567891011121314151617181920212223242526272829303132333435363738@RestController@RequestMapping(&quot;/educms/banneradmin&quot;)@CrossOriginpublic class BannerAdminController &#123; @Autowired private CrmBannerService bannerService; // 分页查询 @GetMapping(&quot;pageBanner/&#123;pageNo&#125;/&#123;limit&#125;&quot;) public R pageBanner(@PathVariable Long limit, @PathVariable Long pageNo) &#123; Page&lt;CrmBanner&gt; pageBanner = new Page&lt;&gt;(pageNo, limit); bannerService.page(pageBanner, null); return R.ok().data(&quot;records&quot;, pageBanner.getRecords()).data(&quot;total&quot;, pageBanner.getTotal()); &#125; //2 添加banner @PostMapping(&quot;addBanner&quot;) public R addBanner(@RequestBody CrmBanner crmBanner) &#123; bannerService.save(crmBanner); return R.ok(); &#125; @ApiOperation(value = &quot;获取Banner&quot;) @GetMapping(&quot;get/&#123;id&#125;&quot;) public R get(@PathVariable String id) &#123; CrmBanner banner = bannerService.getById(id); return R.ok().data(&quot;item&quot;, banner); &#125; @ApiOperation(value = &quot;修改Banner&quot;) @PutMapping(&quot;update&quot;) public R updateById(@RequestBody CrmBanner banner) &#123; bannerService.updateById(banner); return R.ok(); &#125; @ApiOperation(value = &quot;删除Banner&quot;) @DeleteMapping(&quot;remove/&#123;id&#125;&quot;) public R remove(@PathVariable String id) &#123; bannerService.removeById(id); return R.ok(); &#125;&#125; 编写BannerFrontController 用于前台的banner接口，主要用于显示banner 12345678910111213@RestController@RequestMapping(&quot;/educms/bannerfront&quot;)@CrossOriginpublic class BannerFrontController &#123; @Autowired private CrmBannerService bannerService; //查询banner信息 @GetMapping(&quot;getBannerList&quot;) public R getBannerList() &#123; List&lt;CrmBanner&gt; list = bannerService.selectAllBanner(); return R.ok().data(&quot;list&quot;, list); &#125;&#125; 编写Service 这里自己写了个service，结果啥也没实现，纯属脱裤子放屁，我改了 我发现我错了，我应该看完整个视频才说话，这个是为了后面的Redis做准备的 写Mapper里最好（弹幕：感谢这段代码，昨天写了，今天老板让我走） 123456789101112131415@Servicepublic class CrmBannerServiceImpl extends ServiceImpl&lt;CrmBannerMapper, CrmBanner&gt; implements CrmBannerService &#123; // 查询所有banner @Override public List&lt;CrmBanner&gt; selectAllBanner() &#123; // 根据id降序排序，显示排序后的前两条记录 QueryWrapper&lt;CrmBanner&gt; wrapper = new QueryWrapper&lt;&gt;(); // 设置排序条件 wrapper.orderByDesc(&quot;id&quot;); // 设置显示数量，last拼接sql语句 wrapper.last(&quot;limit 2&quot;); List&lt;CrmBanner&gt; crmBanners = baseMapper.selectList(wrapper); return crmBanners; &#125;&#125; 首页热门课程和名师（后端） 注意这里，controller这些又写到service_edu模块中了 编写Mapper 需求：根据id进行降序排序（或者根据表中专门的热度排序），显示排序之后的前8条数据 EduTeacherMapper123456&lt;select id=&quot;selectIndexList&quot; resultType=&quot;com.atguigu.eduservice.entity.EduTeacher&quot;&gt; select * from edu_teacher order by id desc limit 4&lt;/select&gt; EduCourseMapper123456&lt;select id=&quot;selectIndexList&quot; resultType=&quot;com.atguigu.eduservice.entity.EduCourse&quot;&gt; select * from edu_course order by id desc limit 8&lt;/select&gt; 编写service 就直接调用baseMapper中的接口即可 编写controller123456789101112131415161718@RestController@RequestMapping(&quot;/eduservice/index&quot;)@CrossOriginpublic class IndexController &#123; @Autowired private EduCourseService courseService; @Autowired private EduTeacherService teacherService; // 查询热门课程和讲师 @GetMapping(&quot;index&quot;) public R getIndex() &#123; List&lt;EduCourse&gt; courseList = courseService.getIndexList(); List&lt;EduTeacher&gt; teacherList = teacherService.getIndexList(); return R.ok().data(&quot;courseList&quot;, courseList).data(&quot;teacherList&quot;, teacherList); &#125;&#125; 首页轮播图和热门讲师课程（前端）API api -&gt; banner.js api -&gt; index.js banner.js1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; //查询前两条banner数据 getBannerList() &#123; return request(&#123; url: &#x27;/educms/bannerfront/getBannerList&#x27;, method: &#x27;get&#x27; &#125;) &#125;&#125; index.js1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; //查询热门课程和名师 getIndexList() &#123; return request(&#123; url: &#x27;/eduservice/index/getIndexList&#x27;, method: &#x27;get&#x27; &#125;) &#125;&#125; 调用接口 注意这里的response需要两个data，应为这个模板没有帮忙封装response的一些东西，之前的直接获得的是response.data 轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div&gt; &lt;!-- 幻灯片 开始 --&gt; &lt;div v-swiper:mySwiper=&quot;swiperOption&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div v-for=&quot;banner in bannerList&quot; :key=&quot;banner.id&quot; class=&quot;swiper-slide&quot; style=&quot;background: #040b1b&quot; &gt; &lt;a target=&quot;_blank&quot; :href=&quot;banner.linkUrl&quot;&gt; &lt;img :src=&quot;banner.imageUrl&quot; :alt=&quot;banner.title&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination swiper-pagination-white&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev swiper-button-white&quot; slot=&quot;button-prev&quot; &gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next swiper-button-white&quot; slot=&quot;button-next&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 幻灯片 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import bannerApi from &#x27;@/api/banner&#x27; export default &#123; data() &#123; return &#123; swiperOption: &#123; // 配置分页 pagination: &#123; el: &#x27;.swiper-pagination&#x27; // 分页的dom节点 &#125;, // 配置导航 navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, // 下一页dom节点 prevEl: &#x27;.swiper-button-prev&#x27; // 前一页dom节点 &#125; &#125;, // 数组 bannerList: [], courseList: [], teacherList: [] &#125; &#125;, created() &#123; // 初始化数据 this.getBannerList() &#125;, methods: &#123; // 初始化首页轮播图课程讲师列表 getBannerList() &#123; bannerApi.getBannerList().then(result =&gt; &#123; this.bannerList = result.data.data.list &#125;) &#125; &#125; &#125;&lt;/script&gt; 热门课程讲师123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;template&gt; &lt;div&gt; &lt;div id=&quot;aCoursesList&quot;&gt; &lt;!-- 网校课程 开始 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;热门课程&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;comm-course-list&quot;&gt; &lt;ul class=&quot;of&quot; id=&quot;bna&quot;&gt; &lt;li v-for=&quot;course in courseList&quot; :key=&quot;course.id&quot; &gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;course-img&quot;&gt; &lt;img :src=&quot;course.cover&quot; class=&quot;img-responsive&quot; :alt=&quot;course.title&quot; /&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;开始学习&quot; class=&quot;comm-btn c-btn-1&quot; &gt;开始学习&lt;/a &gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a href=&quot;#&quot; :title=&quot;course.title&quot; class=&quot; course-title fsize18 c-333 &quot; &gt;&#123;&#123; course.title &#125;&#125;&lt;/a &gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span class=&quot;fr jgTag bg-green&quot; v-if=&quot; Number(course.price) === 0 &quot; &gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot; &gt;免费&lt;/i &gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot; &gt;9634人学习&lt;/i &gt; | &lt;i class=&quot;c-999 f-fA&quot; &gt;9634评论&lt;/i &gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;section class=&quot;tac pt20&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;全部课程&quot; class=&quot;comm-btn c-btn-2&quot; &gt;全部课程&lt;/a &gt; &lt;/section&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /网校课程 结束 --&gt; &lt;!-- 网校名师 开始 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;名师大咖&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;i-teacher-list&quot;&gt; &lt;ul class=&quot;of&quot;&gt; &lt;li v-for=&quot;teacher in teacherList&quot; :key=&quot;teacher.id&quot; &gt; &lt;section class=&quot;i-teach-wrap&quot;&gt; &lt;div class=&quot;i-teach-pic&quot;&gt; &lt;a href=&quot;/teacher/1&quot; :title=&quot;teacher.name&quot; &gt; &lt;img :alt=&quot;teacher.name&quot; :src=&quot;teacher.avatar&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mt10 hLh30 txtOf tac&quot;&gt; &lt;a href=&quot;/teacher/1&quot; :title=&quot;teacher.name&quot; class=&quot;fsize18 c-666&quot; &gt;&#123;&#123; teacher.name &#125;&#125;&lt;/a &gt; &lt;/div&gt; &lt;div class=&quot;hLh30 txtOf tac&quot;&gt; &lt;span class=&quot;fsize14 c-999&quot;&gt;&#123;&#123; teacher.career &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;mt15 i-q-txt&quot;&gt; &lt;p class=&quot;c-999 f-fA&quot;&gt; &#123;&#123; teacher.intro &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;section class=&quot;tac pt20&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;全部讲师&quot; class=&quot;comm-btn c-btn-2&quot; &gt;全部讲师&lt;/a &gt; &lt;/section&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /网校名师 结束 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import bannerApi from &#x27;@/api/banner&#x27; import indexApi from &#x27;@/api/index&#x27; export default &#123; data() &#123; return &#123; swiperOption: &#123; // 配置分页 pagination: &#123; el: &#x27;.swiper-pagination&#x27; // 分页的dom节点 &#125;, // 配置导航 navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, // 下一页dom节点 prevEl: &#x27;.swiper-button-prev&#x27; // 前一页dom节点 &#125; &#125;, // 数组 bannerList: [], courseList: [], teacherList: [] &#125; &#125;, created() &#123; // 初始化数据 this.getBannerList() this.getCourseTeacher() &#125;, methods: &#123; // 初始化首页课程讲师列表 getCourseTeacher() &#123; indexApi.getIndexList().then(result =&gt; &#123; this.courseList = result.data.data.courseList this.teacherList = result.data.data.teacherList &#125;) &#125; &#125; &#125;&lt;/script&gt; 测试 这里我没有把url对应起来，所以报了Access to XMLHttpRequest at &#39;http://localhost:9001/educms/bannerfront/getBannerList&#39; from origin &#39;http://localhost:3000&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.的错误 这个错误还有可能是nginx没有配置，或者跨域注解没有加 单点登录SSO![02 单点登录三种方式介绍](https://gitee.com/ReRia/images/raw/master/img/02 单点登录三种方式介绍.png) Redis介绍 整合 该项目在common模块中配置 依赖123456789101112&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- spring2.X集成redis所需common-pool2--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt; 创建配置类123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration // 配置类@EnableCaching // 开启cashe缓存public class RedisConfig extends CachingConfigurerSupport &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory); //key序列化方式 template.setKeySerializer(redisSerializer); //value序列化 template.setValueSerializer(jackson2JsonRedisSerializer); //value hashmap序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template; &#125; @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题）,过期时间600秒 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(600)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125;&#125; springboot缓存注解 在相对应接口中添加Redis缓存使用注解即可使用Redis缓存 @Cacheable：一般用在查询方法上，根据方法对其返回结果进行缓存，下次请求时如果缓存存在，name直接读取缓存数据返回 @CachePut：一般用在新增方法上，使用该注解的方法每次都会执行，并将结果存入指定的缓存中 @CacheEvict：一般用在更新或者删除方法上，会清空指定的缓存 使用Redis服务安装Redis并启动 这里我去谷粒商城看了 配置文件 在需要使用redis的模块的配置文件application.properties中添加配置 12345678#redis配置#注意这里的host和port要和虚拟机的对应spring.redis.host=192.168.128.129spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1 首页缓存 在相关的service方法上添加注释（注意这里为什么要在service中加，因为注释自动添加到redis的话，是从返回值获取的，controller中定义了统一返回格式，不适用） 12345678@Servicepublic class CrmBannerServiceImpl extends ServiceImpl&lt;CrmBannerMapper, CrmBanner&gt; implements CrmBannerService &#123; // 查询所有banner @Override @Cacheable(key = &quot;&#x27;selectIndexList&#x27;&quot;, value = &quot;banner&quot;) // Redis缓存,注意这里key中要加单引号 public List&lt;CrmBanner&gt; selectAllBanner() &#123; &#125;&#125; redis相关命令 使用root权限：su root 查看VMwarehost：ifconfig 修改配置文件：vi /mydata/redis/conf/redis.conf 启动redis：docker start redis 进入redis：docker exec -it redis redis-cli 查看所有keyvalue：keys * 设置查看：set/get xxx JWT(Json Web Token) 依赖 先引入依赖，common_utils模块即可 1234567&lt;dependencies&gt; &lt;!-- JWT--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; utils类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jws;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.util.StringUtils;import javax.servlet.http.HttpServletRequest;import java.util.Date;public class JwtUtils &#123; public static final long EXPIRE = 1000 * 60 * 60 * 24; public static final String APP_SECRET = &quot;ukc8BDbRigUDaY6pZFfWus2jZWLPHO&quot;; public static String getJwtToken(String id, String nickname) &#123; String JwtToken = Jwts.builder() .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;) .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;) .setSubject(&quot;guli-user&quot;) .setIssuedAt(new Date()) .setExpiration(new Date(System.currentTimeMillis() + EXPIRE)) .claim(&quot;id&quot;, id) .claim(&quot;nickname&quot;, nickname) .signWith(SignatureAlgorithm.HS256, APP_SECRET) .compact(); return JwtToken; &#125; /** * 判断token是否存在与有效 * * @param jwtToken * @return */ public static boolean checkToken(String jwtToken) &#123; if (StringUtils.isEmpty(jwtToken)) return false; try &#123; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 判断token是否存在与有效 * * @param request * @return */ public static boolean checkToken(HttpServletRequest request) &#123; try &#123; String jwtToken = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(jwtToken)) return false; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 根据token获取会员id * * @param request * @return */ public static String getMemberIdByJwtToken(HttpServletRequest request) &#123; String jwtToken = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(jwtToken)) return &quot;&quot;; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); Claims claims = claimsJws.getBody(); return (String) claims.get(&quot;id&quot;); &#125;&#125; 短信微服务阿里云短信服务 开启之后，申请签名管理和模板管理 ？？？必须要备案网站好家伙mua的 TODO，没有域名下次再说吧 创建子模块 service_msm模块 配置文件application.properties 基本上都是一样的写法 1234567891011121314151617181920212223242526272829# 服务端口server.port=8005# 服务名spring.application.name=service-msm# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789#redis配置spring.redis.host=192.168.128.129spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle=5spring.redis.lettuce.pool.min-idle=0#最小空闲#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/atguigu/educms/mapper/xml/*.xml 启动类1234567@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class MsmApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MsmApplication.class, args); &#125;&#125; controller TODO service TODO 登录注册（后端）基础工作创建模块 service_ucenter 数据库 ucenter_member 代码生成器 老样子 配置文件 老样子 1234567891011121314151617181920212223242526272829# 服务端口server.port=8006# 服务名spring.application.name=service-ucenter# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789#redis配置spring.redis.host=192.168.128.129spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle=5spring.redis.lettuce.pool.min-idle=0#最小空闲#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/atguigu/educenter/mapper/xml/*.xml 启动类12345678@SpringBootApplication@ComponentScan(&#123;&quot;com.atguigu&quot;&#125;)@MapperScan(&quot;com.atguigu.educenter.mapper&quot;)public class UcenterApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UcenterApplication.class, args); &#125;&#125; 还有nginx配置，跨域配置等 登录MD5Utils 加密工具 12345678910111213141516171819202122232425262728293031package com.atguigu.educenter.utils;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public final class MD5 &#123; public static String encrypt(String strSrc) &#123; try &#123; char hexChars[] = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;; byte[] bytes = strSrc.getBytes(); MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); md.update(bytes); bytes = md.digest(); int j = bytes.length; char[] chars = new char[j * 2]; int k = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; byte b = bytes[i]; chars[k++] = hexChars[b &gt;&gt;&gt; 4 &amp; 0xf]; chars[k++] = hexChars[b &amp; 0xf]; &#125; return new String(chars); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;MD5加密出错！！+&quot; + e); &#125; &#125; public static void main(String[] args) &#123; System.out.println(MD5.encrypt(&quot;111111&quot;)); &#125;&#125; controller1234567891011121314@RestController@RequestMapping(&quot;/educenter/member&quot;)@CrossOriginpublic class UcenterMemberController &#123; @Autowired private UcenterMemberService memberService; // 登录 @PostMapping(&quot;login&quot;) public R loginUser(@RequestBody UcenterMember member) &#123; // 调用service方法,并且返回token String token = memberService.login(member); return R.ok().data(&quot;token&quot;, token); &#125;&#125; service 注意使用MD5工具加密再比较密码 12345678910111213141516171819202122232425262728293031323334@Servicepublic class UcenterMemberServiceImpl extends ServiceImpl&lt;UcenterMemberMapper, UcenterMember&gt; implements UcenterMemberService &#123; // 登录 @Override public String login(UcenterMember member) &#123; // 获得手机号和密码 String mobile = member.getMobile(); String password = member.getPassword(); // 非空判断 if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password)) &#123; throw new GuliException(20001, &quot;手机或密码为空&quot;); &#125; // 查询数据库 QueryWrapper&lt;UcenterMember&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;mobile&quot;, mobile); UcenterMember mmember = baseMapper.selectOne(wrapper); if (mmember == null) &#123; throw new GuliException(20001, &quot;该账号不存在&quot;); &#125; // 判断密码是否正确 // 数据库密码为加密后的密码，所以需要转换 // 使用加密方式MD5（只能加密） if (!mmember.getPassword().equals(MD5.encrypt(password))) &#123; throw new GuliException(20001, &quot;密码错误&quot;); &#125; // 判断是否禁用 if (mmember.getIsDisabled()) &#123; throw new GuliException(20001, &quot;账号禁用&quot;); &#125; // 生成token字符串 String token = JwtUtils.getJwtToken(mmember.getId(), mmember.getNickname()); return token; &#125;&#125; swagger测试 初始值随便复制一个mobile，密码统一为111111 注册vo实体类1234567891011@Datapublic class RegisterVo &#123; @ApiModelProperty(value = &quot;昵称&quot;) private String nickname; @ApiModelProperty(value = &quot;手机号&quot;) private String mobile; @ApiModelProperty(value = &quot;密码&quot;) private String password; //@ApiModelProperty(value = &quot;验证码&quot;) //private String code;&#125; controller123456// 注册@PostMapping(&quot;register&quot;)public R registerUser(@RequestBody RegisterVo registerVo) &#123; memberService.register(registerVo); return R.ok();&#125; service12345678910111213141516171819202122232425262728// 注册@Overridepublic void register(RegisterVo registerVo) &#123; // TODO 验证码判断（暂时不写） //获取注册的数据 String mobile = registerVo.getMobile(); //手机号 String nickname = registerVo.getNickname(); //昵称 String password = registerVo.getPassword(); //密码 //非空判断 if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password) || StringUtils.isEmpty(nickname)) &#123; throw new GuliException(20001, &quot;输入为空&quot;); &#125; //判断手机号是否重复，表里面存在相同手机号不进行添加 QueryWrapper&lt;UcenterMember&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;mobile&quot;, mobile); Integer count = baseMapper.selectCount(wrapper); if (count &gt; 0) &#123; throw new GuliException(20001, &quot;手机号重复&quot;); &#125; //数据添加数据库中 UcenterMember member = new UcenterMember(); member.setMobile(mobile); member.setNickname(nickname); member.setPassword(MD5.encrypt(password));//密码需要加密的 member.setIsDisabled(false);//用户不禁用 member.setAvatar(&quot;http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoj0hHXhgJNOTSOFsS4uZs8x1ConecaVOB8eIl115xmJZcT4oCicvia7wMEufibKtTLqiaJeanU2Lpg3w/132&quot;); baseMapper.insert(member);&#125; 回显数据 根据token获得用户信息 controller12345678910// 根据token获取用户信息@GetMapping(&quot;getMemberInfo&quot;)public R getMemberInfo(HttpServletRequest request) &#123; // 调用jwt工具类方法获取request对象的头信息，获得id String memberId = JwtUtils.getMemberIdByJwtToken(request); // 获得用户信息 UcenterMember member = memberService.getById(memberId); // 这里最好额外使用vo实体类 return R.ok().data(&quot;member&quot;, member);&#125; 登录注册（前端）注册layout 创建sign.vue然后cv 这个是专门的注册登录页面的布局 api api中创建对应js即可 1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; // 注册 register(registerVo) &#123; return request(&#123; url: &#x27;/educenter/member/register&#x27;, method: &#x27;post&#x27;, data: registerVo &#125;) &#125;&#125; vue页面 先去layout -&gt; default.vue中的地址该为登录注册页面的地址 然后在pages里创建vue视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;a href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;span&gt;·&lt;/span&gt; &lt;a class=&quot;active&quot; href=&quot;/register&quot;&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;sign-up-container&quot;&gt; &lt;el-form ref=&quot;userForm&quot; :model=&quot;params&quot;&gt; &lt;el-form-item class=&quot;input-prepend restyle&quot; prop=&quot;nickname&quot; :rules=&quot;[ &#123; required: true, message: &#x27;请输入你的昵称&#x27;, trigger: &#x27;blur&#x27; &#125;, ]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;你的昵称&quot; v-model=&quot;params.nickname&quot; /&gt; &lt;i class=&quot;iconfont icon-user&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;input-prepend restyle no-radius&quot; prop=&quot;mobile&quot; :rules=&quot;[ &#123; required: true, message: &#x27;请输入手机号码&#x27;, trigger: &#x27;blur&#x27; &#125;, &#123; validator: checkPhone, trigger: &#x27;blur&#x27; &#125;, ]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;手机号&quot; v-model=&quot;params.mobile&quot; /&gt; &lt;i class=&quot;iconfont icon-phone&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;input-prepend restyle no-radius&quot; prop=&quot;code&quot; :rules=&quot;[ &#123; required: true, message: &#x27;请输入验证码&#x27;, trigger: &#x27;blur&#x27; &#125;, ]&quot; &gt; &lt;div style=&quot;width: 100%; display: block; float: left; position: relative&quot; &gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;验证码&quot; v-model=&quot;params.code&quot; /&gt; &lt;i class=&quot;iconfont icon-phone&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;btn&quot; style=&quot;position: absolute; right: 0; top: 6px; width: 40%&quot; &gt; &lt;a href=&quot;javascript:&quot; type=&quot;button&quot; @click=&quot;getCodeFun()&quot; :value=&quot;codeTest&quot; style=&quot;border: none; background-color: none&quot; &gt;&#123;&#123; codeTest &#125;&#125;&lt;/a &gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;input-prepend&quot; prop=&quot;password&quot; :rules=&quot;[&#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;password&quot; placeholder=&quot;设置密码&quot; v-model=&quot;params.password&quot; /&gt; &lt;i class=&quot;iconfont icon-password&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;sign-up-button&quot; value=&quot;注册&quot; @click=&quot;submitRegister()&quot; /&gt; &lt;/div&gt; &lt;p class=&quot;sign-up-msg&quot;&gt; 点击 “注册” 即表示您同意并愿意遵守简书 &lt;br /&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://www.jianshu.com/p/c44d171298ce&quot; &gt;用户协议&lt;/a &gt; 和 &lt;a target=&quot;_blank&quot; href=&quot;http://www.jianshu.com/p/2ov8x3&quot;&gt;隐私政策&lt;/a&gt; 。 &lt;/p&gt; &lt;/el-form&gt; &lt;!-- 更多注册方式 --&gt; &lt;div class=&quot;more-sign&quot;&gt; &lt;h6&gt;社交帐号直接注册&lt;/h6&gt; &lt;ul&gt; &lt;li&gt; &lt;a id=&quot;weixin&quot; class=&quot;weixin&quot; target=&quot;_blank&quot; href=&quot;http://huaan.free.idcfengye.com/api/ucenter/wx/login&quot; &gt;&lt;i class=&quot;iconfont icon-weixin&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a id=&quot;qq&quot; class=&quot;qq&quot; target=&quot;_blank&quot; href=&quot;#&quot; &gt;&lt;i class=&quot;iconfont icon-qq&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#x27;~/assets/css/sign.css&#x27; import &#x27;~/assets/css/iconfont.css&#x27; export default &#123; layout: &#x27;sign&#x27;, data() &#123; return &#123; params: &#123; // 封装注册输入数据 mobile: &#x27;&#x27;, code: &#x27;&#x27;, // 验证码 nickname: &#x27;&#x27;, password: &#x27;&#x27; &#125;, sending: true, // 是否发送验证码 second: 60, // 倒计时间 codeTest: &#x27;获取验证码&#x27; &#125; &#125;, methods: &#123;&#125; &#125;&lt;/script&gt; vue方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 注册提交submitRegister() &#123; registerApi.register(this.params).then(result =&gt; &#123; // 提示注册成功 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;注册成功&#x27; &#125;) // 跳转登录页面 this.$router.push(&#123; path: &#x27;/login&#x27; &#125;) &#125;)&#125;,// 发送验证码getCodeFun() &#123; if ((this.sending = false)) &#123; this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;请勿频繁点击&#x27; &#125;) return &#125; // 由于阿里云短信服务不能用，所以这里写假验证 this.sending = false // 调用倒计时的方法 this.timeDown()&#125;,// 验证手机号格式checkPhone(rule, value, callback) &#123; // debugger if (!/^1[34578]\\d&#123;9&#125;$/.test(value)) &#123; return callback(new Error(&#x27;手机号码格式不正确&#x27;)) &#125; return callback()&#125;,// 倒计时timeDown() &#123; const result = setInterval(() =&gt; &#123; --this.second this.codeTest = this.second if (this.second &lt; 1) &#123; clearInterval(result) this.sending = true this.second = 60 this.codeTest = &#x27;获取验证码&#x27; &#125; &#125;, 1000)&#125; TODO：这里有很多地方需要完善：比如点击验证码之后再次点击数字需要弹窗警告，但是现在不会而且还会加速计时器 登录cookie插件 这里需要用到cookie，需要下载 npm install js-cookie api12345678910111213141516171819import request from &#x27;@/utils/request&#x27;export default &#123; // 登录 login(member) &#123; return request(&#123; url: &#x27;/educenter/member/login&#x27;, method: &#x27;post&#x27;, data: member &#125;) &#125;, // 根据token获取用户信息 getLoginMemberInfo() &#123; return request(&#123; url: &#x27;/educenter/member/getMemberInfo&#x27;, method: &#x27;get&#x27; &#125;) &#125;&#125; vue视图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;a class=&quot;active&quot; href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;span&gt;·&lt;/span&gt; &lt;a href=&quot;/register&quot;&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;sign-up-container&quot;&gt; &lt;el-form ref=&quot;userForm&quot; :model=&quot;user&quot;&gt; &lt;el-form-item class=&quot;input-prepend restyle&quot; prop=&quot;mobile&quot; :rules=&quot;[ &#123; required: true, message: &#x27;请输入手机号码&#x27;, trigger: &#x27;blur&#x27; &#125;, &#123; validator: checkPhone, trigger: &#x27;blur&#x27; &#125;, ]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;手机号&quot; v-model=&quot;user.mobile&quot; /&gt; &lt;i class=&quot;iconfont icon-phone&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;input-prepend&quot; prop=&quot;password&quot; :rules=&quot;[&#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;password&quot; placeholder=&quot;密码&quot; v-model=&quot;user.password&quot; /&gt; &lt;i class=&quot;iconfont icon-password&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;sign-in-button&quot; value=&quot;登录&quot; @click=&quot;submitLogin()&quot; /&gt; &lt;/div&gt; &lt;/el-form&gt; &lt;!-- 更多登录方式 --&gt; &lt;div class=&quot;more-sign&quot;&gt; &lt;h6&gt;社交帐号登录&lt;/h6&gt; &lt;ul&gt; &lt;li&gt; &lt;a id=&quot;weixin&quot; class=&quot;weixin&quot; target=&quot;_blank&quot; href=&quot;http://qy.free.idcfengye.com/api/ucenter/weixinLogin/login&quot; &gt;&lt;i class=&quot;iconfont icon-weixin&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a id=&quot;qq&quot; class=&quot;qq&quot; target=&quot;_blank&quot; href=&quot;#&quot; &gt;&lt;i class=&quot;iconfont icon-qq&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#x27;~/assets/css/sign.css&#x27; import &#x27;~/assets/css/iconfont.css&#x27; export default &#123; layout: &#x27;sign&#x27;, data() &#123; return &#123; user: &#123; mobile: &#x27;&#x27;, password: &#x27;&#x27; &#125;, loginInfo: &#123;&#125; &#125; &#125;, methods: &#123;&#125; &#125;&lt;/script&gt;&lt;style&gt; .el-form-item__error &#123; z-index: 9999999; &#125;&lt;/style&gt; 拦截器 在下面的方法中有说明登录token的步骤，其中需要用到拦截器 拦截器写在utils文件夹下的request.js文件中 123456789101112131415import cookie from &#x27;js-cookie&#x27;// 每次请求中使用拦截器service.interceptors.request.use( config =&gt; &#123; if (cookie.get(&#x27;guli_token&#x27;)) &#123; // 从cookie中获得token并且放入header中 config.headers[&#x27;token&#x27;] = cookie.get(&#x27;guli_token&#x27;); &#125; return config &#125;, err =&gt; &#123; return Promise.reject(err) &#125;) vue方法 调用接口登录获取token 将token放入cookie 前端拦截器：判断cookie里是否有token，如果有则放到header中 根据header中的token调用接口获取用户信息 把获取的用户信息放入cookie login.vue中 注意这里把对象放入cookie中是要使用JSON.stringify转换为字符串才行，要不然就是object，回报错（cookie获得的json对象为undefined） 12345678910111213141516171819202122232425262728// 登录的方法submitLogin() &#123; // 1、调用接口进行登录，返回token字符串 loginApi.login(this.user).then(result =&gt; &#123; // 2、获得token,并放入cookie // 第一个参数cookie名称，第二个参数值，第三个参数作用范围 cookieApi.set(&#x27;guli_token&#x27;, result.data.data.token, &#123; domain: &#x27;localhost&#x27; &#125;) // 4、调用接口获取header中的token loginApi.getLoginMemberInfo().then(result =&gt; &#123; // 5、根据token获取用户信息放入cookie中 console.log(response.data.data.member) cookieApi.set(&#x27;guli_ucenter&#x27;, JSON.stringify(result.data.data.member), &#123; domain: &#x27;localhost&#x27; &#125;) &#125;) // 跳转页面 this.$router.push(&#123; path: &#x27;/&#x27; &#125;) &#125;)&#125;,// 验证手机号格式checkPhone(rule, value, callback) &#123; if (!/^1[34578]\\d&#123;9&#125;$/.test(value)) &#123; return callback(new Error(&#x27;手机号码格式不正确&#x27;)) &#125; return callback()&#125; default.vue中编写根据token获得用户信息 123456789101112131415161718192021222324252627created() &#123; this.showInfo() &#125;, methods: &#123; // 从cookie中获取用户信息 showInfo() &#123; // 注意这里需要转换 console.log(&#x27;从cookie中获得用户信息：&#x27; + cookieApi.get(&#x27;guli_ucenter&#x27;)) var loginInfoStr = cookieApi.get(&#x27;guli_ucenter&#x27;) console.log(cookieApi.get(&#x27;guli_ucenter&#x27;)) // 把字符串转换为JSON格式 if (loginInfoStr) &#123; this.loginInfo = JSON.parse(loginInfoStr) &#125; &#125;, // 退出登录 logout() &#123; // 清除cookie cookieApi.set(&#x27;guli_token&#x27;, &#x27;&#x27;, &#123; domain: &#x27;localhost&#x27; &#125;) cookieApi.set(&#x27;guli_ucenter&#x27;, &#x27;&#x27;, &#123; domain: &#x27;localhost&#x27; &#125;) // 清除数据 this.token = &#x27;&#x27; this.loginInfo = &#123;&#125; // 跳转至首页 this.$router.push(&#123; path: &#x27;/&#x27; &#125;) &#125; &#125; TODO：这里需要完善的地方有很多，登录校验（JWT strings must contain exactly 2 period characters. Found: 0）如果输入错误页面竟然显示cookie undefined，而且重新登录也不行，还有前端的信息提示 微信扫码登录（后端+前端）OAuth2 一种方案，解决两个问题： 开放系统间授权 分布式访问问题 ![03 OAuth2介绍](https://gitee.com/ReRia/images/raw/master/img/03 OAuth2介绍.png) 微信登录准备工作 没事了要付钱，鹅肠真有你的 没事了老师共享账号，好耶！ 配置文件 service_ucenter模块的配置文件即可（只用于登录注册） 123456# 微信开放平台 appidwx.open.app_id=wxed9954c01bb89b47# 微信开放平台 appsecretwx.open.app_secret=a7482517235173ddb4083788de60b90e# 微信开放平台 重定向urlwx.open.redirect_url=http://localhost:8160/api/ucenter/wx/callback 常量类12345678910111213141516171819202122package com.atguigu.educenter.utils;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class ConstantWxUtils implements InitializingBean &#123; @Value(&quot;$&#123;wx.open.app_id&#125;&quot;) private String appId; @Value(&quot;$&#123;wx.open.app_secret&#125;&quot;) private String appSecret; @Value(&quot;$&#123;wx.open.redirect_url&#125;&quot;) private String redirectUrl; public static String WX_OPEN_APP_ID; public static String WX_OPEN_APP_SECRET; public static String WX_OPEN_REDIRECT_URL; @Override public void afterPropertiesSet() throws Exception &#123; WX_OPEN_APP_ID = appId; WX_OPEN_APP_SECRET = appSecret; WX_OPEN_REDIRECT_URL = redirectUrl; &#125;&#125; 生成二维码controller1234567891011121314151617181920212223@Controller@CrossOrigin@RequestMapping(&quot;/api/ucenter/wx&quot;)public class WxApiController &#123; // 生成扫描二维码 @GetMapping(&quot;login&quot;) public String getWxCode() throws UnsupportedEncodingException &#123; // 参数位置都是用%s来代替，然后使用String.format String baseUrl = &quot;https://open.weixin.qq.com/connect/qrconnect&quot; + &quot;?appid=%s&quot; + &quot;&amp;redirect_uri=%s&quot; + &quot;&amp;response_type=code&quot; + &quot;&amp;scope=snsapi_login&quot; + &quot;&amp;state=%s&quot; + &quot;#wechat_redirect&quot;; // 需要进行url编码 String redirectUrl = URLEncoder.encode(ConstantWxUtils.WX_OPEN_REDIRECT_URL, &quot;UTF-8&quot;); // 传入url中的参数获得最终的url String url = String.format(baseUrl, ConstantWxUtils.WX_OPEN_APP_ID, redirectUrl, &quot;atguigu&quot;); // 重定向到微信地址 return &quot;redirect:&quot; + url; &#125;&#125; 注意这里需要修改端口号，因为用的是老师的url，所以要对应，nginx里也要改 这里我明白了一点nginx的作用，前端只需要访问nginx提供的9001端口号，而9001能够转发到8001等其他端口号，所以后端端口号改了只要该nginx就行，神奇！ 获取扫描人信息依赖1234567891011121314151617 &lt;dependencies&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; HttpClientUtils 太长不复制了 controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Autowiredprivate UcenterMemberService memberService;// 获取扫描人的信息，添加数据@GetMapping(&quot;callback&quot;)public String callback(String code, String status) throws Exception &#123; // 1、获取code，类似于验证码 // 2、请求微信api得到access_token和openid String baseAccessTokenUrl = &quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot; + &quot;?appid=%s&quot; + &quot;&amp;secret=%s&quot; + &quot;&amp;code=%s&quot; + &quot;&amp;grant_type=authorization_code&quot;; // 拼接参数，发送请求 String accessTokenUrl = String.format(baseAccessTokenUrl, ConstantWxUtils.WX_OPEN_APP_ID, ConstantWxUtils.WX_OPEN_APP_SECRET, code); String accessTokenInfo = HttpClientUtils.get(accessTokenUrl); // 转换json-&gt;map集合,获取其中的两个参数,使用json转换工具 Gson Gson gson = new Gson(); HashMap accessTokenMap = gson.fromJson(accessTokenInfo, HashMap.class); String access_token = (String) accessTokenMap.get(&quot;access_token&quot;); String openid = (String) accessTokenMap.get(&quot;openid&quot;); // 把扫描人信息添加数据库里面 // 判断数据表里面是否存在相同微信信息，根据openid判断 UcenterMember member = memberService.getOpenIdMember(openid); if (member == null) &#123; // 3、拿着得到accsess_token 和 openid，再去请求微信提供固定的地址，获取到扫描人信息 // 访问微信的资源服务器，获取用户信息 String baseUserInfoUrl = &quot;https://api.weixin.qq.com/sns/userinfo&quot; + &quot;?access_token=%s&quot; + &quot;&amp;openid=%s&quot;; // 拼接参数，发送请求 String userInfoUrl = String.format(baseUserInfoUrl, access_token, openid); String userInfo = HttpClientUtils.get(userInfoUrl); //转换并获取返回userinfo字符串扫描人信息 HashMap userInfoMap = gson.fromJson(userInfo, HashMap.class); String nickname = (String) userInfoMap.get(&quot;nickname&quot;);//昵称 String headimgurl = (String) userInfoMap.get(&quot;headimgurl&quot;);//头像 // 创建扫描member对象 member = new UcenterMember(); member.setOpenid(openid); member.setNickname(nickname); member.setAvatar(headimgurl); memberService.save(member); &#125; // 4、使用jwt根据member对象生成token字符串 String jwtToken = JwtUtils.getJwtToken(member.getId(), member.getNickname()); // 5、最后：返回首页面，通过路径传递token字符串 return &quot;redirect:http://localhost:3000?token=&quot; + jwtToken;&#125; service12345678// 根据openid查询@Overridepublic UcenterMember getOpenIdMember(String openid) &#123; QueryWrapper&lt;UcenterMember&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;openid&quot;, openid); UcenterMember member = baseMapper.selectOne(wrapper); return member;&#125; 前端 取地址栏中的带名称的参数值（而不是xx/xx/xx这种使用this.$route.params.xx）使用this.$route.query.xxx 1234567891011121314151617181920212223242526272829303132created() &#123; // 获取url中的token this.token = this.$route.query.token if (this.token) &#123; this.wxLogin() &#125; this.showInfo()&#125;,methods: &#123; // 微信登录后显示用户信息 wxLogin() &#123; // 把token放入cookie cookieApi.set(&#x27;guli_token&#x27;, this.token, &#123; domain: &#x27;localhost&#x27; &#125;) // 调用接口获取header中的token loginApi.getLoginMemberInfo().then(result =&gt; &#123; // 5、根据token获取用户信息放入cookie中 cookieApi.set(&#x27;guli_ucenter&#x27;, JSON.stringify(result.data.data.member), &#123; domain: &#x27;localhost&#x27; &#125;) &#125;) // 跳转页面 this.$router.push(&#123; path: &#x27;/&#x27; &#125;) &#125;, // 从cookie中获取用户信息 showInfo() &#123; var loginInfoStr = cookieApi.get(&#x27;guli_ucenter&#x27;) // 把字符串转换为JSON格式 if (loginInfoStr) &#123; this.loginInfo = JSON.parse(loginInfoStr) &#125; &#125;&#125; 注意把进入微信扫码的href改为http://localhost:8160/api/ucenter/wx/login即可","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战4","slug":"【项目笔记】在线教育项目实战4","date":"2021-09-25T05:55:19.301Z","updated":"2021-10-05T07:31:31.097Z","comments":true,"path":"2021/09/25/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-4/","link":"","permalink":"http://example.com/2021/09/25/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-4/","excerpt":"","text":"多表连接查询 方式如下 内连接 左外连接 右外连接 课程全部信息查询（后端）创建值封装对象类1234567891011@Datapublic class CoursePublishVo &#123; private String id; private String title; private String cover; private Integer lessonNum; private String subjectLevelOne; private String subjectLevelTwo; private String teacherName; private String price;//只用于显示&#125; 编写对应mapper接口123public interface EduCourseMapper extends BaseMapper&lt;EduCourse&gt; &#123; CoursePublishVo getCoursePublishInfo(String courseId);&#125; 编写对应mapper中sql语句 先查询完了之后再贴上来，出错率很高 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.eduservice.mapper.EduCourseMapper&quot;&gt; &lt;select id=&quot;getCoursePublishInfo&quot; resultType=&quot;com.atguigu.eduservice.entity.vo.CoursePublishVo&quot;&gt; select ec.id, ec.title, ec.price, ec.lesson_num AS lessonNum, ec.cover, et.name AS teacherName, es1.title AS subjectLevelOne, es2.title AS subjectLevelTwo from edu_course ec left join edu_course_description ecd on ec.id = ecd.id left join edu_teacher et on ec.teacher_id = et.id left join edu_subject es1 on ec.subject_parent_id = es1.id left join edu_subject es2 on ec.subject_id = es2.id where ec.id = #&#123;courseId&#125; &lt;/select&gt;&lt;/mapper&gt; 编写controller123456// 根据id查询课程全部信息@PostMapping(&quot;getCoursePublishInfo/&#123;courseId&#125;&quot;)public R getCoursePublishInfo(@PathVariable String courseId) &#123; CoursePublishVo coursePublishInfo = courseService.getCoursePublishInfo(courseId); return R.ok().data(&quot;coursePublishInfo&quot;, coursePublishInfo);&#125; 编写service 同理，直接快捷键就行 12345// 根据id查询课程全部信息@Overridepublic CoursePublishVo getCoursePublishInfo(String courseId) &#123; return baseMapper.getCoursePublishInfo(courseId);&#125; 调试 Invalid bound statement (not found): com.atguigu.eduservice.mapper.EduCourseMapper.getCoursePublishInfo 报错如上，解决如下（详见p130） mapper有没有写错 在target文件夹中xml配置文件有没有被引入 可以把mapper.xml放在resource下 配置pom.xml和application.properties（子模块的pom.xml） 1mybatis-plus.mapper-locations=classpath:com/atguigu/eduservice/mapper/xml/*.xml 123456789101112&lt;!-- 解决maven没有导入xml文件 --&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 课程全部信息查询（前端）api1234567// 课程全部信息 getCoursePublishInfo(courseId) &#123; return request(&#123; url: `/eduservice/course/getCoursePublishInfo/` + courseId, method: &#x27;get&#x27;, &#125;) &#125; vue模板和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;发布新课程&lt;/h2&gt; &lt;el-steps :active=&quot;3&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px&quot; &gt; &lt;el-step title=&quot;填写课程基本信息&quot; /&gt; &lt;el-step title=&quot;创建课程大纲&quot; /&gt; &lt;el-step title=&quot;最终发布&quot; /&gt; &lt;/el-steps&gt; &lt;div class=&quot;ccInfo&quot;&gt; &lt;img :src=&quot;coursePublishInfo.cover&quot; /&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2&gt;&#123;&#123; coursePublishInfo.title &#125;&#125;&lt;/h2&gt; &lt;p class=&quot;gray&quot;&gt; &lt;span&gt;共&#123;&#123; coursePublishInfo.lessonNum &#125;&#125;课时&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span &gt;所属分类：&#123;&#123; coursePublishInfo.subjectLevelOne &#125;&#125; — &#123;&#123; coursePublishInfo.subjectLevelTwo &#125;&#125;&lt;/span &gt; &lt;/p&gt; &lt;p&gt;课程讲师：&#123;&#123; coursePublishInfo.teacherName &#125;&#125;&lt;/p&gt; &lt;h3 class=&quot;red&quot;&gt;￥&#123;&#123; coursePublishInfo.price &#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;el-button @click=&quot;previous&quot;&gt;返回修改&lt;/el-button&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;publish&quot; &gt;发布课程&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import courseApi from &#x27;@/api/edu/course.js&#x27; export default &#123; data() &#123; return &#123; saveBtnDisabled: false, // 保存按钮是否禁用 courseId: &#x27;&#x27;, // 课程id coursePublishInfo: &#123;&#125; &#125; &#125;, created() &#123; // 获取到路由中的id值 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.courseId = this.$route.params.id this.getCoursePublishInfo(this.courseId) &#125; console.log(this.coursePublishInfo) &#125;, methods: &#123; getCoursePublishInfo(id) &#123; // 调用api courseApi.getCoursePublishInfo(id).then(result =&gt; &#123; console.log this.coursePublishInfo = result.data.coursePublishInfo &#125;) &#125;, previous() &#123; console.log(&#x27;previous&#x27;) this.$router.push(&#123; path: &#x27;/course/chapter/&#x27; + this.courseId &#125;) &#125;, publish() &#123; console.log(&#x27;publish&#x27;) this.$router.push(&#123; path: &#x27;/course/list&#x27; &#125;) &#125; &#125; &#125;&lt;/script&gt; 课程发布（后端+前端）后端 发布就是修改表中一个字段值就行 12345678// 发布课程（修改status字段值）@PostMapping(&quot;publishCourse/&#123;courseId&#125;&quot;)public R publishCourse(@PathVariable String courseId) &#123; EduCourse eduCourse = courseService.getById(courseId); eduCourse.setStatus(&quot;Normal&quot;); courseService.updateById(eduCourse); return R.ok();&#125; 前端 api 1234567 // 发布课程publishCourse(courseId) &#123; return request(&#123; url: `/eduservice/course/publishCourse/` + courseId, method: &#x27;post&#x27;, &#125;)&#125; method 12345 publish() &#123; courseApi.publishCourse(this.courseId).then(result =&gt; &#123; this.$router.push(&#123; path: &#x27;/course/list&#x27; &#125;) &#125;)&#125; 课程列表（后端+前端）后端（待完善）123456// TODO 完善条件查询带分页@GetMapping(&quot;getCourseList&quot;)public R getCourseList() &#123; List&lt;EduCourse&gt; list = courseService.list(null); return R.ok().data(&quot;courseList&quot;, list);&#125; 前端api1234567// 获得课程列表 getCourseList() &#123; return request(&#123; url: `/eduservice/course/getCourseList`, method: &#x27;get&#x27;, &#125;) &#125; vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; 课程列表 &lt;!--查询表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;courseQuery.title&quot; placeholder=&quot;课程名称&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-select v-model=&quot;courseQuery.status&quot; clearable placeholder=&quot;课程状态&quot; &gt; &lt;el-option value=&quot;Normal&quot; label=&quot;已发布&quot; /&gt; &lt;el-option value=&quot;Draft&quot; label=&quot;未发布&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;getList()&quot; &gt;查询&lt;/el-button &gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt; &lt;/el-form&gt; &lt;!-- 表格 --&gt; &lt;el-table :data=&quot;list&quot; border fit highlight-current-row&gt; &lt;el-table-column label=&quot;序号&quot; width=&quot;70&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;title&quot; label=&quot;课程名称&quot; width=&quot;80&quot; /&gt; &lt;el-table-column label=&quot;课程状态&quot; width=&quot;80&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.status === &quot;Normal&quot; ? &quot;已发布&quot; : &quot;未发布&quot; &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;lessonNum&quot; label=&quot;课时数&quot; /&gt; &lt;el-table-column prop=&quot;gmtCreate&quot; label=&quot;添加时间&quot; width=&quot;160&quot; /&gt; &lt;el-table-column prop=&quot;viewCount&quot; label=&quot;浏览数量&quot; width=&quot;60&quot; /&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;编辑课程基本信息&lt;/el-button &gt; &lt;/router-link&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;编辑课程大纲息&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除课程信息&lt;/el-button &gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页 --&gt; &lt;el-pagination :current-page=&quot;page&quot; :page-size=&quot;limit&quot; :total=&quot;total&quot; style=&quot;padding: 30px 0; text-align: center&quot; layout=&quot;total, prev, pager, next, jumper&quot; @current-change=&quot;getList&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用teacher.js文件 import courseApi from &#x27;@/api/edu/course&#x27; export default &#123; data() &#123; return &#123; list: null, // 查询之后接口返回集合(注意这里是数组用null) page: 1, // 当前页 limit: 10, // 每页记录数 total: 0, // 总记录数 courseQuery: &#123;&#125; // 条件封装对象 &#125; &#125;, created() &#123; // 页面渲染之前执行，一般调用methods定义的方法 // 调用 this.getList() &#125;, methods: &#123; getList() &#123; courseApi.getCourseList().then(response =&gt; &#123; // 请求成功 // response接口返回的数据 this.list = response.data.courseList &#125;) &#125;, resetData() &#123; // 表单输入项数据清空 this.courseQuery = &#123;&#125; this.getList() &#125; &#125; &#125;&lt;/script&gt; 课程删除（后端+前端） 删除课程：所有章节也会被删除 后端controller123456// 删除课程@DeleteMapping(&quot;&#123;courseId&#125;&quot;)public R deleteCourse(@PathVariable String courseId) &#123; courseService.deleteCourse(courseId); return R.ok();&#125; service123456789101112131415// 根据课程id删除课程及其描述和章节@Overridepublic void deleteCourse(String courseId) &#123; // 1、删除小节 videoService.removeByCourseId(courseId); // 2、删除章节 chapterService.removeByCourseId(courseId); // 3、删除描述 descriptionService.removeById(courseId); // 4、删除课程 int row = baseMapper.deleteById(courseId); if (row == 0) &#123; throw new GuliException(20001, &quot;删除课程失败&quot;); &#125;&#125; 1234567// 根据课程id删除章节@Overridepublic void removeByCourseId(String courseId) &#123; QueryWrapper&lt;EduChapter&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;course_id&quot;, courseId); baseMapper.delete(queryWrapper);&#125; 前端api1234567// 删除课程 deleteCourse(courseId) &#123; return request(&#123; url: `/eduservice/course/` + courseId, method: &#x27;delete&#x27;, &#125;) &#125;, vue123456789101112131415161718192021// 删除课程deleteCourse(courseId) &#123; courseApi .deleteCourse(courseId) .then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新页面 this.getList() &#125;) .catch(err =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;删除失败!&#x27; &#125;) &#125;)&#125; 阿里云视频点播 视频点播_音视频点播解决方案_视频转码_媒体资源管理系统-阿里云 (aliyun.com) 视频点播 (aliyun.com) 环境搭建 依赖见官网（项目环境搭建的时候已经引入了） 创建模块 子子模块service_vod 引入依赖 注意这个aliyun-java-vod-upload.version依赖未开源，需要手动下载jar包，然后使用命令行安装 mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-java-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.14.jar 注意这里的版本要和下载的jar包对应，还有包名aliyun-java-vod-upload 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 阿里云视频点播所需依赖 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 测试根据视频id获取视频播放地址123456789101112131415161718192021222324public class TestVod &#123; public static void main(String[] args) throws ClientException &#123; // 1、根据视频id获取视频播放地址 // 创建初始化对象(传入oss的id和秘钥) DefaultAcsClient client = InitObject.initVodClient(&quot;&quot;, &quot;&quot;); // 创建获取视频地址的request GetPlayInfoRequest request = new GetPlayInfoRequest(); // 向request中设置id request.setVideoId(&quot;&quot;); // 调用初始化对象的方法，传递request，获取response GetPlayInfoResponse acsResponse = client.getAcsResponse(request); // 获取response中的信息 List&lt;GetPlayInfoResponse.PlayInfo&gt; playInfoList = acsResponse.getPlayInfoList(); //播放地址 for (GetPlayInfoResponse.PlayInfo playInfo : playInfoList) &#123; System.out.print(&quot;PlayInfo.PlayURL = &quot; + playInfo.getPlayURL() + &quot;\\n&quot;); &#125; //Base信息 System.out.print(&quot;VideoBase.Title = &quot; + acsResponse.getVideoBase().getTitle() + &quot;\\n&quot;); System.out.println(acsResponse); &#125;&#125; 根据视频id获取视频播放凭证123456789101112public static void main(String[] args) throws ClientException &#123; // 根据视频id获得视频凭证 // 创建初始化对象(传入oss的id和秘钥) DefaultAcsClient client = InitObject.initVodClient(&quot;&quot;, &quot;&quot;); // 创建获取视频地址的request GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); // 向request中设置id request.setVideoId(&quot;&quot;); // 调用初始化对象的方法，传递request，获取response GetVideoPlayAuthResponse acsResponse = client.getAcsResponse(request); System.out.println(&quot;视频凭证: &quot; + acsResponse.getPlayAuth());&#125; 上传视频 这里注意，如果使用upload的版本为1.4.14，那么根据官方文档说明，oss-sdk的版本必须为3.9及以上，否则会显示一直上传中 12345678910111213141516171819202122232425public static void main(String[] args) throws ClientException &#123; String accessKeyId = &quot;&quot;; String accessKeySecret = &quot;&quot;; String title = &quot;6 - What If I Want to Move Faster - upload by sdk&quot;; //上传之后文件名称 String fileName = &quot;D:/MyProject/6 - What If I Want to Move Faster.mp4&quot;; //本地文件路径和名称 //上传视频的方法 UploadVideoRequest request = new UploadVideoRequest(accessKeyId, accessKeySecret, title, fileName); /* 可指定分片上传时每个分片的大小，默认为2M字节 */ request.setPartSize(2 * 1024 * 1024L); /* 可指定分片上传时的并发线程数，默认为1，(注：该配置会占用服务器CPU资源，需根据服务器情况指定）*/ request.setTaskNum(1); UploadVideoImpl uploader = new UploadVideoImpl(); UploadVideoResponse response = uploader.uploadVideo(request); if (response.isSuccess()) &#123; System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\\n&quot;); &#125; else &#123; /* 如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 */ System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\\n&quot;); System.out.print(&quot;ErrorCode=&quot; + response.getCode() + &quot;\\n&quot;); System.out.print(&quot;ErrorMessage=&quot; + response.getMessage() + &quot;\\n&quot;); &#125;&#125; 课程增加、删除小节（视频）功能（完善）后端配置文件application.properties1234567891011121314# 服务端口server.port=8003# 服务名spring.application.name=service-vod# 环境设置：dev、test、prodspring.profiles.active=dev#阿里云 vod#不同的服务器，地址不同aliyun.vod.file.keyid=aliyun.vod.file.keysecret=# 最大上传单个文件大小：默认1Mspring.servlet.multipart.max-file-size=1024MB# 最大置总上传的数据大小 ：默认10Mspring.servlet.multipart.max-request-size=1024MB 编写常量类1234567891011121314151617181920// 类存储配置文件中的数据以便调用@Componentpublic class ConstantVodUtils implements InitializingBean &#123; @Value(&quot;$&#123;aliyun.vod.file.keyid&#125;&quot;) private String keyid; @Value(&quot;$&#123;aliyun.vod.file.keysecret&#125;&quot;) private String keysecret; public static String ACCESS_KEY_SECRET; public static String ACCESS_KEY_ID; @Override public void afterPropertiesSet() throws Exception &#123; ACCESS_KEY_ID = keyid; ACCESS_KEY_SECRET = keysecret; &#125; &#125; 编写初始化VodClient1234567891011@Componentpublic class InitVodClient &#123; public static DefaultAcsClient initVodClient(String accessKeyId, String accessKeySecret) throws ClientException &#123; String regionId = &quot;cn-shanghai&quot;; // 点播服务接入区域 DefaultProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret); DefaultAcsClient client = new DefaultAcsClient(profile); return client; &#125;&#125; 创建启动类1234567@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) // 不需要引入数据库的配置@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class VodApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(VodApplication.class, args); &#125;&#125; 编写controller123456789101112131415161718192021@RestController@RequestMapping(&quot;/eduvod/video&quot;)@CrossOriginpublic class VodController &#123; @Autowired private VodService vodService; // 上传视频至阿里云 @PostMapping(&quot;uploadVideo&quot;) public R uploadVideo(MultipartFile file) &#123; String videoId = vodService.uploadVideo(file); return R.ok(); &#125; // 根据id删除视频 @DeleteMapping(&quot;removeVideo/&#123;videoId&#125;&quot;) public R removeVideo(@PathVariable String videoId) &#123; vodService.removeVideo(videoId); return R.ok(); &#125;&#125; 编写service1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Servicepublic class VodServiceImpl implements VodService &#123; // 上传视频至阿里云 @Override public String uploadVideo(MultipartFile file) &#123; try &#123; //fileName：上传文件原始名称 String fileName = file.getOriginalFilename(); //title：上传之后显示名称 String title = fileName.substring(0, fileName.lastIndexOf(&quot;.&quot;)); //inputStream：上传文件输入流 InputStream inputStream = file.getInputStream(); //accessKeyId, accessKeySecret UploadStreamRequest request = new UploadStreamRequest(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET, title, fileName, inputStream); UploadVideoImpl uploader = new UploadVideoImpl(); UploadStreamResponse response = uploader.uploadStream(request); String videoId = null; if (response.isSuccess()) &#123; videoId = response.getVideoId(); &#125; else &#123; //如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\\n&quot;); System.out.print(&quot;ErrorCode=&quot; + response.getCode() + &quot;\\n&quot;); System.out.print(&quot;ErrorMessage=&quot; + response.getMessage() + &quot;\\n&quot;); &#125; return videoId; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; // 根据id删除视频 @Override public void removeVideo(String videoId) &#123; try &#123; // 初始化对象 DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET); // 创建删除video的request对象,并设置id DeleteVideoRequest request = new DeleteVideoRequest(); request.setVideoIds(videoId); // 调用初始化对象方法 DeleteVideoResponse acsResponse = client.getAcsResponse(request); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new GuliException(20001, &quot;删除视频失败&quot;); &#125; &#125;&#125; 前端api1234567// 删除小节视频 deleteVideoAli(videoId) &#123; return request(&#123; url: `/eduvod/video/removeVideo/` + videoId, method: &#x27;delete&#x27;, &#125;) &#125; vue模板12345678910111213141516171819&lt;el-upload :on-success=&quot;handleVodUploadSuccess&quot; :on-remove=&quot;handleVodRemove&quot; :before-remove=&quot;beforeVodRemove&quot; :on-exceed=&quot;handleUploadExceed&quot; :file-list=&quot;fileList&quot; :action=&quot;BASE_API+&#x27;/eduvod/video/uploadVideo&#x27;&quot; :limit=&quot;1&quot; class=&quot;upload-demo&quot;&gt;&lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;上传视频&lt;/el-button&gt;&lt;el-tooltip placement=&quot;right-end&quot;&gt; &lt;div slot=&quot;content&quot;&gt;最大支持1G，&lt;br&gt; 支持3GP、ASF、AVI、DAT、DV、FLV、F4V、&lt;br&gt; GIF、M2T、M4V、MJ2、MJPEG、MKV、MOV、MP4、&lt;br&gt; MPE、MPG、MPEG、MTS、OGG、QT、RM、RMVB、&lt;br&gt; SWF、TS、VOB、WMV、WEBM 等视频格式上传&lt;/div&gt; &lt;i class=&quot;el-icon-question&quot;/&gt;&lt;/el-tooltip&gt;&lt;/el-upload&gt; 调用方法1234567891011121314151617181920212223242526// 删除之前beforeVodRemove(file, fileList) &#123; return this.$confirm(`确定移除$&#123;file.name&#125;?`)&#125;,// 删除上传视频handleVodRemove() &#123; // 调用接口 videoApi.deleteVideoAli(this.video.videoSourceId).then(result =&gt; &#123; // 提示 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新fileList 和 resourceId this.fileList = [] this.video.videoSourceId = &#x27;&#x27; &#125;)&#125;,// 上传vod成功handleVodUploadSuccess(response, file, fileList) &#123; this.video.videoSourceId = response.data.videoId&#125;,// 重新上传提示handleUploadExceed() &#123; this.$message.warning(&#x27;想要重新上传视频，请先删除已上传的视频&#x27;)&#125;, 测试 注意这里，要修改nginx的上传文件大小 12345http &#123; include mime.types; default_type application/octet-stream; client_max_body_size 1024m;&#125; 由于controller中返回data只有videoId，所以从后端拿不到原始文件吗，所以从前端赋值即可 删除视频后要清空sourceId，要不然不上传视频也有id存留 springcloud微服务（删除小节功能完善）springcloud 服务集合，TODO springcloud调用接口过程 Nacos服务注册 注册中心 home (nacos.io) 启动 下载并解压，然后启动startup.cmd即可，可能会启动失败，需要修改MODE为standalone Nacos 启动失败_RookieMZL 的博客-CSDN博客_nacos启动失败 依赖 先引入依赖 12345&lt;!--服务注册--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 配置 在要注册的服务的配置文件application.properties中配置 12# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 注解 在启动类上添加注解 123456@EnableDiscoveryClient // nacos注册public class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 测试 致命bug，springboot的版本要2.2.x才行，要不然application启动不起来 http://localhost:8848/nacos Feign服务调用 前提条件：将互相调用的服务在nacos注册完毕 依赖12345&lt;!--服务调用--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 添加注解 在需要调用服务的启动类上添加注解如下 123456789@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@EnableDiscoveryClient // nacos注册@EnableFeignClients // 使用Feignpublic class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 创建接口 在调用端创建接口，使用注解指定需要调用哪一个服务，并定义调用的方法和路径 注意结构（service_edu要调用service_vod的功能） @ Feignclient注解用于指定从哪个服务中调用功能,名称与被调用的服务名保持致。@ GetMapping注解用于对被调用的微服务进行地址映射@ PathVariable注解定要指定参数名称,否则出错@ Component注解防止,在其他位置注入 Codclient时idea报错 12345678@FeignClient(&quot;service-vod&quot;) // 调用服务（服务名），这里的服务名要和对应服务的配置文件中的spring.application.name对应@Componentpublic interface VodClient &#123; // 定义要调用的方法的路径（注意要完全路径） // 根据id删除视频 @DeleteMapping(&quot;/eduvod/video/removeVideo/&#123;videoId&#125;&quot;) public R removeVideo(@PathVariable(&quot;videoId&quot;) String videoId);&#125; 注意这里的@FeignClient(“service-vod”)，服务名不能使用下划线 实现调用（删除小节） 注入接口，调用接口方法即可 123456789101112131415161718@RestController@RequestMapping(&quot;/eduservice/video&quot;)@CrossOrigin // 跨域public class EduVideoController &#123; @Autowired private VodClient vodClient; // 注入接口调用其他服务 // TODO 删除小节 @DeleteMapping(&quot;&#123;videoId&#125;&quot;) public R deleteVideo(@PathVariable(&quot;videoId&quot;) String videoId) &#123; // 实现调用删除阿里云视频，这里需要的是sourceID EduVideo eduVideo = videoService.getById(videoId); String videoSourceId = eduVideo.getVideoSourceId(); vodClient.removeVideo(videoSourceId); // 删除数据库视频 videoService.removeById(videoId); return R.ok(); &#125;&#125; 如果不成功rerun一下就行了 Hystrix熔断器 提供延迟与容错功能 添加依赖1234567891011&lt;!-- ribbn负载均衡 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--hystrix依赖，主要是用 @HystrixCommand --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 调用端配置 注意是在调用端，开启熔断器配置，也可使设置超时时间 12# hytrix开启熔断机制feign.hystrix.enabled=true 创建接口对应实现类 编写出错时的输出信息，实现FeignClient接口 123456789101112@Componentpublic class VodFileDegradeFeignClient implements VodClient &#123; @Override public R removeVideo(String videoId) &#123; return R.error().message(&quot;出错了&quot;); &#125; @Override public R deleteVideoBatch(List&lt;String&gt; videoIdList) &#123; return R.error().message(&quot;出错了&quot;); &#125;&#125; 接口添加属性 feignClient添加注解和属性 123456// fallback = &quot;实现类的class&quot;，熔断器@FeignClient(name = &quot;service-vod&quot;, fallback = VodFileDegradeFeignClient.class)// 调用服务（服务名），这里的服务名要和对应服务的配置文件中的spring.application.name对应@Componentpublic interface VodClient &#123;&#125; 删除课程（功能完善） 删除视频，删除视频下的章节和小节 后端 video中的删除小节功能需要调用vod中的删除 VodController123456// 删除多个阿里云视频@DeleteMapping(&quot;deleteVideoBatch&quot;)public R deleteVideoBatch(@RequestParam(&quot;videoIdList&quot;) List&lt;String&gt; videoIdList) &#123; vodService.removeBatch(videoIdList); return R.ok();&#125; VodService1234567891011121314151617181920// 删除多个阿里云视频@Overridepublic void removeVideoBatch(List&lt;String&gt; videoIdList) &#123; try &#123; // 初始化对象 DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET); // 创建删除video的request对象,并设置id DeleteVideoRequest request = new DeleteVideoRequest(); // 将list转化成1,2,3的格式 String list = StringUtils.join(videoIdList.toArray(), &quot;,&quot;); request.setVideoIds(list); // 调用初始化对象方法 DeleteVideoResponse acsResponse = client.getAcsResponse(request); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new GuliException(20001, &quot;删除视频失败&quot;); &#125;&#125; Feign调用接口 这是service_edu中的 123456789101112@FeignClient(&quot;service-vod&quot;) // 调用服务（服务名），这里的服务名要和对应服务的配置文件中的spring.application.name对应@Componentpublic interface VodClient &#123; // 定义要调用的方法的路径（注意要完全路径） // 根据id删除视频 @DeleteMapping(&quot;/eduvod/video/removeVideo/&#123;videoId&#125;&quot;) public R removeVideo(@PathVariable(&quot;videoId&quot;) String videoId); // 删除多个阿里云视频 @DeleteMapping(&quot;/eduvod/video/deleteVideoBatch&quot;) public R deleteVideoBatch(@RequestParam(&quot;videoIdList&quot;) List&lt;String&gt; videoIdList);&#125; videoMapper123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.eduservice.mapper.EduVideoMapper&quot;&gt; &lt;select id=&quot;getVideoIdListByCourse&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT video_source_id FROM `edu_video` WHERE course_id = #&#123;courseId&#125; AND video_source_id IS NOT NULL AND video_source_id != &#x27;&#x27;; &lt;/select&gt;&lt;/mapper&gt; videoService123456789101112131415161718@Servicepublic class EduVideoServiceImpl extends ServiceImpl&lt;EduVideoMapper, EduVideo&gt; implements EduVideoService &#123; @Autowired private VodClient vodClient; // 根据课程id删除小节 @Override public void removeByCourseId(String courseId) &#123; // 删除该课程下的所有视频（阿里云） List&lt;String&gt; idList = baseMapper.getVideoIdListByCourse(courseId); vodClient.deleteVideoBatch(idList); // 删除小节（数据库） QueryWrapper wrapper = new QueryWrapper(); wrapper.eq(&quot;course_id&quot;, courseId); baseMapper.delete(wrapper); &#125;&#125; 测试 OK 前端 TODO 注意这里有个问题，由于我确定按钮没有绑定是否能够按下的boolean值，所有在文件上传完成之前按下会没有sourceId，之后再改 待续 后台还有好多TODO和完善，竟然就直接进入前台了，好吧还得靠自己","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战3","slug":"【项目笔记】在线教育项目实战3","date":"2021-09-24T02:43:17.317Z","updated":"2021-09-26T09:03:30.866Z","comments":true,"path":"2021/09/24/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-3/","link":"","permalink":"http://example.com/2021/09/24/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-3/","excerpt":"","text":"课程管理模块 数据库表关系 course相关表、chapter、video、teacher、subject……这些表都需要 代码生成器 熟悉的操作，run就完事了 贴一下项目结构 controller记得加下跨域注释，entity记得加下自动填充注释…… 添加课程信息（后端）vo表单数据封装类 需要用到表单提交数据，所以写一个vo类封装 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.eduservice.entity.vo;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.math.BigDecimal;// 表单提交数据封装对象@Datapublic class CourseInfoVo &#123; @ApiModelProperty(value = &quot;课程ID&quot;) private String id; @ApiModelProperty(value = &quot;课程讲师ID&quot;) private String teacherId; @ApiModelProperty(value = &quot;课程专业ID&quot;) private String subjectId; @ApiModelProperty(value = &quot;课程标题&quot;) private String title; @ApiModelProperty(value = &quot;课程销售价格，设置为0则可免费观看&quot;) // 0.01 private BigDecimal price; @ApiModelProperty(value = &quot;总课时&quot;) private Integer lessonNum; @ApiModelProperty(value = &quot;课程封面图片路径&quot;) private String cover; @ApiModelProperty(value = &quot;课程简介&quot;) private String description;&#125; 编写controller12345678910111213141516@RestController@RequestMapping(&quot;/eduservice/course&quot;)@CrossOrigin // 跨域public class EduCourseController &#123; @Autowired private EduCourseService courseService; // 添加课程基本信息 @PostMapping(&quot;addCourseInfo&quot;) public R addCourseInfo(@RequestBody CourseInfoVo courseInfoVo) &#123; courseService.saveCourseInfo(courseInfoVo); return R.ok(); &#125;&#125; 编写service123456789101112131415161718192021222324@Servicepublic class EduCourseServiceImpl extends ServiceImpl&lt;EduCourseMapper, EduCourse&gt; implements EduCourseService &#123; @Autowired private EduCourseDescriptionService courseDescriptionService; // 添加课程基本信息 @Override public void saveCourseInfo(CourseInfoVo courseInfoVo) &#123; // 向课程表中添加课程基本信息 EduCourse eduCourse = new EduCourse(); BeanUtils.copyProperties(courseInfoVo, eduCourse); int affectRow = baseMapper.insert(eduCourse); if (affectRow &lt;= 0) &#123; throw new GuliException(20001, &quot;添加课程失败&quot;); &#125; // 向课程简介表中添加课程简介信息 // 注意baseMapper添加的是当前service对应的表,使用对应的service即可 EduCourseDescription courseDescription = new EduCourseDescription(); courseDescription.setId(eduCourse.getId()); // 这里要保证两张表id相同（1-1关系） courseDescription.setDescription(courseInfoVo.getDescription()); courseDescriptionService.save(courseDescription); &#125;&#125; 同时需要实体类中的id属性为手动输入，而不是自动生成 123456789public class EduCourseDescription implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = &quot;课程ID&quot;) @TableId(value = &quot;id&quot;, type = IdType.INPUT) private String id; &#125; 测试 course和description表中id一样 添加课程信息（前端）添加router1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 课程信息管理模块路由&#123; path: &#x27;/course&#x27;, component: Layout, redirect: &#x27;/course/list&#x27;, name: &#x27;课程管理&#x27;, meta: &#123; title: &#x27;课程管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;课程列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/list&#x27;), meta: &#123; title: &#x27;课程分类列表&#x27;, icon: &#x27;tree&#x27; &#125; &#125;, &#123; path: &#x27;info&#x27;, name: &#x27;添加课程&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/info&#x27;), meta: &#123; title: &#x27;添加课程&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;info/:id&#x27;, name: &#x27;EduCourseInfoEdit&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/info&#x27;), meta: &#123; title: &#x27;编辑课程基本信息&#x27;, icon: &#x27;table&#x27; &#125;, // 不显示该路由(隐藏路由) hidden: true &#125;, &#123; path: &#x27;chapter/:id&#x27;, name: &#x27;EduCourseChapterEdit&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/chapter&#x27;), meta: &#123; title: &#x27;编辑课程大纲&#x27;, icon: &#x27;table&#x27; &#125;, // 不显示该路由(隐藏路由) hidden: true &#125;, &#123; path: &#x27;publish/:id&#x27;, name: &#x27;EduCoursePublishEdit&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/publish&#x27;), meta: &#123; title: &#x27;发布课程&#x27;, icon: &#x27;table&#x27; &#125;, // 不显示该路由(隐藏路由) hidden: true &#125; ]&#125;, 创建vue视图模板 使用element-ui的步骤条和表单即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;发布新课程&lt;/h2&gt; &lt;el-steps :active=&quot;1&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px&quot; &gt; &lt;el-step title=&quot;填写课程基本信息&quot; /&gt; &lt;el-step title=&quot;创建课程大纲&quot; /&gt; &lt;el-step title=&quot;最终发布&quot; /&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;课程标题&quot;&gt; &lt;el-input v-model=&quot;courseInfo.title&quot; placeholder=&quot; 示例：机器学习项目课：从基础到搭建项目视频课程。专业名称注意大小写&quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 所属分类 TODO --&gt; &lt;el-form-item label=&quot;课程分类&quot;&gt; &lt;el-select v-model=&quot;courseInfo.subjectParentId&quot; placeholder=&quot;一级分类&quot; @change=&quot;subjectLevelOneChanged&quot; &gt; &lt;el-option v-for=&quot;subject in subjectOneList&quot; :key=&quot;subject.id&quot; :label=&quot;subject.title&quot; :value=&quot;subject.id&quot; /&gt; &lt;/el-select&gt; &lt;!-- 二级分类 --&gt; &lt;el-select v-model=&quot;courseInfo.subjectId&quot; placeholder=&quot;二级分类&quot; &gt; &lt;el-option v-for=&quot;subject in subjectTwoList&quot; :key=&quot;subject.id&quot; :label=&quot;subject.title&quot; :value=&quot;subject.id&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;!-- 课程讲师 TODO --&gt; &lt;!-- 课程讲师 --&gt; &lt;el-form-item label=&quot;课程讲师&quot;&gt; &lt;el-select v-model=&quot;courseInfo.teacherId&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;teacher in teacherList&quot; :key=&quot;teacher.id&quot; :label=&quot;teacher.name&quot; :value=&quot;teacher.id&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;总课时&quot;&gt; &lt;el-input-number :min=&quot;0&quot; v-model=&quot;courseInfo.lessonNum&quot; controls-position=&quot;right&quot; placeholder=&quot;请填写课程的总课时数&quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 课程简介 TODO --&gt; &lt;el-form-item label=&quot;课程简介&quot;&gt; &lt;el-input v-model=&quot;courseInfo.description&quot; placeholder=&quot; &quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 课程封面 TODO --&gt; &lt;!-- 课程封面--&gt; &lt;el-form-item label=&quot;课程封面&quot;&gt; &lt;el-upload :show-file-list=&quot;false&quot; :on-success=&quot;handleAvatarSuccess&quot; :before-upload=&quot;beforeAvatarUpload&quot; :action=&quot;BASE_API + &#x27;/eduoss/fileoss&#x27;&quot; class=&quot;avatar-uploader&quot; &gt; &lt;img :src=&quot;courseInfo.cover&quot; /&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程价格&quot;&gt; &lt;el-input-number :min=&quot;0&quot; v-model=&quot;courseInfo.price&quot; controls-position=&quot;right&quot; placeholder=&quot;免费课程请设置为0元&quot; /&gt; 元 &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot; &gt;保存并下一步&lt;/el-button &gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // import course from &#x27;@/api/edu/course&#x27; import subject from &#x27;@/api/edu/subject&#x27; export default &#123; data() &#123; return &#123; saveBtnDisabled: false, courseInfo: &#123; title: &#x27;&#x27;, subjectId: &#x27;&#x27;, // 二级分类id subjectParentId: &#x27;&#x27;, // 一级分类id teacherId: &#x27;&#x27;, lessonNum: 0, description: &#x27;&#x27;, cover: &#x27;/static/01.jpg&#x27;, price: 0 &#125;, BASE_API: process.env.BASE_API, // 接口API地址 teacherList: [], // 封装所有的讲师 subjectOneList: [], // 一级分类 subjectTwoList: [] // 二级分类 &#125; &#125;, created() &#123;&#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center;&quot;&gt;发布新课程&lt;/h2&gt; &lt;el-steps :active=&quot;2&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px;&quot;&gt; &lt;el-step title=&quot;填写课程基本信息&quot;/&gt; &lt;el-step title=&quot;创建课程大纲&quot;/&gt; &lt;el-step title=&quot;最终发布&quot;/&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item&gt; &lt;el-button @click=&quot;previous&quot;&gt;上一步&lt;/el-button&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;next&quot;&gt;下一步&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; saveBtnDisabled:false &#125; &#125;, created() &#123; &#125;, methods:&#123; previous() &#123; this.$router.push(&#123;path:&#x27;/course/info/1&#x27;&#125;) &#125;, next() &#123; //跳转到第二步 this.$router.push(&#123;path:&#x27;/course/publish/1&#x27;&#125;) &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;发布新课程&lt;/h2&gt; &lt;el-steps :active=&quot;3&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px&quot; &gt; &lt;el-step title=&quot;填写课程基本信息&quot; /&gt; &lt;el-step title=&quot;创建课程大纲&quot; /&gt; &lt;el-step title=&quot;最终发布&quot; /&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item&gt; &lt;el-button @click=&quot;previous&quot;&gt;返回修改&lt;/el-button&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;publish&quot; &gt;发布课程&lt;/el-button &gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; saveBtnDisabled: false // 保存按钮是否禁用 &#125; &#125;, created() &#123; console.log(&#x27;publish created&#x27;) &#125;, methods: &#123; previous() &#123; console.log(&#x27;previous&#x27;) this.$router.push(&#123; path: &#x27;/course/chapter/1&#x27; &#125;) &#125;, publish() &#123; console.log(&#x27;publish&#x27;) this.$router.push(&#123; path: &#x27;/course/list&#x27; &#125;) &#125; &#125; &#125;&lt;/script&gt; 创建课程相关接口 api -&gt; edu -&gt; course.js 12345678910111213import request from &#x27;@/utils/request&#x27;export default &#123; // 新增课程信息 addCourseInfo(courseInfo) &#123; return request(&#123; url: `/eduservice/course/addCourseInfo`, method: &#x27;post&#x27;, data: courseInfo &#125;) &#125; &#125; 注意这里在后端把之前的代码修改一下，返回新增课程的id，然后重启 编写按钮方法（简单编写未实现功能） 由于表单中显示课程分类和讲师还没有写，所以先简单写一下方法 123456789101112next() &#123; // 调用后端接口传入数据 courseApi.addCourseInfo(this.courseInfo).then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加成功!&#x27; &#125;) // 跳转到第二步，同时传递id值 this.$router.push(&#123; path: &#x27;/course/chapter/&#x27; + result.data.courseId &#125;) &#125;)&#125; 添加课程信息（更多完善）显示讲师下拉列表（后端） 讲师模块写过了，不带分页查询所有讲师 显示讲师下拉列表（前端） 注意这里要现在api中创建所得所有讲师的接口（如果之前讲师模块没写的话） 1234567// 查询所有讲师（不带分页） getTeacherList() &#123; return request(&#123; url: `/eduservice/teacher/findAll`, method: &#x27;get&#x27; &#125;) &#125;, 下拉列表模板，使用循环的方法 123456789101112&lt;!-- 课程讲师 TODO --&gt;&lt;!-- 课程讲师 --&gt;&lt;el-form-item label=&quot;课程讲师&quot;&gt; &lt;el-select v-model=&quot;courseInfo.teacherId&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;teacher in teacherList&quot; :key=&quot;teacher.id&quot; :label=&quot;teacher.name&quot; :value=&quot;teacher.id&quot; /&gt; &lt;/el-select&gt;&lt;/el-form-item&gt; 然后编写vue中对应方法即可 12345getListTeacher() &#123; teacherApi.getTeacherList().then(result =&gt; &#123; this.teacherList = result.data.teacherList &#125;)&#125;, 显示二级联动下拉列表（前端） 后端课程分类模块写好了，使用之前的即可 先获得并保存并初始化显示所有一级分类 12345getOneSubject() &#123; subjectApi.getSubjectList().then(result =&gt; &#123; this.subjectOneList = result.data.list &#125;)&#125;, 实现二级联动，为一级分类下拉列表添加@change对应方法 注意此处el-option绑定了value值赋值为id，所以直接获取即可 12345678910111213// 二级联动,value为绑定的数据（:value=&quot;subject.id&quot;）subjectLevelOneChanged(value) &#123; // 根据id便利subjectOneList获得其children赋值给二级分类 for (var i = 0; i &lt; this.subjectOneList.length; i++) &#123; // 判断：所有一级分类id 和 点击一级分类id是否一样 if (value === this.subjectOneList[i].id) &#123; // 从一级分类获取里面所有的二级分类 this.subjectTwoList = this.subjectOneList[i].children // 把二级分类id值清空 this.courseInfo.subjectId = &#x27;&#x27; &#125; &#125;&#125;, 测试是有一个错误，course表上添加的数据没有父分类id，看了下是我在vo对象把这个属性注释了（因为之前有null错误），记得重启 富文本编辑器 直接整合，指cv 复制组件和静态资源 字面意思 配置变量 再配置html变量，build -&gt; webpack.dev.conf.js 中如下添加（注意所在位置，其他不要变） 12345678910111213141516171819 plugins: [ new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: require(&#x27;../config/dev.env&#x27;) &#125;), new webpack.HotModuleReplacementPlugin(), // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, template: &#x27;index.html&#x27;, inject: true, favicon: resolve(&#x27;favicon.ico&#x27;), title: &#x27;vue-admin-template&#x27;, // 修改配置 templateParameters: &#123; BASE_URL: config.dev.assetsPublicPath + config.dev.assetsSubDirectory &#125; &#125;) ]&#125;) 引入脚本文件 在index.html引入脚本文件，报错是找不到BASE_URL，之前改了配置重启就行 12&lt;script src=&lt;%=BASE_URL %&gt;/tinymce4.7.5/tinymce.min.js &gt;&lt;/script&gt;&lt;script src=&lt;%=BASE_URL %&gt;/tinymce4.7.5/langs/zh_CN.js &gt;&lt;/script&gt; 引入声明组件12345import Tinymce from &#x27;@/components/Tinymce&#x27; //引入组件 export default &#123; // 声明组件 components: &#123; Tinymce &#125;, &#125; 使用组件1&lt;tinymce :height=&quot;300&quot; v-model=&quot;courseInfo.description&quot; /&gt; 测试了一下，注意数据库中的字段属性改为longtext，要不然图片传上去后端报错Data truncation: Data too long for column &#39;description&#39; 显示课程章节（后端）创建章节实体类 类似于一级二级分类即可 编写controller12345678910111213141516@RestController@RequestMapping(&quot;/eduservice/chapter&quot;)@CrossOrigin // 跨域public class EduChapterController &#123; @Autowired private EduChapterService chapterService; // 获得课程大纲列表(根据id @GetMapping(&quot;getChapterVideo/&#123;courseId&#125;&quot;) public R getChapterVideo(@PathVariable(&quot;courseId&quot;) String courseId) &#123; List&lt;ChapterVo&gt; list = chapterService.getChapterVideoByCourseId(courseId); return R.ok().data(&quot;chapterVideoList&quot;, list); &#125; &#125; 编写service 不优雅 12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class EduChapterServiceImpl extends ServiceImpl&lt;EduChapterMapper, EduChapter&gt; implements EduChapterService &#123; @Autowired private EduVideoService videoService; @Override public List&lt;ChapterVo&gt; getChapterVideoByCourseId(String courseId) &#123; // 获得对应id课程的所有章节 QueryWrapper&lt;EduChapter&gt; chapterWrapper = new QueryWrapper&lt;&gt;(); chapterWrapper.eq(&quot;course_id&quot;, courseId); List&lt;EduChapter&gt; chapterList = baseMapper.selectList(chapterWrapper); // 获得对应id课程的所有小节 QueryWrapper&lt;EduVideo&gt; videoWrapper = new QueryWrapper&lt;&gt;(); videoWrapper.eq(&quot;course_id&quot;, courseId); List&lt;EduVideo&gt; videoList = videoService.list(videoWrapper); // 封装 List&lt;ChapterVo&gt; finalList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; chapterList.size(); i++) &#123; EduChapter eduChapter = chapterList.get(i); ChapterVo chapterVo = new ChapterVo(); BeanUtils.copyProperties(eduChapter, chapterVo); List&lt;VideoVo&gt; children = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; videoList.size(); j++) &#123; EduVideo eduVideo = videoList.get(j); if (eduVideo.getChapterId().equals(chapterVo.getId())) &#123; VideoVo videoVo = new VideoVo(); BeanUtils.copyProperties(eduVideo, videoVo); children.add(videoVo); &#125; &#125; chapterVo.setChildren(children); finalList.add(chapterVo); &#125; return finalList; &#125;&#125; 显示课程章节（前端）api1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; // 获得所有以及分类 getChapterVideo(courseId) &#123; return request(&#123; url: `/eduservice/chapter/getChapterVideo/$&#123;courseId&#125;`, method: &#x27;get&#x27;, &#125;) &#125;&#125; vue视图模板和初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;发布新课程&lt;/h2&gt; &lt;!-- 步骤条 --&gt; &lt;el-steps :active=&quot;2&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px&quot; &gt; &lt;el-step title=&quot;填写课程基本信息&quot; /&gt; &lt;el-step title=&quot;创建课程大纲&quot; /&gt; &lt;el-step title=&quot;最终发布&quot; /&gt; &lt;/el-steps&gt; &lt;el-button type=&quot;text&quot; @click=&quot;openChapterDialog()&quot;&gt;添加章节&lt;/el-button&gt; &lt;!-- 章节列表 --&gt; &lt;ul class=&quot;chapterList&quot;&gt; &lt;li v-for=&quot;chapter in chapterVideoList&quot; :key=&quot;chapter.id&quot;&gt; &lt;p&gt; &#123;&#123; chapter.title &#125;&#125; &lt;span class=&quot;acts&quot;&gt; &lt;el-button style=&quot;&quot; type=&quot;text&quot; @click=&quot;openVideo(chapter.id)&quot; &gt;添加小节&lt;/el-button &gt; &lt;el-button style=&quot;&quot; type=&quot;text&quot; @click=&quot;openEditChatper(chapter.id)&quot; &gt;编辑&lt;/el-button &gt; &lt;el-button type=&quot;text&quot; @click=&quot;removeChapter(chapter.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/span&gt; &lt;/p&gt; &lt;!-- 视频 --&gt; &lt;ul class=&quot;chapterList videoList&quot;&gt; &lt;li v-for=&quot;video in chapter.children&quot; :key=&quot;video.id&quot;&gt; &lt;p&gt; &#123;&#123; video.title &#125;&#125; &lt;span class=&quot;acts&quot;&gt; &lt;el-button style=&quot;&quot; type=&quot;text&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; @click=&quot;removeVideo(video.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 操作 --&gt; &lt;div&gt; &lt;el-button @click=&quot;previous&quot;&gt;上一步&lt;/el-button&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;next&quot; &gt;下一步&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import chapterApi from &#x27;@/api/edu/chapter&#x27; export default &#123; data() &#123; return &#123; saveBtnDisabled: false, courseId: &#x27;&#x27;, // 课程id chapterVideoList: [] &#125; &#125;, created() &#123; // 获取到路由中的id值 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.courseId = this.$route.params.id this.getChapterVideo() &#125; &#125;, methods: &#123; // 根据id查询章节和小节 getChapterVideo() &#123; chapterApi.getChapterVideo(this.courseId).then(result =&gt; &#123; this.chapterVideoList = result.data.chapterVideoList &#125;) &#125;, previous() &#123; this.$router.push(&#123; path: &#x27;/course/info/&#x27; + this.courseId &#125;) &#125;, next() &#123; // 跳转到第二步 this.$router.push(&#123; path: &#x27;/course/publish/&#x27; + this.courseId &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .chapterList &#123; position: relative; list-style: none; margin: 0; padding: 0; &#125; .chapterList li &#123; position: relative; &#125; .chapterList p &#123; float: left; font-size: 20px; margin: 10px 0; padding: 10px; height: 70px; line-height: 50px; width: 100%; border: 1px solid #ddd; &#125; .chapterList .acts &#123; float: right; font-size: 14px; &#125; .videoList &#123; padding-left: 50px; &#125; .videoList p &#123; float: left; font-size: 14px; margin: 10px 0; padding: 10px; height: 50px; line-height: 30px; width: 100%; border: 1px dotted #ddd; &#125;&lt;/style&gt; 修改课程信息（后端） “上一步”回显方法：根据id查询课程基本信息 修改课程信息 回显课程信息编写controller123456// 根据id查询基本信息@GetMapping(&quot;getCourseInfo/&#123;courseId&#125;&quot;)public R getCourseInfo(@PathVariable String courseId) &#123; CourseInfoVo courseInfoVo = courseService.getCourseInfoById(courseId); return R.ok().data(&quot;courseInfo&quot;, courseInfoVo);&#125; 编写service12345678910111213// 根据id获得课程Vo@Overridepublic CourseInfoVo getCourseInfoById(String courseId) &#123; // 先查课程表 EduCourse eduCourse = baseMapper.selectById(courseId); // 再查课程描述表 EduCourseDescription courseDescription = courseDescriptionService.getById(courseId); // 封装 CourseInfoVo courseInfoVo = new CourseInfoVo(); BeanUtils.copyProperties(eduCourse, courseInfoVo); courseInfoVo.setDescription(courseDescription.getDescription()); return courseInfoVo;&#125; 修改课程信息编写controller123456// 修改课程信息@PostMapping(&quot;updateCourseInfo&quot;)public R updateCourseInfo(@RequestBody CourseInfoVo courseInfoVo) &#123; courseService.updateCourseInfo(courseInfoVo); return R.ok();&#125; 编写service123456789101112131415// 修改课程信息@Overridepublic void updateCourseInfo(CourseInfoVo courseInfoVo) &#123; // 修改课程表 EduCourse eduCourse = new EduCourse(); BeanUtils.copyProperties(courseInfoVo, eduCourse); int affectRow = baseMapper.updateById(eduCourse); if (affectRow &lt;= 0) &#123; throw new GuliException(20001, &quot;修改课程失败&quot;); &#125; // 修改课程描述表 EduCourseDescription courseDescription = new EduCourseDescription(); BeanUtils.copyProperties(courseInfoVo, courseDescription); courseDescriptionService.updateById(courseDescription);&#125; 修改课程信息（前端）api src -&gt; api -&gt; edu -&gt; course.js 123456789101112131415// 根据id获得课程信息 getCourseInfoById(id) &#123; return request(&#123; url: `/eduservice/course/getCourseInfo/` + id, method: &#x27;get&#x27;, &#125;) &#125;, // 修改课程信息 updateCourseInfo(courseInfo) &#123; return request(&#123; url: `/eduservice/course/updateCourseInfo`, method: &#x27;post&#x27;, data: courseInfo &#125;) &#125;, 回显vue视图和方法表单回显数据 记得在跳转到info页面的按钮上添加id的值 12345678910111213141516171819202122&lt;script&gt; import courseApi from &#x27;@/api/edu/course&#x27; export default &#123; data() &#123; &#125;, created() &#123; // 判断是否需要数据回显 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.courseId = this.$route.params.id this.getCourseInfo() &#125; &#125;, methods: &#123; // 根据id获得课程信息 getCourseInfo() &#123; courseApi.getCourseInfoById(this.courseId).then(result =&gt; &#123; this.courseInfo = result.data.courseInfo &#125;) &#125;, &#125; &#125;&lt;/script&gt; 这里需要注意，返回该页面回显数据中，courseInfo的二级分类列表subjectTwoList只有在一级分类change的时候才会重新显示，否则该列表会显示绑定的courseInfo.subjectId，所以需要完善 下拉列表数据回显123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script&gt; export default &#123; watch: &#123; // 监听路由是否发生了变化，如果是则清除当前页面的数据 $route(to, from) &#123; if (!this.$route.params || !this.$route.params.id) &#123; this.courseInfo = &#123;&#125; &#125; &#125; &#125;, created() &#123; // 获取路由id值 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.courseId = this.$route.params.id // 调用根据id查询课程的方法 this.getCourseInfo() &#125; else &#123; // 初始化所有讲师 this.getListTeacher() // 初始化一级分类 this.getOneSubject() &#125; &#125;, methods: &#123; // 根据id获得课程信息 getCourseInfo() &#123; courseApi.getCourseInfoById(this.courseId).then(response =&gt; &#123; // 在courseInfo课程基本信息，包含 一级分类id 和 二级分类id this.courseInfo = response.data.courseInfo // 1 查询所有的分类，包含一级和二级 subjectApi.getSubjectList().then(response =&gt; &#123; // 2 获取所有一级分类 this.subjectOneList = response.data.list // 3 把所有的一级分类数组进行遍历， for (var i = 0; i &lt; this.subjectOneList.length; i++) &#123; // 获取每个一级分类 var oneSubject = this.subjectOneList[i] // 比较当前courseInfo里面一级分类id和所有的一级分类id if (this.courseInfo.subjectParentId == oneSubject.id) &#123; // 获取一级分类所有的二级分类 this.subjectTwoList = oneSubject.children &#125; &#125; &#125;) // 初始化所有讲师 this.getListTeacher() &#125;) &#125;, &#125; &#125;&lt;/script&gt; 测试，这里很奇怪，我把获得二级列表方法封装了出来，结构顺序都一样的但是测试的时候一开始能显示，后面又不行了，我不理解 修改vue视图和方法12345678910111213141516171819202122232425262728293031323334// 点击下一步next() &#123; // 判断是添加还是修改 if (this.courseInfo.id) &#123; this.updateCourse() &#125; else &#123; this.addCourse() &#125;&#125;,// 添加courseaddCourse() &#123; // 调用后端接口传入数据 courseApi.addCourseInfo(this.courseInfo).then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加成功!&#x27; &#125;) // 跳转到第二步，同时传递id值 this.$router.push(&#123; path: &#x27;/course/chapter/&#x27; + result.data.courseId &#125;) &#125;)&#125;,// 修改courseupdateCourse() &#123; courseApi.updateCourseInfo(this.courseInfo).then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;,s message: &#x27;修改成功!&#x27; &#125;) // 跳转到第二步，同时传递id值 this.$router.push(&#123; path: &#x27;/course/chapter/&#x27; + this.courseId &#125;) &#125;)&#125; 增、删、改课程章节（后端）编写controller1234567891011121314151617181920212223242526272829303132@RestController@RequestMapping(&quot;/eduservice/chapter&quot;)@CrossOrigin // 跨域public class EduChapterController &#123; @Autowired private EduChapterService chapterService; // 根据章节id查询章节 @GetMapping(&quot;getChapterInfo/&#123;chapterId&#125;&quot;) public R getChapterInfo(@PathVariable(&quot;chapterId&quot;) String chapterId) &#123; EduChapter chapter = chapterService.getById(chapterId); return R.ok().data(&quot;chapterInfo&quot;, chapter); &#125; // 添加章节 @PostMapping(&quot;addChapter&quot;) public R addChapter(@RequestBody EduChapter eduChapter) &#123; chapterService.save(eduChapter); return R.ok(); &#125; // 修改章节 @PostMapping(&quot;updateChapter&quot;) public R updateChapter(@RequestBody EduChapter eduChapter) &#123; chapterService.updateById(eduChapter); return R.ok(); &#125; // 删除章节 @DeleteMapping(&quot;&#123;chapterId&#125;&quot;) public R deleteChapter(@PathVariable(&quot;chapterId&quot;) String chapterId) &#123; // 自定义方法，如果有小节则不让删 Boolean b = chapterService.deleteChapter(chapterId); return b ? R.ok() : R.error(); &#125;&#125; 编写service123456789101112131415// 删除章节@Overridepublic Boolean deleteChapter(String chapterId) &#123; // 根据id判断是否有小节 QueryWrapper&lt;EduVideo&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;chapter_id&quot;, chapterId); // 获得小节数 int count = videoService.count(queryWrapper); if (count &gt; 0) &#123; throw new GuliException(20001, &quot;含有小节无法删除&quot;); &#125; else &#123; int row = baseMapper.deleteById(chapterId); return row &gt; 0; &#125;&#125; 增、删、改课程章节（前端）api123456789101112131415161718192021222324252627282930313233import request from &#x27;@/utils/request&#x27;export default &#123; // 添加章节 addChapter(chapter) &#123; return request(&#123; url: `/eduservice/chapter/addChapter`, method: &#x27;post&#x27;, data: chapter &#125;) &#125;, // 根据id查询章节 getChapterInfo(chapterId) &#123; return request(&#123; url: `/eduservice/chapter/getChapterInfo/` + chapterId, method: &#x27;get&#x27;, &#125;) &#125;, // 修改章节 updateChapter(chapter) &#123; return request(&#123; url: `/eduservice/chapter/updateChapter`, method: &#x27;post&#x27;, data: chapter &#125;) &#125;, // 删除章节 deleteChapter(chapterId) &#123; return request(&#123; url: `/eduservice/chapter/` + chapterId, method: &#x27;delete&#x27;, &#125;) &#125;,&#125; vue视图模板 element-ui dialog cv就完事了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 添加章节按钮 --&gt; &lt;el-button type=&quot;text&quot; @click=&quot;dialogChapterFormVisible = true&quot; &gt;添加章节&lt;/el-button &gt; &lt;!-- 添加和修改章节表单 --&gt; &lt;el-dialog :visible.sync=&quot;dialogChapterFormVisible&quot; title=&quot;添加章节&quot;&gt; &lt;el-form :model=&quot;chapter&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;章节标题&quot;&gt; &lt;el-input v-model=&quot;chapter.title&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;章节排序&quot;&gt; &lt;el-input-number v-model=&quot;chapter.sort&quot; :min=&quot;0&quot; controls-position=&quot;right&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogChapterFormVisible = false&quot; &gt;取 消&lt;/el-button &gt; &lt;el-button type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot; &gt;确 定&lt;/el-button &gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import chapterApi from &#x27;@/api/edu/chapter&#x27; export default &#123; data() &#123; return &#123; saveBtnDisabled: false, courseId: &#x27;&#x27;, // 课程id chapterVideoList: [], chapter: &#123; // 封装章节数据 title: &#x27;&#x27;, sort: 0 &#125;, video: &#123; title: &#x27;&#x27;, sort: 0, free: 0, videoSourceId: &#x27;&#x27; &#125;, dialogChapterFormVisible: false, // 章节弹框 dialogVideoFormVisible: false // 小节弹框 &#125; &#125;, &#125;&lt;/script&gt; vue方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990saveOrUpdate() &#123; if (this.chapter.id) &#123; this.updateChapter() &#125; else &#123; this.addChapter() &#125;&#125;,// 添加章节addChapter() &#123; // 记得添加id this.chapter.courseId = this.courseId // 调用api chapterApi.addChapter(this.chapter).then(result =&gt; &#123; // 关闭弹框 this.dialogChapterFormVisible = false // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加章节成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() // 清空弹框表单内容 this.chapter = &#123; title: &#x27;&#x27;, sort: 0 &#125; &#125;)&#125;,// 修改章节,显示弹框，数据回显openEditChatper(chapterId) &#123; // 弹框 this.openChapterDialog() // api chapterApi.getChapterInfo(chapterId).then(result =&gt; &#123; this.chapter = result.data.chapterInfo &#125;)&#125;,// 修改章节updateChapter() &#123; // 调用api chapterApi.updateChapter(this.chapter).then(result =&gt; &#123; // 关闭弹框 this.dialogChapterFormVisible = false // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;修改章节成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() &#125;)&#125;,// 删除章节removeChapter(chapterId) &#123; this.$confirm(&#x27;此操作将永久删除该章节记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(result =&gt; &#123; chapterApi .deleteChapter(chapterId) .then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() &#125;) .catch(err =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;删除失败!&#x27; &#125;) &#125;) &#125;)&#125;,// 弹出章节弹框openChapterDialog() &#123; // 弹框 this.dialogChapterFormVisible = true // 清空弹框表单内容 this.chapter = &#123; title: &#x27;&#x27;, sort: 0 &#125;&#125;,// 根据id查询章节和小节getChapterVideo() &#123; chapterApi.getChapterVideo(this.courseId).then(result =&gt; &#123; this.chapterVideoList = result.data.chapterVideoList &#125;)&#125;, 增、删、改小节（后端）（待完善） 已完善，详见项目笔记4 controller12345678910111213141516171819202122232425262728293031323334353637@RestController@RequestMapping(&quot;/eduservice/video&quot;)@CrossOrigin // 跨域public class EduVideoController &#123; @Autowired private EduVideoService videoService; // 添加小节 @PostMapping(&quot;addVideo&quot;) public R addVideo(@RequestBody EduVideo eduVideo) &#123; videoService.save(eduVideo); return R.ok(); &#125; // 删除小节 @DeleteMapping(&quot;&#123;videoId&#125;&quot;) public R deleteVideo(@PathVariable(&quot;videoId&quot;) String videoId) &#123; videoService.removeById(videoId); return R.ok(); &#125; // 修改小节 @PostMapping(&quot;updateVideo&quot;) public R updateVideo(@RequestBody EduVideo eduVideo) &#123; videoService.updateById(eduVideo); return R.ok(); &#125; // 根据小节id查询小节 @GetMapping(&quot;getVideoInfo/&#123;videoId&#125;&quot;) public R getVideoInfo(@PathVariable(&quot;videoId&quot;) String videoId) &#123; EduVideo video = videoService.getById(videoId); return R.ok().data(&quot;videoInfo&quot;, video); &#125;&#125; 增、删、改小节（前端）（待完善）api123456789101112131415161718192021222324252627282930313233import request from &#x27;@/utils/request&#x27;export default &#123; // 添加小节 addVideo(video) &#123; return request(&#123; url: `/eduservice/video/addVideo`, method: &#x27;post&#x27;, data: video &#125;) &#125;, // 删除小节 deleteVideo(videoId) &#123; return request(&#123; url: `/eduservice/video/` + videoId, method: &#x27;delete&#x27;, &#125;) &#125;, // 修改小节 updateVideo(video) &#123; return request(&#123; url: `/eduservice/video/updateVideo`, method: &#x27;post&#x27;, data: video &#125;) &#125;, // 根据id获得小节信息 getVideoInfo(videoId) &#123; return request(&#123; url: `/eduservice/video/getVideoInfo/` + videoId, method: &#x27;get&#x27;, &#125;) &#125;&#125; vue模板 和章节类似，有一个添加或者删除的弹窗 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 添加和修改小节表单 --&gt;&lt;el-dialog :visible.sync=&quot;dialogVideoFormVisible&quot; title=&quot;添加课时&quot;&gt; &lt;el-form :model=&quot;video&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;课时标题&quot;&gt; &lt;el-input v-model=&quot;video.title&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课时排序&quot;&gt; &lt;el-input-number v-model=&quot;video.sort&quot; :min=&quot;0&quot; controls-position=&quot;right&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;是否免费&quot;&gt; &lt;el-radio-group v-model=&quot;video.free&quot;&gt; &lt;el-radio :label=&quot;true&quot;&gt;免费&lt;/el-radio&gt; &lt;el-radio :label=&quot;false&quot;&gt;默认&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;上传视频&quot;&gt; &lt;!-- TODO --&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVideoFormVisible = false&quot; &gt;取 消&lt;/el-button &gt; &lt;el-button :disabled=&quot;saveVideoBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdateVideo&quot; &gt;确 定&lt;/el-button &gt; &lt;/div&gt;&lt;/el-dialog&gt; vue方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354methods: &#123; // ++++++++++++++++++小节操作+++++++++++++++++++++ // 打开小节编辑弹框 openEditVideo(id) &#123; // 弹框 this.dialogVideoFormVisible = true // 设置章节id this.video.chapterId = id &#125;, // 添加小节 addVideo() &#123; // 设置课程id this.video.courseId = this.courseId videoApi.addVideo(this.video).then(response =&gt; &#123; // 关闭弹框 this.dialogVideoFormVisible = false // 提示 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加小节成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() &#125;) &#125;, // 修改小节 updateVideo() &#123;&#125;, // 删除小节 removeVideo(id) &#123; this.$confirm(&#x27;此操作将删除小节, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; // 点击确定，执行then方法 // 调用删除的方法 videoApi.deleteVideo(id).then(response =&gt; &#123; // 删除成功 // 提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除小节成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() &#125;) &#125;) // 点击取消，执行catch方法 &#125;, saveOrUpdateVideo() &#123; // 先写add，学了视频上传在修改 this.addVideo() &#125;, // ++++++++++++++++++小节操作+++++++++++++++++++++&#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战2","slug":"【项目笔记】在线教育项目实战2","date":"2021-09-21T07:51:30.374Z","updated":"2021-10-08T11:41:58.618Z","comments":true,"path":"2021/09/21/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-2/","link":"","permalink":"http://example.com/2021/09/21/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-2/","excerpt":"","text":"前端技术点简单介绍 一下技术点详见其官方文档或者课件，我就瞄了几眼，之前多多少少也学过了 ES6 Vue axios node.js babel 模块化 webpack 搭建前端环境与框架开发过程vscode创建工作区 新建一个空文件夹 用VSCode打开该文件夹 选择菜单栏 文件 -&gt; 将文件夹另存为工作区 即可 测试运行npm 复制template文件夹至工作区 安装依赖npm install npm run dev测试 config -&gt; index.js -&gt; useEslint = false关闭代码检查 vue项目实现 src -&gt; router -&gt; index.js 添加路由 views -&gt; xxx -&gt; xxx.vue 创建vue页面 api -&gt; xxx.js 定义接口地址和参数 在vue页面引入js文件，调用方法实现功能 用户登录和跨域（后端+前端）修改BASE_API（请求路径前缀） config -&gt; dev.env.js文件 123456module.exports = merge(prodEnv, &#123; NODE_ENV: &#x27;&quot;development&quot;&#x27;, // BASE_API: &#x27;&quot;https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin&quot;&#x27;, // 注意这里要使用http BASE_API: &#x27;&quot;http://localhost:8001&quot;&#x27;,&#125;) 编写loginController 先跳过数据库验证 12345678910111213141516171819202122232425262728293031package com.atguigu.eduservice.controller;import com.atguigu.commonutils.R;import io.swagger.annotations.Api;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Api(&quot;后台登录&quot;)@RestController@RequestMapping(&quot;/eduservice/user&quot;)@CrossOrigin // 解决跨域问题public class EduLoginController &#123; // 登录 @PostMapping(&quot;login&quot;) public R login() &#123; // 先跳过验证 // 此处token需要与前端对应 return R.ok().data(&quot;token&quot;, &quot;admin&quot;); &#125; // 获得用户数据 @GetMapping(&quot;info&quot;) public R info() &#123; return R.ok().data(&quot;roles&quot;, &quot;[admin]&quot;).data(&quot;name&quot;, &quot;admin&quot;).data(&quot;avatar&quot;, &quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;); &#125; &#125; 修改前端访问路径 修改api文件夹下的login.js里的接口路径即可 123456789101112131415161718export function login(username, password) &#123; return request(&#123; url: &#x27;/eduservice/user/login&#x27;, method: &#x27;post&#x27;, data: &#123; username, password &#125; &#125;)&#125;export function getInfo(token) &#123; return request(&#123; url: &#x27;/eduservice/user/info&#x27;, method: &#x27;get&#x27;, params: &#123; token &#125; &#125;)&#125; 跨域问题 访问地址的时候，以下任何一个地方不同，会产生跨域问题： 访问协议 IP地址 端口号 在后端controller接口上添加注解@CrossOrigin即可（常用） 使用网关解决 讲师管理模块（前端）讲师列表添加路由 src\\router\\index.js -&gt; constantRouterMap -&gt; children -&gt; component 1234567891011121314151617181920212223242526export const constantRouterMap = [ // …… &#123; path: &#x27;/teacher&#x27;, component: Layout, redirect: &#x27;/teacher/table&#x27;, name: &#x27;讲师管理&#x27;, meta: &#123; title: &#x27;讲师管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;讲师列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/list&#x27;), meta: &#123; title: &#x27;讲师列表&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加讲师&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;添加讲师&#x27;, icon: &#x27;tree&#x27; &#125; &#125; ] &#125;, // …… &#125; 创建并编写js文件（调用接口） src\\api\\edu\\teacher.js 12345678910111213141516import request from &#x27;@/utils/request&#x27;export default &#123; // 查询讲师列表（带条件分页） getTeacherListPage(current, limit, teacherQuery) &#123; return request(&#123; // url可使用字符串拼接，但是最好用反引号 url: `/eduservice/teacher/pageTeacherCondition/$&#123;current&#125;/$&#123;limit&#125;`, method: &#x27;post&#x27;, // 后端使用requestBody获取teacherQuery，此时需要用data（将teacherQuery转换为JSON格式传输） data: teacherQuery &#125;) &#125;&#125; 创建vue页面，通过接口获取数据 注意routerMap中的对应对象（即创建的router）中component对应的地址，就是vue组件的地址，在该地址下创建vue文件 src\\views\\edu\\teacher\\list.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt;讲师列表&lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; data() &#123; return &#123; list: null, // 查询接口之后获得的列表 page: 1, // 当前页 limit: 10, // 每页记录数 total: 0, // 总记录数 teacherQuery: &#123;&#125;, // 条件值对象 &#125;; &#125;, created() &#123; this.getList(); &#125;, methods: &#123; // 获得讲师列表 getList() &#123; teacher .getTeacherListPage(this.page, this.limit, this.teacherQuery) .then((response) =&gt; &#123; // console.log(response); this.list = response.data.records; this.total = response.data.total; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; 编写列表格式代码 使用element-ui表格即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 表格 --&gt; &lt;el-table :data=&quot;list&quot; border fit highlight-current-row&gt; &lt;el-table-column label=&quot;序号&quot; width=&quot;70&quot; header-align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;名称&quot; width=&quot;80&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;头衔&quot; width=&quot;80&quot; header-align=&quot;center&quot;&gt; &lt;!-- 使用template slot-scope 进行判断显示 --&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.level === 1 ? &quot;高级讲师&quot; : &quot;首席讲师&quot; &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;intro&quot; label=&quot;资历&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column prop=&quot;gmtCreate&quot; label=&quot;添加时间&quot; width=&quot;160&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column prop=&quot;sort&quot; label=&quot;排序&quot; width=&quot;60&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt; 添加分页条 使用element-ui分页即可 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 表格 --&gt; &lt;!-- 分页条 --&gt; &lt;!-- @current-change=&quot;getList&quot; 只需要写方法名即可，自动传入需要跳转的页数 --&gt; &lt;el-pagination :current-page=&quot;page&quot; :page-size=&quot;limit&quot; :total=&quot;total&quot; style=&quot;padding: 30px 0; text-align: center&quot; layout=&quot;total, prev, pager, next, jumper&quot; @current-change=&quot;getList&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; // …… methods: &#123; // 获得讲师列表，page默认为1 getList(page = 1) &#123; this.page = page; teacher .getTeacherListPage(this.page, this.limit, this.teacherQuery) .then((response) =&gt; &#123; // console.log(response); this.list = response.data.records; this.total = response.data.total; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; 条件查询分页 使用element-ui表单即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--查询表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;teacherQuery.name&quot; placeholder=&quot;讲师名&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-select v-model=&quot;teacherQuery.level&quot; clearable placeholder=&quot;讲师头衔&quot; &gt; &lt;el-option :value=&quot;1&quot; label=&quot;高级讲师&quot; /&gt; &lt;el-option :value=&quot;2&quot; label=&quot;首席讲师&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;添加时间&quot;&gt; &lt;el-date-picker v-model=&quot;teacherQuery.begin&quot; type=&quot;datetime&quot; placeholder=&quot;选择开始时间&quot; value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; default-time=&quot;00:00:00&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;teacherQuery.end&quot; type=&quot;datetime&quot; placeholder=&quot;选择截止时间&quot; value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; default-time=&quot;00:00:00&quot; /&gt; &lt;/el-form-item&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;getList()&quot; &gt;查询&lt;/el-button &gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt; &lt;/el-form&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; methods: &#123; // 获得讲师列表，page默认为1 getList(page = 1) &#123; &#125;, //清空表单输入项数据 resetData() &#123; this.teacherQuery = &#123;&#125;; //查询所有讲师数据 this.getList(); &#125;, &#125;, &#125;;&lt;/script&gt; 删除讲师添加页面结构按钮 记得绑定对应方法名 slot插槽，Vue - slot-scope=”scope” 的意义 - 武卡卡 - 博客园 (cnblogs.com) 12345678910111213141516171819&lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt;&lt;/el-table-column&gt; 编写接口调用方法 先去api文件夹下编写调用接口的方法 teacher.js 12345678910111213import request from &#x27;@/utils/request&#x27;export default &#123; // 根据id删除讲师 deleteTeacherById(id) &#123; return request(&#123; url: `/eduservice/teacher/$&#123;id&#125;`, method: &#x27;delete&#x27;, &#125;) &#125;&#125; 编写按钮对应方法 编写按钮对应方法，考虑到用户体验，添加element-ui弹框提示 1234567891011121314151617181920212223242526272829303132removeDataById(id) &#123; this.$confirm(&#x27;此操作将永久删除该讲师记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;) .then(() =&gt; &#123; // 调用删除接口 teacher .deleteTeacherById(id) .then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新列表信息 // 如果是最后一页最后一个记录（total-(page-1)*limit == 1） if (this.total - (this.page - 1) * this.limit == 1) &#123; this.getList(this.page - 1) &#125; else &#123; this.getList(this.page) &#125; &#125;) &#125;) .catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;) &#125;)&#125; 当前项目结构 添加讲师添加页面结构 src\\views\\edu\\teacher\\save.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;讲师名称&quot;&gt; &lt;el-input v-model=&quot;teacher.name&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师排序&quot;&gt; &lt;el-input-number v-model=&quot;teacher.sort&quot; controls-position=&quot;right&quot; min=&quot;0&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师头衔&quot;&gt; &lt;el-select v-model=&quot;teacher.level&quot; clearable placeholder=&quot;请选择&quot; &gt; &lt;el-option :value=&quot;1&quot; label=&quot;高级讲师&quot; /&gt; &lt;el-option :value=&quot;2&quot; label=&quot;首席讲师&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师资历&quot;&gt; &lt;el-input v-model=&quot;teacher.career&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师简介&quot;&gt; &lt;el-input v-model=&quot;teacher.intro&quot; :rows=&quot;10&quot; type=&quot;textarea&quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 讲师头像：TODO --&gt; &lt;el-form-item&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot; &gt;保存&lt;/el-button &gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacherApi from &#x27;@/api/edu/teacher.js&#x27; export default &#123; data() &#123; return &#123; teacher: &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125;, saveBtnDisabled: false &#125; &#125;, created() &#123;&#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 编写接口调用方法12345678// 添加讲师addTeacher(teacher) &#123; return request(&#123; url: `/eduservice/teacher/addTeacher`, method: &#x27;post&#x27;, data: teacher &#125;)&#125; 编写按钮对应方法1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt; // 引入调用接口的js文件 import teacherApi from &#x27;@/api/edu/teacher.js&#x27; export default &#123; data() &#123; return &#123; teacher: &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125;, saveBtnDisabled: false &#125; &#125;, created() &#123;&#125;, methods: &#123; // 添加和修改使用同一个页面 saveOrUpdate() &#123; this.saveTeacher() &#125;, saveTeacher() &#123; teacherApi.addTeacher(this.teacher).then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加成功!&#x27; &#125;) // 路由跳转到列表页面 this.$router.push(&#123; path: &#x27;/teacher/list&#x27; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 优化讲师列表排序 根据添加时间降序 123456789101112131415@ApiOperation(&quot;多条件组合分页&quot;)@PostMapping(&quot;pageTeacherCondition/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacherCondition(@PathVariable long current, @PathVariable long limit, @RequestBody(required = false) TeacherQuery teacherQuery) &#123; // …… // 添加排序条件 wrapper.orderByDesc(&quot;gmt_create&quot;); // 调用service方法将page对象根据条件分页 teacherService.page(pageTeacher, wrapper); // ……&#125; 修改讲师编写页面结构1234567891011121314151617181920&lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!-- router跳转 --&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt;&lt;/el-table-column&gt; 隐藏路由 此处需要额外添加router，且不显示 123456789101112131415161718192021222324252627282930313233export const constantRouterMap = [&#123; path: &#x27;/teacher&#x27;, component: Layout, redirect: &#x27;/teacher/table&#x27;, name: &#x27;讲师管理&#x27;, meta: &#123; title: &#x27;讲师管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;讲师列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/list&#x27;), meta: &#123; title: &#x27;讲师列表&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加讲师&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;添加讲师&#x27;, icon: &#x27;tree&#x27; &#125; &#125;, &#123; // 带有id参数，：为占位符 path: &#x27;edit/:id&#x27;, name: &#x27;EduTeacherEdit&#x27;, // 此处进入的vue组件为save.vue component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;编辑讲师&#x27;, icon: &#x27;tree&#x27; &#125;, // 不显示该路由 hidden: true &#125; ] &#125;,] 数据回显 编写后端接口调用方法 1234567// 根据id获取讲师信息getTeacherInfo(id) &#123; return request(&#123; url: `/eduservice/teacher/getTeacher/$&#123;id&#125;`, method: &#x27;get&#x27;, &#125;)&#125; 编写调用该方法，注意要在需要显示该信息的组件中调用该方法 1234567891011121314151617181920&lt;script&gt;export default &#123; created() &#123; // 判断当前路径是否含有id，有则为修改，否则为添加 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; // 从路径中获取参数值 const id = this.$route.params.id this.getTeacherInfo(id) &#125; &#125;, methods: &#123; // 根据id获得讲师信息 getTeacherInfo(id) &#123; teacherApi.getTeacherInfo(id).then(response =&gt; &#123; this.teacher = response.data.teacher &#125;) &#125; &#125;&#125;&lt;/script&gt; 保存修改 编写后端接口调用方法 12345678// 修改讲师信息updateTeacher(teacher) &#123; return request(&#123; url: `/eduservice/teacher/updateTeacher`, method: &#x27;post&#x27;, data: teacher &#125;)&#125; 页面调用该方法，需要判断是修改还是添加 123456789101112131415161718192021222324252627&lt;script&gt; export default &#123; methods: &#123; // 添加和修改使用同一个页面 saveOrUpdate() &#123; // 判断是否有id if (this.teacher.id) &#123; this.updateTeacher() &#125; else &#123; this.saveTeacher() &#125; &#125;, // 修改讲师信息 updateTeacher() &#123; teacherApi.updateTeacher(this.teacher).then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;修改成功!&#x27; &#125;) // 路由跳转到列表页面 this.$router.push(&#123; path: &#x27;/teacher/list&#x27; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 路由切换存留信息问题 感谢弹幕提醒，使用监听路由的方法，可以防止当点击修改后在edit页面再次点击添加讲师，显示后的页面仍然留存讲师信息的小问题 1234567891011121314151617181920212223242526&lt;script&gt; export default &#123; // 监听 watch: &#123; // 监听路由是否发生了变化，如果是则清除当前页面的数据 $route: &#123; handler: function(val, oldVal) &#123; this.resetData() &#125; &#125; &#125;, methods: &#123; // 清空数据 resetData() &#123; this.teacher = &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125; &#125; &#125; &#125;&lt;/script&gt; 好吧原来下一集就把这个问题解决了，原因是多次跳转至同一个页面created钩子函数只会执行一次 以下是老师的方案 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; export default &#123; // 监听 watch: &#123; // 监听路由是否发生了变化，如果是则清除当前页面的数据 $route(to, from) &#123; this.init() &#125; &#125;, created() &#123; // 这里可以不用调用初始化方法，已经设置了监听 this.init() &#125;, methods: &#123; // 初始化 init() &#123; // 判断当前路径是否含有id，有则为修改，否则为添加 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; // 从路径中获取参数值 const id = this.$route.params.id this.getTeacherInfo(id) &#125; else &#123; this.teacher = &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125; &#125; &#125; &#125; &#125;&lt;/script&gt; nginx 反向代理服务器，功能如下： 请求转发 负载均衡 动静分离 基础命令 启动：nginx.exe 关闭：nginx.exe -s stop 重启：nginx.exe -s reload 配置 nginx.conf文件中配置 修改第一个server下的listen端口号 -&gt; 81 （最好改一下） 添加自己的server，其中listen监听的端口号要和前端config中的端口号(BASE_PATH)对应 例如相当于访问9001下的xxx，就会转发到8001下的xxx或者其他 1234567891011121314server &#123; listen 9001; server_name localhost; location ~ /eduservice/ &#123; proxy_pass http://localhost:8001; &#125; location ~ /eduoss/ &#123; proxy_pass http://localhost:8002; &#125; location ~ /eduvod/ &#123; proxy_pass http://localhost:8003; &#125;&#125; 记得修改前端中的BASE_PATH和监听端口一致 测试 application和npm都打开，前端测试一下，查看network中的header是否为nginx中的监听端口号 上传头像功能（后端+前端）阿里云OSS 简单来说：解决海量数据存储与弹性扩容 简单入门 开通就能进控制台了 创建bucket 文件管理中可以进行上传文件等操作 创建access key获得id和秘钥 小小的吐槽：当天给我的账户里充了1rmb（巨额，确信），配置了一些OSS的东西，第二天就来了个专属客服打电话给我，向我介绍各种产品（上次刚注册的时候也给我打了电话，里面的小姐姐说话都好好听）服务太热情了！ 后端阿里云OSS搭建 去官方文档查看详细介绍 快速入门 (aliyun.com) 创建对应子模块 service模块 -&gt; service_oss子模块即可 引入依赖12345678910111213&lt;dependencies&gt; &lt;!-- 阿里云oss依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 日期工具栏依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.properties aliyun.oss.file后配置阿里云OSS和AccessKey相关信息 1234567server.port=8002spring.application.name=service-ossspring.profiles.active=devaliyun.oss.file.endpoint=oss-cn-beijing.aliyuncs.comaliyun.oss.file.keyid=aliyun.oss.file.keysecret=aliyun.oss.file.bucketname=demo-edu-guli 创建启动类12345678910111213package com.atguigu.oss;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class OssApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OssApplication.class, args); &#125;&#125; 由于只使用上传的功能，所以不需要操作数据库，需要配置默认不加载数据库（否则会报错） 1@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) // exclude排除这个数据源配置类 编写常量类 用于获取配置文件中的常量 123456789101112131415161718192021222324252627282930313233package com.atguigu.oss.utils;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class ConstantPropertiesUtils implements InitializingBean &#123; // 读取配置文件内容 @Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;) // 自动属性注入(注意此处属性名要与properties文件中的名字对应) private String endpoint; @Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;) private String keyid; @Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;) private String keysecret; @Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;) private String bucketname; // 定义公开静态常量 public static String END_POINT; public static String ACCESS_KEY_ID; public static String ACCESS_KEY_SECRET; public static String BUCKET_NAME; // 当初始化properties完成后该方法会执行 @Override public void afterPropertiesSet() throws Exception &#123; END_POINT = endpoint; ACCESS_KEY_ID = keyid; ACCESS_KEY_SECRET = keysecret; BUCKET_NAME = bucketname; &#125;&#125; 编写Controller 实现文件获取和回传url和页面跳转 123456789101112131415161718192021222324252627package com.atguigu.oss.controller;import com.atguigu.commonutils.R;import com.atguigu.oss.service.OssService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;@RestController@RequestMapping(&quot;/eduoss/fileoss&quot;)@CrossOrigin // 解决跨域public class OssController &#123; @Autowired private OssService ossService; // 上传头像 @PostMapping() public R uploadOssFile(MultipartFile file) &#123; // 获取到上传的文件(MultipartFile) String url = ossService.uploadFileAvatar(file); return R.ok().data(&quot;url&quot;, url); &#125; &#125; 主要业务逻辑编写编写Service实现类 先创建接口和实现类，实现类中实现上传业务 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.oss.service.impl;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.atguigu.oss.service.OssService;import com.atguigu.oss.utils.ConstantPropertiesUtils;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;@Servicepublic class OssServiceImpl implements OssService &#123; @Override public String uploadFileAvatar(MultipartFile file) &#123; // 简单上传文件格式（oss文档修改即可） String endpoint = ConstantPropertiesUtils.END_POINT; String accessKeyId = ConstantPropertiesUtils.ACCESS_KEY_ID; String accessKeySecret = ConstantPropertiesUtils.ACCESS_KEY_SECRET; String bucketName = ConstantPropertiesUtils.BUCKET_NAME; String fileName = file.getOriginalFilename(); // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); // 上传文件 try &#123; //依次填写Bucket名称、Object完整路径（文件路径+文件名称）、文件流。Object完整路径中不能包含Bucket名称。 ossClient.putObject(bucketName, fileName, file.getInputStream()); // 拼接oss中文件路径 String url = &quot;https://&quot; + bucketName + &quot;.&quot; + endpoint + &quot;/&quot; + fileName; return url; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; finally &#123; // 关闭OSSClient。 ossClient.shutdown(); &#125; &#125;&#125; 完善Service 防止文件名重复 123456// 为文件名添加唯一的值String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);fileName = uuid + fileName;// 将文件进行分类管理,按照日期分类，使用工具类String datePath = new DateTime().toString(&quot;yyyy/MM/dd&quot;);fileName = datePath + &quot;/&quot; + fileName; 上传头像功能（前端）添加页面结构 element-UI里有相关组件（ImageCropper、PanThumb），cv即可 注意要把组件复制到conponents里 注意修改image-cropper中绑定的url、filed中属性值要与后端接口方法中参数名对应 在添加讲师的页面添加如下标签及代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;!-- 讲师头像 --&gt; &lt;el-form-item label=&quot;讲师头像&quot;&gt; &lt;!-- 头衔缩略图 --&gt; &lt;pan-thumb :image=&quot;teacher.avatar&quot; /&gt; &lt;!-- 文件上传按钮 --&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-upload&quot; @click=&quot;imagecropperShow = true&quot; &gt;更换头像 &lt;/el-button&gt; &lt;!-- v-show：是否显示上传组件 :key：类似于id，如果一个页面多个图片上传控件，可以做区分 :url：后台上传的url地址 @close：关闭上传组件 @crop-upload-success：上传成功后的回调 &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; --&gt; &lt;image-cropper v-show=&quot;imagecropperShow&quot; :width=&quot;300&quot; :height=&quot;300&quot; :key=&quot;imagecropperKey&quot; :url=&quot;BASE_API + &#x27;/eduoss/fileoss&#x27;&quot; field=&quot;file&quot; @close=&quot;close&quot; @crop-upload-success=&quot;cropSuccess&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 上传头像所需组件 import ImageCropper from &#x27;@/components/ImageCropper&#x27; import PanThumb from &#x27;@/components/PanThumb&#x27; export default &#123; // 声明组件 components: &#123; ImageCropper, PanThumb &#125;, data() &#123; return &#123; // 上传弹框组件是否显示 imagecropperShow: false, // 上传组件key值 imagecropperKey: 0, // 获取接口API，固定写法 BASE_API: process.env.BASE_API &#125; &#125;, methods: &#123; // 关闭上传弹框 close() &#123;&#125;, // 上传成功 cropSuccess() &#123;&#125; &#125; &#125;&lt;/script&gt; 使用组件 import以及声明即可 123456789&lt;script&gt; // 上传头像所需组件 import ImageCropper from &#x27;@/components/ImageCropper&#x27; import PanThumb from &#x27;@/components/PanThumb&#x27; export default &#123; // 声明组件 components: &#123; ImageCropper, PanThumb &#125;, &#125;&lt;/script&gt; 编写按钮方法1234567891011// 关闭上传弹框close() &#123; this.imagecropperShow = false // 上传组件初始化 this.imagecropperKey = this.imagecropperKey + 1&#125;,// 上传成功(获得头像url并显示)cropSuccess(data) &#123; this.teacher.avatar = data.url this.close()&#125; 测试，报错与解决✅ 报了一个错，显示上传失败，去看network里的请求URL里的地址不对，中间多了一个undefined，想到可能变量名写错了，稍微对比了一下，BASE_API写成BASE_PATH了，改了就可以了 课程分类管理模块（后端+前端） 记得先导入数据库 添加使用上传excel文件的形式 EasyExcel入门 EasyExcel · 语雀 (yuque.com) 记得引入依赖坐标，同时需要poi的，不过父模块已经引入了 1234567891011121314151617181920212223242526&lt;!-- EasyExcel依赖 --&gt;&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;!--以下是父模块中的相关依赖--&gt; &lt;!--xls--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;/dependency&gt; 写Excel 先创建实体类（一级分类、二级分类） 属性需要全小写 12345678@Datapublic class DemoData &#123; // 实体类，其中属性和Excel表格对应 @ExcelProperty(&quot;学生编号&quot;) // 该注释用于定义表头 private Integer sno; @ExcelProperty(&quot;学生姓名&quot;) private String sname;&#125; 测试代码 12345678910111213141516171819202122public class TestEasyExcel &#123; public static void main(String[] args) &#123; // 写Excel // 1、设置文件地址和名称 String filename = &quot;D:\\\\MyProject\\\\excel\\\\test.xlsx&quot;; // 调用easyExcel方法写入, 可以设置sheet, 执行doWrite传入数据 EasyExcel.write(filename, DemoData.class).sheet(&quot;学生列表&quot;).doWrite(getData()); &#125; private static List&lt;DemoData&gt; getData() &#123; List&lt;DemoData&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; DemoData data = new DemoData(); data.setSname(&quot;aaa&quot; + i); data.setSno(i); list.add(data); &#125; return list; &#125;&#125; 读Excel 稍微修改一下实体类 12345678@Datapublic class DemoData &#123; // 实体类，其中属性和Excel表格对应 @ExcelProperty(value = &quot;学生编号&quot;, index = 0) // 该注释用于定义表头 private Integer sno; @ExcelProperty(value = &quot;学生姓名&quot;, index = 1) // index标记第几列，读操作需要 private String sname;&#125; 创建监听器对excel文件的读取（一行一行的读取需要） 1234567891011121314151617181920// 监听器public class ExcelListener extends AnalysisEventListener&lt;DemoData&gt; &#123; // 读取行数据到实体类对象中 @Override public void invoke(DemoData demoData, AnalysisContext analysisContext) &#123; System.out.println(&quot;*****&quot; + demoData + &quot;*****&quot;); &#125; // 读取完成之后执行 @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; &#125; // 读取表头内容 @Override public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) &#123; System.out.println(&quot;表头：&quot; + headMap); &#125;&#125; 测试代码 12String filename = &quot;D:\\\\MyProject\\\\excel\\\\test.xlsx&quot;;EasyExcel.read(filename, DemoData.class, new ExcelListener()).sheet().doRead(); 代码生成器 先生成entity、service、mapper、controller再说 操作还是一样，详细代码见1，只需要修改表名运行即可 12// 一半不同模块需要修改的地方就是表名strategy.setInclude(&quot;edu_subject&quot;); //加载表 记得为自动生成的实体类添加自动填充（@TableField(fill = FieldFill.INSERT)等）的注解 注意controller添加注释@CrossOrigin解决跨域 添加课程分类（后端）创建表格实体类12345678910111213/** * subject表格实体类 */@Datapublic class SubjectData &#123; @ExcelProperty(index = 0) private String oneSubjectName; @ExcelProperty(index = 1) private String twoSubjectName;&#125; 编写service123456789101112131415@Servicepublic class EduSubjectServiceImpl extends ServiceImpl&lt;EduSubjectMapper, EduSubject&gt; implements EduSubjectService &#123; @Override public void saveSubject(MultipartFile file) &#123; try &#123; // 获得文件输入流 InputStream inputStream = file.getInputStream(); // 调用方法读取 EasyExcel.read(inputStream, SubjectData.class, new SubjectExcelListener()).sheet().doRead(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编写监听器 注意DataListener 不能被spring管理（官方说的），如果使用spring需要使用特定构造器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.atguigu.eduservice.listener;import com.alibaba.excel.context.AnalysisContext;import com.alibaba.excel.event.AnalysisEventListener;import com.atguigu.eduservice.entity.EduSubject;import com.atguigu.eduservice.entity.excel.SubjectData;import com.atguigu.eduservice.service.EduSubjectService;import com.atguigu.servicebase.ExceptionHandler.GuliException;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;public class SubjectExcelListener extends AnalysisEventListener&lt;SubjectData&gt; &#123; public EduSubjectService subjectService; public SubjectExcelListener() &#123; &#125; // 当new当前对象的时候同时注入service public SubjectExcelListener(EduSubjectService subjectService) &#123; this.subjectService = subjectService; &#125; // 读取excel内容，写入数据库 @Override public void invoke(SubjectData subjectData, AnalysisContext analysisContext) &#123; if (subjectData == null) &#123; throw new GuliException(20001, &quot;文件数据为空&quot;); &#125; // 添加一级分类，先判断一级分类是否已经存在 EduSubject existOneSubject = this.existSubject(subjectData.getOneSubjectName(), &quot;0&quot;); if (existOneSubject == null) &#123; // 此时没有相同的一级分类，需要添加 EduSubject eduSubject = new EduSubject(); eduSubject.setParentId(&quot;0&quot;); eduSubject.setTitle(subjectData.getOneSubjectName()); subjectService.save(eduSubject); &#125; else &#123; //添加二级分类，先判断 EduSubject eduTwoSubject = this.existSubject(subjectData.getTwoSubjectName(), existOneSubject.getId()); if (eduTwoSubject == null) &#123; // 此时没有相同的一级分类，需要添加 EduSubject eduSubject = new EduSubject(); eduSubject.setParentId(existOneSubject.getId()); eduSubject.setTitle(subjectData.getTwoSubjectName()); subjectService.save(eduSubject); &#125; &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; &#125; // 用于判断分类是否存在 public EduSubject existSubject(String title, String pid) &#123; // 添加查询条件 QueryWrapper&lt;EduSubject&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;title&quot;, title); // pid=0为一级分类 wrapper.eq(&quot;parent_id&quot;, pid); return subjectService.getOne(wrapper); &#125;&#125; 同时修改一下service中方法的参数 其实这里有点奇怪，listener做了主要业务逻辑，等做完了再试试别的方法 编写controller1234567891011121314151617@RestController@RequestMapping(&quot;/eduservice/subject&quot;)@CrossOriginpublic class EduSubjectController &#123; @Autowired private EduSubjectService subjectService; // 添加课程分类 // 获取上传过来的文件，把文件内容读取出来即可 @PostMapping(&quot;addSubject&quot;) public R addSubject(MultipartFile file) &#123; // 获得上传过来的excel文件 subjectService.saveSubject(file, subjectService); return R.ok(); &#125;&#125; 测试，报错与解决✅ swagger成功，后台报错，看了下说gtm_time没有默认值，然后想到自动注入可能没加，果然。 然后是能够写入数据库了但是一级写到二级去了，看了下是添加二级分类的时候的get方法成getOneSubjectName而不是getTwoSubjectName，改一下就解决了 添加课程分类（前端）配置router src -&gt; router -&gt; index.js 当中添加即可 12345678910111213141516171819202122// 课程管理模块路由 &#123; path: &#x27;/subject&#x27;, component: Layout, redirect: &#x27;/subject/list&#x27;, name: &#x27;课程分类管理&#x27;, meta: &#123; title: &#x27;课程分类管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;课程分类列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/subject/list&#x27;), meta: &#123; title: &#x27;课程分类列表&#x27;, icon: &#x27;tree&#x27; &#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加课程分类&#x27;, component: () =&gt; import(&#x27;@/views/edu/subject/add&#x27;), meta: &#123; title: &#x27;添加课程分类&#x27;, icon: &#x27;table&#x27; &#125; &#125;, ] &#125;, 编写添加课程分类视图 element-ui 中 cv一下（文件上传相关） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;信息描述&quot;&gt; &lt;el-tag type=&quot;info&quot;&gt;excel模版说明&lt;/el-tag&gt; &lt;el-tag&gt; &lt;i class=&quot;el-icon-download&quot; /&gt; &lt;!-- 这里模板放在了本地static文件夹里，也可以放在OSS当中 --&gt; &lt;a :href=&quot;&#x27;/static/demo.xlsx&#x27;&quot;&gt;点击下载模版&lt;/a&gt; &lt;/el-tag&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;选择Excel&quot;&gt; &lt;el-upload ref=&quot;upload&quot; :auto-upload=&quot;false&quot; :on-success=&quot;fileUploadSuccess&quot; :on-error=&quot;fileUploadError&quot; :disabled=&quot;importBtnDisabled&quot; :limit=&quot;1&quot; :action=&quot;BASE_API + &#x27;/eduservice/subject/addSubject&#x27;&quot; name=&quot;file&quot; accept=&quot;application/vnd.ms-excel&quot; &gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot; &gt;选取文件&lt;/el-button &gt; &lt;el-button :loading=&quot;loading&quot; style=&quot;margin-left: 10px&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot; &gt;上传到服务器&lt;/el-button &gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; BASE_API: process.env.BASE_API, // 接口API地址 OSS_PATH: process.env.OSS_PATH, // 阿里云OSS地址 importBtnDisabled: false, // 按钮是否禁用, loading: false &#125; &#125;, created() &#123;&#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 编写调用方法12345678910111213141516171819202122232425methods: &#123; // 上传文件 submitUpload() &#123; this.importBtnDisabled = true this.loading = true // 使用vue的提交，而不是Ajax请求 this.$refs.upload.submit() &#125;, // 上传成功 fileUploadSuccess() &#123; this.loading = false this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加课程分类成功！&#x27; &#125;) &#125;, // 上传失败 fileUploadError() &#123; this.loading = false this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加课程分类失败！&#x27; &#125;) &#125;&#125; 完善 el-upload添加一个 :before-upload=”beforeUpload”，用于上传前判断文件后缀格式 上传文件时判断文件是否为空 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;选择Excel&quot;&gt; &lt;el-upload ref=&quot;upload&quot; :auto-upload=&quot;true&quot; :before-upload=&quot;beforeUpload&quot; :on-success=&quot;fileUploadSuccess&quot; :on-error=&quot;fileUploadError&quot; :disabled=&quot;importBtnDisabled&quot; :limit=&quot;1&quot; :action=&quot;BASE_API + &#x27;/eduservice/subject/addSubject&#x27;&quot; name=&quot;file&quot; accept=&quot;application.xlsx&quot; &gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot; &gt;选取文件&lt;/el-button &gt; &lt;el-button :loading=&quot;loading&quot; style=&quot;margin-left: 10px&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot; &gt;上传到服务器&lt;/el-button &gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; // 上传前判断格式 beforeUpload() &#123; const fileName = this.$refs.upload.uploadFiles[0].name const suffix = fileName.substring(fileName.lastIndexOf(&#x27;.&#x27;) + 1) if (suffix != &#x27;xlsx&#x27;) &#123; this.fileSuffixError() return false &#125; &#125;, // 上传文件 submitUpload() &#123; if (this.$refs.upload.uploadFiles.length == 0) &#123; this.fileUploadError() return &#125; this.importBtnDisabled = true this.loading = true // 使用vue的提交，而不是Ajax请求 this.$refs.upload.submit() &#125;, // 文件格式错误失败 fileSuffixError() &#123; this.loading = false this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;文件格式错误！&#x27; &#125;) &#125; &#125; &#125;&lt;/script&gt; 课程分类列表（后端）针对返回的数据创建对应实体类 一级分类、二级分类都要创建对应实体类 1234567// 一级分类@Datapublic class OneSubject &#123; private String id; private String title; private List&lt;TwoSubject&gt; children = new ArrayList&lt;&gt;();&#125; 123456// 二级分类@Datapublic class TwoSubject &#123; private String id; private String title;&#125; 编写controller123456// 课程分类列表（树形）@GetMapping(&quot;getAllSubjects&quot;)public R getAllSubjects() &#123; List&lt;OneSubject&gt; list = subjectService.getAllSubjects(); return R.ok().data(&quot;list&quot;, &quot;list&quot;);&#125; 编写service service继承的ServiceImpl已经自动注入了baseMapper 这里的代码不够优雅 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic List&lt;OneSubject&gt; getAllSubjects() &#123; // 查询所有一级分类 QueryWrapper&lt;EduSubject&gt; wrapperOne = new QueryWrapper&lt;&gt;(); wrapperOne.eq(&quot;parent_id&quot;, &quot;0&quot;); List&lt;EduSubject&gt; oneSubjectList = baseMapper.selectList(wrapperOne); // 查询所有二级分类 QueryWrapper&lt;EduSubject&gt; wrapperTwo = new QueryWrapper&lt;&gt;(); wrapperTwo.ne(&quot;parent_id&quot;, &quot;0&quot;); List&lt;EduSubject&gt; twoSubjectList = baseMapper.selectList(wrapperTwo); List&lt;OneSubject&gt; finalList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; oneSubjectList.size(); i++) &#123; // 封装一级 EduSubject eduSubjectOne = oneSubjectList.get(i); OneSubject oneSubject = new OneSubject(); BeanUtils.copyProperties(eduSubjectOne, oneSubject); finalList.add(oneSubject); //封装二级分类 List&lt;TwoSubject&gt; childrenList = new ArrayList&lt;&gt;(); //遍历二级分类list集合 for (int m = 0; m &lt; twoSubjectList.size(); m++) &#123; //获取每个二级分类 EduSubject eduSubjectTwo = twoSubjectList.get(m); //判断二级分类parentid和一级分类id是否一样 if (eduSubjectTwo.getParentId().equals(eduSubjectOne.getId())) &#123; //把tSubject值复制到TwoSubject里面，放到twoFinalSubjectList里面 TwoSubject twoSubject = new TwoSubject(); BeanUtils.copyProperties(eduSubjectTwo, twoSubject); childrenList.add(twoSubject); &#125; &#125; //把一级下面所有二级分类放到一级分类里面 oneSubject.setChildren(childrenList); &#125; return finalList;&#125; 课程分类列表（前端）树形结构模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 检索 --&gt; &lt;el-input v-model=&quot;filterText&quot; placeholder=&quot;Filter keyword&quot; style=&quot;margin-bottom: 30px&quot; /&gt; &lt;!-- 树形结构 --&gt; &lt;el-tree ref=&quot;tree2&quot; :data=&quot;data2&quot; :props=&quot;defaultProps&quot; :filter-node-method=&quot;filterNode&quot; class=&quot;filter-tree&quot; default-expand-all /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; filterText: &#x27;&#x27;, data2: [ &#123; id: 1, label: &#x27;Level one 1&#x27;, children: [ &#123; id: 4, label: &#x27;Level two 1-1&#x27;, children: [ &#123; id: 9, label: &#x27;Level three 1-1-1&#x27; &#125;, &#123; id: 10, label: &#x27;Level three 1-1-2&#x27; &#125; ] &#125; ] &#125;, &#123; id: 2, label: &#x27;Level one 2&#x27;, children: [ &#123; id: 5, label: &#x27;Level two 2-1&#x27; &#125;, &#123; id: 6, label: &#x27;Level two 2-2&#x27; &#125; ] &#125;, &#123; id: 3, label: &#x27;Level one 3&#x27;, children: [ &#123; id: 7, label: &#x27;Level two 3-1&#x27; &#125;, &#123; id: 8, label: &#x27;Level two 3-2&#x27; &#125; ] &#125; ], defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;label&#x27; &#125; &#125; &#125;, watch: &#123; filterText(val) &#123; this.$refs.tree2.filter(val) &#125; &#125;, methods: &#123; filterNode(value, data) &#123; if (!value) return true return data.label.indexOf(value) !== -1 &#125; &#125; &#125;&lt;/script&gt; 需要稍微修改 后端接口调用 api -&gt; edu -&gt; subject.js 12345678910111213import request from &#x27;@/utils/request&#x27;export default &#123; // 课程分类列表 getSubjectList() &#123; return request(&#123; url: `/eduservice/subject/getAllSubjects`, method: &#x27;get&#x27; &#125;) &#125;&#125; 记得在vue视图中引入 vue视图和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 检索 --&gt; &lt;el-input v-model=&quot;filterText&quot; placeholder=&quot;Filter keyword&quot; style=&quot;margin-bottom: 30px&quot; /&gt; &lt;!-- 树形结构 --&gt; &lt;el-tree ref=&quot;tree2&quot; :data=&quot;list&quot; :props=&quot;defaultProps&quot; :filter-node-method=&quot;filterNode&quot; class=&quot;filter-tree&quot; default-expand-all /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import subjectApi from &#x27;@/api/edu/subject.js&#x27; export default &#123; data() &#123; return &#123; // 索引文本 filterText: &#x27;&#x27;, list: [], defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;title&#x27; &#125; &#125; &#125;, watch: &#123; filterText(val) &#123; this.$refs.tree2.filter(val) &#125; &#125;, created() &#123; this.getAllSubjectList() &#125;, methods: &#123; // 获得所有subject getAllSubjectList() &#123; subjectApi.getSubjectList().then(result =&gt; &#123; this.list = result.data.list &#125;) &#125;, // 过滤文本（不区分大小写） filterNode(value, data) &#123; if (!value) return true return data.title.toLowerCase().indexOf(value.toLowerCase()) !== -1 &#125; &#125; &#125;&lt;/script&gt; 测试 记得开nginx 待续 进度1/3","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【学习笔记】MyBatisPlus","slug":"【学习笔记】MyBatisPlus","date":"2021-09-20T03:38:01.615Z","updated":"2021-09-23T09:58:17.229Z","comments":true,"path":"2021/09/20/xue-xi-bi-ji-mybatisplus/","link":"","permalink":"http://example.com/2021/09/20/xue-xi-bi-ji-mybatisplus/","excerpt":"","text":"官网MyBatis-Plus (baomidou.com) 创建并初始化数据库见课件 快速创建工程创建springboot工程 new project -&gt; spring Initializr mybatisplus依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.properties123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789# mybatis日志，可以查看更多详细信息mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 创建实体类123456789101112131415package com.example.mybatisplus_demo.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 创建Mapepr接口123456789package com.example.mybatisplus_demo.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.mybatisplus_demo.entity.User;@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; mapper扫描 注意这里有个易错点，mappersan内填写到Mapper文件存放的文件夹，而不是mapper文件 123456789@SpringBootApplication@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MybatisplusDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisplusDemoApplication.class, args); &#125;&#125; 单元测试12345678910111213141516171819package com.example.mybatisplus_demo;import com.example.mybatisplus_demo.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisplusDemoApplicationTests &#123; @Autowired private UserMapper userMapper; // 此处如果报错，则在UserMapper接口处添加注释@Repository即可 @Test void contextLoads() &#123; &#125;&#125; 当前项目结构 基础CRUD接口添加 不需要设置id主键的值，mybatisplus自动生成19位id 12345@Testvoid addUser() &#123; int insert = userMapper.insert(new User(null, &quot;爱丽丝&quot;, 12, &quot;Alice@qq.com&quot;)); System.out.println(&quot;insert: &quot; + insert);&#125; 主键生成策略分布式系统唯一ID生成方案汇总 - nick hao - 博客园 (cnblogs.com) 自动增长 UUID Redis生成 snowflake雪花算法 mybatisplus中指定策略如下 12@TableId(type = IdType.AUTO)private Long id; 修改1234@Testvoid updateUser() &#123; userMapper.updateById(new User(2L, &quot;Jacks&quot;, 11, &quot;Jacks@qq.com&quot;));&#125; 自动填充 为实体类添加带有注解的属性 1234567//create_time@TableField(fill = FieldFill.INSERT)private Date createTime;//update_time 注意这里是INSERT_UPDATE@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 创建handler类，并实现接口MetaObjectHandler的方法 123456789101112131415161718192021222324package com.example.mybatisplus_demo.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;// 需要交给spring@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; // 当使用mp实现添加操作时，这个方法会执行 @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125;&#125; 测试 123456789101112131415161718192021222324 @Test void addUser() &#123; User user = new User(); user.setName(&quot;岳不群1&quot;); user.setAge(70); user.setEmail(&quot;lucy@qq.com&quot;);// user.setCreateTime(new Date());// user.setUpdateTime(new Date()); int insert = userMapper.insert(user); System.out.println(&quot;insert:&quot; + insert); &#125; @Test void updateUser() &#123; User user = new User(); user.setId(1439818355027558402L); user.setAge(120); int row = userMapper.updateById(user); System.out.println(row); &#125; 乐观锁 主要解决：丢失更新 为实体类添加带注解的属性 123@Version@TableField(fill = FieldFill.INSERT)private Integer version; 配置乐观锁插件，可以写在独立的配置类中（MapperScan也可以写在该配置类中） 12345678910111213@Configuration@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MpConfig &#123; /** * 乐观锁插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; &#125;&#125; 编写handler类 1234567@Overridepublic void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); // 默认初始值1 this.setFieldValByName(&quot;version&quot;, 1, metaObject);&#125; 测试 12345678@Testvoid testOptimisticLockerInnerInterceptor() &#123; // 先查 User user = userMapper.selectById(1439842460539846658L); // 后改 user.setAge(44); userMapper.updateById(user);&#125; 查询批量查询12345@Testvoid testSelect() &#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1L, 2L, 3L)); System.out.println(users);&#125; 分页查询 在配置类中配置分页插件 123456789101112131415@Configuration@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MpConfig &#123; /** * 插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 测试 123456789@Testvoid testPage() &#123; // 创建page对象 Page&lt;User&gt; page = new Page&lt;&gt;(1, 2); // 查询 Page&lt;User&gt; page1 = userMapper.selectPage(page, null); System.out.println(page1); // 获得的page对象有许多方法可以获得对应值&#125; 删除 物理删除：真实删除，将数据从数据库中删除逻辑删除：假删除，根据字段状态判断 批量删除（物理删除）1234@Testvoid testDelete() &#123; userMapper.deleteBatchIds(Arrays.asList(1L, 2L));&#125; 逻辑删除 在实体类中添加带注释的属性（可以再加上TableField设置默认值等） 12@TableLogicprivate Integer deleted; 高版本已不需要在配置文件中添加插件 测试 1234@Testvoid testDelete() &#123; userMapper.deleteBatchIds(Arrays.asList(1L, 2L));&#125; 逻辑删除之后的数据在查询的时候不会被查询到（添加了额外的条件deleted=0） 条件构造器123456789@Testvoid testWrapper() &#123; // 创建对象 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 设置条件(更多条件详见官网) wrapper.ge(&quot;age&quot;, 20).le(&quot;age&quot;, 40); List&lt;User&gt; users = userMapper.selectList(wrapper); System.out.println(users);&#125; 代码生成器","categories":[],"tags":[{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://example.com/tags/MyBatisPlus/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"【项目笔记】在线教育项目实战1","slug":"【项目笔记】在线教育项目实战1","date":"2021-09-19T13:01:14.432Z","updated":"2021-09-23T08:05:54.517Z","comments":true,"path":"2021/09/19/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-1/","link":"","permalink":"http://example.com/2021/09/19/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-1/","excerpt":"","text":"背景​ 今天准备写一个ssm整合的crud简单项目，然后顺便应付一下学校课程，然后被spring的注释气到了（注释代码什么都写得一模一样，就是idea报找不到bean，结果我重写了几遍之后莫名的好了，离谱！），被jsp气到了（这个错误之前遇到好几次了，也是代码一模一样，就是报404，离谱！），实在是不想在这些上面折腾了，今天在实验室有一半的时间都在叹气，于是果断放弃了它，投入了springboot+vue的怀抱。 项目简介项目商业模式B2C（当前项目） Business To Customers 两个角色： 管理员：添加、修改、删除 普通用户：查询 B2B2C Business To Business To Customers 例子：淘宝 项目实现功能模块后台（管理员） 讲师管理 课程分类管理 课程管理 视频 统计分析 课程相关 订单管理 banner（轮播图）管理 权限管理 前台（普通用户） 首页数据显示 讲师列表和详情 课程列表和详情 视频在线播放 登录和注册 微信扫码登录 微信支付 项目使用的技术点后端技术 SpringBoot SpringCloud MyBatisPlus SpringSecurity redis，maven，easyExcel，jwt，OAuth2 …… 前端技术 vue element-ui axios node.js …… 其他技术 阿里云oss 阿里云视频点播服务 阿里云短信服务 微信支付和登录 docker，git，Jenkins …… MyBatisPlus介绍 详见单独的文档说明 搭建项目环境数据库 详见资料 项目结构 父工程：pom类型，用于管理以来版本和放公共依赖 子模块n：实现各个模块 创建springboot父项目配置父项目的pom.xml 配置打包方式、删除dependencies、添加properties和dependencyManagement、删除src文件夹等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;guli_parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;guli_parent&lt;/name&gt; &lt;description&gt;guli_parent&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;guli.version&gt;0.0.1-SNAPSHOT&lt;/guli.version&gt; &lt;mybatis-plus.version&gt;3.0.5&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt; &lt;aliyun.oss.version&gt;2.8.3&lt;/aliyun.oss.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;poi.version&gt;3.17&lt;/poi.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-sdk-oss.version&gt;3.1.0&lt;/aliyun-sdk-oss.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-java-vod-upload.version&gt;1.4.11&lt;/aliyun-java-vod-upload.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.11&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;cloud-alibaba.version&gt;0.2.2.RELEASE&lt;/cloud-alibaba.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;$&#123;velocity.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyunOSS--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun.oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期时间工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;jodatime.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xlsx--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;$&#123;jwt.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyun--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-core.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-vod.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-dbutils.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;$&#123;canal.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建子模块 右键new model创建即可，子项目service等 配置pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;dependencies&gt; &lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;com.atguigu&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;service_base&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--hystrix依赖，主要是用 @HystrixCommand --&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--服务注册--&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--服务调用--&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建子子模块 service_edu、service_vod 当前项目结构 common模块swagger工具创建子模块 命名为common，该模块不需要src文件夹 配置依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;guli_parent&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring2.X集成redis所需common-pool2 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建子子模块 service_base 创建SwaggerConfig.java配置类12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.servicebase;import com.google.common.base.Predicates;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2 // swagger注解public class SwaggerConfig &#123; // 一些固定配置 @Bean public Docket webApiConfig() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;webApi&quot;) .apiInfo(webApiInfo()) .select() .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;))) .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;))) .build(); &#125; // 文档提示信息 private ApiInfo webApiInfo() &#123; return new ApiInfoBuilder() .title(&quot;网站-课程中心API文档&quot;) .description(&quot;本文档描述了课程中心微服务接口定义&quot;) .version(&quot;1.0&quot;) .contact(new Contact(&quot;java&quot;, &quot;http://atguigu.com&quot;, &quot;1123@qq.com&quot;)) .build(); &#125;&#125; 引入swagger子模块 需要在service模块中引入swagger模块的子模块servicebase模块，即在service模块的pom.xml文件中添加依赖即可（因为想要在service模块的子模块中使用，且都写上了pom打包，所以只要在service模块的pom.xml中添加即可） 12345&lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;service_base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 启动类添加组件扫描 EduApplication是service_edu模块下的启动类，由于service_base模块中的swaggerconfig配置类所在包地址也是com.atguigu.xxx，所以可以通过这个扫描到，否则只会扫描启动类所在及子包下的类（所以启动类要放在所有package的同级），如果是别的地址再额外添加即可（{“com.atguigu”,”com.xxx”}） 123456789@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 测试（访问）swagger 启动xxxApplication启动类 http://localhost:8001/swagger-ui.html API文档提示编写 一下以controller为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.eduservice.controller;import com.atguigu.eduservice.entity.EduTeacher;import com.atguigu.eduservice.service.EduTeacherService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * &lt;p&gt; * 讲师 前端控制器 * &lt;/p&gt; * * @author testjava * @since 2021-09-20 */@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag; &#125;&#125; 当前项目结构 统一结果返回格式统一结果的格式123456&#123; &quot;success&quot;: 布尔, //响应是否成功 &quot;code&quot;: 数字, //响应码 &quot;message&quot;: 字符串, //返回消息 &quot;data&quot;: HashMap //返回数据，放在键值对中&#125; 创建子模块 common模块下创建common_utils模块 设定状态码 可以写成接口，或者其他形式 1234567package com.atguigu.commonutils;public interface ResultCode &#123; // 状态码 public static Integer SUCCESS = 20000; //成功 public static Integer ERROR = 20001; //失败&#125; 定义返回数据格式 创建一个统一返回结果类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.atguigu.commonutils;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.util.HashMap;import java.util.Map;//统一返回结果的类@Datapublic class R &#123; // 以下属性为返回内容key @ApiModelProperty(value = &quot;是否成功&quot;) private Boolean success; @ApiModelProperty(value = &quot;返回码&quot;) private Integer code; @ApiModelProperty(value = &quot;返回消息&quot;) private String message; @ApiModelProperty(value = &quot;返回数据&quot;) private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); //把构造方法私有 private R() &#123; &#125; //成功静态方法 public static R ok() &#123; R r = new R(); r.setSuccess(true); r.setCode(ResultCode.SUCCESS); r.setMessage(&quot;成功&quot;); return r; &#125; //失败静态方法 public static R error() &#123; R r = new R(); r.setSuccess(false); r.setCode(ResultCode.ERROR); r.setMessage(&quot;失败&quot;); return r; &#125; // 以下的return this返回的是r // 可以实现链式编程（R.success().message().……） public R success(Boolean success) &#123; this.setSuccess(success); return this; &#125; public R message(String message) &#123; this.setMessage(message); return this; &#125; public R code(Integer code) &#123; this.setCode(code); return this; &#125; public R data(String key, Object value) &#123; this.data.put(key, value); return this; &#125; public R data(Map&lt;String, Object&gt; map) &#123; this.setData(map); return this; &#125;&#125; 使用统一返回结果格式 先在模块的pom.xml中引入已经定义好的统一返回结果类所在 将接口方法（controller中的方法）返回结果改为R即可 12345678910111213141516171819202122232425262728// 未使用统一结果格式@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag; &#125;&#125; 12345678910111213141516171819202122232425262728// 使用统一结果格式@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public R findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return R.ok().data(&quot;teacherList&quot;, list); &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public R removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag ? R.ok() : R.error(); &#125;&#125; 当前项目结构 统一异常处理统一异常处理类 在common模块中的service_base中添加即可 123456789101112131415/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理public class GlobalExceptionHandler &#123; // 全局异常处理 @ExceptionHandler(Exception.class) // 指定出现什么异常才会执行这个方法 @ResponseBody // 用于返回数据 public R error(Exception e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了异常!&quot;); &#125;&#125; 这里有一个依赖的问题，需要注意 特定异常处理1234567891011121314151617181920212223/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理public class GlobalExceptionHandler &#123; // 全局异常处理 @ExceptionHandler(Exception.class) // 指定出现什么异常才会执行这个方法 @ResponseBody // 用于返回数据 public R error(Exception e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了异常!&quot;); &#125; // 特定异常处理 @ExceptionHandler(ArithmeticException.class) @ResponseBody public R error(ArithmeticException e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了ArithmeticException异常!&quot;); &#125;&#125; 自定义异常处理 创建自定义异常类 1234567891011@Data@NoArgsConstructor@AllArgsConstructorpublic class GuliException extends RuntimeException &#123; private Integer code; // 状态码 private String msg; // 异常信息 //……&#125; 在统一异常处理类中创建方法 1234567// 自定义异常处理@ExceptionHandler(GuliException.class)@ResponseBodypublic R error(GuliException e) &#123; e.printStackTrace(); return R.error().code(e.getCode()).message(e.getMsg());&#125; 抛出自定义异常 12345try &#123; int i = 1 / 0;&#125; catch (Exception e) &#123; throw new GuliException(20001, &quot;zzzzz&quot;);&#125; 当前项目结构 统一日志处理配置日志级别 application.properties文件中配置即可 1logging.level.root=INFO logback日志工具 log4j，logback等可以将日志输出到文件中 注意：需要先将application.properties中的有关日志的配置注释掉 配置工具的配置文件 在resource文件夹下创建logback-spring.xml配置文件 注意 的路径即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt; &lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt; &lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt; &lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt; &lt;property name=&quot;log.path&quot; value=&quot;D:/MyProject/log/guli_edu&quot; /&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;!-- boldMagenta:粗红--&gt; &lt;!-- cyan:青色 --&gt; &lt;!-- white:白色 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)&quot; /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/Pattern&gt; &lt;!-- 设置字符集 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt; &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_info.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录info级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 WARN 日志 --&gt; &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_warn.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录warn级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt; &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_error.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录ERROR级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。 &lt;logger&gt;仅有一个name属性， 一个可选的level和一个可选的addtivity属性。 name:用来指定受此logger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 如果未设置此属性，那么当前logger将会继承上级的级别。 --&gt; &lt;!-- 使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=&quot;INFO&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息 第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别： --&gt; &lt;!--开发环境:打印控制台--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;!--可以输出项目中的debug日志，包括mybatis的sql日志--&gt; &lt;logger name=&quot;com.guli&quot; level=&quot;INFO&quot; /&gt; &lt;!-- root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG 可以包含零个或多个appender元素。 --&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境:输出到文件--&gt; &lt;springProfile name=&quot;pro&quot;&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 输出错误日志 在统一异常处理类上添加注释，并且在异常处理的时候调用log.error() 12345678910111213141516/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理@Slf4j // 输出错误日志public class GlobalExceptionHandler &#123; // 特定异常处理 @ExceptionHandler(ArithmeticException.class) @ResponseBody public R error(ArithmeticException e) &#123; e.printStackTrace(); log.error(e.getMessage()); // 将错误日志的内容输出到文件当中 return R.error().message(&quot;产生了ArithmeticException异常!&quot;); &#125; // ……&#125; 在配置的路径中即可看到日志文件 当前目录结构 service_edu讲师管理模块（后端）快速前置配置配置文件application.properties12345678910111213141516# 端口号server.port=8001# 服务名spring.application.name=service-edu# 环境spring.profiles.active=dev# mysql数据库信息spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789# 返回JSON的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl mybatisplus代码生成器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import org.junit.Test;public class CodeGenerator &#123; @Test public void run() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); // String projectPath = System.getProperty(&quot;user.dir&quot;); // gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); // 建议写成绝对路径 gc.setOutputDir(&quot;D:\\\\MyProject\\\\springboot\\\\guli_parent\\\\service\\\\service_edu&quot; + &quot;/src/main/java&quot;); gc.setAuthor(&quot;testjava&quot;); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(false); //重新生成时文件是否覆盖 gc.setServiceName(&quot;%sService&quot;); //去掉Service接口的首字母I // id类型如果是Long则改为ID_WORKER gc.setIdType(IdType.ID_WORKER_STR); //主键策略 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123456789&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(&quot;eduservice&quot;); //模块名 pc.setParent(&quot;com.atguigu&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;edu_teacher&quot;); //加载表 strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setTablePrefix(pc.getModuleName() + &quot;_&quot;); //生成实体时去掉表前缀 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; 当前项目结构 创建配置类 配置包扫描等 123456789package com.atguigu.eduservice.config;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123;&#125; 创建启动类 启动类位置要放在controller、entity等package的同级，然后run即可启动 12345678910111213package com.atguigu.eduservice;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 简单查询所有讲师编写controller12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.eduservice.controller;import com.atguigu.eduservice.entity.EduTeacher;import com.atguigu.eduservice.service.EduTeacherService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * &lt;p&gt; * 讲师 前端控制器 * &lt;/p&gt; * * @author testjava * @since 2021-09-20 */@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125;&#125; 测试localhost:8001//eduservice/edu-teacher/findAll 逻辑删除讲师实体类属性添加注解 为EduTeacher实体类添加相应的注释@TableLogic 123@ApiModelProperty(value = &quot;逻辑删除 1（true）已删除， 0（false）未删除&quot;)@TableLogicprivate Integer isDeleted; 创建mybatisplus配置类 添加逻辑删除插件（注意mybatis版本，低版本是需要添加的，高版本不用，而且TableId自动识别Type AutoGenerator写法也有区别等） 123456789101112131415161718192021package com.atguigu.eduservice.config;import com.baomidou.mybatisplus.core.injector.ISqlInjector;import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123; /** * 逻辑删除插件 */ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125;&#125; 编写controller 注意使用REST风格URI，pathVariable对应路径参数 123456// 2、逻辑删除讲师@DeleteMapping(&quot;&#123;id&#125;&quot;)public boolean removeTeacher(@PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag;&#125; 测试（swagger工具） 整合swagger可以用于接口测试、生成在线接口文档等 分页功能配置类导入插件123456789101112131415161718192021@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123; /** * 逻辑删除插件 */ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125; /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125;&#125; 编写controller123456789101112131415161718192021/** * 3、分页功能 * * @param current 当前页 * @param limit 每页记录数 * @return */@GetMapping(&quot;pageTeacher/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacher(@PathVariable long current, @PathVariable long limit) &#123; // 创建page对象 Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(current, limit); // 调用方法实现分类 teacherService.page(pageTeacher, null); long total = pageTeacher.getTotal(); List&lt;EduTeacher&gt; records = pageTeacher.getRecords(); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;total&quot;, total); map.put(&quot;records&quot;, records); return R.ok().data(map);&#125; 多条件组合查询分页创建VO实体对象 把条件值传递到接口里（将条件值封装到VO(ViewObject)实体对象当中，再把对象vo传递到接口中）浅析VO、DTO、DO、PO的概念、区别和用处_zjrbiancheng的专栏-CSDN博客实体类（VO，DO，DTO）的划分_xin.wang的博客-CSDN博客 123456789101112131415161718192021222324package com.atguigu.eduservice.entity.vo;import io.swagger.annotations.ApiModelProperty;import lombok.Data;// 条件封装对象@Datapublic class TeacherQuery &#123; // 一下属性是对应的可被依据的查询条件（注意和表中字段名对应） @ApiModelProperty(value = &quot;教师名称,模糊查询&quot;) private String name; @ApiModelProperty(value = &quot;头衔 1高级讲师 2首席讲师&quot;) private Integer level; @ApiModelProperty(value = &quot;查询开始时间&quot;, example = &quot;2019-01-01 10:10:10&quot;) private String begin;//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换 @ApiModelProperty(value = &quot;查询结束时间&quot;, example = &quot;2019-12-01 10:10:10&quot;) private String end; &#125; 编写controller123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 4、多条件组合分页 * 参数中可以使用@RequestBody TeacherQuery teacherQuery * 该注释表示使用JSON格式向后端传递数据，会自动封装到对应对象中， * 且需要使用POSTMapping才能获取数据，且如果数据有空需要加上(required = false) * * @param current 当前页 * @param limit 每页记录数 * @param teacherQuery 条件值（以对象的形式） * @return */@ApiOperation(&quot;多条件组合分页&quot;)@PostMapping(&quot;pageTeacherCondition/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacherCondition(@PathVariable long current, @PathVariable long limit, @RequestBody(required = false) TeacherQuery teacherQuery) &#123; // 创建page对象 Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(current, limit); // 创建wrapper对象 QueryWrapper&lt;EduTeacher&gt; wrapper = new QueryWrapper&lt;&gt;(); // 设定条件 String name = teacherQuery.getName(); Integer level = teacherQuery.getLevel(); String begin = teacherQuery.getBegin(); String end = teacherQuery.getEnd(); if (StringUtils.hasLength(name)) &#123; wrapper.like(&quot;name&quot;, name); &#125; if (level != null) &#123; wrapper.eq(&quot;level&quot;, level); &#125; if (StringUtils.hasLength(begin)) &#123; wrapper.ge(&quot;gmt_create&quot;, begin); &#125; if (StringUtils.hasLength(end)) &#123; wrapper.le(&quot;gmt_create&quot;, end); &#125; // 调用service方法将page对象根据条件分页 teacherService.page(pageTeacher, wrapper); long total = pageTeacher.getTotal(); List&lt;EduTeacher&gt; records = pageTeacher.getRecords(); return R.ok().data(&quot;total&quot;, total).data(&quot;records&quot;, records);&#125; 添加讲师实体类属性添加注解 @TableField（fill = FieldFill.xxx）自动填充注解 1234567@ApiModelProperty(value = &quot;创建时间&quot;)@TableField(fill = FieldFill.INSERT)private Date gmtCreate;@ApiModelProperty(value = &quot;更新时间&quot;)@TableField(fill = FieldFill.INSERT_UPDATE)private Date gmtModified; 创建自定义handler类 可以放到service_base模块，然后需要使用导入依赖即可 当对应方法被使用的使用会被调用 123456789101112131415161718192021package com.atguigu.servicebase.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;gmtCreate&quot;, new Date(), metaObject); this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject); &#125;&#125; 注意结构 编写controller123456789101112/** * 5、添加讲师 * * @param eduTeacher * @return */@ApiOperation(&quot;添加讲师&quot;)@PostMapping(&quot;addTeacher&quot;)public R addTeacher(@RequestBody EduTeacher eduTeacher) &#123; boolean save = teacherService.save(eduTeacher); return save ? R.ok() : R.error();&#125; 修改讲师编写controller12345678910111213@ApiOperation(&quot;根据id查询讲师&quot;)@GetMapping(&quot;getTeacher/&#123;id&#125;&quot;)public R getTeacher(@PathVariable String id) &#123; EduTeacher teacher = teacherService.getById(id); return R.ok().data(&quot;teacher&quot;, teacher);&#125;@ApiOperation(&quot;修改讲师&quot;)@PostMapping(&quot;updateTeacher&quot;)public R updateTeacher(@RequestBody EduTeacher teacher) &#123; boolean flag = teacherService.updateById(teacher); return flag ? R.ok() : R.error();&#125; 使用@PutMapping如下 12345678@ApiOperation(&quot;修改讲师&quot;)@PutMapping(&quot;&#123;id&#125;&#125;&quot;)public R updateTeacher(@PathVariable String id, @RequestBody EduTeacher teacher) &#123; teacher.setId(id); boolean flag = teacherService.updateById(teacher); return flag ? R.ok() : R.error();&#125; 待续","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【Unity】从独立游戏学习开发","slug":"【Unity2D】从独立游戏学习开发","date":"2021-08-24T07:54:59.786Z","updated":"2021-08-25T13:10:56.313Z","comments":true,"path":"2021/08/24/unity2d-cong-du-li-you-xi-xue-xi-kai-fa/","link":"","permalink":"http://example.com/2021/08/24/unity2d-cong-du-li-you-xi-xue-xi-kai-fa/","excerpt":"","text":"感谢感谢bilibili视频网站M_Studio麦口老师系列视频教学，Unity2D都是从他这学的。 创建项目与导入素材 创建新项目 导入素材，点击菜单栏Assets -&gt; ImportPackage 导入并编辑Tiles 点击菜单栏window -&gt; 2D -&gt; tile palette ，点击createNewPalette创建palette 导入Level文件夹下Spirit文件夹中的素材，并且适当编辑 TileMap 在Hierarchy窗口，创建所需要的2dObject -&gt; tilemap 在Tile Palette窗口，选中相应Active Tile Map并绘制 在Inspector窗口设置Sorting Layer，如下 ​ Sorting Layer中Layer越靠下越显示在前方，位于同一Layer中Order in Layer数值越大越显示在前方 其中 Background Details用于在Background中再添加相应tile（在同一个TileMap上绘制只能显示一个tile，即使tile是含有透明背景，也会完全替换） 2D Extra插件RuleTile 在Tiles文件夹下右键点击 Create -&gt; tiles -&gt; rule tile，并在Inspector窗口中设置 Default Sprite默认图片 在Inspector窗口中，设置Tiling Rules，并将新tile拖拽进Tile Palette并绘制，如下 ​ 每一个Tiling Rules中，右侧图片为符合该规则就显示的tile，九宫格中设置规则，绿色箭头表示在该方向上有tile，红色叉号表示不能有tile，同时列表中越靠上的rule优先级越高​ 如上设置可快速填充封闭图形的对应tile 如下规则解决内角问题，注意这四个角的额外rule要放在横竖两个tile的上方 Brush 想要添加贴合格子的物件prefab，可以使用创建brush的方式 创建brush，右键点击 create -&gt; Brush -&gt; prefab Brush 添加Element 在 Tile Palette 窗口中左下角使用自定义brush即可 添加的对象别忘了设置Layer以判断，同时可以使用Override使得同一物品相同设置 Collider和RigidbodyPlatform设置Collider和Rigidbody 选中Platform对象，在Inspector窗口下方点击 add component -&gt; Tilemap Collider 2D 勾选collider中的 user By Composite，即使用复合碰撞体，按照提示添加 Composite Collider 2D，则整个Platform为一个整体碰撞体 将随之添加的 rigidbody -&gt; bodytype设置为static，即可保持Platform固定，而不会因为gravity重力下落 同时也可以将Platform本身设置为static Player设置Collider和Rigidbody 选中Player对象，点击 add component -&gt; rigidbody 2D，并设置参数如下 ​ 注意Colllision Detection 碰撞方式设置为Continuous，即可持续判断是否产生碰撞； Interpolate差值设置为Interpolate，即可当下落碰撞时对碰撞体产生一定效果（基于上一帧物体位置来插值模拟） 点击 add component -&gt; Box Collider 2D，并点击Edit设置碰撞体范围 同时在 Constraints限制选项中选择Freeze Rotation Z，即可防止当角色处于Platform角上时会绕着Z轴旋转掉落 同时为Collider添加Materail Layer为Platform和Player添加不同的Layer，用于日后判断 Player左右移动和形象翻转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // 创建rigidbody private Rigidbody2D rb; [Header(&quot;移动参数&quot;)] public float speed = 8f; // public float crouchSpeedDivisor = 3f; // 蹲下速度减缓量 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 float xVelocity; // 轴速度 void Start() &#123; // 获取rigidbody rb = GetComponent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; GroundMovement(); &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入并设置移动 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125;&#125; Player下蹲点击 Edit -&gt; Project Setting -&gt; Input Manager -&gt; 复制JumpElement并修改为Crouch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; // public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 float xVelocity; // 轴速度 // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // Update is called once per frame void Update() &#123; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; GroundMovement(); &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否按下下蹲按钮、是否未按下按钮并处于下蹲状态 if (Input.GetButton(&quot;Crouch&quot;)) &#123; // 控制角色下蹲 Crouch(); &#125;else if(isCrouch) &#123; // 控制角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125;&#125; Player跳跃123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isJump; // 是否跳跃 [Header(&quot;环境检测&quot;)] public LayerMask groundLayer; // 地面层 float xVelocity; // 轴速度 float jumpTime; // 跳跃时间，与duration相关 // 按键 bool jumpPressed, jumpHeld, crouchHeld; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; // 是否接触地面层 if (coll.IsTouchingLayers(groundLayer)) &#123; isOnGround = true; &#125; else &#123; isOnGround = false; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否 if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if(!crouchHeld &amp;&amp; isCrouch) &#123; // 未按下按钮并处于下蹲状态 --》 角色起身 StandUp(); &#125; else if(!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色跳跃 void MidAirMovement() &#123; if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125;&#125; Raycast射线检测实现移动跳跃下蹲检测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isHeadBlocked; // 是否头顶遮挡 public bool isJump; // 是否跳跃 [Header(&quot;环境检测&quot;)] public float footOffset = 0.35f; // 单脚的偏移值，即整体xoffset的一半 public float headClearance = 0.5f; public float groundDistance = 0.2f; public LayerMask groundLayer; // 地面层 float xVelocity; // 轴速度 float jumpTime; // 跳跃时间，与duration相关 // 按键 bool jumpPressed, jumpHeld, crouchHeld; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; /* // 当前角色的位置和单脚左右点的offset Vector2 pos = transform.position; Vector2 offset = new Vector2(-footOffset, 0f); // leftCheck/rightCheck即单脚左右点检测 RaycastHit2D leftCheck = Physics2D.Raycast(pos+offset,Vector2.down,groundDistance,groundLayer); // 显示射线 Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f); */ // 1、左右脚检测是否接触地面 // 获得射线检测 RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0f), Vector2.down, groundDistance, groundLayer); RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0f), Vector2.down, groundDistance, groundLayer); // 是否接触地面层 //if (coll.IsTouchingLayers(groundLayer)) if (leftCheck || rightCheck) &#123; isOnGround = true; &#125; else &#123; isOnGround = false; &#125; // 2、头顶检测是否有阻挡 RaycastHit2D headCheck = Raycast(new Vector2(0f, coll.size.y), Vector2.up, headClearance, groundLayer); if (headCheck) &#123; isHeadBlocked = true; &#125; else &#123; isHeadBlocked = false; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否 if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if(!crouchHeld &amp;&amp; isCrouch &amp;&amp; !isHeadBlocked) &#123; // 未按下按钮,处于下蹲状态,头顶无遮挡 --》 角色起身 StandUp(); &#125; else if(!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色跳跃 void MidAirMovement() &#123; if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125; // 增强Raycast函数 RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer) &#123; // 当前角色的位置 Vector2 pos = transform.position; // 创建射线 RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer); // 显示射线,hit返回是否碰撞布尔值 Color color = hit ? Color.red : Color.green; Debug.DrawRay(pos + offset, rayDirection, color); return hit; &#125;&#125; 实现悬挂功能以及下蹲跳跃的优化 判断Raycast射线是否为TRUE的条件：为射线中有接触碰撞体，但是射线起点没有接触碰撞体； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 public float hangingJumpForce = 15f; // 悬挂时跳跃的力 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isHeadBlocked; // 是否头顶遮挡 public bool isJump; // 是否跳跃 public bool isHanging; // 是否悬挂 [Header(&quot;环境检测&quot;)] public LayerMask groundLayer; // 地面层 public float headClearance = 0.25f; public float groundDistance = 0.2f; public float grabDistance = 0.4f; // 抓取距离 public float reachOffset = 0.7f; // 接触偏移值 float footOffset; // 单脚的偏移值，即整体xsize的一半 float xVelocity; // 轴加速度 float jumpTime; // 跳跃时间，与duration相关 float playerHeight; // 角色高度 float eyeHeight; // 角色眼睛高度 // 按键 bool jumpPressed, jumpHeld, crouchHeld, crouchPressed; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); footOffset = coll.size.x / 2; playerHeight = coll.size.y; eyeHeight = playerHeight - 0.4f; // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); crouchPressed = Input.GetButtonDown(&quot;Crouch&quot;); playerHeight = coll.size.y; eyeHeight = playerHeight - 0.4f; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); CrouchMovement(); HangdingMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; /* // 当前角色的位置和单脚左右点的offset Vector2 pos = transform.position; Vector2 offset = new Vector2(-footOffset, 0f); // leftCheck/rightCheck即单脚左右点检测 RaycastHit2D leftCheck = Physics2D.Raycast(pos+offset,Vector2.down,groundDistance,groundLayer); // 显示射线 Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f); */ // 1、左右脚射线检测 是否接触地面 // 获得射线检测 RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0f), Vector2.down, groundDistance, groundLayer); RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0f), Vector2.down, groundDistance, groundLayer); // 是否接触地面层 //if (coll.IsTouchingLayers(groundLayer)) if (leftCheck || rightCheck) isOnGround = true; else isOnGround = false; // 2、头顶射线检测 是否有阻挡 RaycastHit2D headCheck = Raycast(new Vector2(0f, playerHeight), Vector2.up, headClearance, groundLayer); if (headCheck) isHeadBlocked = true; else isHeadBlocked = false; // 3、头前方区域射线检测 是否悬挂 float diraction = transform.localScale.x; RaycastHit2D blockedCheck = Raycast(new Vector2(footOffset * diraction, playerHeight), new Vector2(diraction,0f), grabDistance, groundLayer); RaycastHit2D wallCheck = Raycast(new Vector2(footOffset * diraction, eyeHeight), new Vector2(diraction, 0f), grabDistance, groundLayer); RaycastHit2D ledgeCheck = Raycast(new Vector2(reachOffset * diraction, playerHeight), Vector2.down, grabDistance, groundLayer); if (!isOnGround &amp;&amp; rb.velocity.y &lt; 0f &amp;&amp; ledgeCheck &amp;&amp; wallCheck &amp;&amp; !blockedCheck) &#123; // 将player固定在一个位置 Vector3 pos = transform.position; pos.x += (wallCheck.distance - 0.05f) * diraction; // RaycastHit2D下的distance为起始点到接触点的距离 pos.y -= ledgeCheck.distance; transform.position = pos; rb.bodyType = RigidbodyType2D.Static; // 让角色静止 isHanging = true; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 悬挂时不允许移动 if (isHanging) return; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色下蹲起立 void CrouchMovement() &#123; if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if (!crouchHeld &amp;&amp; isCrouch &amp;&amp; !isHeadBlocked) &#123; // 未按下按钮,处于下蹲状态,头顶无遮挡 --》 角色起身 StandUp(); &#125; else if (!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; &#125; // 控制角色跳跃 void MidAirMovement() &#123; // 跳跃检测 if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump &amp;&amp; !isHeadBlocked) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch &amp;&amp; !isHeadBlocked) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色悬挂时跳跃与下蹲 void HangdingMovement() &#123; // 悬挂时检测 if (isHanging) &#123; if (jumpPressed) &#123; rb.bodyType = RigidbodyType2D.Dynamic; rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse); isHanging = false; &#125; else if (crouchPressed) &#123; rb.bodyType = RigidbodyType2D.Dynamic; isHanging = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125; // 增强Raycast函数 RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer) &#123; // 当前角色的位置 Vector2 pos = transform.position; // 创建射线 RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer); // 显示射线,hit返回是否碰撞布尔值 Color color = hit ? Color.red : Color.green; Debug.DrawRay(pos + offset, rayDirection, color); return hit; &#125;&#125; 2D透视效果与摄像机 PackageManager -&gt; CineMachines插件导入，添加Follow选项 body -&gt; dead zone锁死范围，在该范围内移动不会跟着移动摄像机 body -&gt; Screen 设置follow角色在摄像机的哪个位置 body -&gt; CameraDistance 设置摄像机包括范围 Main Camera -&gt; Projection -&gt; Perspective，即可模拟正常摄像机效果（切换Scene 2D即可查看） Extension -&gt; Confiner添加摄像机移动边界，为Background添加Collider，注意一定要点选is trigger选项 灯光 对Object右键light -&gt; point light 添加点光源 为Plateform、Background添加materail Window -&gt; Rendering -&gt;light -&gt;Enviroment -&gt; Ambient Color，设置主场景灯光 动画 Window -&gt; Animator/Animation，打开窗口 添加script：PlayerAnimation如下 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; int groundID; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); groundID = Animator.StringToHash(&quot;isOnGround&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); &#125; void Update() &#123; // 设置animatior的状态值 animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); // 使用编号对应赋值、字符串对应赋值 animator.SetBool(groundID, movement.isOnGround); animator.SetBool(&quot;isJumping&quot;, movement.isJump); animator.SetBool(&quot;isCrouching&quot;, movement.isCrouch); animator.SetBool(&quot;isHanging&quot;, movement.isHanging); &#125;&#125; 使用BlendTree 在Animator的BaseLayer中右键 Create State -&gt; From New Blend Tree 点击新的BlendTreeState，在Inspector -&gt; Motion 添加Motion，添加每一个motion对应的animation，且将Parameter设置为自定义的state Threshold临界值选项，当对应parameter值复合某一threshold值时会播放该animation，注意垂直向上水平向右为正 ​ 上图中MidAir1~7为起跳到下落的动画 修改动画脚本如下 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; Rigidbody2D rb; int speedID, groundID, jumpingID, crouchingID, hangingID, fallId; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); // animatior parameter对应编号 speedID = Animator.StringToHash(&quot;speed&quot;); groundID = Animator.StringToHash(&quot;isOnGround&quot;); jumpingID = Animator.StringToHash(&quot;isJumping&quot;); crouchingID = Animator.StringToHash(&quot;isCrouching&quot;); hangingID = Animator.StringToHash(&quot;isHanging&quot;); fallId = Animator.StringToHash(&quot;verticalVelocity&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); rb = GetComponentInParent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; // 设置animatior的状态值，两种方法（使用编号对应赋值、字符串对应赋值） // animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); animator.SetFloat(speedID, Mathf.Abs(movement.xVelocity)); animator.SetBool(groundID, movement.isOnGround); animator.SetBool(jumpingID, movement.isJump); animator.SetBool(crouchingID, movement.isCrouch); animator.SetBool(hangingID, movement.isHanging); animator.SetFloat(fallId, rb.velocity.y); &#125;&#125; 音效 注意Animation窗口中对应动画，含有特定的animation event需要添加 添加AudioManager(Prefab)，并为其添加script如下 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; static AudioManager current; [Header(&quot;环境声音&quot;)] public AudioClip ambientCilip; public AudioClip musicClip; [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; public void Awake() &#123; current = this; &#125;&#125; ​ 同时在AudioManager(Prefab)中选择相应的音效 添加AudioSource 12345678910111213141516171819202122232425262728293031323334353637383940414243using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; // ... AudioSource ambientSource, musicSource, fxSource, playerSource, voiceSource; public void Awake() &#123; // 单例模式 if(current != null) &#123; Destroy(gameObject); return; &#125; // 方便在static方法中使用this current = this; // 防止场景加载时被销毁 DontDestroyOnLoad(gameObject); // 使用代码添加AudioSource组件 ambientSource = gameObject.AddComponent&lt;AudioSource&gt;(); musicSource = gameObject.AddComponent&lt;AudioSource&gt;(); fxSource = gameObject.AddComponent&lt;AudioSource&gt;(); playerSource = gameObject.AddComponent&lt;AudioSource&gt;(); voiceSource = gameObject.AddComponent&lt;AudioSource&gt;(); &#125; public static void PlayFootstepAudio() &#123; // 获得随机数 int index = Random.Range(0, current.walkStepClips.Length); // 指定source的clip声音片段 current.playerSource.clip = current.walkStepClips[index]; // 播放 current.playerSource.Play(); &#125;&#125; 在PlayerAnimation中调用方法 1234public void StepAudio()&#123; AudioManager.PlayFootstepAudio();&#125; 其他音效同理，完整如下 AudioManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; static AudioManager current; [Header(&quot;环境声音&quot;)] public AudioClip ambientClip; public AudioClip musicClip; [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; // clip声音片段，source声音源 AudioSource ambientSource, musicSource, fxSource, playerSource, voiceSource; public void Awake() &#123; // 单例模式 if(current != null) &#123; Destroy(gameObject); return; &#125; // 方便在static方法中使用this current = this; // 防止场景加载时被销毁 DontDestroyOnLoad(gameObject); // 使用代码添加AudioSource组件 ambientSource = gameObject.AddComponent&lt;AudioSource&gt;(); musicSource = gameObject.AddComponent&lt;AudioSource&gt;(); fxSource = gameObject.AddComponent&lt;AudioSource&gt;(); playerSource = gameObject.AddComponent&lt;AudioSource&gt;(); voiceSource = gameObject.AddComponent&lt;AudioSource&gt;(); // 背景音乐不需要触发，直接播放 StartLevelAudio(); &#125; // 背景音乐 void StartLevelAudio() &#123; // 打开循环 current.ambientSource.clip = current.ambientClip; current.ambientSource.loop = true; current.ambientSource.Play(); current.musicSource.clip = current.musicClip; current.musicSource.loop = true; current.musicSource.Play(); &#125; // 角色走动音效 public static void PlayFootstepAudio() &#123; // 获得随机数 int index = Random.Range(0, current.walkStepClips.Length); // 指定source的clip声音片段 current.playerSource.clip = current.walkStepClips[index]; // 播放 current.playerSource.Play(); &#125; // 角色下蹲音效 public static void PlayCrouchFootstepAudio() &#123; int index = Random.Range(0, current.crouchStepClips.Length); current.playerSource.clip = current.crouchStepClips[index]; current.playerSource.Play(); &#125; // 角色跳跃音效 public static void PlayJumpAudio() &#123; current.playerSource.clip = current.jumpClip; current.playerSource.Play(); current.voiceSource.clip = current.jumpVoiceClip; current.voiceSource.Play(); &#125;&#125; PlayerAnimation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; Rigidbody2D rb; int speedID, groundID, jumpingID, crouchingID, hangingID, fallId; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); // animatior parameter对应编号 speedID = Animator.StringToHash(&quot;speed&quot;); groundID = Animator.StringToHash(&quot;isOnGround&quot;); jumpingID = Animator.StringToHash(&quot;isJumping&quot;); crouchingID = Animator.StringToHash(&quot;isCrouching&quot;); hangingID = Animator.StringToHash(&quot;isHanging&quot;); fallId = Animator.StringToHash(&quot;verticalVelocity&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); rb = GetComponentInParent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; // 设置animatior的状态值，两种方法（使用编号对应赋值、字符串对应赋值） // animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); animator.SetFloat(speedID, Mathf.Abs(movement.xVelocity)); animator.SetBool(groundID, movement.isOnGround); animator.SetBool(jumpingID, movement.isJump); animator.SetBool(crouchingID, movement.isCrouch); animator.SetBool(hangingID, movement.isHanging); animator.SetFloat(fallId, rb.velocity.y); &#125; public void StepAudio() &#123; AudioManager.PlayFootstepAudio(); &#125; public void CrouchStepAudio() &#123; AudioManager.PlayCrouchFootstepAudio(); &#125;&#125; ​ 由于Animation中没有添加jump的event，所以直接在playerMovement中调用音效即可 死亡机制 添加新的cs代码如下，应用于角色，用于死亡条件判断 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerHealth : MonoBehaviour&#123; // 预制死亡特效 public GameObject deathVFXPrefab; int trapsLayer; void Start() &#123; // 获得对应Layer的编号 trapsLayer = LayerMask.NameToLayer(&quot;Traps&quot;); &#125; // 如果一个碰撞体进入了触发器（当前角色已经被设定为isTrigger）则调用 private void OnTriggerEnter2D(Collider2D collision) &#123; if (collision.gameObject.layer == trapsLayer) &#123; // Instantiate实例化，此处让特效显示 Instantiate(deathVFXPrefab,transform.position,transform.rotation); // 让角色消失 gameObject.SetActive(false); // 播放死亡音效 AudioManager.PlayDeathAudio(); &#125; &#125;&#125; 添加死亡音效，注意在Inspector窗口中选择对应片段 1234567891011121314151617181920212223 [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; public AudioClip deathClip; public AudioClip deathVoiceClip; [Header(&quot;特效音效&quot;)] public AudioClip deathFXClip;// 死亡音效public static void PlayDeathAudio()&#123; current.playerSource.clip = current.deathClip; current.playerSource.Play(); current.voiceSource.clip = current.deathVoiceClip; current.voiceSource.Play(); current.fxSource.clip = current.deathFXClip; current.fxSource.Play();&#125; 设置场景重置，在file -&gt; build settings 中设置scene 123456using UnityEngine.SceneManagement;private void OnTriggerEnter2D(Collider2D collision)&#123; // 重置场景为当前场景 SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);&#125; 视觉效果与相机抖动Post Processing Window -&gt; PackageManager -&gt; 搜索插件Post Processing 为 Main Camera 添加Component -&gt; Post-process Layer，创建一个专门的Layer并添加 创建一个Empty Object，命名为Global Post Processing同时添加上一步骤中的Layer，用于承载视觉效果（如果是单独物件添加特效直接添加即可） 为该对象添加组件 Post-process Volume，其中is Global 用于影响全局，否则添加collider设置影响范围即可 为该对象添加Profile，同时Add effect Camera Shake 在之前添加的Cinemachine中， Inspector -&gt; Extension -&gt;Cinemachine Impulse Listener 在触发相机抖动效果的物件上添加组件 Cinemachine Collision Impulse Source(此为碰撞触发，可选其他source)， 为该组件添加Raw Signal即触发抖动时的效果，可以自行设置，选择TriggerObjectFilter中的LayerMask，即碰撞当前对象的Layer 其余如SignalShape中的FrequencyGain越大速度越快…… GameManager死亡过渡以及相关计数 添加Script，一定命名为GameManager，如下编写 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; DontDestroyOnLoad(this); &#125; public static void PlayerDied() &#123; // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.5f); &#125; // 重启场景 void RestartScene() &#123; SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 添加Empty Object并应用GameManager Script 添加SceneFader Script，编写如下，应用于Fader(UI -&gt; Image对象，含有过渡动画，其中Animator中有Fade参数) 12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;public class SceneFader : MonoBehaviour&#123; Animator anim; int faderID; private void Start() &#123; anim = GetComponent&lt;Animator&gt;(); faderID = Animator.StringToHash(&quot;Fade&quot;); &#125; public void fadeOut() &#123; anim.SetTrigger(faderID); &#125;&#125; 在GameManager中添加如下代码，这里mark一下，上网搜了其他的模式和方法，都可以实现，视频里讲的是观察者模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; SceneFader sceneFader; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; DontDestroyOnLoad(this); &#125; // 用于通知GameManager接收一个SceneFader实例 //public static void RegisterSceneFader(SceneFader fader) //&#123; // gm.sceneFader = fader; //&#125; public static void PlayerDied() &#123; //SceneFader.sf.fadeOut(); SceneFader.sf.fadeOut(); // 以下为另一种调用其他类的方法实现方法，还有其他方法或模式可以实现 //GameObject.Find(&quot;Fader&quot;).SendMessage(&quot;fadeOut&quot;); // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.2f); &#125; // 重启场景 void RestartScene() &#123; SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 123456789101112131415161718192021222324252627282930313233using System.Collections;using System.Collections.Generic;using UnityEngine;public class SceneFader : MonoBehaviour&#123; // 这里使用单例模式，能让其他类调用 public static SceneFader sf; Animator anim; int faderID; private void Awake() &#123; if (sf != null) &#123; return; &#125; sf = this; &#125; private void Start() &#123; anim = GetComponent&lt;Animator&gt;(); faderID = Animator.StringToHash(&quot;Fade&quot;); //GameManager.RegisterSceneFader(this); &#125; public void fadeOut() &#123; anim.SetTrigger(faderID); &#125;&#125; 添加收集物的相关脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; //SceneFader sceneFader; List&lt;Orb&gt; orbs; public int orbNum,deathNum; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; orbs = new List&lt;Orb&gt;(); DontDestroyOnLoad(this); &#125; private void Update() &#123; orbNum = gm.orbs.Count; &#125; // 用于通知GameManager接收一个SceneFader实例 //public static void RegisterSceneFader(SceneFader fader) //&#123; // gm.sceneFader = fader; //&#125; public static void RegisterOrb(Orb orb) &#123; if (!gm.orbs.Contains(orb)) &#123; gm.orbs.Add(orb); &#125; &#125; public static void PlayerDied() &#123; //SceneFader.sf.fadeOut(); SceneFader.sf.fadeOut(); // 以下为另一种调用其他类的方法实现方法，还有其他方法或模式可以实现 //GameObject.Find(&quot;Fader&quot;).SendMessage(&quot;fadeOut&quot;); // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.2f); gm.deathNum++; &#125; public static void PlayerGetOrb(Orb orb) &#123; if (gm.orbs.Count == 0 || !gm.orbs.Contains(orb)) return; gm.orbs.Remove(orb); &#125; // 重启场景 void RestartScene() &#123; gm.orbs.Clear(); SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;public class Orb : MonoBehaviour&#123; int playerLayer; public GameObject explosionVFXPrefab; void Start() &#123; playerLayer = LayerMask.NameToLayer(&quot;Player&quot;); GameManager.RegisterOrb(this); &#125; private void OnTriggerEnter2D(Collider2D collision) &#123; if(collision.gameObject.layer == playerLayer) &#123; GameManager.PlayerGetOrb(this); Instantiate(explosionVFXPrefab, transform.position, transform.rotation); gameObject.SetActive(false); AudioManager.PlayOrbAudio(); &#125; &#125;&#125; Door机关收集物品到一定数量后打开机关 编写Door Script 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class Door : MonoBehaviour&#123; Animator anim; int openID; void Start() &#123; anim = GetComponent&lt;Animator&gt;(); openID = Animator.StringToHash(&quot;Open&quot;); GameManager.RegisterDoor(this); &#125; public void Open() &#123; anim.SetTrigger(openID); AudioManager.PlayOpenDoorAudio(); &#125;&#125; 编写AudioManager 123456// 打开门音效 public static void PlayOpenDoorAudio() &#123; current.fxSource.clip = current.doorFXClip; current.fxSource.PlayDelayed(1f); &#125; UI Manager显示text 编写一个UI Manager Object，添加script如下 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;using TMPro;public class UIManager : MonoBehaviour&#123; static UIManager instance; // 获得Text文本框,记得在Inspector中选择相应的text public TextMeshProUGUI orbText, timeText, deathText, gameOverText; private void Awake() &#123; if(instance != null) &#123; Destroy(gameObject); return; &#125; instance = this; DontDestroyOnLoad(this); &#125; // 更新Orb数量 public static void UpdateOrbUI(int orbCount) &#123; // 设置text instance.orbText.text = orbCount.ToString(); &#125; // 其余text类似&#125; 在GameManager中适当位置调用UIManager相应方法即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System.Collections;using System.Collections.Generic;using UnityEngine;using TMPro;public class UIManager : MonoBehaviour&#123; static UIManager instance; // 获得Text文本框,记得在Inspector中选择相应的text public TextMeshProUGUI orbText, timeText, deathText, gameOverText; private void Awake() &#123; if(instance != null) &#123; Destroy(gameObject); return; &#125; instance = this; DontDestroyOnLoad(this); &#125; // 更新Orb数量 public static void UpdateOrbUI(int orbCount) &#123; // 设置text instance.orbText.text = orbCount.ToString(); &#125; // 更新Death数量 public static void UpdateDeathUI(int deathNum) &#123; // 设置text instance.deathText.text = deathNum.ToString(); &#125; // 更新Time public static void UpdateTimeUI(int time) &#123; int minutes = time / 60; int seconds = time % 60; // 设置text instance.timeText.text = minutes.ToString(&quot;00&quot;)+&quot;:&quot;+seconds.ToString(&quot;00&quot;); &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Unity2D","slug":"Unity2D","permalink":"http://example.com/tags/Unity2D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"}]},{"title":"【学习笔记】Vue","slug":"【学习笔记】Vue","date":"2021-08-04T03:44:20.728Z","updated":"2021-08-24T07:55:46.470Z","comments":true,"path":"2021/08/04/xue-xi-bi-ji-vue/","link":"","permalink":"http://example.com/2021/08/04/xue-xi-bi-ji-vue/","excerpt":"","text":"感谢【尚硅谷】2021最新Vue迅速上手教程丨vue3.0入门到精通_张天禹老师 前言​ 昨天看完springboot2的教学视频，计划着接下来要学什么，毕竟休息一天，就会一直偷懒下去。早上刚看到群里发企业项目要找个会vue，再结合结合vue的热度，虽然自己并不像和前端有太多纠葛（因为强迫症），但是大势所趋，都向着全栈靠呢，而且个人项目肯定也得自己做，所以学了都是好处没坏处。 其实七月初的时候看过两天的vue语法视频（为了暑假集训教学，其实并没有什么用，还忘光了），也没有记笔记，现在正式的看，好好学，好好记，目测两个星期看完？（毕竟也是学了点vue和微信小程序的，上手应该快）看完之后得做个项目了，vue+springboot，不过学期开学也要做个人项目，到时候做也是可以的。 Vue简介什么是Vue 一套用于构建用户界面的渐进式JavaScript框架。 Vue特点 采用组件化模式, 提高代码复用率、且让代码更好维护。 声明式编码,让编码人员无需直接操作DOM, 提高开发效率。 使用虛拟DOM+优秀的Diff算法, 尽量复用DOM节点。 basic容器与Vue实例 其实感觉不用写什么，直接看官方文档或者看代码👌 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 初识Vue： 1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象； 2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法； 3.root容器里的代码被称为【Vue模板】； 4.Vue实例和容器是一一对应的； 5.真实开发中只有一个Vue实例，并且会配合着组件一起使用； 6.&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性； 7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新； 注意区分：js表达式 和 js代码(语句) 1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方： (1). a (2). a+b (3). demo(1) (4). x === y ? &#x27;a&#x27; : &#x27;b&#x27; 2.js代码(语句) (1). if()&#123;&#125; (2). for()&#123;&#125;--&gt;&lt;!-- 准备好一个容器 --&gt;&lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; &gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //创建Vue实例 new Vue(&#123; el:&#x27;#demo&#x27;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。 data:&#123; //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。 name:&#x27;atguigu&#x27;, address:&#x27;北京&#x27; &#125; &#125;)&lt;/script&gt; 单向双向绑定1234567891011121314151617181920212223242526272829303132333435&lt;!-- Vue模板语法有2大类： 1.插值语法： 功能：用于解析标签体内容。 写法：&#123;&#123;xxx&#125;&#125;，xxx是js表达式，且可以直接读取到data中的所有属性。 2.指令语法： 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。 举例：v-bind:href=&quot;xxx&quot; 或 简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式， 且可以直接读取到data中的所有属性。 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。 --&gt;&lt;!-- 准备好一个容器--&gt;&lt;div id=&quot;root&quot;&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;hr/&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习1&lt;/a&gt; &lt;a :href=&quot;school.url&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习2&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;jack&#x27;, school:&#123; name:&#x27;尚硅谷&#x27;, url:&#x27;http://www.atguigu.com&#x27;, &#125; &#125; &#125;)&lt;/script&gt; MVVM 后面写代码去了没写笔记，笔记都在代码上","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"【集训】微信小程序(二)","slug":"【集训】微信小程序(二)","date":"2021-07-22T01:00:03.480Z","updated":"2021-07-23T05:35:01.858Z","comments":true,"path":"2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-er/","link":"","permalink":"http://example.com/2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-er/","excerpt":"","text":"API系统信息Object wx.getSystemInfoSync() | 微信开放文档 (qq.com) 1234567// 获取系统信息wx.getSystemInfo(&#123; success: (result) =&gt; &#123; console.log(result); console.log(result.model); &#125;,&#125;) 交互wx.showToast(Object object) | 微信开放文档 (qq.com) 12345678910111213141516// loading提示框wx.showLoading(&#123; title: &#x27;数据加载中&#x27;,&#125;)setTimeout(res =&gt; &#123; wx.hideLoading(&#123; success: (res) =&gt; &#123; console.log(&quot;加载完成&quot;); &#125;, &#125;)&#125;, 2000)// 消息提示wx.showToast(&#123; title: &#x27;提示信息&#x27;,&#125;) 路由跳转页面wx.navigateTo(Object object) | 微信开放文档 (qq.com) 1&lt;button type=&quot;primary&quot; bindtap=&quot;clickBtn&quot;&gt;跳转到demo01&lt;/button&gt; 123456789clickBtn() &#123; // 可带参数,调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会 wx.navigateTo(&#123; url: &#x27;/pages/demo05/demo05?id=111&#x27;, success: (res) =&gt; &#123; console.log(res); &#125; &#125;) &#125; 返回页面wx.navigateBack(Object object) | 微信开放文档 (qq.com) 1&lt;button bindtap=&quot;clickBack&quot; type=&quot;primary&quot;&gt;返回上一页&lt;/button&gt; 12345clickBack() &#123; wx.navigateBack(&#123; delta: 1, &#125;) &#125; 事件传值EventChannel | 微信开放文档 (qq.com) demo04.js 1234567891011121314151617clickBtn() &#123; // 可带参数,调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会 wx.navigateTo(&#123; url: &#x27;/pages/demo05/demo05?id=111&#x27;, events: &#123; // 为指定事件添加一个监听器 myBackData(data) &#123; console.log(data); &#125; &#125;, // 成功的回调函数 success: (res) =&gt; &#123; // 触发一个事件 res.eventChannel.emit(&quot;myGetData&quot;, &#123; data: &quot;传递的数据&quot; &#125;) &#125; &#125;) &#125; demo05.js 1234567891011121314151617181920onLoad() &#123; // 获取所有打开的EventChannel事件 const eventChannel = this.getOpenerEventChannel(); // 监听index页面的myGetData事件 eventChannel.on(&quot;myGetData&quot;, (res) =&gt; &#123; // 被触发后的操作 console.log(res); &#125;); eventChannel.emit(&quot;myBackData&quot;, &#123; data: &quot;返回的数据&quot; &#125;)&#125;,clickBack() &#123; //const eventChannel = this.getOpenerEventChannel(); //eventChannel.emit(&quot;myBackData&quot;, &#123; data: &quot;返回的数据&quot; &#125;) // 通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。 wx.navigateBack(&#123; delta: 1, &#125;)&#125; 网络临时数据demo06.wxml 123456789101112&lt;!--pages/demo06/demo06.wxml--&gt;&lt;view class=&quot;out&quot;&gt; &lt;view class=&quot;row&quot; wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; wx:key=&quot;*this&quot;&gt; &lt;view class=&quot;pic&quot;&gt; &lt;image src=&quot;&#123;&#123;item.url&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;text&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;item.time&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; demo06.js 12345678910111213141516171819data: &#123; dataList: [ &#123; title: &quot;标题1&quot;, time: &quot;2020-01-01&quot;, url: &quot;/images/image1.png&quot; &#125;, &#123; title: &quot;标题2&quot;, time: &quot;2020-01-02&quot;, url: &quot;/images/image1.png&quot; &#125;, &#123; title: &quot;标题3&quot;, time: &quot;2020-01-03&quot;, url: &quot;/images/image1.png&quot; &#125; ]&#125;, 请求数据RequestTask | 微信开放文档 (qq.com) 使用wx.request获取数据 1234567891011121314151617181920onLoad: function (options) &#123; wx.request(&#123; // 接口地址 url: &#x27;http://edu.newsight.cn/wxList.php&#x27;, // 请求的参数 data: &#123; num: 5, page: 1 &#125;, // 接口调用成功的回调函数 success: (res) =&gt; &#123; console.log(res); console.log(res.data); // 设置数据 this.setData(&#123; reqData: res.data &#125;) &#125;, &#125;)&#125;, 修改之前的代码 demo06.wxml 123456789101112&lt;!--pages/demo06/demo06.wxml--&gt;&lt;view class=&quot;out&quot;&gt; &lt;view class=&quot;row&quot; wx:for=&quot;&#123;&#123;reqData&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;view class=&quot;pic&quot;&gt; &lt;image src=&quot;&#123;&#123;item.picurl&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;text&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;item.posttime&#125;&#125; - &#123;&#123;item.author&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 如果域名检验不合法，可以在微信公众平台的开发中管理添加所需要使用的域名，或者开发者工具在设置不检测合法。 事件绑定刷新数据demo06.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// pages/demo06/demo06.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; reqData: [], scrollTop: 0 &#125;, reqParam: &#123; page: 1 &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.getReqData(1); &#125;, // 下一页 clickToNextPage() &#123; this.reqParam.page++; this.getReqData(this.reqParam.page) &#125;, getReqData(page) &#123; wx.request(&#123; // 接口地址 url: &#x27;http://edu.newsight.cn/wxList.php&#x27;, // 请求的参数 data: &#123; num: 4, page: page &#125;, // 接口调用成功的回调函数 success: (res) =&gt; &#123; console.log(res); console.log(res.data); // 设置数据 this.setData(&#123; reqData: res.data &#125;) &#125;, &#125;) &#125;&#125;) demo06.wxml 1&lt;button bindtap=&quot;clickToNextPage&quot; type=&quot;primary&quot;&gt;下一页&lt;/button&gt; 用户信息wx.getUserProfile(Object object) | 微信开放文档 (qq.com) demo07.wxml 123&lt;button bindtap=&quot;login&quot; type=&quot;primary&quot;&gt;授权登录&lt;/button&gt;&lt;view&gt;&#123;&#123;nickName&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt; demo07.js 12345678910111213141516171819202122data: &#123; nickName: &quot;&quot;, avatar: &quot;&quot;,&#125;,// 授权登录login() &#123; wx.getUserProfile(&#123; // 声明获取用户个人信息后的用途，不超过30个字符 desc: &#x27;声明获取用户信息后的用途&#x27;, success: (res) =&gt; &#123; console.log(res); this.setData(&#123; nickName: res.userInfo.nickName, avatar: res.userInfo.avatarUrl &#125;) &#125;, fail: (res) =&gt; &#123; console.log(res); &#125; &#125;)&#125; 缓存wx.setStorageSync(string key, any data) | 微信开放文档 (qq.com) 存123456789101112131415161718login() &#123; wx.getUserProfile(&#123; // 声明获取用户个人信息后的用途，不超过30个字符 desc: &#x27;声明获取用户信息后的用途&#x27;, success: (res) =&gt; &#123; console.log(res); this.setData(&#123; nickName: res.userInfo.nickName, avatar: res.userInfo.avatarUrl &#125;); // 存信息 wx.setStorageSync(&#x27;userInfo&#x27;, res.userInfo); &#125;, fail: (res) =&gt; &#123; console.log(res); &#125; &#125;)&#125; 取123&lt;button bindtap=&quot;login&quot; type=&quot;primary&quot; wx:if=&quot;&#123;&#123;!nickName&#125;&#125;&quot;&gt;授权登录&lt;/button&gt;&lt;view&gt;&#123;&#123;nickName&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt; 123456789onLoad: function (options) &#123; // 取缓存 let userInfo = wx.getStorageSync(&#x27;userInfo&#x27;); console.log(userInfo); this.setData(&#123; nickName: userInfo.nickName, avatar: userInfo.avatarUrl &#125;)&#125;, 模块化Object module | 微信开放文档 (qq.com) public.js 123456789101112var myPublic = &#123; fun1() &#123; console.log(&quot;执行fun1&quot;); &#125;, fun2(p) &#123; console.log(&quot;执行fun2,参数：&quot; + p); &#125;&#125;module.exports = myPublic demo08.js 123456const myPublic = require(&#x27;../../utils/public.js&#x27;)onLoad: function (options) &#123; myPublic.fun1(); myPublic.fun2(&quot;param&quot;);&#125;, 小程序上线 修改测试号为AppID 小程序 (qq.com)管理服务器域名，取消不检验合法域名 上传代码 小程序 (qq.com)提交审核","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"【集训】微信小程序(一)","slug":"【集训】微信小程序(一)","date":"2021-07-22T01:00:03.478Z","updated":"2021-07-23T05:50:01.078Z","comments":true,"path":"2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-yi/","link":"","permalink":"http://example.com/2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-yi/","excerpt":"","text":"自定义组件Component(Object object) | 微信开放文档 (qq.com) 将部分重复代码抽取出来 商品分类 (taobao.com) 创建自定义组件 类似于页面，一个自定义组件由json、wxml、wxss、js 4个文件组成 可以在微信开发者⼯具中快速创建组件的⽂件结构 声明组件、引入组件tabs.json 123&#123; &quot;component&quot;: true&#125; demo01.json 12345&#123; &quot;usingComponents&quot;: &#123; &quot;Tabs&quot;: &quot;/components/Tabs/Tabs&quot; &#125;&#125; 简单编辑组件Tabs.wxml 123456789101112&lt;!--components/Tabs/Tabs.wxml--&gt;&lt;view class=&quot;tabs&quot;&gt; &lt;view class=&quot;tabs_title&quot;&gt; &lt;view class=&quot;title_item active&quot;&gt;首页&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;原创&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;分类&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;关于&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tabs_content&quot;&gt; &lt;/view&gt;&lt;/view&gt; Tabs.wxss 12345678910111213141516171819202122/* components/Tabs/Tabs.wxss */.tabs &#123;&#125;.tabs_title &#123; display: flex; padding: 10rpx 0;&#125;.title_item &#123; flex: 1; display: flex; justify-content: center; align-items: center;&#125;/* 选中时的样式 */.active &#123; color: #b81d24; border-bottom: 5rpx solid currentColor;&#125;.tabs_content &#123;&#125; 以上数据都写在组件的wxml中，接下来来实现js动态数据 填入初始数据Tabs.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// components/Tabs/Tabs.jsComponent(&#123; /** * 组件的属性列表 */ properties: &#123; &#125;, /** * 组件的初始数据 */ data: &#123; tabs: [ &#123; id: 0, name: &quot;首页&quot;, isActive: true &#125;, &#123; id: 1, name: &quot;原创&quot;, isActive: false &#125; , &#123; id: 2, name: &quot;分类&quot;, isActive: false &#125; , &#123; id: 3, name: &quot;关于&quot;, isActive: false &#125; ] &#125;, /** * 组件的方法列表 */ methods: &#123; &#125;&#125;) Tab.wxml 12345678910111213&lt;view class=&quot;tabs&quot;&gt; &lt;view class=&quot;tabs_title&quot;&gt; &lt;!-- 列表渲染 --&gt; &lt;!-- class中三元表达式，根据item的isActive属性判断是否选中，选中则添加类名以显示样式 --&gt; &lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tabs_content&quot;&gt;&lt;/view&gt; &lt;/view&gt; 绑定点击事件Tab.wxml 123456789&lt;view class=&quot;tabs_title&quot;&gt; &lt;!-- 列表渲染 --&gt; &lt;!-- class中三元表达式，根据item的isActive属性判断是否选中，选中则添加类名以显示样式 --&gt; &lt;!-- data-index自定义属性，用于传递当前的索引值 --&gt; &lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot; bindtap=&quot;handleItemTap&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/view&gt;&lt;/view&gt; 注意自定义组件的方法写在methods中 Tabs.js 123456789101112131415161718192021222324252627methods: &#123; handleItemTap(e) &#123; // 查看索引所在的位置 console.log(e); // 1.获取被点击的索引 // ES6常量const,只读不可改 // ES6解构赋值:const &#123; index &#125; = e.currentTarget.dataset; const index = e.currentTarget.dataset.index; // 2.获取原数组 // ES6变量let,块级作用域 // ES6解构赋值:let &#123; tabs &#125; = this.data; let tabs = this.data.tabs; // 3.循环数组：为当前索引项设置isActive：true,其余false // ES6箭头函数 tabs.forEach((v, i) =&gt; &#123; i === index ? v.isActive = true : v.isActive = false &#125;); // 修改数据 this.setData(&#123; tabs &#125;) &#125;&#125; 以上数据都写在组件中，接下来来实现父向子传递数据 父向子传递数据demo01.wxml 123456&lt;!-- 父组件demo01，子组件Tabs 父组件通过标签属性传递数据 子组件在properties中接收--&gt;&lt;Tabs abc=&quot;要传递的数据&quot;&gt;&lt;/Tabs&gt; Tabs.js 123456789properties: &#123; // 属性名 abc: &#123; // 接收的数据的类型 type: String, // 默认值 value: &quot;&quot; &#125;&#125;, Tabs.wxml 12&lt;!-- 相当于data中的数据使，用&#123;&#123;&#125;&#125;渲染 --&gt;&lt;view&gt;&#123;&#123;abc&#125;&#125;&lt;/view&gt; 接下来修改案例代码 将要传递的数据放在父组件的data中，即原先写在Tabs.js的data中的数据放在demo01.js的data中 1234567891011121314151617181920212223242526data: &#123; tabs: [ &#123; id: 0, name: &quot;首页&quot;, isActive: true &#125;, &#123; id: 1, name: &quot;原创&quot;, isActive: false &#125; , &#123; id: 2, name: &quot;分类&quot;, isActive: false &#125; , &#123; id: 3, name: &quot;关于&quot;, isActive: false &#125; ]&#125;, 父组件通过标签属性传递数据 demo01.wxml 1&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot;&gt;&lt;/Tabs&gt; 子组件在properties中接收，最后效果与之前相同 Tabs.js 123456properties: &#123; tabs: &#123; type: Array, value: [] &#125;&#125;, 此时Tabs.js中代码仍然是在子组件当中修改tab数组，而不是在父组件的data中修改tab（可以在AppData窗口查看） 123456// this.data中找不到数据，则在properties中寻找let tabs = this.data.tabs;// 将tabs放入data当中this.setData(&#123; tabs&#125;) 所以需要将处理数据放在父组件当中，而所需要的索引值则由子组件传递给父组件（子向父传递数据） 子向父传递数据Tabs.js 12345678methods: &#123; handleItemTap(e) &#123; // 1.获取被点击的索引 const index = e.currentTarget.dataset.index; // 2.触发父组件中的自定义事件，并传递数据 this.triggerEvent(&quot;itemChange&quot;, &#123; index &#125;); //triggerEvent(&quot;自定义事件名&quot;, 要传递的数据) &#125;&#125; demo01.wxml 123456&lt;!-- 子组件Tabs -&gt; 父组件demo01 在子组件的标签中添加自定义事件 编写父组件js事件方法--&gt;&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tabs&gt; demo01.js 1234567891011121314// 自定义事件方法handleItemChange(e) &#123; console.log(e); // 接收传递的数据 const index = e.detail.index; // 以下代码相同 let tabs = this.data.tabs; tabs.forEach((v, i) =&gt; &#123; i === index ? v.isActive = true : v.isActive = false &#125;); this.setData(&#123; tabs &#125;)&#125;, AppData窗口查看即可 slot标签 slot占位符（插槽），父组件调用子组件传递一些标签来替换slot的位置 Tabs.wxml 123&lt;view class=&quot;tabs_content&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/view&gt; demo01.wxml 123456&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt; &lt;block wx:if=&quot;&#123;&#123;tabs[0].isActive&#125;&#125;&quot;&gt;内容1&lt;/block&gt; &lt;block wx:elif=&quot;&#123;&#123;tabs[1].isActive&#125;&#125;&quot;&gt;内容2&lt;/block&gt; &lt;block wx:elif=&quot;&#123;&#123;tabs[2].isActive&#125;&#125;&quot;&gt;内容3&lt;/block&gt; &lt;block wx:else&gt;内容4&lt;/block&gt;&lt;/Tabs&gt; 生命周期应用 12345678910111213141516171819202122232425262728293031323334// app.jsApp(&#123; // 应用 第一次启动 的时候触发，可用于最开始获取用户的个人信息等 onLaunch() &#123; console.log(&quot;onLaunch&quot;); &#125;, // 应用 显示 的时候触发，可用于对页面数据、页面效果进行重置 onShow() &#123; console.log(&quot;onShow&quot;); // 可调用多次 &#125;, // 应用 隐藏 的时候触发，可用于暂停或清除定时器 onHide() &#123; console.log(&quot;onHide&quot;); &#125;, // 应用 代码报错 的时候触发，可用于收集错误信息并发送到后台 onError(error) &#123; console.log(&quot;onError&quot;); console.log(error); &#125;, // 应用 第一次启动找不到入口页面 的时候触发，可用于跳转 onPageNotFound() &#123; console.log(&quot;onPageNotFound&quot;); wx.navigateTo(&#123; url: &#x27;/pages/demo01/demo01&#x27;, &#125;) &#125;&#125;) 页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// pages/demo02/demo02.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 * 发送异步请求初始化页面数据 */ onLoad: function (options) &#123; console.log(&quot;onLoad&quot;); &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; console.log(&quot;onShow&quot;); &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; console.log(&quot;onReady&quot;); &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; console.log(&quot;onHide&quot;); &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; console.log(&quot;onUnload&quot;); &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 * 对页面初始化 */ onPullDownRefresh: function () &#123; console.log(&quot;onPullDownRefresh&quot;); &#125;, /** * 页面上拉触底事件的处理函数 * 触底加载更多数据 */ onReachBottom: function () &#123; console.log(&quot;onReachBottom&quot;); &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; console.log(&quot;onShareAppMessage&quot;); &#125;, /** * 页面滚动 */ onPageScroll() &#123; console.log(&quot;onPageScroll&quot;); &#125;, /** * 页面尺寸改变 */ onResize() &#123; console.log(&quot;onResize&quot;); &#125;, /** * 当前是tab页，点击当前页的tab时触发 */ onTabItemTap() &#123; console.log(&quot;onTabItemTap&quot;); &#125;&#125;)","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"【学习笔记】SpringBoot2","slug":"【学习笔记】SpringBoot2","date":"2021-07-20T10:31:35.005Z","updated":"2021-08-18T04:48:58.808Z","comments":true,"path":"2021/07/20/xue-xi-bi-ji-springboot2/","link":"","permalink":"http://example.com/2021/07/20/xue-xi-bi-ji-springboot2/","excerpt":"","text":"教程与文档SpringBoot2核心技术与响应式编程 · 语雀 (yuque.com) Spring与SpringBoot201、Spring与SpringBoot · 语雀 (yuque.com) HelloWorld 导入依赖 pom.xml 1234567891011121314&lt;!-- 父项目配置 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- web场景启动器 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写controller HelloController.java 12345678910// @Controller // 注明controller// @ResponseBody // 注明将java对象转为json格式的数据@RestController // 代替以上两者public class HelloController &#123; // 映射请求的地址 @RequestMapping(&quot;/hello&quot;) public String handle1() &#123; return &quot;Hello,SpringBoot2&quot;; &#125;&#125; 编写主程序类并测试 MainApplication.java 1234567891011/** * 主程序类 */// 表明这是一个SpringBoot应用@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // run声明主程序类，返回一个IoC容器 SpringApplication.run(MainApplication.class, args); &#125;&#125; resources文件夹下application.properties，可根据文档自定义配置 Common Application properties (spring.io) 创建可执行jar包，添加build依赖，然后点击maven中的lifecycle中的clean与package并执行 pom.xml 123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行jar包，在target目录下执行以下命令 java -jar 包名.jar 依赖管理与自动配置特性雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 底层注解@Configuration、@Bean 配置对象原原Spring使用xml配置文件配置bean对象如下 bean.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user01&quot; class=&quot;com.myspringboot2.bean.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.myspringboot2.bean.Pet&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;mimi&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 现编写配置MyConfig.java 1234567891011121314151617/** * 1、配置类里面使用@Bean添加对象，默认是单实例 * 2、配置类本身也是对象 * 3、proxyBeanMethods: 代理bean的方法。默认为true(full模式)，使用代理对象调用方法，保证对象是单实例；否则(lite模式)非单实例 */@Configuration(proxyBeanMethods = true) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; // 无论外部对这个配置类中的方法调用多少次，获得的都是容器中的单实例对象 @Bean //向容器中添加组件，id为方法名(可以自定义)，组件类型为返回类型，组件在容器中的实例为返回地值 public User user01() &#123; return new User(&quot;zhangsan&quot;, 18); &#125; @Bean(&quot;pet01&quot;) //自定义id public Pet cat() &#123; return new Pet(&quot;mimi&quot;); &#125;&#125; 测试类MainApplication.java 123456789101112131415/** * 主程序类 */// 表明这是一个SpringBoot应用@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类,返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 从容器中获取bean,默认是单实例 User user01 = run.getBean(&quot;user01&quot;, User.class); Pet pet01 = run.getBean(&quot;pet01&quot;, Pet.class); MyConfig myConfig = run.getBean(MyConfig.class); &#125;&#125; Full模式与Lite模式 配置类组件之间无依赖关系用Lite模式加速客器启动过程,减少判断 配置类组件之间有依赖关系,方法会被调用得到之前单实例组件,用Full模式 @ComponentScan 包扫描1234// 一下三者相当于@SpringBootApplication@ComponentScan(&quot;com.myspringboot2&quot;) //包扫描地址@EnableAutoConfiguration@SpringBootConfiguration @Import 注入对象1@Import(&#123;User.class, DBHelper.class&#125;) //向容器中添加对应类型的对象,默认对象名为对应类的全类名 @Conditional 条件装配使用 MyConfig.java 12345678@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; @ConditionalOnBean(name = &quot;pet02&quot;) // 按条件执行向容器中注入对象,可放在类上(则按条件执行是否注入类中所有的对象) @Bean //向容器中添加组件，id为方法名(可以自定义)，组件类型为返回类型，组件在容器中的实例为返回地值 public User user01() &#123; return new User(&quot;zhangsan&quot;, 18); &#125;&#125; 测试 MainApplication.java 123456789@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类，返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 由于user01配置的是由添加了ConditinalOnBean,而其中的条件pet02对象并不在容器当中，所以未注入user01 System.out.println(run.containsBean(&quot;user01&quot;)); &#125;&#125; @ImportResource 导入xml配置文件1234@ImportResource(&quot;classpath:beans.xml&quot;) //兼容xml配置@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123;&#125; 123456789@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类，返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 使用@ImportResource成功注入beans.xml中的对象 System.out.println(run.containsBean(&quot;user01&quot;)); &#125;&#125; @ConfigurationProperties 配置绑定编写属性， application.properties，注意使用全小写 12mycar.brand=ABCmycar.price=100000 第一种方法：需要在容器中的组件上使用， Car.java 1234567@Component //声明为组件，只有容器中的组件才能使用@ConfigurationProperties(prefix = &quot;mycar&quot;) //绑定配置文件中的属性，prefix指定对应前缀public class Car &#123; String brand; Integer price; // ……&#125; 第二种方法：不使用@Component声明Car为组件，而是在配置类种开启指定对象的属性配置功能 12345@EnableConfigurationProperties(Car.class) //开启指定对象的属性配置功能@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; // ……&#125; 测试， HelloController.java 123456789@RestControllerpublic class HelloController &#123; @Autowired Car car; @RequestMapping(&quot;/car&quot;) public Car car() &#123; return car; &#125;&#125; 自动配置原理（源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili @SpringBootApplication 声明当前是一个配置类 @ComponentScan 指定扫描路径 @EnableAutoConfiguration@AutoConfigurationPackage 利用Registrar将当前包下的所有组件全部导入进容器 @Import 导入默认组件 便捷使用Lombok 简化JavaBean编写等 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 编写JavaBean 1234567@NoArgsConstructor //自动编写无参构造器@AllArgsConstructor //自动编写全参构造器@Data //自动编写set/get/toString方法public class Car &#123; String brand; Integer price;&#125; 编写controller的日志打印 12345678910@Slf4j //引入日志接口@RestControllerpublic class HelloController &#123; // 映射请求的地址 @RequestMapping(&quot;/hello&quot;) public String handle1() &#123; log.info(&quot;hello&quot;); //日志打印信息 return &quot;Hello,SpringBoot2&quot;; &#125;&#125; Dev-tools、JRebel 自动重启、热更新 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 使用 Ctrl+F9 更新 Spring Initializr 快速创建springboot应用，创建应用时选择即可 配置文件propertiesyaml基本语法 key: value #注意空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进空格数无影响，同层级的元素需要左对齐 #编写注释 “”双引号内\\n等不转义，仍然是回车的本意显示为回车，’’单引号内转义，\\n显示为字符串 数据类型 字面量 1key: value 对象 123456k: &#123;k1: v1,k2: v2,k3: v3&#125;# 或k: k1: v1 k2: v2 k3: v3 数组 123456k: [v1,v2,v3]# 或k: - v1 - v2 - v3 示例雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili configuration-processor 配置处理器 添加依赖 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;!-- 打包的时候不带这个包 --&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; web开发简单功能静态资源访问 静态资源目录 存放路径：类路径(resources资源根目录)下的/static or /public or /resources or /META-INF/resources 访问路径：项目根路径/静态资源名 原理： 静态映射/**。请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面 改变默认的静态资源访问路径和存放路径，在配置文件application.yaml中编写 12345spring: mvc: static-path-pattern: /res/** #res为自定义前缀，即访问地址须在项目根路径/res/静态资源名 resources: static-locations: [classpath:/自定义文件夹名/] 欢迎页命名为index.html放在静态资源目录下即可。 自定义Favicon命名为favicon.ico 放在静态资源目录下即可。 源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 请求处理@xxxMapping 请求映射 Rest风格支持（使用HTTP请求方式动词来表示对资源的操作） 以前：**/getUser 获取用户 /deleteUser 删除用户 /editUser 修改用户 /saveUser 保存用户 现在： /user GET-获取用户 DELETE-删除用户 PUT-修改用户 POST-保存用户 编写controller类 1234567891011121314151617181920212223@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET) public String getUser() &#123; return &quot;getUser GET&quot;; &#125; @PostMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST) public String saveUser() &#123; return &quot;saveUser POST&quot;; &#125; @PutMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT) public String modifiedUser() &#123; return &quot;modifiedUser PUT&quot;; &#125; @DeleteMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE) public String deleteUser() &#123; return &quot;deleteUser DELETE&quot;; &#125;&#125; 编写页面 12345678910111213141516&lt;form action=&quot;/user&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;get提交&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;post提交&quot;&gt;&lt;/form&gt;&lt;!-- form表单中method只能写get/post --&gt;&lt;!-- 使用隐藏域传递_method方法参数的值 --&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;PUT提交&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;DELETE提交&quot;&gt;&lt;/form&gt; 在配置文件中开启hiddenmethod-filter(默认为false)，如果前端不是使用表单发送请求则不需要开启filter 12345spring: mvc: hiddenmethod: filter: enabled: true 自定义HiddenMethodFilter编写配置类，自定义filter 12345678@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; public HiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; HiddenHttpMethodFilter filter = new HiddenHttpMethodFilter(); filter.setMethodParam(&quot;_m&quot;); //修改方法参数名为_m return filter; &#125;&#125; 请求映射原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 参数注解@PathVariable、@RequestHeader、@RequestParam、@CookieValue、@RequestBody12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@RestControllerpublic class ParamTestController &#123; // 测试url: http://localhost:8080/test1/1/lisi?age=10&amp;inters=%E5%90%83%E9%A5%AD&amp;inters=%E7%9D%A1%E8%A7%89 @GetMapping(&quot;/test1/&#123;id&#125;/&#123;username&#125;&quot;) public Map&lt;String, Object&gt; test1(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String, String&gt; variables, @RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader Map&lt;String, String&gt; headers, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, @RequestParam Map&lt;String,String&gt; params1, @RequestParam MultiValueMap&lt;String, String&gt; params2, @CookieValue(&quot;_xsrf&quot;) String _xsrf, @CookieValue(&quot;_xsrf&quot;) Cookie cookie) &#123; /** * @PathVariable(&quot;&quot;) 获得指定路径变量名的值 * @PathVariable 获得所有路径变量名以及值，存放到Map&lt;String, String&gt;中 * 注意后者键值对对应的是地址栏中的username参数名，而前者是形参名name * * @RequestHeader(&quot;&quot;) 获得请求头中指定key的值 * @RequestHeader 获得请求头中所有的key及其值 * * @RequestParam(&quot;&quot;) 获得指定请求参数名的值 * @RequestParam 获得所有请求参数名以及值，存放到Map&lt;String, String&gt;中 * 注意后者存放在map中，kv只有一对，可使用MultiValueMap获取到一对多的键值对。 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 以下是测试 map.put(&quot;id&quot;, id); map.put(&quot;name&quot;, name); map.put(&quot;pv&quot;, variables); map.put(&quot;userAgent&quot;, userAgent); map.put(&quot;rh&quot;, headers); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params1&quot;,params1); map.put(&quot;params2&quot;,params2); map.put(&quot;_xsrf&quot;,_xsrf); System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;/test2&quot;) public Map&lt;String, Object&gt; test2(@RequestBody String content)&#123; /** * @RequestBody 获得请求体中所有的key及对应值 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 以下是测试 map.put(&quot;content&quot;, content); return map; &#125;&#125; @RequestAttribute 获取域对象参数值1234567891011121314151617181920212223@Controller //注意RestController写return &quot;forward:/success&quot;只会解析成字符串public class RequestController &#123; @GetMapping(&quot;/goto&quot;) public String gotoPage(HttpServletRequest req) &#123; req.setAttribute(&quot;msg&quot;, &quot;信息&quot;); req.setAttribute(&quot;code&quot;, &quot;信息123123&quot;); return &quot;forward:/success&quot;; //转发到/success请求 &#125; @ResponseBody @GetMapping(&quot;/success&quot;) public Map&lt;String, Object&gt; success(@RequestAttribute(&quot;msg&quot;) String msg, @RequestAttribute(&quot;code&quot;) String code) &#123; /** * @RequestAttribute 获得request域对象中的指定值 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;, msg); map.put(&quot;code&quot;, code); return map; &#125; &#125; @MatrixVariable 获取矩阵变量12345678910111213141516171819202122232425262728//1、矩阵变量语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd //2、SpringBoot默认是禁用了矩阵变量的功能 // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。 // removeSemicolonContent（移除分号内容）支持矩阵变量的 //3、矩阵变量必须有url路径变量才能被解析 @GetMapping(&quot;/cars/&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; // /boss/1;age=20/2;age=10 @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125; 12345678910111213141516171819202122@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; public HiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; HiddenHttpMethodFilter filter = new HiddenHttpMethodFilter(); filter.setMethodParam(&quot;_m&quot;); //修改_method return filter; &#125; @Bean // 自定义其中的功能,此处演示启用矩阵变量功能 public WebMvcConfigurer webMvcConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper = new UrlPathHelper(); // 设置不删除分号内容 urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125; &#125;; &#125;&#125; ServletAPI WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 参数注解源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 直接看困了，以后再看吧。 自定义参数绑定 编写两个bean 12345678@Datapublic class User &#123; String username; String password; Integer age; Date birthday; Pet pet;&#125; 12345@Datapublic class Pet &#123; String name; Integer age;&#125; 编写表单 12345678&lt;form action=&quot;/saveuser&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot;&gt; 生日：&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt; 宠物名字：&lt;input type=&quot;text&quot; name=&quot;pet.name&quot;&gt; 宠物年龄：&lt;input type=&quot;number&quot; name=&quot;pet.age&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;POST提交&quot;&gt;&lt;/form&gt; 编写controller测试 1234@PostMapping(&quot;/saveuser&quot;)public User saveuser(User user) &#123; return user;&#125; 自定义转换器12345678910111213141516171819202122232425@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; @Bean // 自定义其中的功能 public WebMvcConfigurer webMvcConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new Converter&lt;String, Date&gt;() &#123; @Override public Date convert(String s) &#123; SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try &#123; date = sf.parse(s); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; &#125;); &#125; &#125;; &#125;&#125; 数据响应与内容协商响应JSON数据 引入jackson.jar，已包含在starter-web场景启动器中 使用注解@ResponseBody 响应原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 内容协商 根据客户端接收能力不同，返回不同媒体类型的数据。 以xml为示例，引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt; 请求头里accept字段，设置了接收数据以xml格式为优先 开启基于请求参数的内容协商原理，同时url中添加请求参数format=xxx即可 1234spring: mvc: contentnegotiation: favor-parameter: true 内容协商原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 自定义MessageConvertor雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 视图解析与模板引擎thymeleaf java模板引擎 基本语法 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 编写模板 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;默认的值&lt;/h1&gt; &lt;h2&gt; &lt;a href=&quot;www.google.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;跳转百度&lt;/a&gt; &lt;a href=&quot;www.google.com&quot; th:href=&quot;@&#123;link&#125;&quot;&gt;跳转百度&lt;/a&gt; &lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 编写controller 1234567891011@Controllerpublic class ViewTestController &#123; @GetMapping(&quot;/testsuccess&quot;) public String test(Model model) &#123; // model中的数据会被放在请求域中 model.addAttribute(&quot;msg&quot;, &quot;msgTest&quot;); model.addAttribute(&quot;link&quot;, &quot;https://www.baidu.com&quot;); // 跳转页面写页面的前名 return &quot;success&quot;; &#125;&#125; 拦截器雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 编写Interceptor 123456789101112131415161718192021222324252627282930313233343536/** * 登陆检查 */@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; /** * 目标方法执行之前 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info(&quot;Run LoginInterceptor.preHandle&quot;); HttpSession session = request.getSession(); Object loginUser = session.getAttribute(&quot;loginUser&quot;); if (loginUser != null) &#123; return true; &#125; else &#123; session.setAttribute(&quot;msg&quot;, &quot;当前尚未登录&quot;); response.sendRedirect(&quot;/&quot;); return false; &#125; &#125; /** * 目标方法执行之后 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;Run LoginInterceptor.postHandle&quot;,modelAndView); &#125; /** * 页面渲染以后 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info(&quot;Run LoginInterceptor.afterCompletion&quot;,ex); &#125;&#125; 编写WebConfig类，添加interceptor 12345678910@Configurationpublic class AdminWebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 添加拦截器，并且设置拦截地址与不拦截地址 // /**拦截目录下所有资源，静态资源也会被拦截 registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/js/**&quot;,&quot;/font/**&quot;,&quot;/images/**&quot;); // 设置exlucde不拦截，或者在配置文件中编写static-path-pattern=/static/**，注意此时需要修改标签中的href &#125;&#125; 文件上传雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 编写controller 1234567891011121314151617181920212223242526272829303132333435/** * 文件上传测试 */@Slf4j@Controllerpublic class FormTestController &#123; @GetMapping(&quot;/form_layouts&quot;) public String formLayouts() &#123; return &quot;form/form_layouts&quot;; &#125; /** * MultipartFile自动封装上传过来的文件 */ @PostMapping(&quot;/upload&quot;) public String upload(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;name&quot;) String name, @RequestPart(&quot;headImg&quot;) MultipartFile headImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123; // 获取的信息 log.info(&quot;上传的信息：email=&#123;&#125;,name=&#123;&#125;,headImg=&#123;&#125;,photos=&#123;&#125;&quot;, email, name, headImg.getSize(), photos.length); if (!headImg.isEmpty()) &#123; // 获取原文件名、保存到服务器 headImg.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\test1\\\\&quot;+headImg.getOriginalFilename())); &#125; if (photos.length &gt; 0) &#123; for (MultipartFile photo : photos) &#123; if (!photo.isEmpty()) &#123; photo.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\test2\\\\&quot;+photo.getOriginalFilename())); &#125; &#125; &#125; return &quot;index&quot;; &#125;&#125; 编写配置文件 123#修改上传文件的最大大小spring.servlet.multipart.max-file-size=10MBspring.servlet.multipart.max-request-size=100MB 异常处理 默认情况下，Spring Boot提供/error处理所有错误的映射 对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。 对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据 自定义错误页在将400.html、500.html等页面放在resources &gt; templates &gt;error下即可 自定义异常处理@ControllerAdvice+@ExceptionHandler1234567891011121314151617/** * 处理整个web controller的异常 */@Slf4j@ControllerAdvice //注明这是一个增强的controllerpublic class GlobalExceptionHandler &#123; /** * 处理数学异常、空指针异常 * @param e * @return */ @ExceptionHandler(&#123;ArithmeticException.class, NullPointerException.class&#125;) // 表明用于处理指定异常 public String handleArithException(Exception e) &#123; log.error(&quot;异常是：&#123;&#125;&quot;, e); return &quot;error/404&quot;; // 指定返回视图的地址 &#125;&#125; @ResponseStatus+自定义Exception123456789@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;用户数量太多&quot;) //注明异常返回状态码和原因public class UserTooManyException extends RuntimeException &#123; public UserTooManyException() &#123; &#125; public UserTooManyException(String msg) &#123; super(msg); &#125;&#125; 自定义HandlerExceptionResolver123456789101112@Componentpublic class CustomerHandlerExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; try &#123; httpServletResponse.sendError(511, &quot;自定义错误&quot;); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return new ModelAndView(); &#125;&#125; 原生组件注入ServletAPI@ServletComponentScan主应用类中使用@ServletComponentScan配置扫描路径 1234567@ServletComponentScan(basePackages = &quot;com.spb_adminex.servlet&quot;) //配置servlet、filter、listener扫描地址@SpringBootApplicationpublic class SpbAdminexApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpbAdminexApplication.class, args); &#125;&#125; @WebServlet1234567@WebServlet(urlPatterns = &quot;/my&quot;)public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write(&quot;MyServlet running&quot;); &#125;&#125; @WebFilter1234567891011121314151617@Slf4j@WebFilter(urlPatterns = &#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;)public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; log.info(&quot;MyFilter初始化&quot;); &#125; @Override public void destroy() &#123; log.info(&quot;MyFilter销毁&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; log.info(&quot;MyFilter running&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; @WebListener123456789101112@Slf4j@WebListenerpublic class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; log.info(&quot;MyListener监听到项目初始化完成&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; log.info(&quot;MyListener监听到项目销毁&quot;); &#125;&#125; RegisterBean编写一个配置类 1234567891011121314151617@Configurationpublic class MyRegisterConfig &#123; @Bean public ServletRegistrationBean myServlet() &#123; return new ServletRegistrationBean(new MyServlet(), &quot;/my&quot;); &#125; @Bean public FilterRegistrationBean myFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new MyFilter()); filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;)); return filterRegistrationBean; &#125; @Bean public ServletListenerRegistrationBean myListener() &#123; return new ServletListenerRegistrationBean(new MyListener()); &#125;&#125; 数据访问SQL使用默认数据源、jdbcTemplate 导入starter场景和数据库驱动 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 编写配置文件application.yaml 123456spring: datasource: url: jdbc:mysql://localhost:3306/online_bookstore username: root password: 123456789 driver-class-name: com.mysql.cj.jdbc.Driver 使用jdbcTemplate测试 1234567891011@Slf4j@SpringBootTestclass SpbAdminexApplicationTests &#123; @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() &#123; Long count = jdbcTemplate.queryForObject(&quot;select count(*) from admin&quot;, Long.class); log.info(&quot;当前表的记录数为&quot; + count); &#125;&#125; 使用Druid数据源 引入数据源 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 编写数据源配置类 12345678910@Configurationpublic class MyDataSourceConfig &#123; // 引入自己的数据源之后，自动配置的默认DataSource失效 @ConfigurationProperties(&quot;spring.datasource&quot;) //将组件与配置文件中的属性绑定 @Bean public DataSource dataSource() &#123; DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; &#125;&#125; 测试 12345678910@Slf4j@SpringBootTestclass SpbAdminexApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() &#123; log.info(&quot;当前数据源类型为&#123;&#125;&quot;, dataSource.getClass()); &#125;&#125; 其他👉雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 使用xml配置文件整合MyBatis 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt; 编写application.yaml配置文件 123mybatis: config-location: classpath:mybatis/mybatis-config.xml #全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 编写mybatis-config.xml全局配置文件/或者编写application配置文件(此时不能同时配置全局配置文件位置) 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;settings&gt;&lt;!-- 开启下划线转驼峰命名法 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;&lt;/configuration&gt; 1234mybatis: mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 configuration: map-underscore-to-camel-case: true #开启下划线转驼峰命名法 编写beanMapper接口 12345@Mapper //注明这是一个mapper接口public interface AdminMapper &#123; public Admin getAdmin(Integer id); public Boolean insertAdmin(Admin admin);&#125; 编写beanMapper.xml配置文件 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.spb_adminex.mapper.AdminMapper&quot;&gt; &lt;select id=&quot;getAdmin&quot; resultType=&quot;com.spb_adminex.bean.Admin&quot; &gt; select * from admin where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;insertAdmin&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into admin(`account`,`password`) values(#&#123;account&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 编写service层 123456789101112@Servicepublic class AdminService &#123; @Autowired AdminMapper adminMapper; public Admin getAdminById(Integer id) &#123; return adminMapper.getAdmin(id); &#125; public Boolean insertAdmin(Admin admin) &#123; return adminMapper.insertAdmin(admin); &#125;&#125; 编写controller层 1234567891011@Controllerpublic class AdminController &#123; @Autowired AdminService adminService; @ResponseBody @GetMapping(&quot;/getAdmin&quot;) public Admin getAdminById(@RequestParam(&quot;id&quot;) Integer id) &#123; return adminService.getAdminById(id); &#125;&#125; 使用注解整合MyBatis 其余文件，且不需要beanMapper.xml 编写beanMapper接口 12345@Mapper //注明这是一个mapper接口public interface AdminMapper &#123; @Select(&quot;select * from admin where id=#&#123;id&#125;&quot;) //注解替换beanMapper.xml文件 public Admin getAdmin(Integer id);&#125; 整合MyBatis-Plus快速开始 | MyBatis-Plus (baomidou.com) 获取数据 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt; 为启动类添加@MapperScan，注明扫描Mapper文件的地址 123456789@SpringBootApplication@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(QuickStartApplication.class, args); &#125;&#125; 编写全局配置文件 123456spring: datasource: url: jdbc:mysql://localhost:3306/spb_adminex username: root password: 123456789 driver-class-name: com.mysql.cj.jdbc.Driver 编写Bean类 12345678910111213@NoArgsConstructor@AllArgsConstructor@Data@TableName(&quot;user&quot;) //可以指定表名，不知道则默认为类名public class User &#123; private Long id; private String name; private String age; private String email; @TableField(exist = false) //注明当前字段在表中不存在 private String test;&#125; 编写BeanMapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 编写BeanService接口 123public interface UserService extends IService&lt;User&gt; &#123;&#125; 编写BeanServiceImpl实现类 1234@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;&#125; 编写controller 12345678910111213141516171819@Controllerpublic class TableController &#123; @Autowired UserService userService = new UserServiceImpl(); @GetMapping(&quot;/dynamic_table&quot;) public String dynamicTable(Model model) &#123; List&lt;User&gt; userList = userService.list(); model.addAttribute(&quot;userList&quot;, userList); return &quot;table/dynamic_table&quot;; &#125; @GetMapping(&quot;/responsive_table&quot;) public String responsiveTable() &#123; return &quot;table/responsive_table&quot;; &#125; @GetMapping(&quot;/editable_table&quot;) public String editableTable() &#123; return &quot;table/editable_table&quot;; &#125;&#125; 分页操作 编写MybatisPlugConfig 12345678910@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; // 创建MybatisPlusInterceptor MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 编写controller 12345678910111213141516171819202122232425@Controllerpublic class TableController &#123; @Autowired UserService userService = new UserServiceImpl(); // 进入dynamic_table并展示分页数据 @GetMapping(&quot;/dynamic_table&quot;) public String dynamicTable(@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)Integer pn, Model model) &#123; // 获得分页结果对象，并设置分页 Page&lt;User&gt; page = userService.page(new Page&lt;User&gt;(pn, 2)); model.addAttribute(&quot;page&quot;, page); // page.getRecords获得所有记录，page.current获得当前页数，page.pages获得总页数，page.getTotal获得总条数…… return &quot;table/dynamic_table&quot;; &#125; @GetMapping(&quot;/user/delete/&#123;id&#125;&quot;) // 删除用户功能 public String deleteUser(@PathVariable(&quot;id&quot;) Long id, @RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn, RedirectAttributes ra) &#123; userService.removeById(id); ra.addAttribute(&quot;pn&quot;, pn); return &quot;redirect:/dynamic_table&quot;; &#125;&#125; 编写html页面，thymeleaf语法详见雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 123456789101112131415161718192021222324252627282930313233343536373839&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,status:$&#123;page.getRecords()&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;status.count&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td&gt; &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;&quot; class=&quot;btn btn-primary&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;row-fluid&quot;&gt; &lt;div&gt; &lt;div class=&quot;dataTables_info&quot;&gt;当前第[[$&#123;page.current&#125;]]页 总计[[$&#123;page.pages&#125;]]页 总[[$&#123;page.getTotal&#125;]]条记录 &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class=&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt; &lt;ul&gt; &lt;li class=&quot;prev disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;← Previous&lt;/a&gt;&lt;/li&gt; &lt;li th:class=&quot;$&#123;num == page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;&quot; th:each=&quot;num:$&#123;#numbers.sequence(1,page.pages)&#125;&quot;&gt; &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;Next → &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; NoSQL(Redis)不尝试了没钱 单元测试@SpringBootTest123456@SpringBootTestclass MyTest &#123; @Test public void test() &#123; &#125;&#125; 常用注解 **@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 **@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍 **@RepeatedTest :**表示方法可重复执行，下方会有详细介绍 **@DisplayName :**为测试类或者测试方法设置展示名称 **@BeforeEach :**表示在每个单元测试之前执行 **@AfterEach :**表示在每个单元测试之后执行 **@BeforeAll :**表示在所有单元测试之前执行 **@AfterAll :**表示在所有单元测试之后执行 **@Tag :**表示单元测试类别，类似于JUnit4中的@Categories **@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore **@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误 **@ExtendWith :**为测试类或测试方法提供扩展类引用 断言机制雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili ……指标监控雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 高级特性后会有期源码和其他部分到时候(也不知道啥时候)会再去看的，but not today","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"}]},{"title":"【学习笔记】MyBatis","slug":"【学习笔记】MyBatis","date":"2021-07-16T11:12:59.990Z","updated":"2021-07-23T05:49:19.787Z","comments":true,"path":"2021/07/16/xue-xi-bi-ji-mybatis/","link":"","permalink":"http://example.com/2021/07/16/xue-xi-bi-ji-mybatis/","excerpt":"","text":"概述 mybatis是一个优秀的基于java的持久层框架,它内部封装了jdbc,使开发者只需要关注sq语句本身,而不需要花费精力去处理加载驱动、创建连接、创建 statement等繁杂的过程。 mybatis通过xm或注解的方式将要执行的各种 statement配置起来,并通过java对象和 statement中sq的动态参数进行映射生成最终执行的sq语句。 最后 mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题,对jdbc进行了封装,屏蔽了 jdbc api底层访问细节,使我们不用与 jdbc api打交道,就可以完成对数据库的持久化操作。 开发步骤 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 编写数据表与Bean类 创建并编写mapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.myspring.bean.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 创建并编写sqlMapConfig.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456789&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 调用操作 123456789101112// 获得核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis/sqlMapConfig.xml&quot;);// 获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);// 获得session会话对象SqlSession sqlSession = sqlSessionFactory.openSession();// 执行操作,参数即mapper.xml中的namespace.idList&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);// 测试System.out.println(userList);// 释放资源sqlSession.close(); 增删改查操作代码123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.myspring.bean.User&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 插入 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; insert into user values (#&#123;name&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; update user set age=#&#123;age&#125; where name = #&#123;name&#125; &lt;/update&gt;&lt;/mapper&gt; 1234567891011121314151617181920// 获得核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis/sqlMapConfig.xml&quot;);// 获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);// 获得session会话对象SqlSession sqlSession = sqlSessionFactory.openSession();// 查询List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);// 插入sqlSession.insert(&quot;userMapper.save&quot;, new User(&quot;李52四&quot;, 11));// 修改sqlSession.update(&quot;userMapper.update&quot;, new User(&quot;李52四&quot;, 110));// 删除sqlSession.delete(&quot;userMapper.delete&quot;, &quot;李52四&quot;);// 执行更新操作需要提交事务sqlSession.commit();// 释放资源sqlSession.close(); 配置文件常用标签environments标签 配置数据库环境，支持多环境 transactionManager事务管理器属性 JDBC: 这个配置就是直接使用了JDBC的提交和回滚设置,它依赖于从数据源得到的连接来管理事务作用域 MANAGED: 这个配置几乎没做什么。它从来不提交或回滚一个连接,而是让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文)。默认情况下它会关闭连接,然而一些容器并不希望这样,因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 daraSource数据源属性 UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。 JNDI:这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用,容器可以集中或在外部配置数据源,然后放置一个JNDI上下文的引用。 Mapper标签 加载映射，加载方式有多种。 使用相对于类路径的资源引用,例如:&lt; mapper resource=”org/ mybatis/ builder/ AuthorMapperxm”/&gt; 使用完全限定资源定位符(URL),例如:&lt; mapper url=”file//ar/ mappers/ Author Mapper.xm”/ 使用映射器接口实现类的完全限定类名,例如:&lt; mapper class=” org. mybatis builder. AuthorMapper”/&gt; 将包内的映射器接口实现全部注主册为映射器,例如:&lt; package name=” org. mybatis. builder”/&gt; Properties标签 实际开发中,习惯将数据源的配置信息单独抽取成个 properties文件,该标签可以加载额外配置的 properties文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 加载properties文件 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; typeAliases标签 起别名，有已经设置好的常用的类型的别名，也可自定义 1234&lt;!-- 自定义别名，注意标签在config.xml中的顺序 --&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.myspring.bean.User&quot; alias=&quot;user&quot;/&gt;&lt;/typeAliases&gt; MyBatis相关APISqlSession工厂构建器SqlSessionFactoryBuilder SqlSession工厂对象SqlSessionFactory SqlSession会话对象 DAO层实现 采用 Mybatis的代理开发方式实现DAO层的开发,这种方式是我们后面进入企业的主流。 Mapper接口开发方法只需要程序员编写 Mapper接口(相当于Dao接口),由 Mybatis框架根据接口定义创建接口的动态代理对象,代理对象的方法体同上边Dao接口实现类方法。 Mapper.xm文件中的 namespace与 mapper接口的全限定名相同 Mapper接口方法名和 Mapper. xm中定义的每个 statement的id相同 Mapper接口方法的输入参数类型和 mapper. xn中定义的毎个sql的 parameter Type的类型相同 Mapper接口方法的辅出参数类型和 mapper. xm中定义的每个sq的 resultType的类型相同 创建并编写Mapper.xml文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.myspring.dao.UserMapper&quot;&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据name查询所有 --&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 创建并编写Mapper接口 123456public interface UserMapper &#123; // 查询所有 List&lt;User&gt; findAll() throws Exception; // 根据id查询所有 User findById(int id);&#125; 调用 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;myBatis/sqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();User user = mapper.findById(2); 映射文件：动态sql语句123456789101112131415161718192021222324252627282930313233&lt;!-- sql语句抽取 --&gt;&lt;sql id=&quot;selectUser&quot;&gt; select * from user&lt;/sql&gt;&lt;!-- 动态条件 --&gt;&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-- 动态条件 --&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;where&gt; -- select * from user where id in(?,?) -- collection写list或array等 &lt;foreach collection=&quot;list&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 配置文件类型转换TypeHandler标签黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 插件plugins标签 添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 在配置文件中添加标签 12345&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 调用 12345678910111213141516171819// 分页助手，设置分页信息以分页，startPage(pageNum,pageSize)PageHelper.startPage(1, 1);// 当前页List&lt;User&gt; userList = mapper.findAll();// 分页信息PageInfo&lt;User&gt; userPageInfo = new PageInfo&lt;&gt;(userList);for (User user : userList) &#123; System.out.println(user);&#125;System.out.println(&quot;上一页：&quot; + userPageInfo.getPrePage());System.out.println(&quot;当前页：&quot; + userPageInfo.getPageNum());System.out.println(&quot;下一页：&quot; + userPageInfo.getNextPage());System.out.println(&quot;总页数：&quot; + userPageInfo.getPages());System.out.println(&quot;当前条数：&quot; + userPageInfo.getPageSize());System.out.println(&quot;总条数：&quot; + userPageInfo.getTotal());System.out.println(&quot;是否第一页：&quot; + userPageInfo.isIsFirstPage());System.out.println(&quot;是否末页：&quot; + userPageInfo.isIsLastPage()); 多表操作黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 注解开发使用xml开发crud1234&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.myspring.dao.UserMapper&quot;&gt; &lt;!-- sql语句抽取 --&gt; &lt;sql id=&quot;selectUser&quot;&gt; select * from user &lt;/sql&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;/select&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; -- select * from user where id in(?,?) -- collection写list或array等 &lt;foreach collection=&quot;list&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 插入 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; insert into user (name, age) values (#&#123;name&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; update user set age=#&#123;age&#125;, name=#&#123;name&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除 --&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 123456789101112131415public interface UserMapper &#123; List&lt;User&gt; findAll(); User findById(int id); List&lt;User&gt; findByCondition(User user); List&lt;User&gt; findByIds(List&lt;Integer&gt; ids); void save(User user); void update(User user); void delete(int id);&#125; 123456789101112131415161718192021222324252627282930313233343536373839public class UserMapperTest &#123; private UserMapper userMapper; @Before public void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;myBatis/sqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class); &#125; @Test public void testSave() throws Exception &#123; User user = new User(); user.setName(&quot;钱老板&quot;); user.setAge(90); userMapper.save(user); &#125; @Test public void testUpdate() throws Exception &#123; User user = userMapper.findById(3); user.setAge(99); userMapper.update(user); &#125; @Test public void testDelete() throws Exception &#123; userMapper.delete(4); &#125; @Test public void testFindById() throws Exception &#123; User user = userMapper.findById(3); System.out.println(user); &#125;&#125; 注解开发CRUD12345678910111213141516public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User findById(int id); @Insert(&quot;insert into user (name, age) values (#&#123;name&#125;, #&#123;age&#125;)&quot;) void save(User user); @Update(&quot;update user set age=#&#123;age&#125;, name=#&#123;name&#125; where id = #&#123;id&#125;&quot;) void update(User user); @Update(&quot; delete from user where id = #&#123;id&#125;&quot;) void delete(int id);&#125; 12345&lt;!-- 加载映射关系 --&gt;&lt;mappers&gt; &lt;!-- 指定接口所在的包 --&gt; &lt;package name=&quot;com.myspring.dao&quot;/&gt;&lt;/mappers&gt; 调用不变","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"}]},{"title":"【项目笔记】ssm整合练习简单CRUD项目","slug":"【项目笔记】ssm整合练习","date":"2021-07-16T07:09:38.168Z","updated":"2021-09-19T12:40:33.243Z","comments":true,"path":"2021/07/16/xiang-mu-bi-ji-ssm-zheng-he-lian-xi/","link":"","permalink":"http://example.com/2021/07/16/xiang-mu-bi-ji-ssm-zheng-he-lian-xi/","excerpt":"","text":"项目简介功能点 分页 数据校验 jQuery前端校验 JSR303后端校验 AJAX REST风格 技术点 基础框架ssm 数据库MySQL 请阿丹框架bootstrap 项目管理maven 分页插件pagehelper 逆向工程mybatis generator 基础环境搭建创建项目​ 创建maven项目，添加javaee-web application framework support 引入maven相关依赖​ 引入spring springmvc mybatis等相关依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssm_crud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!-- spring springmvc --&gt; &lt;dependencies&gt; &lt;!-- springmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring aspects aop面向切面编程 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池、驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 其他 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 引入前端框架​ 引入jQuery、Bootstrap 12345678&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; ssm整合配置文件web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 1、启动spring的容器 --&gt; &lt;!-- 设置全局参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 2、springmvc前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置xml地址 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 3、全局字符编码过滤器，注意这个过滤器一定要放在所有过滤器之前 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 4、过滤器：使用REST风格的URI 将页面普通的POST请求转为指定的delete或者put请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; spring-mvc.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- springMVC的配置文件 --&gt; &lt;!-- 配置组件扫描路径 --&gt; &lt;context:component-scan base-package=&quot;com.sss_crud&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- 只扫描controller(即所有注释controller的类) --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 过滤静态资源 （将springmvc不能处理的请求交给Tomcat，该标签表示当spring找不到资源时交由原始容器(tomcat)寻找） --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- mvc注解驱动 以及其他一些功能支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- spring配置文件 --&gt; &lt;!-- 配置组件扫描路径 --&gt; &lt;context:component-scan base-package=&quot;com.sss_crud&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- 不扫描controller(即所有注释controller的类) --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- 加载外部的properties文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源，事务控制 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; &lt;!-- mybatis整合 --&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- mybatis全局配置文件、数据源、mapper配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置扫描器，将mybatis接口的实现加入到IOC容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.sss_crud.mapper&quot; /&gt; &lt;/bean&gt; &lt;!-- 事务控制 --&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 开启基于注解的事务 --&gt; &lt;aop:config&gt; &lt;!-- 切入点表达式 --&gt; &lt;aop:pointcut id=&quot;txPoint&quot; expression=&quot;execution(* com.sss_crud.service..*(..))&quot; /&gt; &lt;!-- 配置事务增强 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPoint&quot; /&gt; &lt;/aop:config&gt; &lt;!-- 配置事务增强，事务如何切入 --&gt; &lt;tx:advice id=&quot;txAdvice&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 切入点切入的所有方法（连接点）都是事务方法 --&gt; &lt;tx:method name=&quot;*&quot; /&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;/beans&gt; jdbc.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=123456789 mybatis-config.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 开启驼峰命名 --&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt; &lt;/settings&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 自动扫描路径下的类并且起别名 --&gt; &lt;package name=&quot;com.sss_crud.bean&quot; /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 数据库构建ssm_crud.sql1234567891011121314151617181920212223242526272829SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tbl_dept-- ----------------------------DROP TABLE IF EXISTS `tbl_dept`;CREATE TABLE `tbl_dept` ( `dept_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;部门id&#x27;, `dept_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, PRIMARY KEY (`dept_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for tbl_emp-- ----------------------------DROP TABLE IF EXISTS `tbl_emp`;CREATE TABLE `tbl_emp` ( `emp_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;员工id&#x27;, `emp_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `gender` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `d_id` int NULL DEFAULT NULL, PRIMARY KEY (`emp_id`) USING BTREE, INDEX `fk_emp_dept`(`d_id`) USING BTREE, CONSTRAINT `fk_emp_dept` FOREIGN KEY (`d_id`) REFERENCES `tbl_dept` (`dept_id`) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; 基础模块mybatis逆向工程生成bean、mappergeneratorConfig.xml mybatis generator的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--注意targetProject中使用反斜杠，connectionURL需要添加useSSL=true--&gt; &lt;!--配置要链接的数据库的数据源--&gt; &lt;!-- &lt;classPathEntry location=&quot;E:/GARBAGE_TEMP_SPACE/mysql-connector-java-5.1.46.jar&quot; /&gt;--&gt; &lt;!---Mybatis上下文--&gt; &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- 取消生成的文件的全部自动注释 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--配置数据库的链接信息--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssm_crud?useSSL=false&quot; userId=&quot;root&quot; password=&quot;123456789&quot; /&gt; &lt;!--数据库BigDecimals字段在java中定义--&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!--实体类生成信息 指定javabean生成位置--&gt; &lt;javaModelGenerator targetPackage=&quot;com.sss_crud.bean&quot; targetProject=&quot;src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!--指定mybatis的mapper.xml映射文件地址--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!--指定mybatis的mapper接口生成地址--&gt; &lt;javaClientGenerator targetPackage=&quot;com.sss_crud.mapper&quot; targetProject=&quot;src\\main\\java&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!--要生成的表结构--&gt; &lt;table tableName=&quot;tbl_emp&quot; domainObjectName=&quot;Employee&quot; /&gt; &lt;table tableName=&quot;tbl_dept&quot; domainObjectName=&quot;Department&quot; /&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; MBGTest.class 运行mybatis generator以自动生成bean和mapper，可能需要手动添加构造器 123456789101112131415161718192021import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class MBGTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 当前项目结构 MapperTest单元测试引入maven123456&lt;!-- spring test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt;&lt;/dependency&gt; 添加可以批量操作的sqlSession 注意在applicationContext.xml文件中添加可以批量操作的sqlSession 12345&lt;!-- 一个可以执行批量操作的SQLSession --&gt;&lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;constructor-arg name=&quot;executorType&quot; value=&quot;BATCH&quot; /&gt;&lt;/bean&gt; MapperTest类编写123456789101112131415161718192021222324252627282930313233343536373839import com.sss_crud.bean.Employee;import com.sss_crud.mapper.DepartmentMapper;import com.sss_crud.mapper.EmployeeMapper;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.UUID;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class MapperTest &#123; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Autowired SqlSession session; @Test public void test() &#123; // departmentMapper.insertSelective(new Department(null, &quot;开发&quot;)); // departmentMapper.insertSelective(new Department(null, &quot;测试&quot;)); // employeeMapper.insertSelective(new Employee(null, &quot;Jerry&quot;, &quot;M&quot;, &quot;Jerry@qq.com&quot;, 1)); // employeeMapper.insertSelective(new Employee(null, &quot;Cat&quot;, &quot;W&quot;, &quot;Cat@qq.com&quot;, 2)); // 使用可以批量操作的session获得mapper,从而进行批量操作 EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); for (int i = 0; i &lt; 1000; i++) &#123; String uid = UUID.randomUUID().toString().substring(0, 5) + i; mapper.insertSelective(new Employee(null, uid, &quot;M&quot;, uid + &quot;@qq.com&quot;, 1)); &#125; &#125;&#125; 查询功能 此功能需要使用分页插件pageHelper pagehelper分页插件引入maven依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt; 配置mybatis-config.xml以使用插件1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- ...... --&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; viewsindex.jsp12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 跳转至展示所有员工信息 --%&gt; &lt;jsp:forward page=&quot;/emps&quot;&gt;&lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; serviceEmployeeServiceImpl.java123456789101112131415161718192021package com.sss_crud.service.impl;import com.sss_crud.bean.Employee;import com.sss_crud.mapper.EmployeeMapper;import com.sss_crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; public List&lt;Employee&gt; getAll() &#123; return employeeMapper.selectByExampleWithDept(null); &#125;&#125; controllerEmployeeController.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.sss_crud.controller;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.sss_crud.bean.Employee;import com.sss_crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import java.util.List;/** * 处理员工CRUD请求 */@Controllerpublic class EmployeeController &#123; @Autowired EmployeeService employeeService; /** * 查询员工数据（分页） * url请求参数“pn”为请求页数 * * @return */ @RequestMapping(&quot;/emps&quot;) public ModelAndView getEmps(@RequestParam(value = &quot;pn&quot;, defaultValue = &quot;1&quot;) Integer pn) &#123; ModelAndView mav = new ModelAndView(); // 使用pageHelper实现分页功能 PageHelper.startPage(pn, 5); // 查询（此时的数据已经是分页后的数据） List&lt;Employee&gt; emps = employeeService.getAll(); // 使用pageInfo包装（加入其他更多的信息，所有页，当前页等等） PageInfo pageInfo = new PageInfo(emps, 5); mav.addObject(&quot;pageInfo&quot;, pageInfo); mav.setViewName(&quot;list&quot;); return mav; &#125;&#125; Test单元测试12345678910111213141516171819202122232425262728293031323334353637383940import com.github.pagehelper.PageInfo;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@WebAppConfiguration(value = &quot;src/main/web&quot;)@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;, &quot;classpath:spring-mvc.xml&quot;&#125;)public class MvcTest &#123; //传入springmvc的ioc @Autowired WebApplicationContext context; // 虚拟MVC请求 获得请求结果 MockMvc mockMvc; @Before public void initMockMvc() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void test() throws Exception &#123; MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/emps&quot;).param(&quot;pn&quot;, &quot;1&quot;)).andReturn(); MockHttpServletRequest request = result.getRequest(); PageInfo pageInfo = (PageInfo) request.getAttribute(&quot;pageInfo&quot;); System.out.println(pageInfo); &#125;&#125; 没有成功，返回为null，我不理解，都spring了还用nm的jsp呢，不弄了！反正结构都差不多了实现逻辑也就那样，拜拜了您嘞！","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"【学习笔记】SpringMVC","slug":"【学习笔记】SpringMVC","date":"2021-07-15T05:37:42.134Z","updated":"2021-09-19T12:45:12.814Z","comments":true,"path":"2021/07/15/xue-xi-bi-ji-springmvc/","link":"","permalink":"http://example.com/2021/07/15/xue-xi-bi-ji-springmvc/","excerpt":"","text":"SpringMVC概述 SpringMVC是种基于Java的实现MVc设计模型的请求驱动类型的轻量级Web框架,属于Spring FrameWork的后续产品,已经融合在 Spring Web Flow中。 SpringMvC已经成为目前最主流的MVC框架之一,并且随着 Spring30的发布,全面超越 Struts2,成为最优秀的MVC框架。它通过一套注解,让一个简单的Java类成为处理请求的控制器,而无须实现任何接口。同时它还支持RESTful编程风格的请求。 SpringMVC快速开发步骤 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 123456789101112131415&lt;!-- springMVC前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置xml地址 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写controller 12345678910@Controllerpublic class UserController &#123; // 使用RequestMapping映射controller地址 @RequestMapping(&quot;/myController&quot;) public String save() &#123; System.out.println(&quot;Controller save running&quot;); // return要跳转的视图页面 return &quot;success.jsp&quot;; &#125;&#125; 在resources下新增spring-mvc.xmld的spring config文件 12345xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- controller的组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring.controller&quot;/&gt; SpringMVC组件解析@RequestMapping用于建立请求URL和处理请求方法之间的对应关系 位置 类上,请求URL的第一级访问目录。此处不写的话,就相当于应用的根目录 方法上,请求URL的第二级访问目录,与类上的使用@ ReqquestMapping标主的级目录起组成访问虚拟路径 return 后跟的路径：不加”/“，则从相对路径查询，否则从web路径下查询。 属性 value：用于指定请求的URL。它和path属性的作用是一样的 method：用于指定请求的方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和vaue必须和配置的一模一样 MVC命名空间引入12345&lt;!-- 命名空间 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;&lt;!-- 约束地址 --&gt;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; 组件扫描1&lt;context:component-scan base-package=&quot;com.myspring.controller&quot;/&gt; XML配置return重定义与请求转发12return &quot;forward:/success.jsp&quot;;return &quot;redirect:/success.jsp&quot;; 内部资源（视图）解析器 在spring-mvc.xml中配置如下 12345678910111213&lt;!-- 内部资源解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt; &lt;!-- 配置后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;2. 编写controller ```java // return &quot;/jsp/success.jsp&quot;; return &quot;success&quot; //效果与上述相同 SpringMVC数据响应页面跳转返回字符串1return &quot;/jsp/success.jsp&quot;; 返回ModelAndview对象在controller中编写如下 1234567891011121314151617181920212223242526272829// 第一种@RequestMapping(&quot;/myController1&quot;)public ModelAndView save2() &#123; ModelAndView modelAndView = new ModelAndView(); // 设置视图 modelAndView.setViewName(&quot;success&quot;); // 设置模型 modelAndView.addObject(&quot;username&quot;, &quot;qqq&quot;); return modelAndView;&#125;// 第二种@RequestMapping(&quot;/myController2&quot;)public ModelAndView save3(ModelAndView modelAndView) &#123; modelAndView.setViewName(&quot;success&quot;); modelAndView.addObject(&quot;username&quot;, &quot;qqq&quot;); return modelAndView;&#125;// 第三种@RequestMapping(&quot;/myController3&quot;)public ModelAndView save4(Model model) &#123; model.setAttribute(&quot;username&quot;, &quot;qqq&quot;); return &quot;success&quot;;&#125;// 第四种@RequestMapping(&quot;/myController4&quot;)public String save4(HttpServletRequest request) &#123; request.setAttribute(&quot;username&quot;, &quot;qqq&quot;); return &quot;success&quot;;&#125; 回写数据返回字符串（@ResponseBody）1234567891011// 第一种@RequestMapping(&quot;/myController1&quot;)public void save1(HttpServletResponse resp) throws IOException &#123; resp.getWriter().print(&quot;hello!!!&quot;);&#125;// 第二种,使用ResponseBody，用于区分页面跳转@RequestMapping(&quot;/myController2&quot;)@ResponseBodypublic String save2() &#123; return &quot;hello!!!&quot;;&#125; 返回JSON格式字符串 添加依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; 转换为JSON 1234567891011@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic String save() throws Exception &#123; // 获得bean User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); // 转换为JSON String userJson = new ObjectMapper().writeValueAsString(user); return userJson;&#125; 返回Spring自动转换Bean-&gt;JSON 配置spring-mvc.xml 12345678&lt;!-- 处理器映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 或者使用mvc注解驱动如下配置： 123456xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&lt;!-- mvc注解驱动 --&gt;&lt;mvc:annotation-driven/&gt; 编写controller 123456789// 第二种,使用ResponseBody，用于区分页面跳转@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic User save() throws Exception &#123; User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); return user;&#125; SpringMVC请求获取请求参数获取基本类型参数1234567@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(String username, int age) &#123; // 使用形参接收数据，注意此处参数名与表单中input的name值对应 System.out.println(username); System.out.println(age);&#125; 获取Bean类型参数123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(User user) &#123; // 实际上是使用了Bean对象里的set方法，所以要让参数的名字与set方法名对应，否则接收不到 System.out.println(user);&#125; 获取数据类型参数12345@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(String[] strs) &#123; System.out.println(Arrays.toString(strs));&#125; 获取集合类型参数 前端传输数据 123456789101112&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var userList = new Array(); userList.push(&#123;name: &quot;张三&quot;, age: 10&#125;); userList.push(&#123;name: &quot;李四&quot;, age: 20&#125;); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;$&#123;pageContext.request.contextPath&#125;/test/myController&quot;, data: JSON.stringify(userList), contentType: &quot;application/json;charset=utf-8&quot; &#125;)&lt;/script&gt; controller获得数据 123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(@RequestBody List&lt;User&gt; userList) &#123; // 注意 @RequestBody List&lt;User&gt; userList System.out.println(userList);&#125; 静态资源访问权限开放spring-mvc.xml中配置如下 1234&lt;!-- 开放资源访问，设置可访问地址 --&gt;&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;&lt;!-- 该标签表示当spring找不到时交由原始容器(tomcat)寻找 --&gt;&lt;mvc:default-servlet-handler/&gt; 全局编码过滤（防止中文乱码）12345678910111213&lt;!-- 全局编码过滤 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 参数绑定注解@RequestParam value: 与请求参数名称 required: 此在指定的请求参数是否必须包括,默认是true,提交时如果没有此参数则报错 defaultvalue: 当没有指定请求参数时,则使用指定的默认值赋值 123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(@RequestParam(value=&quot;name&quot;, required=false，defaultvalue=&quot;000&quot;) String username) &#123; // 将获得的参数name映射为所需要的username System.out.println(username);&#125; 获得Restfil风格参数 Restful是一种软件架构风格、设计风格,而不是标准,只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件,基于这个风格设计的软件可以更简洁,更有层次,更易于实现缓存机制等。 Restful风格的请求是使用“”ur+请求方式”表示次请求目的的,HTP协议里面四个表示操作方式的动词如下： GET: 用于获取资源 POST: 用于新建资源 PUT: 用于更新资源 DELETE: 用于删除资源 123456@RequestMapping(&quot;/myController/&#123;name&#125;&quot;)// 使用占位符&#123;&#125;@ResponseBodypublic void save(@PathVariable(&quot;name&quot;) String username) &#123; System.out.println(username);&#125; 自定义类型转换器黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 获得请求头@RequestHeader 文件上传 导入依赖 1234567891011dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 在spring-mvc.xml中配置文件上传解析器 12345678&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 上传文件的编码类型 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 上传文件总大小 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242800&quot;/&gt; &lt;!-- 上传单个文件的大小 --&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;5242800&quot;/&gt;&lt;/bean&gt; 编写controller 12345@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(MultipartFile uploadedFile) throws Exception &#123; uploadedFile.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\&quot; + uploadedFile.getOriginalFilename()));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(MultipartFile[] files) throws Exception &#123; for (MultipartFile file : files) &#123; file.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\&quot; + file.getOriginalFilename())); &#125;&#125;## SpringMVC拦截器interceptor&gt; Spring Mvc的拦截器类似于 Servlet开发中的过滤器 Filter,用于对处理器进行预处理和后处理。&gt;&gt; 将拦截器按一定的顺序联结成条链,这条链称为拦截器链( interceptor Chain)。在访问被拦截的方法或字段时,拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。### 开发步骤1. 编写interceptor ```java public class MyInterceptor implements HandlerInterceptor &#123; // 在目标方法执行之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); String param = request.getParameter(&quot;param&quot;); if (&quot;yes&quot;.equals(param)) &#123; return true; &#125; else &#123; request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request, response); return false; &#125; &#125; // 在目标方法执行之后，试图返回之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); // 可以对model进行修改 modelAndView.addObject(&quot;name&quot;, &quot;newName&quot;); &#125; // 在流程执行完毕之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion&quot;); &#125; &#125; 在spring-mvc.xml中配置interceptor 123456789101112131415&lt;mvc:interceptors&gt; &lt;!-- 对应执行顺序 --&gt; &lt;mvc:interceptor&gt; &lt;!-- 对哪些资源执行拦截操作 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 对应interceptor --&gt; &lt;bean class=&quot;com.myspring.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 对哪些资源执行拦截操作 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 对应interceptor --&gt; &lt;bean class=&quot;com.myspring.interceptor.MyInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 方法说明 SpringMVC异常处理简单异常处理器1234567891011&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 默认错误视图 --&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error1&quot;/&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;map&gt; &lt;!-- key:异常类型 value:错误视图 --&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error2&quot;/&gt; &lt;entry key=&quot;java.io.IOException&quot; value=&quot;error3&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 自定义异常处理器 黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 1listener","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"【学习笔记】Spring","slug":"【学习笔记】Spring","date":"2021-07-13T12:59:14.495Z","updated":"2021-09-19T07:07:36.261Z","comments":true,"path":"2021/07/13/xue-xi-bi-ji-spring/","link":"","permalink":"http://example.com/2021/07/13/xue-xi-bi-ji-spring/","excerpt":"","text":"什么是SpringSpring用来干什么 Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成。 Spring是分层的 Java SE/EE应用 full-stack轻量级开源框架,以loC(Inverse of Control:反转控制)和Aop(Aspect Oriented Programming:面向切面编程)为内核。 提供了展现层 Spring MVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库,逐渐成为使用最多的 Java EE企业应用开源框架。 Spring发展历程 1997年,BM提出了EB的思想1998年,SUN制定开发标准规范E丿B1.01999年,EB1.1发布2001年,EB2.0发布2003年,EB2.1发布2006年,EB3.0发布 Spring之父 Rod Johnson( Spring之父) 《Expert One-to-One J2EE Design and development(2002)》阐述了J2EE使用EB开发设计的优点及解决方案《Expert One-to-One J2EE Development without EJB(2004)》阐述了2E开发不使用EB的解决方式( Spring维形) Spring的优势 方便解耦,简化开发 通过 Spring提供的loC容器,可以将对象间的依赖关系交由 Spring进行控制,避免硬编码所造成的过度耦合。 用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码,可以更专注于上层的应用。 AOP编程的支持 通过 Spring的AOP功能,方便进行面向切面编程,许多不容易用传统OOP实现的功能可以通过AOP轻松实现。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来,通过声明式方式灵活的进行事务管理,提高发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作,测试不再是昂贵的操作,而是随手可做的事情。 方便集成各种优秀框架 Spring对各种优秀框架( Struts、 Hibernate、 Hessian、Quartz等)的支持。 降低 JavaEE AP的使用难度 Spring对 JavaEE API(如JDBC、 JavaMail、远程调用等)进行了薄薄的封装层,使这些APl的使用难度大为降低。 Spring体系结构 Spring快速开发步骤 导入maven依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Spring conf配置文件（通常命名为applicationContext） 配置如下 1&lt;bean id=&quot;userDao&quot; class=&quot;com.myspring.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 实现 1234567public class UserDaoDemo &#123; public static void main(String[] args) &#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; Spring配置文件Bean标签 用于配置对象交由 Spring来创建。默认情况下它调用的是类中的**无参构造函数,**如果没有无参构造函数则不能创建成功。 基本属性 id: Bean实例在 Spring容器中的唯一标识 class: Bean的全限定名称 scope：指对象的作用范围，取值如下 singleton、prototype下bean对象的不同创建时间singleton、prototype下bean对象的不同创建时间 Bean实例化三种方法 无参构造方法实例化 1234// 创建容器ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 从容器中获得对象UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); 工厂静态方法实例化 工厂实例方法实例化 演示视频 Bean的依赖注入 依赖注入( Dependency Injection)：它是 Spring框架核心|OC的具体实现在编写程序时,通过控制反转,把对象的创健建交给了 Spring,但是代码中不可能出现没有依赖的情况。OC解耦只是降低他们的依赖关系,但不会消除。例如:业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系,在使用 Spring之后,就让 Spring来维护了简单的说,就是坐等框架把持久层对象传入业务层,而不用我们自己去获取。 set方法（property标签）12345678&lt;!-- 第一种 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;!-- name属性值对应set方法名 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 第二种 --&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot; /&gt; 123456// UserServiceImpl中依赖注入，获得userDao对象private UserDao userDao;// set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 构造（有参）方法（constructor-arg标签）1234&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;!-- name属性值对应userServiceImpl内UserDao的属性名 --&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123456// 依赖注入，获得userDao对象private UserDao userDao;// 构造方法public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao;&#125; 注入数据的数据类型 普通数据类型 引用数据类型 集合数据类型 演示视频 分模块开发（import标签） 实际开发中, Spring的配置内容非常多,这就导致 Spring配置很繁杂且体积很大,所以,可以将部分配置拆解到其他配置文件中,而在 Spring主配置文件通过impor标签进行加载。 1&lt;import resource=&quot;applicationContext-user.xml&quot;&gt;&lt;/import&gt; Spring相关APIApplicationContext application Context：接口类型,代表应用上下文,可以通过其实例获得 Spring容器中的Bean对象 三种实现类 ClassPathXmlApplicationContext它是从类的根路径下加载配置文件推荐使用这种 FileSystemXmlApplicationContext它是从磁盘路径上加载配置文件,配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext当使用注解配置容器对象时,需要使用此类来创建 spring容器。它用来读取注解。 getBean()方法 12UserService userService1 = (UserService) app.getBean(&quot;userService&quot;);UserService userService2 = app.getBean(UserService.class); Spring配置数据源数据源（连接池）的作用 数据源(连接池)是提高程序性能如出现的 事先实例化数据源,初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 手动创建数据源的开发步骤 导入Maven依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 创建jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/数据库名jdbc.username=rootjdbc.password=123456789 加载properties配置文件 12345ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;);String driver = rb.getString(&quot;jdbc.driver&quot;);String url = rb.getString(&quot;jdbc.url&quot;);String username = rb.getString(&quot;jdbc.username&quot;);String password = rb.getString(&quot;jdbc.password&quot;); 创建数据源 1234567// 创建c3p0数据源ComboPooledDataSource dataSource = new ComboPooledDataSource();dataSource.setDriverClass(driver);dataSource.setJdbcUrl(url);dataSource.setUser(username);dataSource.setPassword(password);Connection connection = dataSource.getConnection(); 1234567// 创建Druid数据源DruidDataSource dataSource = new DruidDataSource();dataSource.setDriverClassName(driver);dataSource.setUrl(url);dataSource.setUsername(username);dataSource.setPassword(password);DruidPooledConnection connection = dataSource.getConnection(); 使用Spring创建数据源的开发步骤 导入相关依赖 在applicationContext中配置数据源bean 12345678910111213141516171819202122&lt;!-- 引入context命名空间和约束路径 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 加载外部的properties文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;&lt;!-- c3p0 --&gt;&lt;bean id=&quot;dataSource1&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- Driud --&gt;&lt;bean id=&quot;dataSource2&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/property&gt;&lt;/bean&gt; 创建数据源对象 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);DataSource dataSource = applicationContext.getBean(DataSource.class);Connection connection = dataSource.getConnection(); Spring注解开发 Spring原始注解主要是替代的配置 原始注解 组件扫描使用注解进行开发时,需要在 applicationContext. xm中配置组件扫描,作用是指定哪个包及其子包下的Bean，需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!-- 配置组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt; Dao类12&lt;!-- 配置文件 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.myspring.dao.impl.UserDaoImpl&quot; scope=&quot;prototype&quot;&gt; &lt;/bean&gt; 1234// 注解配置，写在类名之上@Component(&quot;userDao&quot;)// 第二种可读性更强@Repository(&quot;userDao&quot;) Service类1234&lt;!-- 配置文件 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot; /&gt;&lt;/bean&gt; 1234// 注解配置，写在类名之上@Component(&quot;userService&quot;)// 第二种可读性更强@Service(&quot;userService&quot;) 1234567891011// 注解配置，写在字段之前// Autowired从spring容器中根据 数据类型 进行匹配，所以同一数据类型只有单个bean可以只写Autowired@Autowired// Qualifier从spring容器中根据 id值类型 进行匹配，但是必须结合Autowired一起使用@Qualifier(&quot;userDao&quot;)// @Resource(name = &quot;userDao&quot;) 相当于前两者结合private UserDao userDao;// 此时类中可以不写set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 普通属性注入12@Value(&quot;$&#123;jdbc.driver&#125;&quot;)private String driver; 新注解 整合在一起的样子，如下： 1234567891011121314151617181920212223@Configuration // 标志该类是Spring的核心配置类@ComponentScan(&quot;com.myspring&quot;) // 配置组件扫描,替换&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt;@PropertySource(&quot;classpath:jdbc.properties&quot;) // 加载外部的properties文件,替换&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;public class SpringConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) // spring会将当前方法的返回值以指定名称存储到spring容器当中 public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 分模块如下（推荐）： 123456@Configuration // 标志该类是Spring的核心配置类@ComponentScan(&quot;com.myspring&quot;) // 配置组件扫描,替换&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt;@Import(&#123;DataSourceConfiguration.class,&#125;) //括号内写数组&#123;xxx.class,xxx.class&#125;,替换&lt;import resource=&quot;&quot;/&gt;public class SpringConfiguration &#123; &#125; 123456789101112131415161718192021@PropertySource(&quot;classpath:jdbc.properties&quot;) // 加载外部的properties文件,替换&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) // spring会将当前方法的返回值以指定名称存储到spring容器当中 public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; Spring集成junit 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 编写测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)// @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) // 非注解方式注入配置@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) // 注解方式注入配置public class SpringJunitTest &#123; @Resource(name = &quot;userService&quot;) private UserService userService; @Test public void test1() &#123; userService.save(); &#125;&#125; Spring集成web环境 应用上下文对象是通过 new ClasspathXmlApplication Context( spring配置文件)方式获取的,但是每次从容器中获得Bean时都要编写 new ClasspathXmlApplication Context( spring配置文件),这样的弊端是配置文件加载多次,应用上下文对象创建多次。 在Web项目中,可以使用 ServletcontextListener监听Web应用的启动,我们可以在Web应用启动时,就加载 Spring的配置文件,创建应用上下文对象 Application Context,在将其存储到最大的域 servletContext域中,这样就可以在任意位置从域中获得应用上下文 Application Context对象了 手动使用listener获取应用上下文对象 创建listener类 123456789101112131415public class ContextLoaderListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; // ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //使用非注解时用该方法创建 ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfiguration.class); // 使用注解时用该方法创建 // 将Spring的应用上下文对象存储到ServletContext域对象中 servletContextEvent.getServletContext().setAttribute(&quot;app&quot;, app); System.out.println(&quot;spring容器创建完毕&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; &#125;&#125; 在web.xml中配置listener 123&lt;listener&gt; &lt;listener-class&gt;com.myspring.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取servletContext域对象中的应用上下文对象 1ApplicationContext app = (ApplicationContext) this.getServletContext().getAttribute(&quot;app&quot;); 使用Spring获取应用上下文对象 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 123456789&lt;!-- 设置全局参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 配置监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取应用上下文对象 1WebApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(req.getServletContext()); JdbcTemplate概述 它是 spring框架中提供的个对象,是对原始繁琐的 dbc API对象的简单封装。 spring框架为我们提供了很多的操作模板类。例如:操作关系型数据的 dbcTemplate和 bernate Template,操作nosq数据库的 RedisTemplate,操作消息队列的 UmsTemplate等等。 手动开发步骤 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建数据库表和javaBean 创建jdbcTemplate对象、执行数据库操作 12345678910111213141516public class JdbcTemplateTest &#123; @Test // 测试dbcTemplate开发步骤 public void test() &#123; // 创建Druid数据源 DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456789&quot;); // 创建jdbcTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 数据库操作 jdbcTemplate.update(&quot;insert into test1 values(?,?)&quot;, &quot;张三&quot;, 18); &#125;&#125; Spring使用JdbcTemplate开发步骤 添加依赖 编写jdbc.properties文件 编写spring-config文件applicationContext.xml，添加数据源对象，jdbcTemplate对象 12345678910111213141516171819&lt;!-- 引入context命名空间和约束路径 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 加载外部的properties文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!-- Druid DataSource --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring JdbcTemplate --&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 编写代码 123456// 获得applicationContextApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 从容器中获得jdbcTemplate对象JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class);// 数据库操作jdbcTemplate.update(&quot;insert into test1 values(?,?)&quot;, &quot;张三&quot;, 18); 常用操作1234jdbcTemplate.update(&quot;update test1 set age=? where name =?&quot;, 10, &quot;张三&quot;);List&lt;User&gt; userList = jdbcTemplate.query(&quot;select * from test1&quot;, new BeanPropertyRowMapper&lt;&gt;(User.class));User user = jdbcTemplate.queryForObject(&quot;select * from test1 where age=?&quot;, new BeanPropertyRowMapper&lt;&gt;(User.class), 18);Long count = jdbcTemplate.queryForObject(&quot;select count(*) from test1&quot;, Long.class); AOP概述 AOP为 Aspect Oriented Programming的缩写,意思为面向切面编程,是通过预编译方式和运行期动态代理现程序功能的同统一维护的一种技术。 AOP是OOP的延续,是软件开发中的一个热点,也是 Spring框架中的个重要内容,是函数式编程的种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 作用与优势黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili JDK动态代理、cglib动态代理黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 概念 Target(目标对象):代理的目标对象。 Proxy(代理):—个类被AOP织入增强后,就产生一个结果代理类。 Joinpoint(连接点):所谓连接点是指那些被拦截到的点。在 spring中这些点指的是方法,因为 spring只支持方法类型的连接点。 Pointcut(切入点):所谓切入点是指我们要对哪些 Joinpoint迸行拦截的定义。 Advice(通知/增强):所谓通知是指拦截到 Joinpoint之后所要做的事情就是通知。 Aspect(切面):是切入点和通知(引介个)的结合。 eaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring釆用动态代理织入,而Aspect采用编译期织入和类装载期织入。 基于XML开发AOP步骤 导入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.7&lt;/version&gt;&lt;/dependency&gt; 创建目标接口和目标类 创建切面类（含增强方法） 123456789101112public class MyAspect &#123; public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125; public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;前置增强。。。&quot;); Object proceed = pjp.proceed(); System.out.println(&quot;后置增强。。。&quot;); return proceed; &#125;&#125; 配置applicationContext.xml 12345678910111213141516xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&lt;!-- 目标对象 --&gt;&lt;bean id=&quot;target&quot; class=&quot;com.myspring.aop.Target&quot;/&gt;&lt;!-- 切面对象 --&gt;&lt;bean id=&quot;myAspect&quot; class=&quot;com.myspring.aop.MyAspect&quot;/&gt;&lt;!-- 配置织入，即哪些方法需要哪些增强(前置后置增强等) --&gt;&lt;aop:config&gt; &lt;!-- 声明切面 --&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 切点+通知(增强) --&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(* com.myspring.aop.*.*(..))&quot;&gt;&lt;/aop:before&gt; &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.myspring.aop.*.*(..))&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) // 非注解方式注入配置public class SpringJunitTest &#123; @Autowired private TargetInterface target; @Test public void test1() &#123; target.save(); &#125;&#125; 切点表达式 12345678910&lt;aop:config&gt; &lt;!-- 声明切面 --&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 切点表达式的抽取 --&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.myspring.aop.*.*(..))&quot;/&gt; &lt;!-- 切点+通知(增强) --&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知类型 基于注解开发AOP 目标类、切面类 配置目标类、切面类 1234@Component(&quot;target&quot;)public class Target implements TargetInterface &#123;&#125; 12345678@Component(&quot;myAspect&quot;)@Aspect //标注当前是一个切面类public class MyAspect &#123; @Before(&quot;execution(* com.myspring.aop.*.*(..))&quot;) public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125;&#125; 配置applicationContext.xml 1234&lt;!-- 注解开发组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring.aop&quot;/&gt;&lt;!-- aop自动代理 --&gt;&lt;aop:aspectj-autoproxy/&gt; 切点表达式抽取12345678910111213@Component(&quot;myAspect&quot;)@Aspect //标注当前是一个切面类public class MyAspect &#123; @Before(&quot;pointCut()&quot;) public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125; // 定义切点表达式 @Pointcut(&quot;execution(* com.myspring.aop.*.*(..))&quot;) public void pointCut() &#123; &#125;&#125; 事务控制黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"【集训】Servlet","slug":"【集训】servlet","date":"2021-07-11T11:56:48.738Z","updated":"2021-07-23T05:50:22.649Z","comments":true,"path":"2021/07/11/ji-xun-servlet/","link":"","permalink":"http://example.com/2021/07/11/ji-xun-servlet/","excerpt":"","text":"什么是Servlet？ Servlet 是运行在 Web 服务器或应用服务器上的java程序，是Java EE规范之一（一种接口）。 它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层，即接收客户端发送过来的请求并且响应数据给客户端。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 💡配置Servlet 创建一个Java类并实现Servlet接口（一般通过继承HTTPServlet类去实现servlet） 重写方法，实现逻辑操作 在web.xml中配置这个servlet的访问地址 1234567891011121314&lt;!-- 给tomcat配置servlet相关信息 --&gt;&lt;servlet&gt; &lt;!-- 写明servlet的名字（一般使用类名即可） --&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;!-- 写明servlet的全类名 --&gt; &lt;servlet-class&gt;servlet.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 给servlet配置访问地址 --&gt;&lt;servlet-mapping&gt; &lt;!-- 写明需要配置访问地址的servlet --&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;!-- 写明为该servlet配置的访问地址 --&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;标签中 / 的作用：相当于拼接到 http://ip:port/工程路径后，即http://ip:port/工程路径/myServlet HTTP协议什么是HTTP协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准，即客户端与服务器之间通信、传输数据需要遵守的规则。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 请求与响应 客户端给服务器发送数据为请求，请求分为GET、POST请求 服务器给客户端回传数据为响应 💡HTTP协议内容 请求/响应行 请求/响应头： 属性名：属性值 请求/响应体： 重要，自行阅读学习 常见响应码 200：表示请求成功 302：表示请求重定向 404：表示服务器找不到该请求地址（地址有错） 500：表示服务器内部错误（代码有错） 💡表单处理、常用API request对象常用方法 方法介绍 getParameter(String name) 返回name指定参数的参数值 getParameterValues(String name) 返回包含参数name的所有值的数组 setAttribute(String,Object) 存储此请求中的属性 getAttribute(String name) 返回指定属性的属性值 getContextPath() 返回当前WEB项目相对路径 getMethod() 获取请求类型 getSession() 获取Session对象 getCookies() 获取所有Cookie,返回一个Cookie数组 request对象常用方法 方法介绍 setHeader() 设置消息头 setStatus() 设置状态码 addCookie() 添加Cookie getWriter() 获取通向浏览器的字符流 获取/回传数据123456789&lt;form action=&quot;http://localhost:8080/jsp_war_exploded/myServlet&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;画画&quot;&gt;画画 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;打篮球&quot;&gt;打篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;敲代码&quot;&gt;敲代码 &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345String username = req.getParameter(&quot;username&quot;);String password = req.getParameter(&quot;password&quot;);String[] hobby = req.getParameterValues(&quot;hobby&quot;);System.out.println(&quot;用户名：&quot;+username+&quot;,密码：&quot;+password);System.out.println(Arrays.toString(hobby)); 1resp.getWriter().println(&quot;&lt;div&gt;这是一个div&lt;/div&gt;&quot;); http://localhost:8080/jsp_war_exploded/myServlet?username=111&amp;password=222使用?传递参数 请求转发与重定向 1234String username = req.getParameter(&quot;username&quot;);req.setAttribute(&quot;key&quot;, &quot;MyServlet处理的信息:&quot;);System.out.println(&quot;MyServlet中的request获得的数据&quot;+username);req.getRequestDispatcher(&quot;/myServlet2&quot;).forward(req, resp); 123String username = req.getParameter(&quot;username&quot;);System.out.println(&quot;MyServlet2中的request获得的数据:&quot;+username);System.out.println(&quot;MyServlet2中显示之前处理并保存的数据:&quot;+req.getAttribute(&quot;key&quot;)); 请求转发的特点： 浏览器地址栏没有变化 一次请求 共享request中的数据 可以转发到WEB-INF目录下（工程路径下） 1234resp.sendRedirect(req.getContextPath()+&quot;/myServlet2&quot;);// req.getContextPath()获得当前WEB项目相对路径resp.sendRedirect(&quot;http://www.baidu.com&quot;);// 访问外部资源必写http 重定向的特点： 浏览器地址栏发生变化 两次请求 不共享request中的数据 不能访问WEB-INF目录下资源 可以访问工程外的资源 💡Filter过滤器自行学习 中文乱码问题12req.setCharacterEncoding(&quot;UTF-8&quot;);resp.setContentType(&quot;text/html;charset=UTF-8&quot;); 相关阅读材料 Web开发 - 廖雪峰的官方网站 (liaoxuefeng.com) 尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版_哔哩哔哩_bilibili 作业 熟悉servlet、jsp并实现一些功能，并写一篇博文。 博文内容要求（必须要求）： 写一篇博文记录你使用servlet、jsp实现功能时遇到了哪些困难、不理解、不知道该如何实现的地方，以及写上解决的过程与结果（未解决的也可以写上有哪些疑惑），或者学习笔记等等皆可。 功能实例（仅参考，不是最低/最高标准）： 含有登陆/注册页面、其他页面。 登录功能：手动输入信息，符合已存在的用户信息则成功登录。 注册功能：手动输入信息，不能重复注册已存在的用户名，否则注册失败。 用户展示：在页面上展示所有已经注册的用户的信息。 登陆过滤：其他页面，只有登陆成功后才可访问，否则跳转至登陆页面。 其他页面：利用循环控制语句或其他工具功能输出由后台传递而来的数据。 等等 提交内容与时间： 提交内容：程序源码+博文链接 提交时间：7.27日晚零点前，将压缩包命名为班级+姓名+学号发送至&#x37;&#48;&#55;&#56;&#50;&#x33;&#56;&#x31;&#52;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d; 可能时间太短无法实现太多功能，没有关系，程序源码附上自己实现了的东西就行，没有实现完整也没关系，实现了更多功能也挺好，这个作业打分主要看你的博文里面写的记录内容，程序主要是用来练习以熟悉servlet和jsp的，毕竟大作业会用到。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"}]},{"title":"【集训】jsp","slug":"【集训】jsp","date":"2021-07-11T07:14:09.093Z","updated":"2021-07-23T05:51:57.089Z","comments":true,"path":"2021/07/11/ji-xun-jsp/","link":"","permalink":"http://example.com/2021/07/11/ji-xun-jsp/","excerpt":"","text":"什么是JSP JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。 JSP全称Java Server Pages，是建立在JAVA基础上的一种网络编程语言，JSP是一种Java servlet（JSP在执行前首先被编译成一个Servlet），主要用于实现Java web应用程序的用户界面部分。 网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。 jsp &lt;-&gt; java(servlet)C:\\Users\\卢荟\\AppData\\Local\\JetBrains\\IntelliJIdea2021.1\\tomcat\\20e10a3d-4da9-4eee-b7fa-327b2feb3d84\\work\\Catalina\\localhost\\jsp_war_exploded\\org\\apache\\jsp 类似于上述文件目录（tomcat下的webapp目录下存放工程项目，只不过现在tomcat在idea里用）即找到生成的java文件。 可见JSP本质上就是一个Servlet，只不过无需配置映射路径，Web Server会根据路径查找对应的.jsp文件，如果找到了，就自动编译成Servlet再执行。 JSP语法JSP注释 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 HTML注释，通过浏览器查看网页源代码时可以看见注释内容 💡脚本（在JSP中编写Java代码）先导入jsp-api.jar和servlet-api.jar（tomcat自带，但是IDE并无提示会报红） 语法 描述 &lt;% 代码片段 %&gt; 一般定义变量和编写语句。 &lt;%! 声明代码 %&gt; 可以声明常量，编写方法，编写类 &lt;%= 表达式 %&gt; 表达式被转化成String，然后插入到表达式出现的地方 123456789101112131415161718192021&lt;%! public class MyMath &#123; int a,b; public MyMath(int a, int b) &#123; this.a = a; this.b = b; &#125; int doMath()&#123; return a+b; &#125; &#125;%&gt;&lt;% out.println(&quot;打印语句&quot;); MyMath myMath = new MyMath(1, 1); int num = myMath.doMath();%&gt;&lt;h1&gt; 和为&lt;%= num %&gt; &lt;/h1&gt;&lt;div&gt; &lt;%= &quot;&lt;h2&gt;这是一个标签&lt;/h2&gt;&quot; %&gt; &lt;/div&gt; 对于流程控制语句的编写可能稍微繁琐 123456789101112&lt;% int day = 1 %&gt;&lt;% if (day == 1 || day == 7) &#123; %&gt;&lt;p&gt;今天是周末&lt;/p&gt;&lt;% &#125; else &#123; %&gt;&lt;p&gt;今天不是周末&lt;/p&gt;&lt;% &#125; %&gt; &lt;%for ( int fontSize = 1; fontSize &lt;= 3; fontSize++)&#123; %&gt; &lt;font color=&quot;green&quot; size=&quot;&lt;%= fontSize %&gt;&quot;&gt; 菜鸟教程 &lt;/font&gt;&lt;br /&gt;&lt;%&#125;%&gt; 当然也可以用out对象输出 12345678&lt;% int fontSize; for ( fontSize = 10; fontSize &lt;= 13; fontSize++) &#123; out.write(&quot;&lt;div&gt;&quot;); out.write(fontSize+&quot;&quot;); out.write(&quot;&lt;/div&gt;&lt;br&gt;&quot;); &#125;%&gt; JSP指令JSP指令用来设置与整个JSP页面相关的属性。 JSP指令 描述 &lt;%@ page 属性名=”属性值” %&gt; 定义页面的依赖属性，导包 &lt;%@ include 属性名=”属性值” %&gt; 包含其他文件（静态包含） &lt;%@ taglib 属性名=”属性值” %&gt; 引入标签库的定义，可以是自定义标签 123&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot; &quot; %&gt; &lt;%@ include file=&quot; &quot;%&gt; JSP行为自行学习 1&lt;jsp:行为名 属性名=&quot;属性值&quot; /&gt; 中文编码问题1&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; 💡JSP九大内置对象与四大作用域四大域对象 对象 作用域 变化操作 pageContext 当前页面有效，当当前页面关闭或转到其他页面时，page对象将在响应回馈给客户端后释放。 跳转页面 request 当次请求有效，可以跨越forward()不重定向跳转前后的两页，可以通过setAttribute()方法实现页面中的信息传递。 两次请求 session 当前会话有效，指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应 关闭浏览器 application 所有应用程序中有效，整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。 关闭服务器 12345678910&lt;% pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;); request.setAttribute(&quot;key&quot;, &quot;request&quot;); session.setAttribute(&quot;key&quot;, &quot;session&quot;); application.setAttribute(&quot;key&quot;, &quot;application&quot;);%&gt;pageContext的值：&lt;%=pageContext.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;request的值：&lt;%=request.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;session的值：&lt;%=session.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;application的值：&lt;%=application.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt; 九大内置对象在生成的java文件中可以找到 对象 描述 作用域 request javax.servlet.http.HttpServletRequest 类的实例 request response javax.servlet.http.HttpServletResponse类的实例 pageContext out javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。 pageContext session javax.servlet.http.HttpSession 类的实例 session application javax.servlet.ServletContext 类的实例。与应用上下文有关 application config javax.servlet.ServletConfig 类的实例。这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 pageContext pageContext javax.servlet.jsp.PageContext 类的实例，提供对JSP页面所有对象以及命名空间的访问 pageContext page 指向当前JSP对象 pageContext exception exception 类的对象，代表发生错误的 JSP 页面中对应的异常对象，&lt;%@ page …… isErrorPage=”true” %&gt; pageContext EL表达式与JSTL标准标签库自行学习 💡MVC框架MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。 Model（模型）：如一个存取数据的对象或 JavaBean View（视图）：如jsp动态页面 Controller（控制器）：控制数据流向模型对象，并在数据变化时更新视图，使视图与模型分离开，如servlet MVC重要特点就是两种分离： 视图和数据模型的分离：使用不同的视图对相同的数据进行展示；分离可视和不可视的组件，能够对模型进行独立测试。因为分离了可视组件减少了外部（数据库也是一种外部组件）依赖利于测试。 视图和表现逻辑(Controller)的分离：Controller是一个表现逻辑的组件，并非一个业务逻辑组件。MVC可以作为表现模式也可以作为建构模式，意味这Controller也可以是业务逻辑。分离逻辑和具体展示，能够对逻辑进行独立测试。 MVC优缺点： 优点：低耦合、重用性高、生命周期成本低、部署快、可维护性高 缺点：没有明确的定义、不适合小、中型应用程序、增加系统结构和实现的复杂性、视图对模型数据的低效率访问 作业在上一个文档中已经声明，这两节课只要交一个作业就行。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"jsp","slug":"jsp","permalink":"http://example.com/tags/jsp/"}]}],"categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"微服务","slug":"微服务","permalink":"http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://example.com/tags/ElasticSearch/"},{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://example.com/tags/MyBatisPlus/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"Unity2D","slug":"Unity2D","permalink":"http://example.com/tags/Unity2D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"},{"name":"jsp","slug":"jsp","permalink":"http://example.com/tags/jsp/"}]}