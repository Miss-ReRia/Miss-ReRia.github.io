{"meta":{"title":"Reria's BLOG","subtitle":"","description":"","author":"reria","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-07-23T06:13:25.410Z","updated":"2021-07-23T06:13:25.410Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-07-24T06:04:10.054Z","updated":"2021-07-24T06:04:10.054Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-26T04:37:20.692Z","updated":"2021-07-26T04:36:37.020Z","comments":true,"path":"notice.html","permalink":"http://example.com/notice.html","excerpt":"","text":"本站默认替换了右键菜单， 如需唤醒原系统菜单请使用： ctrol + 右键"},{"title":"关于","date":"2021-07-25T10:36:20.062Z","updated":"2021-07-25T10:36:20.062Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"正在维护(其实是懒得写介绍🤭"},{"title":"我的朋友们","date":"2021-07-24T06:02:31.921Z","updated":"2021-07-24T06:02:31.921Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2021-07-24T06:00:48.297Z","updated":"2021-07-24T06:00:48.297Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-24T06:01:03.653Z","updated":"2021-07-24T06:01:03.653Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【集训】微信小程序(二)","slug":"【集训】微信小程序(二)","date":"2021-07-22T01:00:03.480Z","updated":"2021-07-23T05:35:01.858Z","comments":true,"path":"2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-er/","link":"","permalink":"http://example.com/2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-er/","excerpt":"","text":"API系统信息Object wx.getSystemInfoSync() | 微信开放文档 (qq.com) 1234567// 获取系统信息wx.getSystemInfo(&#123; success: (result) =&gt; &#123; console.log(result); console.log(result.model); &#125;,&#125;) 交互wx.showToast(Object object) | 微信开放文档 (qq.com) 12345678910111213141516// loading提示框wx.showLoading(&#123; title: &#x27;数据加载中&#x27;,&#125;)setTimeout(res =&gt; &#123; wx.hideLoading(&#123; success: (res) =&gt; &#123; console.log(&quot;加载完成&quot;); &#125;, &#125;)&#125;, 2000)// 消息提示wx.showToast(&#123; title: &#x27;提示信息&#x27;,&#125;) 路由跳转页面wx.navigateTo(Object object) | 微信开放文档 (qq.com) 1&lt;button type=&quot;primary&quot; bindtap=&quot;clickBtn&quot;&gt;跳转到demo01&lt;/button&gt; 123456789clickBtn() &#123; // 可带参数,调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会 wx.navigateTo(&#123; url: &#x27;/pages/demo05/demo05?id=111&#x27;, success: (res) =&gt; &#123; console.log(res); &#125; &#125;) &#125; 返回页面wx.navigateBack(Object object) | 微信开放文档 (qq.com) 1&lt;button bindtap=&quot;clickBack&quot; type=&quot;primary&quot;&gt;返回上一页&lt;/button&gt; 12345clickBack() &#123; wx.navigateBack(&#123; delta: 1, &#125;) &#125; 事件传值EventChannel | 微信开放文档 (qq.com) demo04.js 1234567891011121314151617clickBtn() &#123; // 可带参数,调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会 wx.navigateTo(&#123; url: &#x27;/pages/demo05/demo05?id=111&#x27;, events: &#123; // 为指定事件添加一个监听器 myBackData(data) &#123; console.log(data); &#125; &#125;, // 成功的回调函数 success: (res) =&gt; &#123; // 触发一个事件 res.eventChannel.emit(&quot;myGetData&quot;, &#123; data: &quot;传递的数据&quot; &#125;) &#125; &#125;) &#125; demo05.js 1234567891011121314151617181920onLoad() &#123; // 获取所有打开的EventChannel事件 const eventChannel = this.getOpenerEventChannel(); // 监听index页面的myGetData事件 eventChannel.on(&quot;myGetData&quot;, (res) =&gt; &#123; // 被触发后的操作 console.log(res); &#125;); eventChannel.emit(&quot;myBackData&quot;, &#123; data: &quot;返回的数据&quot; &#125;)&#125;,clickBack() &#123; //const eventChannel = this.getOpenerEventChannel(); //eventChannel.emit(&quot;myBackData&quot;, &#123; data: &quot;返回的数据&quot; &#125;) // 通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。 wx.navigateBack(&#123; delta: 1, &#125;)&#125; 网络临时数据demo06.wxml 123456789101112&lt;!--pages/demo06/demo06.wxml--&gt;&lt;view class=&quot;out&quot;&gt; &lt;view class=&quot;row&quot; wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; wx:key=&quot;*this&quot;&gt; &lt;view class=&quot;pic&quot;&gt; &lt;image src=&quot;&#123;&#123;item.url&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;text&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;item.time&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; demo06.js 12345678910111213141516171819data: &#123; dataList: [ &#123; title: &quot;标题1&quot;, time: &quot;2020-01-01&quot;, url: &quot;/images/image1.png&quot; &#125;, &#123; title: &quot;标题2&quot;, time: &quot;2020-01-02&quot;, url: &quot;/images/image1.png&quot; &#125;, &#123; title: &quot;标题3&quot;, time: &quot;2020-01-03&quot;, url: &quot;/images/image1.png&quot; &#125; ]&#125;, 请求数据RequestTask | 微信开放文档 (qq.com) 使用wx.request获取数据 1234567891011121314151617181920onLoad: function (options) &#123; wx.request(&#123; // 接口地址 url: &#x27;http://edu.newsight.cn/wxList.php&#x27;, // 请求的参数 data: &#123; num: 5, page: 1 &#125;, // 接口调用成功的回调函数 success: (res) =&gt; &#123; console.log(res); console.log(res.data); // 设置数据 this.setData(&#123; reqData: res.data &#125;) &#125;, &#125;)&#125;, 修改之前的代码 demo06.wxml 123456789101112&lt;!--pages/demo06/demo06.wxml--&gt;&lt;view class=&quot;out&quot;&gt; &lt;view class=&quot;row&quot; wx:for=&quot;&#123;&#123;reqData&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;view class=&quot;pic&quot;&gt; &lt;image src=&quot;&#123;&#123;item.picurl&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;text&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;item.posttime&#125;&#125; - &#123;&#123;item.author&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 如果域名检验不合法，可以在微信公众平台的开发中管理添加所需要使用的域名，或者开发者工具在设置不检测合法。 事件绑定刷新数据demo06.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// pages/demo06/demo06.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; reqData: [], scrollTop: 0 &#125;, reqParam: &#123; page: 1 &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.getReqData(1); &#125;, // 下一页 clickToNextPage() &#123; this.reqParam.page++; this.getReqData(this.reqParam.page) &#125;, getReqData(page) &#123; wx.request(&#123; // 接口地址 url: &#x27;http://edu.newsight.cn/wxList.php&#x27;, // 请求的参数 data: &#123; num: 4, page: page &#125;, // 接口调用成功的回调函数 success: (res) =&gt; &#123; console.log(res); console.log(res.data); // 设置数据 this.setData(&#123; reqData: res.data &#125;) &#125;, &#125;) &#125;&#125;) demo06.wxml 1&lt;button bindtap=&quot;clickToNextPage&quot; type=&quot;primary&quot;&gt;下一页&lt;/button&gt; 用户信息wx.getUserProfile(Object object) | 微信开放文档 (qq.com) demo07.wxml 123&lt;button bindtap=&quot;login&quot; type=&quot;primary&quot;&gt;授权登录&lt;/button&gt;&lt;view&gt;&#123;&#123;nickName&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt; demo07.js 12345678910111213141516171819202122data: &#123; nickName: &quot;&quot;, avatar: &quot;&quot;,&#125;,// 授权登录login() &#123; wx.getUserProfile(&#123; // 声明获取用户个人信息后的用途，不超过30个字符 desc: &#x27;声明获取用户信息后的用途&#x27;, success: (res) =&gt; &#123; console.log(res); this.setData(&#123; nickName: res.userInfo.nickName, avatar: res.userInfo.avatarUrl &#125;) &#125;, fail: (res) =&gt; &#123; console.log(res); &#125; &#125;)&#125; 缓存wx.setStorageSync(string key, any data) | 微信开放文档 (qq.com) 存123456789101112131415161718login() &#123; wx.getUserProfile(&#123; // 声明获取用户个人信息后的用途，不超过30个字符 desc: &#x27;声明获取用户信息后的用途&#x27;, success: (res) =&gt; &#123; console.log(res); this.setData(&#123; nickName: res.userInfo.nickName, avatar: res.userInfo.avatarUrl &#125;); // 存信息 wx.setStorageSync(&#x27;userInfo&#x27;, res.userInfo); &#125;, fail: (res) =&gt; &#123; console.log(res); &#125; &#125;)&#125; 取123&lt;button bindtap=&quot;login&quot; type=&quot;primary&quot; wx:if=&quot;&#123;&#123;!nickName&#125;&#125;&quot;&gt;授权登录&lt;/button&gt;&lt;view&gt;&#123;&#123;nickName&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt; 123456789onLoad: function (options) &#123; // 取缓存 let userInfo = wx.getStorageSync(&#x27;userInfo&#x27;); console.log(userInfo); this.setData(&#123; nickName: userInfo.nickName, avatar: userInfo.avatarUrl &#125;)&#125;, 模块化Object module | 微信开放文档 (qq.com) public.js 123456789101112var myPublic = &#123; fun1() &#123; console.log(&quot;执行fun1&quot;); &#125;, fun2(p) &#123; console.log(&quot;执行fun2,参数：&quot; + p); &#125;&#125;module.exports = myPublic demo08.js 123456const myPublic = require(&#x27;../../utils/public.js&#x27;)onLoad: function (options) &#123; myPublic.fun1(); myPublic.fun2(&quot;param&quot;);&#125;, 小程序上线 修改测试号为AppID 小程序 (qq.com)管理服务器域名，取消不检验合法域名 上传代码 小程序 (qq.com)提交审核","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"【集训】微信小程序(一)","slug":"【集训】微信小程序(一)","date":"2021-07-22T01:00:03.478Z","updated":"2021-07-23T05:50:01.078Z","comments":true,"path":"2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-yi/","link":"","permalink":"http://example.com/2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-yi/","excerpt":"","text":"自定义组件Component(Object object) | 微信开放文档 (qq.com) 将部分重复代码抽取出来 商品分类 (taobao.com) 创建自定义组件 类似于页面，一个自定义组件由json、wxml、wxss、js 4个文件组成 可以在微信开发者⼯具中快速创建组件的⽂件结构 声明组件、引入组件tabs.json 123&#123; &quot;component&quot;: true&#125; demo01.json 12345&#123; &quot;usingComponents&quot;: &#123; &quot;Tabs&quot;: &quot;/components/Tabs/Tabs&quot; &#125;&#125; 简单编辑组件Tabs.wxml 123456789101112&lt;!--components/Tabs/Tabs.wxml--&gt;&lt;view class=&quot;tabs&quot;&gt; &lt;view class=&quot;tabs_title&quot;&gt; &lt;view class=&quot;title_item active&quot;&gt;首页&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;原创&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;分类&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;关于&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tabs_content&quot;&gt; &lt;/view&gt;&lt;/view&gt; Tabs.wxss 12345678910111213141516171819202122/* components/Tabs/Tabs.wxss */.tabs &#123;&#125;.tabs_title &#123; display: flex; padding: 10rpx 0;&#125;.title_item &#123; flex: 1; display: flex; justify-content: center; align-items: center;&#125;/* 选中时的样式 */.active &#123; color: #b81d24; border-bottom: 5rpx solid currentColor;&#125;.tabs_content &#123;&#125; 以上数据都写在组件的wxml中，接下来来实现js动态数据 填入初始数据Tabs.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// components/Tabs/Tabs.jsComponent(&#123; /** * 组件的属性列表 */ properties: &#123; &#125;, /** * 组件的初始数据 */ data: &#123; tabs: [ &#123; id: 0, name: &quot;首页&quot;, isActive: true &#125;, &#123; id: 1, name: &quot;原创&quot;, isActive: false &#125; , &#123; id: 2, name: &quot;分类&quot;, isActive: false &#125; , &#123; id: 3, name: &quot;关于&quot;, isActive: false &#125; ] &#125;, /** * 组件的方法列表 */ methods: &#123; &#125;&#125;) Tab.wxml 12345678910111213&lt;view class=&quot;tabs&quot;&gt; &lt;view class=&quot;tabs_title&quot;&gt; &lt;!-- 列表渲染 --&gt; &lt;!-- class中三元表达式，根据item的isActive属性判断是否选中，选中则添加类名以显示样式 --&gt; &lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tabs_content&quot;&gt;&lt;/view&gt; &lt;/view&gt; 绑定点击事件Tab.wxml 123456789&lt;view class=&quot;tabs_title&quot;&gt; &lt;!-- 列表渲染 --&gt; &lt;!-- class中三元表达式，根据item的isActive属性判断是否选中，选中则添加类名以显示样式 --&gt; &lt;!-- data-index自定义属性，用于传递当前的索引值 --&gt; &lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot; bindtap=&quot;handleItemTap&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/view&gt;&lt;/view&gt; 注意自定义组件的方法写在methods中 Tabs.js 123456789101112131415161718192021222324252627methods: &#123; handleItemTap(e) &#123; // 查看索引所在的位置 console.log(e); // 1.获取被点击的索引 // ES6常量const,只读不可改 // ES6解构赋值:const &#123; index &#125; = e.currentTarget.dataset; const index = e.currentTarget.dataset.index; // 2.获取原数组 // ES6变量let,块级作用域 // ES6解构赋值:let &#123; tabs &#125; = this.data; let tabs = this.data.tabs; // 3.循环数组：为当前索引项设置isActive：true,其余false // ES6箭头函数 tabs.forEach((v, i) =&gt; &#123; i === index ? v.isActive = true : v.isActive = false &#125;); // 修改数据 this.setData(&#123; tabs &#125;) &#125;&#125; 以上数据都写在组件中，接下来来实现父向子传递数据 父向子传递数据demo01.wxml 123456&lt;!-- 父组件demo01，子组件Tabs 父组件通过标签属性传递数据 子组件在properties中接收--&gt;&lt;Tabs abc=&quot;要传递的数据&quot;&gt;&lt;/Tabs&gt; Tabs.js 123456789properties: &#123; // 属性名 abc: &#123; // 接收的数据的类型 type: String, // 默认值 value: &quot;&quot; &#125;&#125;, Tabs.wxml 12&lt;!-- 相当于data中的数据使，用&#123;&#123;&#125;&#125;渲染 --&gt;&lt;view&gt;&#123;&#123;abc&#125;&#125;&lt;/view&gt; 接下来修改案例代码 将要传递的数据放在父组件的data中，即原先写在Tabs.js的data中的数据放在demo01.js的data中 1234567891011121314151617181920212223242526data: &#123; tabs: [ &#123; id: 0, name: &quot;首页&quot;, isActive: true &#125;, &#123; id: 1, name: &quot;原创&quot;, isActive: false &#125; , &#123; id: 2, name: &quot;分类&quot;, isActive: false &#125; , &#123; id: 3, name: &quot;关于&quot;, isActive: false &#125; ]&#125;, 父组件通过标签属性传递数据 demo01.wxml 1&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot;&gt;&lt;/Tabs&gt; 子组件在properties中接收，最后效果与之前相同 Tabs.js 123456properties: &#123; tabs: &#123; type: Array, value: [] &#125;&#125;, 此时Tabs.js中代码仍然是在子组件当中修改tab数组，而不是在父组件的data中修改tab（可以在AppData窗口查看） 123456// this.data中找不到数据，则在properties中寻找let tabs = this.data.tabs;// 将tabs放入data当中this.setData(&#123; tabs&#125;) 所以需要将处理数据放在父组件当中，而所需要的索引值则由子组件传递给父组件（子向父传递数据） 子向父传递数据Tabs.js 12345678methods: &#123; handleItemTap(e) &#123; // 1.获取被点击的索引 const index = e.currentTarget.dataset.index; // 2.触发父组件中的自定义事件，并传递数据 this.triggerEvent(&quot;itemChange&quot;, &#123; index &#125;); //triggerEvent(&quot;自定义事件名&quot;, 要传递的数据) &#125;&#125; demo01.wxml 123456&lt;!-- 子组件Tabs -&gt; 父组件demo01 在子组件的标签中添加自定义事件 编写父组件js事件方法--&gt;&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tabs&gt; demo01.js 1234567891011121314// 自定义事件方法handleItemChange(e) &#123; console.log(e); // 接收传递的数据 const index = e.detail.index; // 以下代码相同 let tabs = this.data.tabs; tabs.forEach((v, i) =&gt; &#123; i === index ? v.isActive = true : v.isActive = false &#125;); this.setData(&#123; tabs &#125;)&#125;, AppData窗口查看即可 slot标签 slot占位符（插槽），父组件调用子组件传递一些标签来替换slot的位置 Tabs.wxml 123&lt;view class=&quot;tabs_content&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/view&gt; demo01.wxml 123456&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt; &lt;block wx:if=&quot;&#123;&#123;tabs[0].isActive&#125;&#125;&quot;&gt;内容1&lt;/block&gt; &lt;block wx:elif=&quot;&#123;&#123;tabs[1].isActive&#125;&#125;&quot;&gt;内容2&lt;/block&gt; &lt;block wx:elif=&quot;&#123;&#123;tabs[2].isActive&#125;&#125;&quot;&gt;内容3&lt;/block&gt; &lt;block wx:else&gt;内容4&lt;/block&gt;&lt;/Tabs&gt; 生命周期应用 12345678910111213141516171819202122232425262728293031323334// app.jsApp(&#123; // 应用 第一次启动 的时候触发，可用于最开始获取用户的个人信息等 onLaunch() &#123; console.log(&quot;onLaunch&quot;); &#125;, // 应用 显示 的时候触发，可用于对页面数据、页面效果进行重置 onShow() &#123; console.log(&quot;onShow&quot;); // 可调用多次 &#125;, // 应用 隐藏 的时候触发，可用于暂停或清除定时器 onHide() &#123; console.log(&quot;onHide&quot;); &#125;, // 应用 代码报错 的时候触发，可用于收集错误信息并发送到后台 onError(error) &#123; console.log(&quot;onError&quot;); console.log(error); &#125;, // 应用 第一次启动找不到入口页面 的时候触发，可用于跳转 onPageNotFound() &#123; console.log(&quot;onPageNotFound&quot;); wx.navigateTo(&#123; url: &#x27;/pages/demo01/demo01&#x27;, &#125;) &#125;&#125;) 页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// pages/demo02/demo02.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 * 发送异步请求初始化页面数据 */ onLoad: function (options) &#123; console.log(&quot;onLoad&quot;); &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; console.log(&quot;onShow&quot;); &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; console.log(&quot;onReady&quot;); &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; console.log(&quot;onHide&quot;); &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; console.log(&quot;onUnload&quot;); &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 * 对页面初始化 */ onPullDownRefresh: function () &#123; console.log(&quot;onPullDownRefresh&quot;); &#125;, /** * 页面上拉触底事件的处理函数 * 触底加载更多数据 */ onReachBottom: function () &#123; console.log(&quot;onReachBottom&quot;); &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; console.log(&quot;onShareAppMessage&quot;); &#125;, /** * 页面滚动 */ onPageScroll() &#123; console.log(&quot;onPageScroll&quot;); &#125;, /** * 页面尺寸改变 */ onResize() &#123; console.log(&quot;onResize&quot;); &#125;, /** * 当前是tab页，点击当前页的tab时触发 */ onTabItemTap() &#123; console.log(&quot;onTabItemTap&quot;); &#125;&#125;)","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"【学习笔记】MyBatis","slug":"【学习笔记】MyBatis","date":"2021-07-16T11:12:59.990Z","updated":"2021-07-23T05:49:19.787Z","comments":true,"path":"2021/07/16/xue-xi-bi-ji-mybatis/","link":"","permalink":"http://example.com/2021/07/16/xue-xi-bi-ji-mybatis/","excerpt":"","text":"概述 mybatis是一个优秀的基于java的持久层框架,它内部封装了jdbc,使开发者只需要关注sq语句本身,而不需要花费精力去处理加载驱动、创建连接、创建 statement等繁杂的过程。 mybatis通过xm或注解的方式将要执行的各种 statement配置起来,并通过java对象和 statement中sq的动态参数进行映射生成最终执行的sq语句。 最后 mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题,对jdbc进行了封装,屏蔽了 jdbc api底层访问细节,使我们不用与 jdbc api打交道,就可以完成对数据库的持久化操作。 开发步骤 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 编写数据表与Bean类 创建并编写mapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.myspring.bean.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 创建并编写sqlMapConfig.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456789&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 调用操作 123456789101112// 获得核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis/sqlMapConfig.xml&quot;);// 获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);// 获得session会话对象SqlSession sqlSession = sqlSessionFactory.openSession();// 执行操作,参数即mapper.xml中的namespace.idList&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);// 测试System.out.println(userList);// 释放资源sqlSession.close(); 增删改查操作代码123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.myspring.bean.User&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 插入 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; insert into user values (#&#123;name&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; update user set age=#&#123;age&#125; where name = #&#123;name&#125; &lt;/update&gt;&lt;/mapper&gt; 1234567891011121314151617181920// 获得核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis/sqlMapConfig.xml&quot;);// 获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);// 获得session会话对象SqlSession sqlSession = sqlSessionFactory.openSession();// 查询List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);// 插入sqlSession.insert(&quot;userMapper.save&quot;, new User(&quot;李52四&quot;, 11));// 修改sqlSession.update(&quot;userMapper.update&quot;, new User(&quot;李52四&quot;, 110));// 删除sqlSession.delete(&quot;userMapper.delete&quot;, &quot;李52四&quot;);// 执行更新操作需要提交事务sqlSession.commit();// 释放资源sqlSession.close(); 配置文件常用标签environments标签 配置数据库环境，支持多环境 transactionManager事务管理器属性 JDBC: 这个配置就是直接使用了JDBC的提交和回滚设置,它依赖于从数据源得到的连接来管理事务作用域 MANAGED: 这个配置几乎没做什么。它从来不提交或回滚一个连接,而是让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文)。默认情况下它会关闭连接,然而一些容器并不希望这样,因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 daraSource数据源属性 UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。 JNDI:这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用,容器可以集中或在外部配置数据源,然后放置一个JNDI上下文的引用。 Mapper标签 加载映射，加载方式有多种。 使用相对于类路径的资源引用,例如:&lt; mapper resource=”org/ mybatis/ builder/ AuthorMapperxm”/&gt; 使用完全限定资源定位符(URL),例如:&lt; mapper url=”file//ar/ mappers/ Author Mapper.xm”/ 使用映射器接口实现类的完全限定类名,例如:&lt; mapper class=” org. mybatis builder. AuthorMapper”/&gt; 将包内的映射器接口实现全部注主册为映射器,例如:&lt; package name=” org. mybatis. builder”/&gt; Properties标签 实际开发中,习惯将数据源的配置信息单独抽取成个 properties文件,该标签可以加载额外配置的 properties文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 加载properties文件 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; typeAliases标签 起别名，有已经设置好的常用的类型的别名，也可自定义 1234&lt;!-- 自定义别名，注意标签在config.xml中的顺序 --&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.myspring.bean.User&quot; alias=&quot;user&quot;/&gt;&lt;/typeAliases&gt; MyBatis相关APISqlSession工厂构建器SqlSessionFactoryBuilder SqlSession工厂对象SqlSessionFactory SqlSession会话对象 DAO层实现 采用 Mybatis的代理开发方式实现DAO层的开发,这种方式是我们后面进入企业的主流。 Mapper接口开发方法只需要程序员编写 Mapper接口(相当于Dao接口),由 Mybatis框架根据接口定义创建接口的动态代理对象,代理对象的方法体同上边Dao接口实现类方法。 Mapper.xm文件中的 namespace与 mapper接口的全限定名相同 Mapper接口方法名和 Mapper. xm中定义的每个 statement的id相同 Mapper接口方法的输入参数类型和 mapper. xn中定义的毎个sql的 parameter Type的类型相同 Mapper接口方法的辅出参数类型和 mapper. xm中定义的每个sq的 resultType的类型相同 创建并编写Mapper.xml文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.myspring.dao.UserMapper&quot;&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据name查询所有 --&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 创建并编写Mapper接口 123456public interface UserMapper &#123; // 查询所有 List&lt;User&gt; findAll() throws Exception; // 根据id查询所有 User findById(int id);&#125; 调用 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;myBatis/sqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();User user = mapper.findById(2); 映射文件：动态sql语句123456789101112131415161718192021222324252627282930313233&lt;!-- sql语句抽取 --&gt;&lt;sql id=&quot;selectUser&quot;&gt; select * from user&lt;/sql&gt;&lt;!-- 动态条件 --&gt;&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-- 动态条件 --&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;where&gt; -- select * from user where id in(?,?) -- collection写list或array等 &lt;foreach collection=&quot;list&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 配置文件类型转换TypeHandler标签黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 插件plugins标签 添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 在配置文件中添加标签 12345&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 调用 12345678910111213141516171819// 分页助手，设置分页信息以分页，startPage(pageNum,pageSize)PageHelper.startPage(1, 1);// 当前页List&lt;User&gt; userList = mapper.findAll();// 分页信息PageInfo&lt;User&gt; userPageInfo = new PageInfo&lt;&gt;(userList);for (User user : userList) &#123; System.out.println(user);&#125;System.out.println(&quot;上一页：&quot; + userPageInfo.getPrePage());System.out.println(&quot;当前页：&quot; + userPageInfo.getPageNum());System.out.println(&quot;下一页：&quot; + userPageInfo.getNextPage());System.out.println(&quot;总页数：&quot; + userPageInfo.getPages());System.out.println(&quot;当前条数：&quot; + userPageInfo.getPageSize());System.out.println(&quot;总条数：&quot; + userPageInfo.getTotal());System.out.println(&quot;是否第一页：&quot; + userPageInfo.isIsFirstPage());System.out.println(&quot;是否末页：&quot; + userPageInfo.isIsLastPage()); 多表操作黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 注解开发使用xml开发crud1234&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.myspring.dao.UserMapper&quot;&gt; &lt;!-- sql语句抽取 --&gt; &lt;sql id=&quot;selectUser&quot;&gt; select * from user &lt;/sql&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;/select&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; -- select * from user where id in(?,?) -- collection写list或array等 &lt;foreach collection=&quot;list&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 插入 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; insert into user (name, age) values (#&#123;name&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; update user set age=#&#123;age&#125;, name=#&#123;name&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除 --&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 123456789101112131415public interface UserMapper &#123; List&lt;User&gt; findAll(); User findById(int id); List&lt;User&gt; findByCondition(User user); List&lt;User&gt; findByIds(List&lt;Integer&gt; ids); void save(User user); void update(User user); void delete(int id);&#125; 123456789101112131415161718192021222324252627282930313233343536373839public class UserMapperTest &#123; private UserMapper userMapper; @Before public void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;myBatis/sqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class); &#125; @Test public void testSave() throws Exception &#123; User user = new User(); user.setName(&quot;钱老板&quot;); user.setAge(90); userMapper.save(user); &#125; @Test public void testUpdate() throws Exception &#123; User user = userMapper.findById(3); user.setAge(99); userMapper.update(user); &#125; @Test public void testDelete() throws Exception &#123; userMapper.delete(4); &#125; @Test public void testFindById() throws Exception &#123; User user = userMapper.findById(3); System.out.println(user); &#125;&#125; 注解开发CRUD12345678910111213141516public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User findById(int id); @Insert(&quot;insert into user (name, age) values (#&#123;name&#125;, #&#123;age&#125;)&quot;) void save(User user); @Update(&quot;update user set age=#&#123;age&#125;, name=#&#123;name&#125; where id = #&#123;id&#125;&quot;) void update(User user); @Update(&quot; delete from user where id = #&#123;id&#125;&quot;) void delete(int id);&#125; 12345&lt;!-- 加载映射关系 --&gt;&lt;mappers&gt; &lt;!-- 指定接口所在的包 --&gt; &lt;package name=&quot;com.myspring.dao&quot;/&gt;&lt;/mappers&gt; 调用不变","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"}]},{"title":"【学习笔记】SpringMVC","slug":"【学习笔记】SpringMVC","date":"2021-07-15T05:37:42.134Z","updated":"2021-07-23T05:48:57.464Z","comments":true,"path":"2021/07/15/xue-xi-bi-ji-springmvc/","link":"","permalink":"http://example.com/2021/07/15/xue-xi-bi-ji-springmvc/","excerpt":"","text":"SpringMVC概述 SpringMVC是种基于Java的实现MVc设计模型的请求驱动类型的轻量级Web框架,属于Spring FrameWork的后续产品,已经融合在 Spring Web Flow中。 SpringMvC已经成为目前最主流的MVC框架之一,并且随着 Spring30的发布,全面超越 Struts2,成为最优秀的MVC框架。它通过一套注解,让一个简单的Java类成为处理请求的控制器,而无须实现任何接口。同时它还支持RESTful编程风格的请求。 SpringMVC快速开发步骤 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 123456789101112131415&lt;!-- springMVC前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置xml地址 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写controller 12345678910@Controllerpublic class UserController &#123; // 使用RequestMapping映射controller地址 @RequestMapping(&quot;/myController&quot;) public String save() &#123; System.out.println(&quot;Controller save running&quot;); // return要跳转的视图页面 return &quot;success.jsp&quot;; &#125;&#125; 在resources下新增spring-mvc.xmld的spring config文件 12345xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- controller的组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring.controller&quot;/&gt; SpringMVC组件解析@RequestMapping用于建立请求URL和处理请求方法之间的对应关系 位置 类上,请求URL的第一级访问目录。此处不写的话,就相当于应用的根目录 方法上,请求URL的第二级访问目录,与类上的使用@ ReqquestMapping标主的级目录起组成访问虚拟路径 return 后跟的路径：不加”/“，则从相对路径查询，否则从web路径下查询。 属性 value：用于指定请求的URL。它和path属性的作用是一样的 method：用于指定请求的方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和vaue必须和配置的一模一样 MVC命名空间引入12345&lt;!-- 命名空间 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;&lt;!-- 约束地址 --&gt;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; 组件扫描1&lt;context:component-scan base-package=&quot;com.myspring.controller&quot;/&gt; XML配置return重定义与请求转发12return &quot;forward:/success.jsp&quot;;return &quot;redirect:/success.jsp&quot;; 内部资源（视图）解析器 在spring-mvc.xml中配置如下 12345678910111213&lt;!-- 内部资源解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt; &lt;!-- 配置后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;2. 编写controller ```java // return &quot;/jsp/success.jsp&quot;; return &quot;success&quot; //效果与上述相同 SpringMVC数据响应页面跳转返回字符串1return &quot;/jsp/success.jsp&quot;; 返回ModelAndview对象在controller中编写如下 1234567891011121314151617181920212223242526272829// 第一种@RequestMapping(&quot;/myController1&quot;)public ModelAndView save2() &#123; ModelAndView modelAndView = new ModelAndView(); // 设置视图 modelAndView.setViewName(&quot;success&quot;); // 设置模型 modelAndView.addObject(&quot;username&quot;, &quot;qqq&quot;); return modelAndView;&#125;// 第二种@RequestMapping(&quot;/myController2&quot;)public ModelAndView save3(ModelAndView modelAndView) &#123; modelAndView.setViewName(&quot;success&quot;); modelAndView.addObject(&quot;username&quot;, &quot;qqq&quot;); return modelAndView;&#125;// 第三种@RequestMapping(&quot;/myController3&quot;)public ModelAndView save4(Model model) &#123; model.setAttribute(&quot;username&quot;, &quot;qqq&quot;); return &quot;success&quot;;&#125;// 第四种@RequestMapping(&quot;/myController4&quot;)public String save4(HttpServletRequest request) &#123; request.setAttribute(&quot;username&quot;, &quot;qqq&quot;); return &quot;success&quot;;&#125; 回写数据返回字符串（@ResponseBody）1234567891011// 第一种@RequestMapping(&quot;/myController1&quot;)public void save1(HttpServletResponse resp) throws IOException &#123; resp.getWriter().print(&quot;hello!!!&quot;);&#125;// 第二种,使用ResponseBody，用于区分页面跳转@RequestMapping(&quot;/myController2&quot;)@ResponseBodypublic String save2() &#123; return &quot;hello!!!&quot;;&#125; 返回JSON格式字符串 添加依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; 转换为JSON 1234567891011@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic String save() throws Exception &#123; // 获得bean User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); // 转换为JSON String userJson = new ObjectMapper().writeValueAsString(user); return userJson;&#125; 返回Spring自动转换Bean-&gt;JSON 配置spring-mvc.xml 12345678&lt;!-- 处理器映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 或者使用mvc注解驱动如下配置： 123456xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&lt;!-- mvc注解驱动 --&gt;&lt;mvc:annotation-driven/&gt; 编写controller 123456789// 第二种,使用ResponseBody，用于区分页面跳转@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic User save() throws Exception &#123; User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); return user;&#125; SpringMVC请求获取请求参数获取基本类型参数1234567@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(String username, int age) &#123; // 使用形参接收数据，注意此处参数名与表单中input的name值对应 System.out.println(username); System.out.println(age);&#125; 获取Bean类型参数123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(User user) &#123; // 实际上是使用了Bean对象里的set方法，所以要让参数的名字与set方法名对应，否则接收不到 System.out.println(user);&#125; 获取数据类型参数12345@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(String[] strs) &#123; System.out.println(Arrays.toString(strs));&#125; 获取集合类型参数 前端传输数据 123456789101112&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var userList = new Array(); userList.push(&#123;name: &quot;张三&quot;, age: 10&#125;); userList.push(&#123;name: &quot;李四&quot;, age: 20&#125;); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;$&#123;pageContext.request.contextPath&#125;/test/myController&quot;, data: JSON.stringify(userList), contentType: &quot;application/json;charset=utf-8&quot; &#125;)&lt;/script&gt; controller获得数据 123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(@RequestBody List&lt;User&gt; userList) &#123; // 注意 @RequestBody List&lt;User&gt; userList System.out.println(userList);&#125; 静态资源访问权限开放spring-mvc.xml中配置如下 1234&lt;!-- 开放资源访问，设置可访问地址 --&gt;&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;&lt;!-- 该标签表示当spring找不到时交由原始容器(tomcat)寻找 --&gt;&lt;mvc:default-servlet-handler/&gt; 全局编码过滤（防止中文乱码）12345678910111213&lt;!-- 全局编码过滤 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 参数绑定注解@RequestParam value: 与请求参数名称 required: 此在指定的请求参数是否必须包括,默认是true,提交时如果没有此参数则报错 defaultvalue: 当没有指定请求参数时,则使用指定的默认值赋值 123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(@RequestParam(value=&quot;name&quot;, required=false，defaultvalue=&quot;000&quot;) String username) &#123; // 将获得的参数name映射为所需要的username System.out.println(username);&#125; 获得Restfil风格参数 Restful是一种软件架构风格、设计风格,而不是标准,只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件,基于这个风格设计的软件可以更简洁,更有层次,更易于实现缓存机制等。 Restful风格的请求是使用“”ur+请求方式”表示次请求目的的,HTP协议里面四个表示操作方式的动词如下： GET: 用于获取资源 POST: 用于新建资源 PUT: 用于更新资源 DELETE: 用于删除资源 123456@RequestMapping(&quot;/myController/&#123;name&#125;&quot;)// 使用占位符&#123;&#125;@ResponseBodypublic void save(@PathVariable(&quot;name&quot;) String username) &#123; System.out.println(username);&#125; 自定义类型转换器黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 获得请求头@RequestHeader 文件上传 导入依赖 1234567891011dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 在spring-mvc.xml中配置文件上传解析器 12345678&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 上传文件的编码类型 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 上传文件总大小 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242800&quot;/&gt; &lt;!-- 上传单个文件的大小 --&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;5242800&quot;/&gt;&lt;/bean&gt; 编写controller 12345@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(MultipartFile uploadedFile) throws Exception &#123; uploadedFile.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\&quot; + uploadedFile.getOriginalFilename()));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(MultipartFile[] files) throws Exception &#123; for (MultipartFile file : files) &#123; file.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\&quot; + file.getOriginalFilename())); &#125;&#125;## SpringMVC拦截器interceptor&gt; Spring Mvc的拦截器类似于 Servlet开发中的过滤器 Filter,用于对处理器进行预处理和后处理。&gt;&gt; 将拦截器按一定的顺序联结成条链,这条链称为拦截器链( interceptor Chain)。在访问被拦截的方法或字段时,拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。### 开发步骤1. 编写interceptor ```java public class MyInterceptor implements HandlerInterceptor &#123; // 在目标方法执行之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); String param = request.getParameter(&quot;param&quot;); if (&quot;yes&quot;.equals(param)) &#123; return true; &#125; else &#123; request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request, response); return false; &#125; &#125; // 在目标方法执行之后，试图返回之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); // 可以对model进行修改 modelAndView.addObject(&quot;name&quot;, &quot;newName&quot;); &#125; // 在流程执行完毕之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion&quot;); &#125; &#125; 在spring-mvc.xml中配置interceptor 123456789101112131415&lt;mvc:interceptors&gt; &lt;!-- 对应执行顺序 --&gt; &lt;mvc:interceptor&gt; &lt;!-- 对哪些资源执行拦截操作 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 对应interceptor --&gt; &lt;bean class=&quot;com.myspring.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 对哪些资源执行拦截操作 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 对应interceptor --&gt; &lt;bean class=&quot;com.myspring.interceptor.MyInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 方法说明 SpringMVC异常处理简单异常处理器1234567891011&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 默认错误视图 --&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error1&quot;/&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;map&gt; &lt;!-- key:异常类型 value:错误视图 --&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error2&quot;/&gt; &lt;entry key=&quot;java.io.IOException&quot; value=&quot;error3&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 自定义异常处理器 黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"},{"name":"JavaEE","slug":"JavaEE","permalink":"http://example.com/tags/JavaEE/"}]},{"title":"【学习笔记】Spring","slug":"【学习笔记】Spring","date":"2021-07-13T12:59:14.495Z","updated":"2021-07-23T05:49:09.426Z","comments":true,"path":"2021/07/13/xue-xi-bi-ji-spring/","link":"","permalink":"http://example.com/2021/07/13/xue-xi-bi-ji-spring/","excerpt":"","text":"什么是SpringSpring用来干什么 Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成。 Spring是分层的 Java SE/EE应用 full-stack轻量级开源框架,以loC(Inverse of Control:反转控制)和Aop(Aspect Oriented Programming:面向切面编程)为内核。 提供了展现层 Spring MVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库,逐渐成为使用最多的 Java EE企业应用开源框架。 Spring发展历程 1997年,BM提出了EB的思想1998年,SUN制定开发标准规范E丿B1.01999年,EB1.1发布2001年,EB2.0发布2003年,EB2.1发布2006年,EB3.0发布 Spring之父 Rod Johnson( Spring之父) 《Expert One-to-One J2EE Design and development(2002)》阐述了J2EE使用EB开发设计的优点及解决方案《Expert One-to-One J2EE Development without EJB(2004)》阐述了2E开发不使用EB的解决方式( Spring维形) Spring的优势 方便解耦,简化开发 通过 Spring提供的loC容器,可以将对象间的依赖关系交由 Spring进行控制,避免硬编码所造成的过度耦合。 用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码,可以更专注于上层的应用。 AOP编程的支持 通过 Spring的AOP功能,方便进行面向切面编程,许多不容易用传统OOP实现的功能可以通过AOP轻松实现。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来,通过声明式方式灵活的进行事务管理,提高发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作,测试不再是昂贵的操作,而是随手可做的事情。 方便集成各种优秀框架 Spring对各种优秀框架( Struts、 Hibernate、 Hessian、Quartz等)的支持。 降低 JavaEE AP的使用难度 Spring对 JavaEE API(如JDBC、 JavaMail、远程调用等)进行了薄薄的封装层,使这些APl的使用难度大为降低。 Spring体系结构 Spring快速开发步骤 导入maven依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Spring conf配置文件（通常命名为applicationContext） 配置如下 1&lt;bean id=&quot;userDao&quot; class=&quot;com.myspring.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 实现 1234567public class UserDaoDemo &#123; public static void main(String[] args) &#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; Spring配置文件Bean标签 用于配置对象交由 Spring来创建。默认情况下它调用的是类中的**无参构造函数,**如果没有无参构造函数则不能创建成功。 基本属性 id: Bean实例在 Spring容器中的唯一标识 class: Bean的全限定名称 scope：指对象的作用范围，取值如下 singleton、prototype下bean对象的不同创建时间singleton、prototype下bean对象的不同创建时间 Bean实例化三种方法 无参构造方法实例化 1234// 创建容器ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 从容器中获得对象UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); 工厂静态方法实例化 工厂实例方法实例化 演示视频 Bean的依赖注入 依赖注入( Dependency Injection)：它是 Spring框架核心|OC的具体实现在编写程序时,通过控制反转,把对象的创健建交给了 Spring,但是代码中不可能出现没有依赖的情况。OC解耦只是降低他们的依赖关系,但不会消除。例如:业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系,在使用 Spring之后,就让 Spring来维护了简单的说,就是坐等框架把持久层对象传入业务层,而不用我们自己去获取。 set方法（property标签）12345678&lt;!-- 第一种 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;!-- name属性值对应set方法名 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 第二种 --&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot; /&gt; 123456// UserServiceImpl中依赖注入，获得userDao对象private UserDao userDao;// set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 构造（有参）方法（constructor-arg标签）1234&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;!-- name属性值对应userServiceImpl内UserDao的属性名 --&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123456// 依赖注入，获得userDao对象private UserDao userDao;// 构造方法public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao;&#125; 注入数据的数据类型 普通数据类型 引用数据类型 集合数据类型 演示视频 分模块开发（import标签） 实际开发中, Spring的配置内容非常多,这就导致 Spring配置很繁杂且体积很大,所以,可以将部分配置拆解到其他配置文件中,而在 Spring主配置文件通过impor标签进行加载。 1&lt;import resource=&quot;applicationContext-user.xml&quot;&gt;&lt;/import&gt; Spring相关APIApplicationContext application Context：接口类型,代表应用上下文,可以通过其实例获得 Spring容器中的Bean对象 三种实现类 ClassPathXmlApplicationContext它是从类的根路径下加载配置文件推荐使用这种 FileSystemXmlApplicationContext它是从磁盘路径上加载配置文件,配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext当使用注解配置容器对象时,需要使用此类来创建 spring容器。它用来读取注解。 getBean()方法 12UserService userService1 = (UserService) app.getBean(&quot;userService&quot;);UserService userService2 = app.getBean(UserService.class); Spring配置数据源数据源（连接池）的作用 数据源(连接池)是提高程序性能如出现的 事先实例化数据源,初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 手动创建数据源的开发步骤 导入Maven依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 创建jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/数据库名jdbc.username=rootjdbc.password=123456789 加载properties配置文件 12345ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;);String driver = rb.getString(&quot;jdbc.driver&quot;);String url = rb.getString(&quot;jdbc.url&quot;);String username = rb.getString(&quot;jdbc.username&quot;);String password = rb.getString(&quot;jdbc.password&quot;); 创建数据源 1234567// 创建c3p0数据源ComboPooledDataSource dataSource = new ComboPooledDataSource();dataSource.setDriverClass(driver);dataSource.setJdbcUrl(url);dataSource.setUser(username);dataSource.setPassword(password);Connection connection = dataSource.getConnection(); 1234567// 创建Druid数据源DruidDataSource dataSource = new DruidDataSource();dataSource.setDriverClassName(driver);dataSource.setUrl(url);dataSource.setUsername(username);dataSource.setPassword(password);DruidPooledConnection connection = dataSource.getConnection(); 使用Spring创建数据源的开发步骤 导入相关依赖 在applicationContext中配置数据源bean 12345678910111213141516171819202122&lt;!-- 引入context命名空间和约束路径 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 加载外部的properties文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;&lt;!-- c3p0 --&gt;&lt;bean id=&quot;dataSource1&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- Driud --&gt;&lt;bean id=&quot;dataSource2&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/property&gt;&lt;/bean&gt; 创建数据源对象 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);DataSource dataSource = applicationContext.getBean(DataSource.class);Connection connection = dataSource.getConnection(); Spring注解开发 Spring原始注解主要是替代的配置 原始注解 组件扫描使用注解进行开发时,需要在 applicationContext. xm中配置组件扫描,作用是指定哪个包及其子包下的Bean，需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!-- 配置组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt; Dao类12&lt;!-- 配置文件 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.myspring.dao.impl.UserDaoImpl&quot; scope=&quot;prototype&quot;&gt; &lt;/bean&gt; 1234// 注解配置，写在类名之上@Component(&quot;userDao&quot;)// 第二种可读性更强@Repository(&quot;userDao&quot;) Service类1234&lt;!-- 配置文件 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot; /&gt;&lt;/bean&gt; 1234// 注解配置，写在类名之上@Component(&quot;userService&quot;)// 第二种可读性更强@Service(&quot;userService&quot;) 1234567891011// 注解配置，写在字段之前// Autowired从spring容器中根据 数据类型 进行匹配，所以同一数据类型只有单个bean可以只写Autowired@Autowired// Qualifier从spring容器中根据 id值类型 进行匹配，但是必须结合Autowired一起使用@Qualifier(&quot;userDao&quot;)// @Resource(name = &quot;userDao&quot;) 相当于前两者结合private UserDao userDao;// 此时类中可以不写set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 普通属性注入12@Value(&quot;$&#123;jdbc.driver&#125;&quot;)private String driver; 新注解 整合在一起的样子，如下： 1234567891011121314151617181920212223@Configuration // 标志该类是Spring的核心配置类@ComponentScan(&quot;com.myspring&quot;) // 配置组件扫描,替换&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt;@PropertySource(&quot;classpath:jdbc.properties&quot;) // 加载外部的properties文件,替换&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;public class SpringConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) // spring会将当前方法的返回值以指定名称存储到spring容器当中 public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 分模块如下（推荐）： 123456@Configuration // 标志该类是Spring的核心配置类@ComponentScan(&quot;com.myspring&quot;) // 配置组件扫描,替换&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt;@Import(&#123;DataSourceConfiguration.class,&#125;) //括号内写数组&#123;xxx.class,xxx.class&#125;,替换&lt;import resource=&quot;&quot;/&gt;public class SpringConfiguration &#123; &#125; 123456789101112131415161718192021@PropertySource(&quot;classpath:jdbc.properties&quot;) // 加载外部的properties文件,替换&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) // spring会将当前方法的返回值以指定名称存储到spring容器当中 public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; Spring集成junit 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 编写测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)// @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) // 非注解方式注入配置@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) // 注解方式注入配置public class SpringJunitTest &#123; @Resource(name = &quot;userService&quot;) private UserService userService; @Test public void test1() &#123; userService.save(); &#125;&#125; Spring集成web环境 应用上下文对象是通过 new ClasspathXmlApplication Context( spring配置文件)方式获取的,但是每次从容器中获得Bean时都要编写 new ClasspathXmlApplication Context( spring配置文件),这样的弊端是配置文件加载多次,应用上下文对象创建多次。 在Web项目中,可以使用 ServletcontextListener监听Web应用的启动,我们可以在Web应用启动时,就加载 Spring的配置文件,创建应用上下文对象 Application Context,在将其存储到最大的域 servletContext域中,这样就可以在任意位置从域中获得应用上下文 Application Context对象了 手动使用listener获取应用上下文对象 创建listener类 123456789101112131415public class ContextLoaderListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; // ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //使用非注解时用该方法创建 ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfiguration.class); // 使用注解时用该方法创建 // 将Spring的应用上下文对象存储到ServletContext域对象中 servletContextEvent.getServletContext().setAttribute(&quot;app&quot;, app); System.out.println(&quot;spring容器创建完毕&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; &#125;&#125; 在web.xml中配置listener 123&lt;listener&gt; &lt;listener-class&gt;com.myspring.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取servletContext域对象中的应用上下文对象 1ApplicationContext app = (ApplicationContext) this.getServletContext().getAttribute(&quot;app&quot;); 使用Spring获取应用上下文对象 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 123456789&lt;!-- 设置全局参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 配置监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取应用上下文对象 1WebApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(req.getServletContext()); JdbcTemplate概述 它是 spring框架中提供的个对象,是对原始繁琐的 dbc API对象的简单封装。 spring框架为我们提供了很多的操作模板类。例如:操作关系型数据的 dbcTemplate和 bernate Template,操作nosq数据库的 RedisTemplate,操作消息队列的 UmsTemplate等等。 手动开发步骤 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建数据库表和javaBean 创建jdbcTemplate对象、执行数据库操作 12345678910111213141516public class JdbcTemplateTest &#123; @Test // 测试dbcTemplate开发步骤 public void test() &#123; // 创建Druid数据源 DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456789&quot;); // 创建jdbcTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 数据库操作 jdbcTemplate.update(&quot;insert into test1 values(?,?)&quot;, &quot;张三&quot;, 18); &#125;&#125; Spring使用JdbcTemplate开发步骤 添加依赖 编写jdbc.properties文件 编写spring-config文件applicationContext.xml，添加数据源对象，jdbcTemplate对象 12345678910111213141516171819&lt;!-- 引入context命名空间和约束路径 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 加载外部的properties文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!-- Druid DataSource --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring JdbcTemplate --&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 编写代码 123456// 获得applicationContextApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 从容器中获得jdbcTemplate对象JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class);// 数据库操作jdbcTemplate.update(&quot;insert into test1 values(?,?)&quot;, &quot;张三&quot;, 18); 常用操作1234jdbcTemplate.update(&quot;update test1 set age=? where name =?&quot;, 10, &quot;张三&quot;);List&lt;User&gt; userList = jdbcTemplate.query(&quot;select * from test1&quot;, new BeanPropertyRowMapper&lt;&gt;(User.class));User user = jdbcTemplate.queryForObject(&quot;select * from test1 where age=?&quot;, new BeanPropertyRowMapper&lt;&gt;(User.class), 18);Long count = jdbcTemplate.queryForObject(&quot;select count(*) from test1&quot;, Long.class); AOP概述 AOP为 Aspect Oriented Programming的缩写,意思为面向切面编程,是通过预编译方式和运行期动态代理现程序功能的同统一维护的一种技术。 AOP是OOP的延续,是软件开发中的一个热点,也是 Spring框架中的个重要内容,是函数式编程的种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 作用与优势黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili JDK动态代理、cglib动态代理黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 概念 Target(目标对象):代理的目标对象。 Proxy(代理):—个类被AOP织入增强后,就产生一个结果代理类。 Joinpoint(连接点):所谓连接点是指那些被拦截到的点。在 spring中这些点指的是方法,因为 spring只支持方法类型的连接点。 Pointcut(切入点):所谓切入点是指我们要对哪些 Joinpoint迸行拦截的定义。 Advice(通知/增强):所谓通知是指拦截到 Joinpoint之后所要做的事情就是通知。 Aspect(切面):是切入点和通知(引介个)的结合。 eaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring釆用动态代理织入,而Aspect采用编译期织入和类装载期织入。 基于XML开发AOP步骤 导入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.7&lt;/version&gt;&lt;/dependency&gt; 创建目标接口和目标类 创建切面类（含增强方法） 123456789101112public class MyAspect &#123; public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125; public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;前置增强。。。&quot;); Object proceed = pjp.proceed(); System.out.println(&quot;后置增强。。。&quot;); return proceed; &#125;&#125; 配置applicationContext.xml 12345678910111213141516xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&lt;!-- 目标对象 --&gt;&lt;bean id=&quot;target&quot; class=&quot;com.myspring.aop.Target&quot;/&gt;&lt;!-- 切面对象 --&gt;&lt;bean id=&quot;myAspect&quot; class=&quot;com.myspring.aop.MyAspect&quot;/&gt;&lt;!-- 配置织入，即哪些方法需要哪些增强(前置后置增强等) --&gt;&lt;aop:config&gt; &lt;!-- 声明切面 --&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 切点+通知(增强) --&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(* com.myspring.aop.*.*(..))&quot;&gt;&lt;/aop:before&gt; &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.myspring.aop.*.*(..))&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) // 非注解方式注入配置public class SpringJunitTest &#123; @Autowired private TargetInterface target; @Test public void test1() &#123; target.save(); &#125;&#125; 切点表达式 12345678910&lt;aop:config&gt; &lt;!-- 声明切面 --&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 切点表达式的抽取 --&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.myspring.aop.*.*(..))&quot;/&gt; &lt;!-- 切点+通知(增强) --&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知类型 基于注解开发AOP 目标类、切面类 配置目标类、切面类 1234@Component(&quot;target&quot;)public class Target implements TargetInterface &#123;&#125; 12345678@Component(&quot;myAspect&quot;)@Aspect //标注当前是一个切面类public class MyAspect &#123; @Before(&quot;execution(* com.myspring.aop.*.*(..))&quot;) public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125;&#125; 配置applicationContext.xml 1234&lt;!-- 注解开发组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring.aop&quot;/&gt;&lt;!-- aop自动代理 --&gt;&lt;aop:aspectj-autoproxy/&gt; 切点表达式抽取12345678910111213@Component(&quot;myAspect&quot;)@Aspect //标注当前是一个切面类public class MyAspect &#123; @Before(&quot;pointCut()&quot;) public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125; // 定义切点表达式 @Pointcut(&quot;execution(* com.myspring.aop.*.*(..))&quot;) public void pointCut() &#123; &#125;&#125; 事务控制黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"}]},{"title":"【集训】Servlet","slug":"【集训】servlet","date":"2021-07-11T11:56:48.738Z","updated":"2021-07-23T05:50:22.649Z","comments":true,"path":"2021/07/11/ji-xun-servlet/","link":"","permalink":"http://example.com/2021/07/11/ji-xun-servlet/","excerpt":"","text":"什么是Servlet？ Servlet 是运行在 Web 服务器或应用服务器上的java程序，是Java EE规范之一（一种接口）。 它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层，即接收客户端发送过来的请求并且响应数据给客户端。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 💡配置Servlet 创建一个Java类并实现Servlet接口（一般通过继承HTTPServlet类去实现servlet） 重写方法，实现逻辑操作 在web.xml中配置这个servlet的访问地址 1234567891011121314&lt;!-- 给tomcat配置servlet相关信息 --&gt;&lt;servlet&gt; &lt;!-- 写明servlet的名字（一般使用类名即可） --&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;!-- 写明servlet的全类名 --&gt; &lt;servlet-class&gt;servlet.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 给servlet配置访问地址 --&gt;&lt;servlet-mapping&gt; &lt;!-- 写明需要配置访问地址的servlet --&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;!-- 写明为该servlet配置的访问地址 --&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;标签中 / 的作用：相当于拼接到 http://ip:port/工程路径后，即http://ip:port/工程路径/myServlet HTTP协议什么是HTTP协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准，即客户端与服务器之间通信、传输数据需要遵守的规则。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 请求与响应 客户端给服务器发送数据为请求，请求分为GET、POST请求 服务器给客户端回传数据为响应 💡HTTP协议内容 请求/响应行 请求/响应头： 属性名：属性值 请求/响应体： 重要，自行阅读学习 常见响应码 200：表示请求成功 302：表示请求重定向 404：表示服务器找不到该请求地址（地址有错） 500：表示服务器内部错误（代码有错） 💡表单处理、常用API request对象常用方法 方法介绍 getParameter(String name) 返回name指定参数的参数值 getParameterValues(String name) 返回包含参数name的所有值的数组 setAttribute(String,Object) 存储此请求中的属性 getAttribute(String name) 返回指定属性的属性值 getContextPath() 返回当前WEB项目相对路径 getMethod() 获取请求类型 getSession() 获取Session对象 getCookies() 获取所有Cookie,返回一个Cookie数组 request对象常用方法 方法介绍 setHeader() 设置消息头 setStatus() 设置状态码 addCookie() 添加Cookie getWriter() 获取通向浏览器的字符流 获取/回传数据123456789&lt;form action=&quot;http://localhost:8080/jsp_war_exploded/myServlet&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;画画&quot;&gt;画画 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;打篮球&quot;&gt;打篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;敲代码&quot;&gt;敲代码 &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345String username = req.getParameter(&quot;username&quot;);String password = req.getParameter(&quot;password&quot;);String[] hobby = req.getParameterValues(&quot;hobby&quot;);System.out.println(&quot;用户名：&quot;+username+&quot;,密码：&quot;+password);System.out.println(Arrays.toString(hobby)); 1resp.getWriter().println(&quot;&lt;div&gt;这是一个div&lt;/div&gt;&quot;); http://localhost:8080/jsp_war_exploded/myServlet?username=111&amp;password=222使用?传递参数 请求转发与重定向 1234String username = req.getParameter(&quot;username&quot;);req.setAttribute(&quot;key&quot;, &quot;MyServlet处理的信息:&quot;);System.out.println(&quot;MyServlet中的request获得的数据&quot;+username);req.getRequestDispatcher(&quot;/myServlet2&quot;).forward(req, resp); 123String username = req.getParameter(&quot;username&quot;);System.out.println(&quot;MyServlet2中的request获得的数据:&quot;+username);System.out.println(&quot;MyServlet2中显示之前处理并保存的数据:&quot;+req.getAttribute(&quot;key&quot;)); 请求转发的特点： 浏览器地址栏没有变化 一次请求 共享request中的数据 可以转发到WEB-INF目录下（工程路径下） 1234resp.sendRedirect(req.getContextPath()+&quot;/myServlet2&quot;);// req.getContextPath()获得当前WEB项目相对路径resp.sendRedirect(&quot;http://www.baidu.com&quot;);// 访问外部资源必写http 重定向的特点： 浏览器地址栏发生变化 两次请求 不共享request中的数据 不能访问WEB-INF目录下资源 可以访问工程外的资源 💡Filter过滤器自行学习 中文乱码问题12req.setCharacterEncoding(&quot;UTF-8&quot;);resp.setContentType(&quot;text/html;charset=UTF-8&quot;); 相关阅读材料 Web开发 - 廖雪峰的官方网站 (liaoxuefeng.com) 尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版_哔哩哔哩_bilibili 作业 熟悉servlet、jsp并实现一些功能，并写一篇博文。 博文内容要求（必须要求）： 写一篇博文记录你使用servlet、jsp实现功能时遇到了哪些困难、不理解、不知道该如何实现的地方，以及写上解决的过程与结果（未解决的也可以写上有哪些疑惑），或者学习笔记等等皆可。 功能实例（仅参考，不是最低/最高标准）： 含有登陆/注册页面、其他页面。 登录功能：手动输入信息，符合已存在的用户信息则成功登录。 注册功能：手动输入信息，不能重复注册已存在的用户名，否则注册失败。 用户展示：在页面上展示所有已经注册的用户的信息。 登陆过滤：其他页面，只有登陆成功后才可访问，否则跳转至登陆页面。 其他页面：利用循环控制语句或其他工具功能输出由后台传递而来的数据。 等等 提交内容与时间： 提交内容：程序源码+博文链接 提交时间：7.27日晚零点前，将压缩包命名为班级+姓名+学号发送至&#55;&#x30;&#55;&#x38;&#x32;&#x33;&#x38;&#49;&#52;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109; 可能时间太短无法实现太多功能，没有关系，程序源码附上自己实现了的东西就行，没有实现完整也没关系，实现了更多功能也挺好，这个作业打分主要看你的博文里面写的记录内容，程序主要是用来练习以熟悉servlet和jsp的，毕竟大作业会用到。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"}]},{"title":"【集训】jsp","slug":"【集训】jsp","date":"2021-07-11T07:14:09.093Z","updated":"2021-07-23T05:51:57.089Z","comments":true,"path":"2021/07/11/ji-xun-jsp/","link":"","permalink":"http://example.com/2021/07/11/ji-xun-jsp/","excerpt":"","text":"什么是JSP JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。 JSP全称Java Server Pages，是建立在JAVA基础上的一种网络编程语言，JSP是一种Java servlet（JSP在执行前首先被编译成一个Servlet），主要用于实现Java web应用程序的用户界面部分。 网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。 jsp &lt;-&gt; java(servlet)C:\\Users\\卢荟\\AppData\\Local\\JetBrains\\IntelliJIdea2021.1\\tomcat\\20e10a3d-4da9-4eee-b7fa-327b2feb3d84\\work\\Catalina\\localhost\\jsp_war_exploded\\org\\apache\\jsp 类似于上述文件目录（tomcat下的webapp目录下存放工程项目，只不过现在tomcat在idea里用）即找到生成的java文件。 可见JSP本质上就是一个Servlet，只不过无需配置映射路径，Web Server会根据路径查找对应的.jsp文件，如果找到了，就自动编译成Servlet再执行。 JSP语法JSP注释 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 HTML注释，通过浏览器查看网页源代码时可以看见注释内容 💡脚本（在JSP中编写Java代码）先导入jsp-api.jar和servlet-api.jar（tomcat自带，但是IDE并无提示会报红） 语法 描述 &lt;% 代码片段 %&gt; 一般定义变量和编写语句。 &lt;%! 声明代码 %&gt; 可以声明常量，编写方法，编写类 &lt;%= 表达式 %&gt; 表达式被转化成String，然后插入到表达式出现的地方 123456789101112131415161718192021&lt;%! public class MyMath &#123; int a,b; public MyMath(int a, int b) &#123; this.a = a; this.b = b; &#125; int doMath()&#123; return a+b; &#125; &#125;%&gt;&lt;% out.println(&quot;打印语句&quot;); MyMath myMath = new MyMath(1, 1); int num = myMath.doMath();%&gt;&lt;h1&gt; 和为&lt;%= num %&gt; &lt;/h1&gt;&lt;div&gt; &lt;%= &quot;&lt;h2&gt;这是一个标签&lt;/h2&gt;&quot; %&gt; &lt;/div&gt; 对于流程控制语句的编写可能稍微繁琐 123456789101112&lt;% int day = 1 %&gt;&lt;% if (day == 1 || day == 7) &#123; %&gt;&lt;p&gt;今天是周末&lt;/p&gt;&lt;% &#125; else &#123; %&gt;&lt;p&gt;今天不是周末&lt;/p&gt;&lt;% &#125; %&gt; &lt;%for ( int fontSize = 1; fontSize &lt;= 3; fontSize++)&#123; %&gt; &lt;font color=&quot;green&quot; size=&quot;&lt;%= fontSize %&gt;&quot;&gt; 菜鸟教程 &lt;/font&gt;&lt;br /&gt;&lt;%&#125;%&gt; 当然也可以用out对象输出 12345678&lt;% int fontSize; for ( fontSize = 10; fontSize &lt;= 13; fontSize++) &#123; out.write(&quot;&lt;div&gt;&quot;); out.write(fontSize+&quot;&quot;); out.write(&quot;&lt;/div&gt;&lt;br&gt;&quot;); &#125;%&gt; JSP指令JSP指令用来设置与整个JSP页面相关的属性。 JSP指令 描述 &lt;%@ page 属性名=”属性值” %&gt; 定义页面的依赖属性，导包 &lt;%@ include 属性名=”属性值” %&gt; 包含其他文件（静态包含） &lt;%@ taglib 属性名=”属性值” %&gt; 引入标签库的定义，可以是自定义标签 123&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot; &quot; %&gt; &lt;%@ include file=&quot; &quot;%&gt; JSP行为自行学习 1&lt;jsp:行为名 属性名=&quot;属性值&quot; /&gt; 中文编码问题1&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; 💡JSP九大内置对象与四大作用域四大域对象 对象 作用域 变化操作 pageContext 当前页面有效，当当前页面关闭或转到其他页面时，page对象将在响应回馈给客户端后释放。 跳转页面 request 当次请求有效，可以跨越forward()不重定向跳转前后的两页，可以通过setAttribute()方法实现页面中的信息传递。 两次请求 session 当前会话有效，指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应 关闭浏览器 application 所有应用程序中有效，整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。 关闭服务器 12345678910&lt;% pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;); request.setAttribute(&quot;key&quot;, &quot;request&quot;); session.setAttribute(&quot;key&quot;, &quot;session&quot;); application.setAttribute(&quot;key&quot;, &quot;application&quot;);%&gt;pageContext的值：&lt;%=pageContext.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;request的值：&lt;%=request.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;session的值：&lt;%=session.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;application的值：&lt;%=application.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt; 九大内置对象在生成的java文件中可以找到 对象 描述 作用域 request javax.servlet.http.HttpServletRequest 类的实例 request response javax.servlet.http.HttpServletResponse类的实例 pageContext out javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。 pageContext session javax.servlet.http.HttpSession 类的实例 session application javax.servlet.ServletContext 类的实例。与应用上下文有关 application config javax.servlet.ServletConfig 类的实例。这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 pageContext pageContext javax.servlet.jsp.PageContext 类的实例，提供对JSP页面所有对象以及命名空间的访问 pageContext page 指向当前JSP对象 pageContext exception exception 类的对象，代表发生错误的 JSP 页面中对应的异常对象，&lt;%@ page …… isErrorPage=”true” %&gt; pageContext EL表达式与JSTL标准标签库自行学习 💡MVC框架MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。 Model（模型）：如一个存取数据的对象或 JavaBean View（视图）：如jsp动态页面 Controller（控制器）：控制数据流向模型对象，并在数据变化时更新视图，使视图与模型分离开，如servlet MVC重要特点就是两种分离： 视图和数据模型的分离：使用不同的视图对相同的数据进行展示；分离可视和不可视的组件，能够对模型进行独立测试。因为分离了可视组件减少了外部（数据库也是一种外部组件）依赖利于测试。 视图和表现逻辑(Controller)的分离：Controller是一个表现逻辑的组件，并非一个业务逻辑组件。MVC可以作为表现模式也可以作为建构模式，意味这Controller也可以是业务逻辑。分离逻辑和具体展示，能够对逻辑进行独立测试。 MVC优缺点： 优点：低耦合、重用性高、生命周期成本低、部署快、可维护性高 缺点：没有明确的定义、不适合小、中型应用程序、增加系统结构和实现的复杂性、视图对模型数据的低效率访问 作业在上一个文档中已经声明，这两节课只要交一个作业就行。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"jsp","slug":"jsp","permalink":"http://example.com/tags/jsp/"}]}],"categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"},{"name":"JavaEE","slug":"JavaEE","permalink":"http://example.com/tags/JavaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"},{"name":"jsp","slug":"jsp","permalink":"http://example.com/tags/jsp/"}]}