{"meta":{"title":"Reria's BLOG","subtitle":"","description":"","author":"reria","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-07-23T06:13:25.410Z","updated":"2021-07-23T06:13:25.410Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-09-22T12:12:27.438Z","updated":"2021-09-22T12:12:27.438Z","comments":false,"path":"notice.html","permalink":"http://example.com/notice.html","excerpt":"","text":"本站默认替换了右键菜单，如需唤醒原系统菜单请使用： ctrl + 右键"},{"title":"","date":"2021-07-26T05:59:04.234Z","updated":"2021-07-26T05:59:04.234Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-29T03:28:37.138Z","updated":"2021-07-29T03:28:37.138Z","comments":true,"path":"bb/index.html","permalink":"http://example.com/bb/index.html","excerpt":"","text":""},{"title":"【】","date":"2021-09-22T12:12:40.562Z","updated":"2021-09-20T03:38:29.350Z","comments":true,"path":"模板.html","permalink":"http://example.com/%E6%A8%A1%E6%9D%BF.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-07-29T09:43:44.508Z","updated":"2021-07-29T09:43:44.508Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T03:29:26.295Z","updated":"2021-07-29T03:29:26.295Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"正在维护(其实是懒得写介绍🤭"},{"title":"我的朋友们","date":"2021-08-24T08:21:05.250Z","updated":"2021-08-24T08:21:05.250Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"🧡💛💚💙💜🤎🖤🤍"},{"title":"","date":"2021-07-27T01:43:04.243Z","updated":"2021-07-27T01:43:04.243Z","comments":true,"path":"bangumis/index.html","permalink":"http://example.com/bangumis/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-29T09:43:17.916Z","updated":"2021-07-29T09:43:17.916Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【项目笔记】在线教育项目实战2","slug":"【项目笔记】在线教育项目实战2","date":"2021-09-21T07:51:30.374Z","updated":"2021-09-22T12:05:18.318Z","comments":true,"path":"2021/09/21/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-2/","link":"","permalink":"http://example.com/2021/09/21/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-2/","excerpt":"","text":"前端技术点简单介绍vscode 新建一个空文件夹 用VSCode打开该文件夹 选择菜单栏 文件 -&gt; 将文件夹另存为工作区 即可 ES6介绍 详细看课件 Vue介绍 详细看课件和之前的博文 axios介绍 详细看课件 node.js 详细看课件 babel 详细看课件 模块化 详细看课件 webpack 详细看课件 搭建前端环境与框架开发过程 复制template文件夹至工作区 安装依赖npm install npm run dev测试 config -&gt; index.js -&gt; useEslint = false关闭代码检查 src -&gt; router -&gt; index.js 添加路由 views -&gt; xxx -&gt; xxx.vue 创建vue页面 api -&gt; xxx.js 定义接口地址和参数 在vue页面引入js文件，调用方法实现功能 后端登录功能和跨域修改BASE_API（请求路径前缀） config -&gt; dev.env.js文件 123456module.exports = merge(prodEnv, &#123; NODE_ENV: &#x27;&quot;development&quot;&#x27;, // BASE_API: &#x27;&quot;https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin&quot;&#x27;, // 注意这里要使用http BASE_API: &#x27;&quot;http://localhost:8001&quot;&#x27;,&#125;) 编写loginController 先跳过数据库验证 12345678910111213141516171819202122232425262728293031package com.atguigu.eduservice.controller;import com.atguigu.commonutils.R;import io.swagger.annotations.Api;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Api(&quot;后台登录&quot;)@RestController@RequestMapping(&quot;/eduservice/user&quot;)@CrossOrigin // 解决跨域问题public class EduLoginController &#123; // 登录 @PostMapping(&quot;login&quot;) public R login() &#123; // 先跳过验证 // 此处token需要与前端对应 return R.ok().data(&quot;token&quot;, &quot;admin&quot;); &#125; // 获得用户数据 @GetMapping(&quot;info&quot;) public R info() &#123; return R.ok().data(&quot;roles&quot;, &quot;[admin]&quot;).data(&quot;name&quot;, &quot;admin&quot;).data(&quot;avatar&quot;, &quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;); &#125; &#125; 修改前端访问路径 修改api文件夹下的login.js里的接口路径即可 123456789101112131415161718export function login(username, password) &#123; return request(&#123; url: &#x27;/eduservice/user/login&#x27;, method: &#x27;post&#x27;, data: &#123; username, password &#125; &#125;)&#125;export function getInfo(token) &#123; return request(&#123; url: &#x27;/eduservice/user/info&#x27;, method: &#x27;get&#x27;, params: &#123; token &#125; &#125;)&#125; 跨域问题 访问地址的时候，以下任何一个地方不同，会产生跨域问题： 访问协议 IP地址 端口号 在后端controller接口上添加注解@CrossOrigin即可（常用） 使用网关解决 讲师管理模块讲师列表添加路由 src\\router\\index.js -&gt; constantRouterMap -&gt; children -&gt; component 1234567891011121314151617181920212223242526export const constantRouterMap = [ // …… &#123; path: &#x27;/teacher&#x27;, component: Layout, redirect: &#x27;/teacher/table&#x27;, name: &#x27;讲师管理&#x27;, meta: &#123; title: &#x27;讲师管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;讲师列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/list&#x27;), meta: &#123; title: &#x27;讲师列表&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加讲师&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;添加讲师&#x27;, icon: &#x27;tree&#x27; &#125; &#125; ] &#125;, // …… &#125; 创建并编写js文件（调用接口） src\\api\\edu\\teacher.js 12345678910111213141516import request from &#x27;@/utils/request&#x27;export default &#123; // 查询讲师列表（带条件分页） getTeacherListPage(current, limit, teacherQuery) &#123; return request(&#123; // url可使用字符串拼接，但是最好用反引号 url: `/eduservice/teacher/pageTeacherCondition/$&#123;current&#125;/$&#123;limit&#125;`, method: &#x27;post&#x27;, // 后端使用requestBody获取teacherQuery，此时需要用data（将teacherQuery转换为JSON格式传输） data: teacherQuery &#125;) &#125;&#125; 创建vue页面，通过接口获取数据 注意routerMap中的对应对象（即创建的router）中component对应的地址，就是vue组件的地址，在该地址下创建vue文件 src\\views\\edu\\teacher\\list.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt;讲师列表&lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; data() &#123; return &#123; list: null, // 查询接口之后获得的列表 page: 1, // 当前页 limit: 10, // 每页记录数 total: 0, // 总记录数 teacherQuery: &#123;&#125;, // 条件值对象 &#125;; &#125;, created() &#123; this.getList(); &#125;, methods: &#123; // 获得讲师列表 getList() &#123; teacher .getTeacherListPage(this.page, this.limit, this.teacherQuery) .then((response) =&gt; &#123; // console.log(response); this.list = response.data.records; this.total = response.data.total; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; 编写列表格式代码 使用element-ui表格即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 表格 --&gt; &lt;el-table :data=&quot;list&quot; border fit highlight-current-row&gt; &lt;el-table-column label=&quot;序号&quot; width=&quot;70&quot; header-align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;名称&quot; width=&quot;80&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;头衔&quot; width=&quot;80&quot; header-align=&quot;center&quot;&gt; &lt;!-- 使用template slot-scope 进行判断显示 --&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.level === 1 ? &quot;高级讲师&quot; : &quot;首席讲师&quot; &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;intro&quot; label=&quot;资历&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column prop=&quot;gmtCreate&quot; label=&quot;添加时间&quot; width=&quot;160&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column prop=&quot;sort&quot; label=&quot;排序&quot; width=&quot;60&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt; 添加分页条 使用element-ui分页即可 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 表格 --&gt; &lt;!-- 分页条 --&gt; &lt;!-- @current-change=&quot;getList&quot; 只需要写方法名即可，自动传入需要跳转的页数 --&gt; &lt;el-pagination :current-page=&quot;page&quot; :page-size=&quot;limit&quot; :total=&quot;total&quot; style=&quot;padding: 30px 0; text-align: center&quot; layout=&quot;total, prev, pager, next, jumper&quot; @current-change=&quot;getList&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; // …… methods: &#123; // 获得讲师列表，page默认为1 getList(page = 1) &#123; this.page = page; teacher .getTeacherListPage(this.page, this.limit, this.teacherQuery) .then((response) =&gt; &#123; // console.log(response); this.list = response.data.records; this.total = response.data.total; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; 条件查询分页 使用element-ui表单即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--查询表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;teacherQuery.name&quot; placeholder=&quot;讲师名&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-select v-model=&quot;teacherQuery.level&quot; clearable placeholder=&quot;讲师头衔&quot; &gt; &lt;el-option :value=&quot;1&quot; label=&quot;高级讲师&quot; /&gt; &lt;el-option :value=&quot;2&quot; label=&quot;首席讲师&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;添加时间&quot;&gt; &lt;el-date-picker v-model=&quot;teacherQuery.begin&quot; type=&quot;datetime&quot; placeholder=&quot;选择开始时间&quot; value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; default-time=&quot;00:00:00&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;teacherQuery.end&quot; type=&quot;datetime&quot; placeholder=&quot;选择截止时间&quot; value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; default-time=&quot;00:00:00&quot; /&gt; &lt;/el-form-item&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;getList()&quot; &gt;查询&lt;/el-button &gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt; &lt;/el-form&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; methods: &#123; // 获得讲师列表，page默认为1 getList(page = 1) &#123; &#125;, //清空表单输入项数据 resetData() &#123; this.teacherQuery = &#123;&#125;; //查询所有讲师数据 this.getList(); &#125;, &#125;, &#125;;&lt;/script&gt; 删除讲师添加页面结构按钮 记得绑定对应方法名 slot插槽，Vue - slot-scope=”scope” 的意义 - 武卡卡 - 博客园 (cnblogs.com) 12345678910111213141516171819&lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt;&lt;/el-table-column&gt; 编写接口调用方法 先去api文件夹下编写调用接口的方法 teacher.js 12345678910111213import request from &#x27;@/utils/request&#x27;export default &#123; // 根据id删除讲师 deleteTeacherById(id) &#123; return request(&#123; url: `/eduservice/teacher/$&#123;id&#125;`, method: &#x27;delete&#x27;, &#125;) &#125;&#125; 编写按钮对应方法 编写按钮对应方法，考虑到用户体验，添加element-ui弹框提示 1234567891011121314151617181920212223242526272829303132removeDataById(id) &#123; this.$confirm(&#x27;此操作将永久删除该讲师记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;) .then(() =&gt; &#123; // 调用删除接口 teacher .deleteTeacherById(id) .then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新列表信息 // 如果是最后一页最后一个记录（total-(page-1)*limit == 1） if (this.total - (this.page - 1) * this.limit == 1) &#123; this.getList(this.page - 1) &#125; else &#123; this.getList(this.page) &#125; &#125;) &#125;) .catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;) &#125;)&#125; 当前项目结构 添加讲师添加页面结构 src\\views\\edu\\teacher\\save.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;讲师名称&quot;&gt; &lt;el-input v-model=&quot;teacher.name&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师排序&quot;&gt; &lt;el-input-number v-model=&quot;teacher.sort&quot; controls-position=&quot;right&quot; min=&quot;0&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师头衔&quot;&gt; &lt;el-select v-model=&quot;teacher.level&quot; clearable placeholder=&quot;请选择&quot; &gt; &lt;el-option :value=&quot;1&quot; label=&quot;高级讲师&quot; /&gt; &lt;el-option :value=&quot;2&quot; label=&quot;首席讲师&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师资历&quot;&gt; &lt;el-input v-model=&quot;teacher.career&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师简介&quot;&gt; &lt;el-input v-model=&quot;teacher.intro&quot; :rows=&quot;10&quot; type=&quot;textarea&quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 讲师头像：TODO --&gt; &lt;el-form-item&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot; &gt;保存&lt;/el-button &gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacherApi from &#x27;@/api/edu/teacher.js&#x27; export default &#123; data() &#123; return &#123; teacher: &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125;, saveBtnDisabled: false &#125; &#125;, created() &#123;&#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 编写接口调用方法12345678// 添加讲师addTeacher(teacher) &#123; return request(&#123; url: `/eduservice/teacher/addTeacher`, method: &#x27;post&#x27;, data: teacher &#125;)&#125; 编写按钮对应方法1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt; // 引入调用接口的js文件 import teacherApi from &#x27;@/api/edu/teacher.js&#x27; export default &#123; data() &#123; return &#123; teacher: &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125;, saveBtnDisabled: false &#125; &#125;, created() &#123;&#125;, methods: &#123; // 添加和修改使用同一个页面 saveOrUpdate() &#123; this.saveTeacher() &#125;, saveTeacher() &#123; teacherApi.addTeacher(this.teacher).then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加成功!&#x27; &#125;) // 路由跳转到列表页面 this.$router.push(&#123; path: &#x27;/teacher/list&#x27; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 优化讲师列表排序 根据添加时间降序 123456789101112131415@ApiOperation(&quot;多条件组合分页&quot;)@PostMapping(&quot;pageTeacherCondition/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacherCondition(@PathVariable long current, @PathVariable long limit, @RequestBody(required = false) TeacherQuery teacherQuery) &#123; // …… // 添加排序条件 wrapper.orderByDesc(&quot;gmt_create&quot;); // 调用service方法将page对象根据条件分页 teacherService.page(pageTeacher, wrapper); // ……&#125; 修改讲师编写页面结构1234567891011121314151617181920&lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!-- router跳转 --&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt;&lt;/el-table-column&gt; 隐藏路由 此处需要额外添加router，且不显示 123456789101112131415161718192021222324252627282930313233export const constantRouterMap = [&#123; path: &#x27;/teacher&#x27;, component: Layout, redirect: &#x27;/teacher/table&#x27;, name: &#x27;讲师管理&#x27;, meta: &#123; title: &#x27;讲师管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;讲师列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/list&#x27;), meta: &#123; title: &#x27;讲师列表&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加讲师&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;添加讲师&#x27;, icon: &#x27;tree&#x27; &#125; &#125;, &#123; // 带有id参数，：为占位符 path: &#x27;edit/:id&#x27;, name: &#x27;EduTeacherEdit&#x27;, // 此处进入的vue组件为save.vue component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;编辑讲师&#x27;, icon: &#x27;tree&#x27; &#125;, // 不显示该路由 hidden: true &#125; ] &#125;,] 数据回显 编写后端接口调用方法 1234567// 根据id获取讲师信息getTeacherInfo(id) &#123; return request(&#123; url: `/eduservice/teacher/getTeacher/$&#123;id&#125;`, method: &#x27;get&#x27;, &#125;)&#125; 编写调用该方法，注意要在需要显示该信息的组件中调用该方法 1234567891011121314151617181920&lt;script&gt;export default &#123; created() &#123; // 判断当前路径是否含有id，有则为修改，否则为添加 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; // 从路径中获取参数值 const id = this.$route.params.id this.getTeacherInfo(id) &#125; &#125;, methods: &#123; // 根据id获得讲师信息 getTeacherInfo(id) &#123; teacherApi.getTeacherInfo(id).then(response =&gt; &#123; this.teacher = response.data.teacher &#125;) &#125; &#125;&#125;&lt;/script&gt; 保存修改 编写后端接口调用方法 12345678// 修改讲师信息updateTeacher(teacher) &#123; return request(&#123; url: `/eduservice/teacher/updateTeacher`, method: &#x27;post&#x27;, data: teacher &#125;)&#125; 页面调用该方法，需要判断是修改还是添加 123456789101112131415161718192021222324252627&lt;script&gt; export default &#123; methods: &#123; // 添加和修改使用同一个页面 saveOrUpdate() &#123; // 判断是否有id if (this.teacher.id) &#123; this.updateTeacher() &#125; else &#123; this.saveTeacher() &#125; &#125;, // 修改讲师信息 updateTeacher() &#123; teacherApi.updateTeacher(this.teacher).then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;修改成功!&#x27; &#125;) // 路由跳转到列表页面 this.$router.push(&#123; path: &#x27;/teacher/list&#x27; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 路由切换存留信息问题 感谢弹幕提醒，使用监听路由的方法，可以防止当点击修改后在edit页面再次点击添加讲师，显示后的页面仍然留存讲师信息的小问题 1234567891011121314151617181920212223242526&lt;script&gt; export default &#123; // 监听 watch: &#123; // 监听路由是否发生了变化，如果是则清除当前页面的数据 $route: &#123; handler: function(val, oldVal) &#123; this.resetData() &#125; &#125; &#125;, methods: &#123; // 清空数据 resetData() &#123; this.teacher = &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125; &#125; &#125; &#125;&lt;/script&gt; 好吧原来下一集就把这个问题解决了，原因是多次跳转至同一个页面created钩子函数只会执行一次 以下是老师的方案 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; export default &#123; // 监听 watch: &#123; // 监听路由是否发生了变化，如果是则清除当前页面的数据 $route(to, from) &#123; this.init() &#125; &#125;, created() &#123; // 这里可以不用调用初始化方法，已经设置了监听 this.init() &#125;, methods: &#123; // 初始化 init() &#123; // 判断当前路径是否含有id，有则为修改，否则为添加 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; // 从路径中获取参数值 const id = this.$route.params.id this.getTeacherInfo(id) &#125; else &#123; this.teacher = &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125; &#125; &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"http://example.com/tags/springcloud/"}]},{"title":"【学习笔记】MyBatisPlus","slug":"【学习笔记】MyBatisPlus","date":"2021-09-20T03:38:01.615Z","updated":"2021-09-20T07:42:44.934Z","comments":true,"path":"2021/09/20/xue-xi-bi-ji-mybatisplus/","link":"","permalink":"http://example.com/2021/09/20/xue-xi-bi-ji-mybatisplus/","excerpt":"","text":"官网MyBatis-Plus (baomidou.com) 创建并初始化数据库见课件 快速创建工程创建springboot工程 new project -&gt; spring Initializr mybatisplus依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3.3&lt;/version&gt;&lt;/dependency&gt; 配置application.properties123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789# mybatis日志，可以查看更多详细信息mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 创建实体类123456789101112131415package com.example.mybatisplus_demo.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 创建Mapepr接口123456789package com.example.mybatisplus_demo.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.mybatisplus_demo.entity.User;@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; mapper扫描 注意这里有个易错点，mappersan内填写到Mapper文件存放的文件夹，而不是mapper文件 123456789@SpringBootApplication@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MybatisplusDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisplusDemoApplication.class, args); &#125;&#125; 单元测试12345678910111213141516171819package com.example.mybatisplus_demo;import com.example.mybatisplus_demo.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisplusDemoApplicationTests &#123; @Autowired private UserMapper userMapper; // 此处如果报错，则在UserMapper接口处添加注释@Repository即可 @Test void contextLoads() &#123; &#125;&#125; 当前项目结构 基础CRUD接口添加 不需要设置id主键的值，mybatisplus自动生成19位id 12345@Testvoid addUser() &#123; int insert = userMapper.insert(new User(null, &quot;爱丽丝&quot;, 12, &quot;Alice@qq.com&quot;)); System.out.println(&quot;insert: &quot; + insert);&#125; 主键生成策略分布式系统唯一ID生成方案汇总 - nick hao - 博客园 (cnblogs.com) 自动增长 UUID Redis生成 snowflake雪花算法 mybatisplus中指定策略如下 12@TableId(type = IdType.AUTO)private Long id; 修改1234@Testvoid updateUser() &#123; userMapper.updateById(new User(2L, &quot;Jacks&quot;, 11, &quot;Jacks@qq.com&quot;));&#125; 自动填充 为实体类添加带有注解的属性 1234567//create_time@TableField(fill = FieldFill.INSERT)private Date createTime;//update_time 注意这里是INSERT_UPDATE@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 创建handler类，并实现接口MetaObjectHandler的方法 123456789101112131415161718192021222324package com.example.mybatisplus_demo.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;// 需要交给spring@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; // 当使用mp实现添加操作时，这个方法会执行 @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125;&#125; 测试 123456789101112131415161718192021222324 @Test void addUser() &#123; User user = new User(); user.setName(&quot;岳不群1&quot;); user.setAge(70); user.setEmail(&quot;lucy@qq.com&quot;);// user.setCreateTime(new Date());// user.setUpdateTime(new Date()); int insert = userMapper.insert(user); System.out.println(&quot;insert:&quot; + insert); &#125; @Test void updateUser() &#123; User user = new User(); user.setId(1439818355027558402L); user.setAge(120); int row = userMapper.updateById(user); System.out.println(row); &#125; 乐观锁 主要解决：丢失更新 为实体类添加带注解的属性 123@Version@TableField(fill = FieldFill.INSERT)private Integer version; 配置乐观锁插件，可以写在独立的配置类中（MapperScan也可以写在该配置类中） 12345678910111213@Configuration@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MpConfig &#123; /** * 乐观锁插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; &#125;&#125; 编写handler类 1234567@Overridepublic void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); // 默认初始值1 this.setFieldValByName(&quot;version&quot;, 1, metaObject);&#125; 测试 12345678@Testvoid testOptimisticLockerInnerInterceptor() &#123; // 先查 User user = userMapper.selectById(1439842460539846658L); // 后改 user.setAge(44); userMapper.updateById(user);&#125; 查询批量查询12345@Testvoid testSelect() &#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1L, 2L, 3L)); System.out.println(users);&#125; 分页查询 在配置类中配置分页插件 123456789101112131415@Configuration@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MpConfig &#123; /** * 插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 测试 123456789@Testvoid testPage() &#123; // 创建page对象 Page&lt;User&gt; page = new Page&lt;&gt;(1, 2); // 查询 Page&lt;User&gt; page1 = userMapper.selectPage(page, null); System.out.println(page1); // 获得的page对象有许多方法可以获得对应值&#125; 删除 物理删除：真实删除，将数据从数据库中删除逻辑删除：假删除，根据字段状态判断 批量删除（物理删除）1234@Testvoid testDelete() &#123; userMapper.deleteBatchIds(Arrays.asList(1L, 2L));&#125; 逻辑删除 在实体类中添加带注释的属性（可以再加上TableField设置默认值等） 12@TableLogicprivate Integer deleted; 高版本已不需要在配置文件中添加插件 测试 1234@Testvoid testDelete() &#123; userMapper.deleteBatchIds(Arrays.asList(1L, 2L));&#125; 逻辑删除之后的数据在查询的时候不会被查询到（添加了额外的条件deleted=0） 条件构造器123456789@Testvoid testWrapper() &#123; // 创建对象 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 设置条件(更多条件详见官网) wrapper.ge(&quot;age&quot;, 20).le(&quot;age&quot;, 40); List&lt;User&gt; users = userMapper.selectList(wrapper); System.out.println(users);&#125; 代码生成器","categories":[],"tags":[{"name":"mybatisplus","slug":"mybatisplus","permalink":"http://example.com/tags/mybatisplus/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"【项目笔记】在线教育项目实战1","slug":"【项目笔记】在线教育项目实战1","date":"2021-09-19T13:01:14.432Z","updated":"2021-09-21T07:52:06.928Z","comments":true,"path":"2021/09/19/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-1/","link":"","permalink":"http://example.com/2021/09/19/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-1/","excerpt":"","text":"背景​ 今天准备写一个ssm整合的crud简单项目，然后顺便应付一下学校课程，然后被spring的注释气到了（注释代码什么都写得一模一样，就是idea报找不到bean，结果我重写了几遍之后莫名的好了，离谱！），被jsp气到了（这个错误之前遇到好几次了，也是代码一模一样，就是报404，离谱！），实在是不想在这些上面折腾了，今天在实验室有一半的时间都在叹气，于是果断放弃了它，投入了springboot+vue的怀抱。 项目简介项目商业模式B2C（当前项目） Business To Customers 两个角色： 管理员：添加、修改、删除 普通用户：查询 B2B2C Business To Business To Customers 例子：淘宝 项目实现功能模块后台（管理员） 讲师管理 课程分类管理 课程管理 视频 统计分析 课程相关 订单管理 banner（轮播图）管理 权限管理 前台（普通用户） 首页数据显示 讲师列表和详情 课程列表和详情 视频在线播放 登录和注册 微信扫码登录 微信支付 项目使用的技术点前端技术 SpringBoot SpringCloud MybatisPlus SpringSecurity redis，maven，easyExcel，jwt，OAuth2 …… 后端技术 vue elementUI axios nodejs …… 其他技术 阿里云oss 阿里云视频点播服务 阿里云短信服务 微信支付和登录 docker，git，Jenkins …… MyBatisPlus介绍 详见单独的文档说明 搭建项目环境数据库 详见资料 项目结构 父工程：pom类型，用于管理以来版本和放公共依赖 子模块n：实现各个模块 创建springboot父项目配置父项目的pom.xml 配置打包方式、删除dependencies、添加properties和dependencyManagement、删除src文件夹等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;guli_parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;guli_parent&lt;/name&gt; &lt;description&gt;guli_parent&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;guli.version&gt;0.0.1-SNAPSHOT&lt;/guli.version&gt; &lt;mybatis-plus.version&gt;3.0.5&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt; &lt;aliyun.oss.version&gt;2.8.3&lt;/aliyun.oss.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;poi.version&gt;3.17&lt;/poi.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-sdk-oss.version&gt;3.1.0&lt;/aliyun-sdk-oss.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-java-vod-upload.version&gt;1.4.11&lt;/aliyun-java-vod-upload.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.11&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;cloud-alibaba.version&gt;0.2.2.RELEASE&lt;/cloud-alibaba.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;$&#123;velocity.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyunOSS--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun.oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期时间工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;jodatime.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xlsx--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;$&#123;jwt.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyun--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-core.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-vod.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-dbutils.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;$&#123;canal.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建子模块 右键new model创建即可，子项目service等 配置pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;dependencies&gt; &lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;com.atguigu&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;service_base&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--hystrix依赖，主要是用 @HystrixCommand --&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--服务注册--&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--服务调用--&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建子子模块 service_edu、service_vod 当前项目结构 common模块swagger工具创建子模块 命名为common，该模块不需要src文件夹 配置依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;guli_parent&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring2.X集成redis所需common-pool2 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建子子模块 service_base 创建SwaggerConfig.java配置类12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.servicebase;import com.google.common.base.Predicates;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2 // swagger注解public class SwaggerConfig &#123; // 一些固定配置 @Bean public Docket webApiConfig() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;webApi&quot;) .apiInfo(webApiInfo()) .select() .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;))) .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;))) .build(); &#125; // 文档提示信息 private ApiInfo webApiInfo() &#123; return new ApiInfoBuilder() .title(&quot;网站-课程中心API文档&quot;) .description(&quot;本文档描述了课程中心微服务接口定义&quot;) .version(&quot;1.0&quot;) .contact(new Contact(&quot;java&quot;, &quot;http://atguigu.com&quot;, &quot;1123@qq.com&quot;)) .build(); &#125;&#125; 引入swagger子模块 需要在service模块中引入swagger模块的子模块servicebase模块，即在service模块的pom.xml文件中添加依赖即可（因为想要在service模块的子模块中使用，且都写上了pom打包，所以只要在service模块的pom.xml中添加即可） 12345&lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;service_base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 启动类添加组件扫描 EduApplication是service_edu模块下的启动类，由于service_base模块中的swaggerconfig配置类所在包地址也是com.atguigu.xxx，所以可以通过这个扫描到，否则只会扫描启动类所在及子包下的类（所以启动类要放在所有package的同级），如果是别的地址再额外添加即可（{“com.atguigu”,”com.xxx”}） 123456789@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 测试（访问）swagger 启动xxxApplication启动类 http://localhost:8001/swagger-ui.html API文档提示编写 一下以controller为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.eduservice.controller;import com.atguigu.eduservice.entity.EduTeacher;import com.atguigu.eduservice.service.EduTeacherService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * &lt;p&gt; * 讲师 前端控制器 * &lt;/p&gt; * * @author testjava * @since 2021-09-20 */@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag; &#125;&#125; 当前项目结构 统一结果返回格式统一结果的格式123456&#123; &quot;success&quot;: 布尔, //响应是否成功 &quot;code&quot;: 数字, //响应码 &quot;message&quot;: 字符串, //返回消息 &quot;data&quot;: HashMap //返回数据，放在键值对中&#125; 创建子模块 common模块下创建common_utils模块 设定状态码 可以写成接口，或者其他形式 1234567package com.atguigu.commonutils;public interface ResultCode &#123; // 状态码 public static Integer SUCCESS = 20000; //成功 public static Integer ERROR = 20001; //失败&#125; 定义返回数据格式 创建一个统一返回结果类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.atguigu.commonutils;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.util.HashMap;import java.util.Map;//统一返回结果的类@Datapublic class R &#123; // 以下属性为返回内容key @ApiModelProperty(value = &quot;是否成功&quot;) private Boolean success; @ApiModelProperty(value = &quot;返回码&quot;) private Integer code; @ApiModelProperty(value = &quot;返回消息&quot;) private String message; @ApiModelProperty(value = &quot;返回数据&quot;) private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); //把构造方法私有 private R() &#123; &#125; //成功静态方法 public static R ok() &#123; R r = new R(); r.setSuccess(true); r.setCode(ResultCode.SUCCESS); r.setMessage(&quot;成功&quot;); return r; &#125; //失败静态方法 public static R error() &#123; R r = new R(); r.setSuccess(false); r.setCode(ResultCode.ERROR); r.setMessage(&quot;失败&quot;); return r; &#125; // 以下的return this返回的是r // 可以实现链式编程（R.success().message().……） public R success(Boolean success) &#123; this.setSuccess(success); return this; &#125; public R message(String message) &#123; this.setMessage(message); return this; &#125; public R code(Integer code) &#123; this.setCode(code); return this; &#125; public R data(String key, Object value) &#123; this.data.put(key, value); return this; &#125; public R data(Map&lt;String, Object&gt; map) &#123; this.setData(map); return this; &#125;&#125; 使用统一返回结果格式 先在模块的pom.xml中引入已经定义好的统一返回结果类所在 将接口方法（controller中的方法）返回结果改为R即可 12345678910111213141516171819202122232425262728// 未使用统一结果格式@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag; &#125;&#125; 12345678910111213141516171819202122232425262728// 使用统一结果格式@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public R findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return R.ok().data(&quot;teacherList&quot;, list); &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public R removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag ? R.ok() : R.error(); &#125;&#125; 当前项目结构 统一异常处理统一异常处理类 在common模块中的service_base中添加即可 123456789101112131415/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理public class GlobalExceptionHandler &#123; // 全局异常处理 @ExceptionHandler(Exception.class) // 指定出现什么异常才会执行这个方法 @ResponseBody // 用于返回数据 public R error(Exception e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了异常!&quot;); &#125;&#125; 这里有一个依赖的问题，需要注意 特定异常处理1234567891011121314151617181920212223/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理public class GlobalExceptionHandler &#123; // 全局异常处理 @ExceptionHandler(Exception.class) // 指定出现什么异常才会执行这个方法 @ResponseBody // 用于返回数据 public R error(Exception e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了异常!&quot;); &#125; // 特定异常处理 @ExceptionHandler(ArithmeticException.class) @ResponseBody public R error(ArithmeticException e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了ArithmeticException异常!&quot;); &#125;&#125; 自定义异常处理 创建自定义异常类 1234567891011@Data@NoArgsConstructor@AllArgsConstructorpublic class GuliException extends RuntimeException &#123; private Integer code; // 状态码 private String msg; // 异常信息 //……&#125; 在统一异常处理类中创建方法 1234567// 自定义异常处理@ExceptionHandler(GuliException.class)@ResponseBodypublic R error(GuliException e) &#123; e.printStackTrace(); return R.error().code(e.getCode()).message(e.getMsg());&#125; 抛出自定义异常 12345try &#123; int i = 1 / 0;&#125; catch (Exception e) &#123; throw new GuliException(20001, &quot;zzzzz&quot;);&#125; 当前项目结构 统一日志处理配置日志级别 application.properties文件中配置即可 1logging.level.root=INFO logback日志工具 log4j，logback等可以将日志输出到文件中 注意：需要先将application.properties中的有关日志的配置注释掉 配置工具的配置文件 在resource文件夹下创建logback-spring.xml配置文件 注意 的路径即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt; &lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt; &lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt; &lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt; &lt;property name=&quot;log.path&quot; value=&quot;D:/MyProject/log/guli_edu&quot; /&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;!-- boldMagenta:粗红--&gt; &lt;!-- cyan:青色 --&gt; &lt;!-- white:白色 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)&quot; /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/Pattern&gt; &lt;!-- 设置字符集 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt; &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_info.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录info级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 WARN 日志 --&gt; &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_warn.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录warn级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt; &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_error.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录ERROR级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。 &lt;logger&gt;仅有一个name属性， 一个可选的level和一个可选的addtivity属性。 name:用来指定受此logger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 如果未设置此属性，那么当前logger将会继承上级的级别。 --&gt; &lt;!-- 使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=&quot;INFO&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息 第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别： --&gt; &lt;!--开发环境:打印控制台--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;!--可以输出项目中的debug日志，包括mybatis的sql日志--&gt; &lt;logger name=&quot;com.guli&quot; level=&quot;INFO&quot; /&gt; &lt;!-- root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG 可以包含零个或多个appender元素。 --&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境:输出到文件--&gt; &lt;springProfile name=&quot;pro&quot;&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 输出错误日志 在统一异常处理类上添加注释，并且在异常处理的时候调用log.error() 12345678910111213141516/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理@Slf4j // 输出错误日志public class GlobalExceptionHandler &#123; // 特定异常处理 @ExceptionHandler(ArithmeticException.class) @ResponseBody public R error(ArithmeticException e) &#123; e.printStackTrace(); log.error(e.getMessage()); // 将错误日志的内容输出到文件当中 return R.error().message(&quot;产生了ArithmeticException异常!&quot;); &#125; // ……&#125; 在配置的路径中即可看到日志文件 当前目录结构 service_edu讲师管理模块（简单方式）快速前置配置配置文件application.properties12345678910111213141516# 端口号server.port=8001# 服务名spring.application.name=service-edu# 环境spring.profiles.active=dev# mysql数据库信息spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789# 返回JSON的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl mybatisplus代码生成器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import org.junit.Test;public class CodeGenerator &#123; @Test public void run() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); // String projectPath = System.getProperty(&quot;user.dir&quot;); // gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); // 建议写成绝对路径 gc.setOutputDir(&quot;D:\\\\MyProject\\\\springboot\\\\guli_parent\\\\service\\\\service_edu&quot; + &quot;/src/main/java&quot;); gc.setAuthor(&quot;testjava&quot;); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(false); //重新生成时文件是否覆盖 gc.setServiceName(&quot;%sService&quot;); //去掉Service接口的首字母I // id类型如果是Long则改为ID_WORKER gc.setIdType(IdType.ID_WORKER_STR); //主键策略 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123456789&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(&quot;eduservice&quot;); //模块名 pc.setParent(&quot;com.atguigu&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;edu_teacher&quot;); //加载表 strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setTablePrefix(pc.getModuleName() + &quot;_&quot;); //生成实体时去掉表前缀 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; 当前项目结构 创建配置类 配置包扫描等 123456789package com.atguigu.eduservice.config;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123;&#125; 创建启动类 启动类位置要放在controller、entity等package的同级，然后run即可启动 12345678910111213package com.atguigu.eduservice;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 简单查询所有讲师编写controller12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.eduservice.controller;import com.atguigu.eduservice.entity.EduTeacher;import com.atguigu.eduservice.service.EduTeacherService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * &lt;p&gt; * 讲师 前端控制器 * &lt;/p&gt; * * @author testjava * @since 2021-09-20 */@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125;&#125; 测试localhost:8001//eduservice/edu-teacher/findAll 逻辑删除讲师实体类属性添加注解 为EduTeacher实体类添加相应的注释@TableLogic 123@ApiModelProperty(value = &quot;逻辑删除 1（true）已删除， 0（false）未删除&quot;)@TableLogicprivate Integer isDeleted; 创建mybatisplus配置类 添加逻辑删除插件（注意mybatis版本，低版本是需要添加的，高版本不用，而且TableId自动识别Type AutoGenerator写法也有区别等） 123456789101112131415161718192021package com.atguigu.eduservice.config;import com.baomidou.mybatisplus.core.injector.ISqlInjector;import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123; /** * 逻辑删除插件 */ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125;&#125; 编写controller 注意使用REST风格URI，pathVariable对应路径参数 123456// 2、逻辑删除讲师@DeleteMapping(&quot;&#123;id&#125;&quot;)public boolean removeTeacher(@PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag;&#125; 测试（swagger工具） 整合swagger可以用于接口测试、生成在线接口文档等 分页功能配置类导入插件123456789101112131415161718192021@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123; /** * 逻辑删除插件 */ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125; /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125;&#125; 编写controller123456789101112131415161718192021/** * 3、分页功能 * * @param current 当前页 * @param limit 每页记录数 * @return */@GetMapping(&quot;pageTeacher/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacher(@PathVariable long current, @PathVariable long limit) &#123; // 创建page对象 Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(current, limit); // 调用方法实现分类 teacherService.page(pageTeacher, null); long total = pageTeacher.getTotal(); List&lt;EduTeacher&gt; records = pageTeacher.getRecords(); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;total&quot;, total); map.put(&quot;records&quot;, records); return R.ok().data(map);&#125; 多条件组合查询分页创建VO实体对象 把条件值传递到接口里（将条件值封装到VO(ViewObject)实体对象当中，再把对象vo传递到接口中）浅析VO、DTO、DO、PO的概念、区别和用处_zjrbiancheng的专栏-CSDN博客实体类（VO，DO，DTO）的划分_xin.wang的博客-CSDN博客 123456789101112131415161718192021222324package com.atguigu.eduservice.entity.vo;import io.swagger.annotations.ApiModelProperty;import lombok.Data;// 条件封装对象@Datapublic class TeacherQuery &#123; // 一下属性是对应的可被依据的查询条件（注意和表中字段名对应） @ApiModelProperty(value = &quot;教师名称,模糊查询&quot;) private String name; @ApiModelProperty(value = &quot;头衔 1高级讲师 2首席讲师&quot;) private Integer level; @ApiModelProperty(value = &quot;查询开始时间&quot;, example = &quot;2019-01-01 10:10:10&quot;) private String begin;//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换 @ApiModelProperty(value = &quot;查询结束时间&quot;, example = &quot;2019-12-01 10:10:10&quot;) private String end; &#125; 编写controller123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 4、多条件组合分页 * 参数中可以使用@RequestBody TeacherQuery teacherQuery * 该注释表示使用JSON格式向后端传递数据，会自动封装到对应对象中， * 且需要使用POSTMapping才能获取数据，且如果数据有空需要加上(required = false) * * @param current 当前页 * @param limit 每页记录数 * @param teacherQuery 条件值（以对象的形式） * @return */@ApiOperation(&quot;多条件组合分页&quot;)@PostMapping(&quot;pageTeacherCondition/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacherCondition(@PathVariable long current, @PathVariable long limit, @RequestBody(required = false) TeacherQuery teacherQuery) &#123; // 创建page对象 Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(current, limit); // 创建wrapper对象 QueryWrapper&lt;EduTeacher&gt; wrapper = new QueryWrapper&lt;&gt;(); // 设定条件 String name = teacherQuery.getName(); Integer level = teacherQuery.getLevel(); String begin = teacherQuery.getBegin(); String end = teacherQuery.getEnd(); if (StringUtils.hasLength(name)) &#123; wrapper.like(&quot;name&quot;, name); &#125; if (level != null) &#123; wrapper.eq(&quot;level&quot;, level); &#125; if (StringUtils.hasLength(begin)) &#123; wrapper.ge(&quot;gmt_create&quot;, begin); &#125; if (StringUtils.hasLength(end)) &#123; wrapper.le(&quot;gmt_create&quot;, end); &#125; // 调用service方法将page对象根据条件分页 teacherService.page(pageTeacher, wrapper); long total = pageTeacher.getTotal(); List&lt;EduTeacher&gt; records = pageTeacher.getRecords(); return R.ok().data(&quot;total&quot;, total).data(&quot;records&quot;, records);&#125; 添加讲师实体类属性添加注解 @TableField（fill = FieldFill.xxx）自动填充注解 1234567@ApiModelProperty(value = &quot;创建时间&quot;)@TableField(fill = FieldFill.INSERT)private Date gmtCreate;@ApiModelProperty(value = &quot;更新时间&quot;)@TableField(fill = FieldFill.INSERT_UPDATE)private Date gmtModified; 创建自定义handler类 可以放到service_base模块，然后需要使用导入依赖即可 当对应方法被使用的使用会被调用 123456789101112131415161718192021package com.atguigu.servicebase.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;gmtCreate&quot;, new Date(), metaObject); this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject); &#125;&#125; 注意结构 编写controller123456789101112/** * 5、添加讲师 * * @param eduTeacher * @return */@ApiOperation(&quot;添加讲师&quot;)@PostMapping(&quot;addTeacher&quot;)public R addTeacher(@RequestBody EduTeacher eduTeacher) &#123; boolean save = teacherService.save(eduTeacher); return save ? R.ok() : R.error();&#125; 修改讲师编写controller12345678910111213@ApiOperation(&quot;根据id查询讲师&quot;)@GetMapping(&quot;getTeacher/&#123;id&#125;&quot;)public R getTeacher(@PathVariable String id) &#123; EduTeacher teacher = teacherService.getById(id); return R.ok().data(&quot;teacher&quot;, teacher);&#125;@ApiOperation(&quot;修改讲师&quot;)@PostMapping(&quot;updateTeacher&quot;)public R updateTeacher(@RequestBody EduTeacher teacher) &#123; boolean flag = teacherService.updateById(teacher); return flag ? R.ok() : R.error();&#125; 使用@PutMapping如下 12345678@ApiOperation(&quot;修改讲师&quot;)@PutMapping(&quot;&#123;id&#125;&#125;&quot;)public R updateTeacher(@PathVariable String id, @RequestBody EduTeacher teacher) &#123; teacher.setId(id); boolean flag = teacherService.updateById(teacher); return flag ? R.ok() : R.error();&#125; 待续","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"http://example.com/tags/springcloud/"}]},{"title":"【Unity】从独立游戏学习开发","slug":"【Unity2D】从独立游戏学习开发","date":"2021-08-24T07:54:59.786Z","updated":"2021-08-25T13:10:56.313Z","comments":true,"path":"2021/08/24/unity2d-cong-du-li-you-xi-xue-xi-kai-fa/","link":"","permalink":"http://example.com/2021/08/24/unity2d-cong-du-li-you-xi-xue-xi-kai-fa/","excerpt":"","text":"感谢感谢bilibili视频网站M_Studio麦口老师系列视频教学，Unity2D都是从他这学的。 创建项目与导入素材 创建新项目 导入素材，点击菜单栏Assets -&gt; ImportPackage 导入并编辑Tiles 点击菜单栏window -&gt; 2D -&gt; tile palette ，点击createNewPalette创建palette 导入Level文件夹下Spirit文件夹中的素材，并且适当编辑 TileMap 在Hierarchy窗口，创建所需要的2dObject -&gt; tilemap 在Tile Palette窗口，选中相应Active Tile Map并绘制 在Inspector窗口设置Sorting Layer，如下 ​ Sorting Layer中Layer越靠下越显示在前方，位于同一Layer中Order in Layer数值越大越显示在前方 其中 Background Details用于在Background中再添加相应tile（在同一个TileMap上绘制只能显示一个tile，即使tile是含有透明背景，也会完全替换） 2D Extra插件RuleTile 在Tiles文件夹下右键点击 Create -&gt; tiles -&gt; rule tile，并在Inspector窗口中设置 Default Sprite默认图片 在Inspector窗口中，设置Tiling Rules，并将新tile拖拽进Tile Palette并绘制，如下 ​ 每一个Tiling Rules中，右侧图片为符合该规则就显示的tile，九宫格中设置规则，绿色箭头表示在该方向上有tile，红色叉号表示不能有tile，同时列表中越靠上的rule优先级越高​ 如上设置可快速填充封闭图形的对应tile 如下规则解决内角问题，注意这四个角的额外rule要放在横竖两个tile的上方 Brush 想要添加贴合格子的物件prefab，可以使用创建brush的方式 创建brush，右键点击 create -&gt; Brush -&gt; prefab Brush 添加Element 在 Tile Palette 窗口中左下角使用自定义brush即可 添加的对象别忘了设置Layer以判断，同时可以使用Override使得同一物品相同设置 Collider和RigidbodyPlatform设置Collider和Rigidbody 选中Platform对象，在Inspector窗口下方点击 add component -&gt; Tilemap Collider 2D 勾选collider中的 user By Composite，即使用复合碰撞体，按照提示添加 Composite Collider 2D，则整个Platform为一个整体碰撞体 将随之添加的 rigidbody -&gt; bodytype设置为static，即可保持Platform固定，而不会因为gravity重力下落 同时也可以将Platform本身设置为static Player设置Collider和Rigidbody 选中Player对象，点击 add component -&gt; rigidbody 2D，并设置参数如下 ​ 注意Colllision Detection 碰撞方式设置为Continuous，即可持续判断是否产生碰撞； Interpolate差值设置为Interpolate，即可当下落碰撞时对碰撞体产生一定效果（基于上一帧物体位置来插值模拟） 点击 add component -&gt; Box Collider 2D，并点击Edit设置碰撞体范围 同时在 Constraints限制选项中选择Freeze Rotation Z，即可防止当角色处于Platform角上时会绕着Z轴旋转掉落 同时为Collider添加Materail Layer为Platform和Player添加不同的Layer，用于日后判断 Player左右移动和形象翻转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // 创建rigidbody private Rigidbody2D rb; [Header(&quot;移动参数&quot;)] public float speed = 8f; // public float crouchSpeedDivisor = 3f; // 蹲下速度减缓量 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 float xVelocity; // 轴速度 void Start() &#123; // 获取rigidbody rb = GetComponent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; GroundMovement(); &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入并设置移动 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125;&#125; Player下蹲点击 Edit -&gt; Project Setting -&gt; Input Manager -&gt; 复制JumpElement并修改为Crouch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; // public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 float xVelocity; // 轴速度 // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // Update is called once per frame void Update() &#123; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; GroundMovement(); &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否按下下蹲按钮、是否未按下按钮并处于下蹲状态 if (Input.GetButton(&quot;Crouch&quot;)) &#123; // 控制角色下蹲 Crouch(); &#125;else if(isCrouch) &#123; // 控制角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125;&#125; Player跳跃123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isJump; // 是否跳跃 [Header(&quot;环境检测&quot;)] public LayerMask groundLayer; // 地面层 float xVelocity; // 轴速度 float jumpTime; // 跳跃时间，与duration相关 // 按键 bool jumpPressed, jumpHeld, crouchHeld; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; // 是否接触地面层 if (coll.IsTouchingLayers(groundLayer)) &#123; isOnGround = true; &#125; else &#123; isOnGround = false; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否 if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if(!crouchHeld &amp;&amp; isCrouch) &#123; // 未按下按钮并处于下蹲状态 --》 角色起身 StandUp(); &#125; else if(!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色跳跃 void MidAirMovement() &#123; if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125;&#125; Raycast射线检测实现移动跳跃下蹲检测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isHeadBlocked; // 是否头顶遮挡 public bool isJump; // 是否跳跃 [Header(&quot;环境检测&quot;)] public float footOffset = 0.35f; // 单脚的偏移值，即整体xoffset的一半 public float headClearance = 0.5f; public float groundDistance = 0.2f; public LayerMask groundLayer; // 地面层 float xVelocity; // 轴速度 float jumpTime; // 跳跃时间，与duration相关 // 按键 bool jumpPressed, jumpHeld, crouchHeld; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; /* // 当前角色的位置和单脚左右点的offset Vector2 pos = transform.position; Vector2 offset = new Vector2(-footOffset, 0f); // leftCheck/rightCheck即单脚左右点检测 RaycastHit2D leftCheck = Physics2D.Raycast(pos+offset,Vector2.down,groundDistance,groundLayer); // 显示射线 Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f); */ // 1、左右脚检测是否接触地面 // 获得射线检测 RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0f), Vector2.down, groundDistance, groundLayer); RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0f), Vector2.down, groundDistance, groundLayer); // 是否接触地面层 //if (coll.IsTouchingLayers(groundLayer)) if (leftCheck || rightCheck) &#123; isOnGround = true; &#125; else &#123; isOnGround = false; &#125; // 2、头顶检测是否有阻挡 RaycastHit2D headCheck = Raycast(new Vector2(0f, coll.size.y), Vector2.up, headClearance, groundLayer); if (headCheck) &#123; isHeadBlocked = true; &#125; else &#123; isHeadBlocked = false; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否 if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if(!crouchHeld &amp;&amp; isCrouch &amp;&amp; !isHeadBlocked) &#123; // 未按下按钮,处于下蹲状态,头顶无遮挡 --》 角色起身 StandUp(); &#125; else if(!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色跳跃 void MidAirMovement() &#123; if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125; // 增强Raycast函数 RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer) &#123; // 当前角色的位置 Vector2 pos = transform.position; // 创建射线 RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer); // 显示射线,hit返回是否碰撞布尔值 Color color = hit ? Color.red : Color.green; Debug.DrawRay(pos + offset, rayDirection, color); return hit; &#125;&#125; 实现悬挂功能以及下蹲跳跃的优化 判断Raycast射线是否为TRUE的条件：为射线中有接触碰撞体，但是射线起点没有接触碰撞体； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 public float hangingJumpForce = 15f; // 悬挂时跳跃的力 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isHeadBlocked; // 是否头顶遮挡 public bool isJump; // 是否跳跃 public bool isHanging; // 是否悬挂 [Header(&quot;环境检测&quot;)] public LayerMask groundLayer; // 地面层 public float headClearance = 0.25f; public float groundDistance = 0.2f; public float grabDistance = 0.4f; // 抓取距离 public float reachOffset = 0.7f; // 接触偏移值 float footOffset; // 单脚的偏移值，即整体xsize的一半 float xVelocity; // 轴加速度 float jumpTime; // 跳跃时间，与duration相关 float playerHeight; // 角色高度 float eyeHeight; // 角色眼睛高度 // 按键 bool jumpPressed, jumpHeld, crouchHeld, crouchPressed; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); footOffset = coll.size.x / 2; playerHeight = coll.size.y; eyeHeight = playerHeight - 0.4f; // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); crouchPressed = Input.GetButtonDown(&quot;Crouch&quot;); playerHeight = coll.size.y; eyeHeight = playerHeight - 0.4f; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); CrouchMovement(); HangdingMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; /* // 当前角色的位置和单脚左右点的offset Vector2 pos = transform.position; Vector2 offset = new Vector2(-footOffset, 0f); // leftCheck/rightCheck即单脚左右点检测 RaycastHit2D leftCheck = Physics2D.Raycast(pos+offset,Vector2.down,groundDistance,groundLayer); // 显示射线 Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f); */ // 1、左右脚射线检测 是否接触地面 // 获得射线检测 RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0f), Vector2.down, groundDistance, groundLayer); RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0f), Vector2.down, groundDistance, groundLayer); // 是否接触地面层 //if (coll.IsTouchingLayers(groundLayer)) if (leftCheck || rightCheck) isOnGround = true; else isOnGround = false; // 2、头顶射线检测 是否有阻挡 RaycastHit2D headCheck = Raycast(new Vector2(0f, playerHeight), Vector2.up, headClearance, groundLayer); if (headCheck) isHeadBlocked = true; else isHeadBlocked = false; // 3、头前方区域射线检测 是否悬挂 float diraction = transform.localScale.x; RaycastHit2D blockedCheck = Raycast(new Vector2(footOffset * diraction, playerHeight), new Vector2(diraction,0f), grabDistance, groundLayer); RaycastHit2D wallCheck = Raycast(new Vector2(footOffset * diraction, eyeHeight), new Vector2(diraction, 0f), grabDistance, groundLayer); RaycastHit2D ledgeCheck = Raycast(new Vector2(reachOffset * diraction, playerHeight), Vector2.down, grabDistance, groundLayer); if (!isOnGround &amp;&amp; rb.velocity.y &lt; 0f &amp;&amp; ledgeCheck &amp;&amp; wallCheck &amp;&amp; !blockedCheck) &#123; // 将player固定在一个位置 Vector3 pos = transform.position; pos.x += (wallCheck.distance - 0.05f) * diraction; // RaycastHit2D下的distance为起始点到接触点的距离 pos.y -= ledgeCheck.distance; transform.position = pos; rb.bodyType = RigidbodyType2D.Static; // 让角色静止 isHanging = true; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 悬挂时不允许移动 if (isHanging) return; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色下蹲起立 void CrouchMovement() &#123; if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if (!crouchHeld &amp;&amp; isCrouch &amp;&amp; !isHeadBlocked) &#123; // 未按下按钮,处于下蹲状态,头顶无遮挡 --》 角色起身 StandUp(); &#125; else if (!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; &#125; // 控制角色跳跃 void MidAirMovement() &#123; // 跳跃检测 if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump &amp;&amp; !isHeadBlocked) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch &amp;&amp; !isHeadBlocked) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色悬挂时跳跃与下蹲 void HangdingMovement() &#123; // 悬挂时检测 if (isHanging) &#123; if (jumpPressed) &#123; rb.bodyType = RigidbodyType2D.Dynamic; rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse); isHanging = false; &#125; else if (crouchPressed) &#123; rb.bodyType = RigidbodyType2D.Dynamic; isHanging = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125; // 增强Raycast函数 RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer) &#123; // 当前角色的位置 Vector2 pos = transform.position; // 创建射线 RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer); // 显示射线,hit返回是否碰撞布尔值 Color color = hit ? Color.red : Color.green; Debug.DrawRay(pos + offset, rayDirection, color); return hit; &#125;&#125; 2D透视效果与摄像机 PackageManager -&gt; CineMachines插件导入，添加Follow选项 body -&gt; dead zone锁死范围，在该范围内移动不会跟着移动摄像机 body -&gt; Screen 设置follow角色在摄像机的哪个位置 body -&gt; CameraDistance 设置摄像机包括范围 Main Camera -&gt; Projection -&gt; Perspective，即可模拟正常摄像机效果（切换Scene 2D即可查看） Extension -&gt; Confiner添加摄像机移动边界，为Background添加Collider，注意一定要点选is trigger选项 灯光 对Object右键light -&gt; point light 添加点光源 为Plateform、Background添加materail Window -&gt; Rendering -&gt;light -&gt;Enviroment -&gt; Ambient Color，设置主场景灯光 动画 Window -&gt; Animator/Animation，打开窗口 添加script：PlayerAnimation如下 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; int groundID; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); groundID = Animator.StringToHash(&quot;isOnGround&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); &#125; void Update() &#123; // 设置animatior的状态值 animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); // 使用编号对应赋值、字符串对应赋值 animator.SetBool(groundID, movement.isOnGround); animator.SetBool(&quot;isJumping&quot;, movement.isJump); animator.SetBool(&quot;isCrouching&quot;, movement.isCrouch); animator.SetBool(&quot;isHanging&quot;, movement.isHanging); &#125;&#125; 使用BlendTree 在Animator的BaseLayer中右键 Create State -&gt; From New Blend Tree 点击新的BlendTreeState，在Inspector -&gt; Motion 添加Motion，添加每一个motion对应的animation，且将Parameter设置为自定义的state Threshold临界值选项，当对应parameter值复合某一threshold值时会播放该animation，注意垂直向上水平向右为正 ​ 上图中MidAir1~7为起跳到下落的动画 修改动画脚本如下 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; Rigidbody2D rb; int speedID, groundID, jumpingID, crouchingID, hangingID, fallId; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); // animatior parameter对应编号 speedID = Animator.StringToHash(&quot;speed&quot;); groundID = Animator.StringToHash(&quot;isOnGround&quot;); jumpingID = Animator.StringToHash(&quot;isJumping&quot;); crouchingID = Animator.StringToHash(&quot;isCrouching&quot;); hangingID = Animator.StringToHash(&quot;isHanging&quot;); fallId = Animator.StringToHash(&quot;verticalVelocity&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); rb = GetComponentInParent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; // 设置animatior的状态值，两种方法（使用编号对应赋值、字符串对应赋值） // animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); animator.SetFloat(speedID, Mathf.Abs(movement.xVelocity)); animator.SetBool(groundID, movement.isOnGround); animator.SetBool(jumpingID, movement.isJump); animator.SetBool(crouchingID, movement.isCrouch); animator.SetBool(hangingID, movement.isHanging); animator.SetFloat(fallId, rb.velocity.y); &#125;&#125; 音效 注意Animation窗口中对应动画，含有特定的animation event需要添加 添加AudioManager(Prefab)，并为其添加script如下 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; static AudioManager current; [Header(&quot;环境声音&quot;)] public AudioClip ambientCilip; public AudioClip musicClip; [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; public void Awake() &#123; current = this; &#125;&#125; ​ 同时在AudioManager(Prefab)中选择相应的音效 添加AudioSource 12345678910111213141516171819202122232425262728293031323334353637383940414243using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; // ... AudioSource ambientSource, musicSource, fxSource, playerSource, voiceSource; public void Awake() &#123; // 单例模式 if(current != null) &#123; Destroy(gameObject); return; &#125; // 方便在static方法中使用this current = this; // 防止场景加载时被销毁 DontDestroyOnLoad(gameObject); // 使用代码添加AudioSource组件 ambientSource = gameObject.AddComponent&lt;AudioSource&gt;(); musicSource = gameObject.AddComponent&lt;AudioSource&gt;(); fxSource = gameObject.AddComponent&lt;AudioSource&gt;(); playerSource = gameObject.AddComponent&lt;AudioSource&gt;(); voiceSource = gameObject.AddComponent&lt;AudioSource&gt;(); &#125; public static void PlayFootstepAudio() &#123; // 获得随机数 int index = Random.Range(0, current.walkStepClips.Length); // 指定source的clip声音片段 current.playerSource.clip = current.walkStepClips[index]; // 播放 current.playerSource.Play(); &#125;&#125; 在PlayerAnimation中调用方法 1234public void StepAudio()&#123; AudioManager.PlayFootstepAudio();&#125; 其他音效同理，完整如下 AudioManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; static AudioManager current; [Header(&quot;环境声音&quot;)] public AudioClip ambientClip; public AudioClip musicClip; [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; // clip声音片段，source声音源 AudioSource ambientSource, musicSource, fxSource, playerSource, voiceSource; public void Awake() &#123; // 单例模式 if(current != null) &#123; Destroy(gameObject); return; &#125; // 方便在static方法中使用this current = this; // 防止场景加载时被销毁 DontDestroyOnLoad(gameObject); // 使用代码添加AudioSource组件 ambientSource = gameObject.AddComponent&lt;AudioSource&gt;(); musicSource = gameObject.AddComponent&lt;AudioSource&gt;(); fxSource = gameObject.AddComponent&lt;AudioSource&gt;(); playerSource = gameObject.AddComponent&lt;AudioSource&gt;(); voiceSource = gameObject.AddComponent&lt;AudioSource&gt;(); // 背景音乐不需要触发，直接播放 StartLevelAudio(); &#125; // 背景音乐 void StartLevelAudio() &#123; // 打开循环 current.ambientSource.clip = current.ambientClip; current.ambientSource.loop = true; current.ambientSource.Play(); current.musicSource.clip = current.musicClip; current.musicSource.loop = true; current.musicSource.Play(); &#125; // 角色走动音效 public static void PlayFootstepAudio() &#123; // 获得随机数 int index = Random.Range(0, current.walkStepClips.Length); // 指定source的clip声音片段 current.playerSource.clip = current.walkStepClips[index]; // 播放 current.playerSource.Play(); &#125; // 角色下蹲音效 public static void PlayCrouchFootstepAudio() &#123; int index = Random.Range(0, current.crouchStepClips.Length); current.playerSource.clip = current.crouchStepClips[index]; current.playerSource.Play(); &#125; // 角色跳跃音效 public static void PlayJumpAudio() &#123; current.playerSource.clip = current.jumpClip; current.playerSource.Play(); current.voiceSource.clip = current.jumpVoiceClip; current.voiceSource.Play(); &#125;&#125; PlayerAnimation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; Rigidbody2D rb; int speedID, groundID, jumpingID, crouchingID, hangingID, fallId; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); // animatior parameter对应编号 speedID = Animator.StringToHash(&quot;speed&quot;); groundID = Animator.StringToHash(&quot;isOnGround&quot;); jumpingID = Animator.StringToHash(&quot;isJumping&quot;); crouchingID = Animator.StringToHash(&quot;isCrouching&quot;); hangingID = Animator.StringToHash(&quot;isHanging&quot;); fallId = Animator.StringToHash(&quot;verticalVelocity&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); rb = GetComponentInParent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; // 设置animatior的状态值，两种方法（使用编号对应赋值、字符串对应赋值） // animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); animator.SetFloat(speedID, Mathf.Abs(movement.xVelocity)); animator.SetBool(groundID, movement.isOnGround); animator.SetBool(jumpingID, movement.isJump); animator.SetBool(crouchingID, movement.isCrouch); animator.SetBool(hangingID, movement.isHanging); animator.SetFloat(fallId, rb.velocity.y); &#125; public void StepAudio() &#123; AudioManager.PlayFootstepAudio(); &#125; public void CrouchStepAudio() &#123; AudioManager.PlayCrouchFootstepAudio(); &#125;&#125; ​ 由于Animation中没有添加jump的event，所以直接在playerMovement中调用音效即可 死亡机制 添加新的cs代码如下，应用于角色，用于死亡条件判断 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerHealth : MonoBehaviour&#123; // 预制死亡特效 public GameObject deathVFXPrefab; int trapsLayer; void Start() &#123; // 获得对应Layer的编号 trapsLayer = LayerMask.NameToLayer(&quot;Traps&quot;); &#125; // 如果一个碰撞体进入了触发器（当前角色已经被设定为isTrigger）则调用 private void OnTriggerEnter2D(Collider2D collision) &#123; if (collision.gameObject.layer == trapsLayer) &#123; // Instantiate实例化，此处让特效显示 Instantiate(deathVFXPrefab,transform.position,transform.rotation); // 让角色消失 gameObject.SetActive(false); // 播放死亡音效 AudioManager.PlayDeathAudio(); &#125; &#125;&#125; 添加死亡音效，注意在Inspector窗口中选择对应片段 1234567891011121314151617181920212223 [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; public AudioClip deathClip; public AudioClip deathVoiceClip; [Header(&quot;特效音效&quot;)] public AudioClip deathFXClip;// 死亡音效public static void PlayDeathAudio()&#123; current.playerSource.clip = current.deathClip; current.playerSource.Play(); current.voiceSource.clip = current.deathVoiceClip; current.voiceSource.Play(); current.fxSource.clip = current.deathFXClip; current.fxSource.Play();&#125; 设置场景重置，在file -&gt; build settings 中设置scene 123456using UnityEngine.SceneManagement;private void OnTriggerEnter2D(Collider2D collision)&#123; // 重置场景为当前场景 SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);&#125; 视觉效果与相机抖动Post Processing Window -&gt; PackageManager -&gt; 搜索插件Post Processing 为 Main Camera 添加Component -&gt; Post-process Layer，创建一个专门的Layer并添加 创建一个Empty Object，命名为Global Post Processing同时添加上一步骤中的Layer，用于承载视觉效果（如果是单独物件添加特效直接添加即可） 为该对象添加组件 Post-process Volume，其中is Global 用于影响全局，否则添加collider设置影响范围即可 为该对象添加Profile，同时Add effect Camera Shake 在之前添加的Cinemachine中， Inspector -&gt; Extension -&gt;Cinemachine Impulse Listener 在触发相机抖动效果的物件上添加组件 Cinemachine Collision Impulse Source(此为碰撞触发，可选其他source)， 为该组件添加Raw Signal即触发抖动时的效果，可以自行设置，选择TriggerObjectFilter中的LayerMask，即碰撞当前对象的Layer 其余如SignalShape中的FrequencyGain越大速度越快…… GameManager死亡过渡以及相关计数 添加Script，一定命名为GameManager，如下编写 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; DontDestroyOnLoad(this); &#125; public static void PlayerDied() &#123; // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.5f); &#125; // 重启场景 void RestartScene() &#123; SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 添加Empty Object并应用GameManager Script 添加SceneFader Script，编写如下，应用于Fader(UI -&gt; Image对象，含有过渡动画，其中Animator中有Fade参数) 12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;public class SceneFader : MonoBehaviour&#123; Animator anim; int faderID; private void Start() &#123; anim = GetComponent&lt;Animator&gt;(); faderID = Animator.StringToHash(&quot;Fade&quot;); &#125; public void fadeOut() &#123; anim.SetTrigger(faderID); &#125;&#125; 在GameManager中添加如下代码，这里mark一下，上网搜了其他的模式和方法，都可以实现，视频里讲的是观察者模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; SceneFader sceneFader; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; DontDestroyOnLoad(this); &#125; // 用于通知GameManager接收一个SceneFader实例 //public static void RegisterSceneFader(SceneFader fader) //&#123; // gm.sceneFader = fader; //&#125; public static void PlayerDied() &#123; //SceneFader.sf.fadeOut(); SceneFader.sf.fadeOut(); // 以下为另一种调用其他类的方法实现方法，还有其他方法或模式可以实现 //GameObject.Find(&quot;Fader&quot;).SendMessage(&quot;fadeOut&quot;); // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.2f); &#125; // 重启场景 void RestartScene() &#123; SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 123456789101112131415161718192021222324252627282930313233using System.Collections;using System.Collections.Generic;using UnityEngine;public class SceneFader : MonoBehaviour&#123; // 这里使用单例模式，能让其他类调用 public static SceneFader sf; Animator anim; int faderID; private void Awake() &#123; if (sf != null) &#123; return; &#125; sf = this; &#125; private void Start() &#123; anim = GetComponent&lt;Animator&gt;(); faderID = Animator.StringToHash(&quot;Fade&quot;); //GameManager.RegisterSceneFader(this); &#125; public void fadeOut() &#123; anim.SetTrigger(faderID); &#125;&#125; 添加收集物的相关脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; //SceneFader sceneFader; List&lt;Orb&gt; orbs; public int orbNum,deathNum; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; orbs = new List&lt;Orb&gt;(); DontDestroyOnLoad(this); &#125; private void Update() &#123; orbNum = gm.orbs.Count; &#125; // 用于通知GameManager接收一个SceneFader实例 //public static void RegisterSceneFader(SceneFader fader) //&#123; // gm.sceneFader = fader; //&#125; public static void RegisterOrb(Orb orb) &#123; if (!gm.orbs.Contains(orb)) &#123; gm.orbs.Add(orb); &#125; &#125; public static void PlayerDied() &#123; //SceneFader.sf.fadeOut(); SceneFader.sf.fadeOut(); // 以下为另一种调用其他类的方法实现方法，还有其他方法或模式可以实现 //GameObject.Find(&quot;Fader&quot;).SendMessage(&quot;fadeOut&quot;); // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.2f); gm.deathNum++; &#125; public static void PlayerGetOrb(Orb orb) &#123; if (gm.orbs.Count == 0 || !gm.orbs.Contains(orb)) return; gm.orbs.Remove(orb); &#125; // 重启场景 void RestartScene() &#123; gm.orbs.Clear(); SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;public class Orb : MonoBehaviour&#123; int playerLayer; public GameObject explosionVFXPrefab; void Start() &#123; playerLayer = LayerMask.NameToLayer(&quot;Player&quot;); GameManager.RegisterOrb(this); &#125; private void OnTriggerEnter2D(Collider2D collision) &#123; if(collision.gameObject.layer == playerLayer) &#123; GameManager.PlayerGetOrb(this); Instantiate(explosionVFXPrefab, transform.position, transform.rotation); gameObject.SetActive(false); AudioManager.PlayOrbAudio(); &#125; &#125;&#125; Door机关收集物品到一定数量后打开机关 编写Door Script 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class Door : MonoBehaviour&#123; Animator anim; int openID; void Start() &#123; anim = GetComponent&lt;Animator&gt;(); openID = Animator.StringToHash(&quot;Open&quot;); GameManager.RegisterDoor(this); &#125; public void Open() &#123; anim.SetTrigger(openID); AudioManager.PlayOpenDoorAudio(); &#125;&#125; 编写AudioManager 123456// 打开门音效 public static void PlayOpenDoorAudio() &#123; current.fxSource.clip = current.doorFXClip; current.fxSource.PlayDelayed(1f); &#125; UI Manager显示text 编写一个UI Manager Object，添加script如下 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;using TMPro;public class UIManager : MonoBehaviour&#123; static UIManager instance; // 获得Text文本框,记得在Inspector中选择相应的text public TextMeshProUGUI orbText, timeText, deathText, gameOverText; private void Awake() &#123; if(instance != null) &#123; Destroy(gameObject); return; &#125; instance = this; DontDestroyOnLoad(this); &#125; // 更新Orb数量 public static void UpdateOrbUI(int orbCount) &#123; // 设置text instance.orbText.text = orbCount.ToString(); &#125; // 其余text类似&#125; 在GameManager中适当位置调用UIManager相应方法即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System.Collections;using System.Collections.Generic;using UnityEngine;using TMPro;public class UIManager : MonoBehaviour&#123; static UIManager instance; // 获得Text文本框,记得在Inspector中选择相应的text public TextMeshProUGUI orbText, timeText, deathText, gameOverText; private void Awake() &#123; if(instance != null) &#123; Destroy(gameObject); return; &#125; instance = this; DontDestroyOnLoad(this); &#125; // 更新Orb数量 public static void UpdateOrbUI(int orbCount) &#123; // 设置text instance.orbText.text = orbCount.ToString(); &#125; // 更新Death数量 public static void UpdateDeathUI(int deathNum) &#123; // 设置text instance.deathText.text = deathNum.ToString(); &#125; // 更新Time public static void UpdateTimeUI(int time) &#123; int minutes = time / 60; int seconds = time % 60; // 设置text instance.timeText.text = minutes.ToString(&quot;00&quot;)+&quot;:&quot;+seconds.ToString(&quot;00&quot;); &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Unity2D","slug":"Unity2D","permalink":"http://example.com/tags/Unity2D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"}]},{"title":"【学习笔记】Vue","slug":"【学习笔记】Vue","date":"2021-08-04T03:44:20.728Z","updated":"2021-08-24T07:55:46.470Z","comments":true,"path":"2021/08/04/xue-xi-bi-ji-vue/","link":"","permalink":"http://example.com/2021/08/04/xue-xi-bi-ji-vue/","excerpt":"","text":"感谢【尚硅谷】2021最新Vue迅速上手教程丨vue3.0入门到精通_张天禹老师 前言​ 昨天看完springboot2的教学视频，计划着接下来要学什么，毕竟休息一天，就会一直偷懒下去。早上刚看到群里发企业项目要找个会vue，再结合结合vue的热度，虽然自己并不像和前端有太多纠葛（因为强迫症），但是大势所趋，都向着全栈靠呢，而且个人项目肯定也得自己做，所以学了都是好处没坏处。 其实七月初的时候看过两天的vue语法视频（为了暑假集训教学，其实并没有什么用，还忘光了），也没有记笔记，现在正式的看，好好学，好好记，目测两个星期看完？（毕竟也是学了点vue和微信小程序的，上手应该快）看完之后得做个项目了，vue+springboot，不过学期开学也要做个人项目，到时候做也是可以的。 Vue简介什么是Vue 一套用于构建用户界面的渐进式JavaScript框架。 Vue特点 采用组件化模式, 提高代码复用率、且让代码更好维护。 声明式编码,让编码人员无需直接操作DOM, 提高开发效率。 使用虛拟DOM+优秀的Diff算法, 尽量复用DOM节点。 basic容器与Vue实例 其实感觉不用写什么，直接看官方文档或者看代码👌 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 初识Vue： 1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象； 2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法； 3.root容器里的代码被称为【Vue模板】； 4.Vue实例和容器是一一对应的； 5.真实开发中只有一个Vue实例，并且会配合着组件一起使用； 6.&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性； 7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新； 注意区分：js表达式 和 js代码(语句) 1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方： (1). a (2). a+b (3). demo(1) (4). x === y ? &#x27;a&#x27; : &#x27;b&#x27; 2.js代码(语句) (1). if()&#123;&#125; (2). for()&#123;&#125;--&gt;&lt;!-- 准备好一个容器 --&gt;&lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; &gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //创建Vue实例 new Vue(&#123; el:&#x27;#demo&#x27;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。 data:&#123; //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。 name:&#x27;atguigu&#x27;, address:&#x27;北京&#x27; &#125; &#125;)&lt;/script&gt; 单向双向绑定1234567891011121314151617181920212223242526272829303132333435&lt;!-- Vue模板语法有2大类： 1.插值语法： 功能：用于解析标签体内容。 写法：&#123;&#123;xxx&#125;&#125;，xxx是js表达式，且可以直接读取到data中的所有属性。 2.指令语法： 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。 举例：v-bind:href=&quot;xxx&quot; 或 简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式， 且可以直接读取到data中的所有属性。 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。 --&gt;&lt;!-- 准备好一个容器--&gt;&lt;div id=&quot;root&quot;&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;hr/&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习1&lt;/a&gt; &lt;a :href=&quot;school.url&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习2&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;jack&#x27;, school:&#123; name:&#x27;尚硅谷&#x27;, url:&#x27;http://www.atguigu.com&#x27;, &#125; &#125; &#125;)&lt;/script&gt; MVVM 后面写代码去了没写笔记，笔记都在代码上","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"【集训】微信小程序(二)","slug":"【集训】微信小程序(二)","date":"2021-07-22T01:00:03.480Z","updated":"2021-07-23T05:35:01.858Z","comments":true,"path":"2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-er/","link":"","permalink":"http://example.com/2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-er/","excerpt":"","text":"API系统信息Object wx.getSystemInfoSync() | 微信开放文档 (qq.com) 1234567// 获取系统信息wx.getSystemInfo(&#123; success: (result) =&gt; &#123; console.log(result); console.log(result.model); &#125;,&#125;) 交互wx.showToast(Object object) | 微信开放文档 (qq.com) 12345678910111213141516// loading提示框wx.showLoading(&#123; title: &#x27;数据加载中&#x27;,&#125;)setTimeout(res =&gt; &#123; wx.hideLoading(&#123; success: (res) =&gt; &#123; console.log(&quot;加载完成&quot;); &#125;, &#125;)&#125;, 2000)// 消息提示wx.showToast(&#123; title: &#x27;提示信息&#x27;,&#125;) 路由跳转页面wx.navigateTo(Object object) | 微信开放文档 (qq.com) 1&lt;button type=&quot;primary&quot; bindtap=&quot;clickBtn&quot;&gt;跳转到demo01&lt;/button&gt; 123456789clickBtn() &#123; // 可带参数,调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会 wx.navigateTo(&#123; url: &#x27;/pages/demo05/demo05?id=111&#x27;, success: (res) =&gt; &#123; console.log(res); &#125; &#125;) &#125; 返回页面wx.navigateBack(Object object) | 微信开放文档 (qq.com) 1&lt;button bindtap=&quot;clickBack&quot; type=&quot;primary&quot;&gt;返回上一页&lt;/button&gt; 12345clickBack() &#123; wx.navigateBack(&#123; delta: 1, &#125;) &#125; 事件传值EventChannel | 微信开放文档 (qq.com) demo04.js 1234567891011121314151617clickBtn() &#123; // 可带参数,调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会 wx.navigateTo(&#123; url: &#x27;/pages/demo05/demo05?id=111&#x27;, events: &#123; // 为指定事件添加一个监听器 myBackData(data) &#123; console.log(data); &#125; &#125;, // 成功的回调函数 success: (res) =&gt; &#123; // 触发一个事件 res.eventChannel.emit(&quot;myGetData&quot;, &#123; data: &quot;传递的数据&quot; &#125;) &#125; &#125;) &#125; demo05.js 1234567891011121314151617181920onLoad() &#123; // 获取所有打开的EventChannel事件 const eventChannel = this.getOpenerEventChannel(); // 监听index页面的myGetData事件 eventChannel.on(&quot;myGetData&quot;, (res) =&gt; &#123; // 被触发后的操作 console.log(res); &#125;); eventChannel.emit(&quot;myBackData&quot;, &#123; data: &quot;返回的数据&quot; &#125;)&#125;,clickBack() &#123; //const eventChannel = this.getOpenerEventChannel(); //eventChannel.emit(&quot;myBackData&quot;, &#123; data: &quot;返回的数据&quot; &#125;) // 通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。 wx.navigateBack(&#123; delta: 1, &#125;)&#125; 网络临时数据demo06.wxml 123456789101112&lt;!--pages/demo06/demo06.wxml--&gt;&lt;view class=&quot;out&quot;&gt; &lt;view class=&quot;row&quot; wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; wx:key=&quot;*this&quot;&gt; &lt;view class=&quot;pic&quot;&gt; &lt;image src=&quot;&#123;&#123;item.url&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;text&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;item.time&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; demo06.js 12345678910111213141516171819data: &#123; dataList: [ &#123; title: &quot;标题1&quot;, time: &quot;2020-01-01&quot;, url: &quot;/images/image1.png&quot; &#125;, &#123; title: &quot;标题2&quot;, time: &quot;2020-01-02&quot;, url: &quot;/images/image1.png&quot; &#125;, &#123; title: &quot;标题3&quot;, time: &quot;2020-01-03&quot;, url: &quot;/images/image1.png&quot; &#125; ]&#125;, 请求数据RequestTask | 微信开放文档 (qq.com) 使用wx.request获取数据 1234567891011121314151617181920onLoad: function (options) &#123; wx.request(&#123; // 接口地址 url: &#x27;http://edu.newsight.cn/wxList.php&#x27;, // 请求的参数 data: &#123; num: 5, page: 1 &#125;, // 接口调用成功的回调函数 success: (res) =&gt; &#123; console.log(res); console.log(res.data); // 设置数据 this.setData(&#123; reqData: res.data &#125;) &#125;, &#125;)&#125;, 修改之前的代码 demo06.wxml 123456789101112&lt;!--pages/demo06/demo06.wxml--&gt;&lt;view class=&quot;out&quot;&gt; &lt;view class=&quot;row&quot; wx:for=&quot;&#123;&#123;reqData&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;view class=&quot;pic&quot;&gt; &lt;image src=&quot;&#123;&#123;item.picurl&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;text&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;item.posttime&#125;&#125; - &#123;&#123;item.author&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 如果域名检验不合法，可以在微信公众平台的开发中管理添加所需要使用的域名，或者开发者工具在设置不检测合法。 事件绑定刷新数据demo06.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// pages/demo06/demo06.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; reqData: [], scrollTop: 0 &#125;, reqParam: &#123; page: 1 &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.getReqData(1); &#125;, // 下一页 clickToNextPage() &#123; this.reqParam.page++; this.getReqData(this.reqParam.page) &#125;, getReqData(page) &#123; wx.request(&#123; // 接口地址 url: &#x27;http://edu.newsight.cn/wxList.php&#x27;, // 请求的参数 data: &#123; num: 4, page: page &#125;, // 接口调用成功的回调函数 success: (res) =&gt; &#123; console.log(res); console.log(res.data); // 设置数据 this.setData(&#123; reqData: res.data &#125;) &#125;, &#125;) &#125;&#125;) demo06.wxml 1&lt;button bindtap=&quot;clickToNextPage&quot; type=&quot;primary&quot;&gt;下一页&lt;/button&gt; 用户信息wx.getUserProfile(Object object) | 微信开放文档 (qq.com) demo07.wxml 123&lt;button bindtap=&quot;login&quot; type=&quot;primary&quot;&gt;授权登录&lt;/button&gt;&lt;view&gt;&#123;&#123;nickName&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt; demo07.js 12345678910111213141516171819202122data: &#123; nickName: &quot;&quot;, avatar: &quot;&quot;,&#125;,// 授权登录login() &#123; wx.getUserProfile(&#123; // 声明获取用户个人信息后的用途，不超过30个字符 desc: &#x27;声明获取用户信息后的用途&#x27;, success: (res) =&gt; &#123; console.log(res); this.setData(&#123; nickName: res.userInfo.nickName, avatar: res.userInfo.avatarUrl &#125;) &#125;, fail: (res) =&gt; &#123; console.log(res); &#125; &#125;)&#125; 缓存wx.setStorageSync(string key, any data) | 微信开放文档 (qq.com) 存123456789101112131415161718login() &#123; wx.getUserProfile(&#123; // 声明获取用户个人信息后的用途，不超过30个字符 desc: &#x27;声明获取用户信息后的用途&#x27;, success: (res) =&gt; &#123; console.log(res); this.setData(&#123; nickName: res.userInfo.nickName, avatar: res.userInfo.avatarUrl &#125;); // 存信息 wx.setStorageSync(&#x27;userInfo&#x27;, res.userInfo); &#125;, fail: (res) =&gt; &#123; console.log(res); &#125; &#125;)&#125; 取123&lt;button bindtap=&quot;login&quot; type=&quot;primary&quot; wx:if=&quot;&#123;&#123;!nickName&#125;&#125;&quot;&gt;授权登录&lt;/button&gt;&lt;view&gt;&#123;&#123;nickName&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt; 123456789onLoad: function (options) &#123; // 取缓存 let userInfo = wx.getStorageSync(&#x27;userInfo&#x27;); console.log(userInfo); this.setData(&#123; nickName: userInfo.nickName, avatar: userInfo.avatarUrl &#125;)&#125;, 模块化Object module | 微信开放文档 (qq.com) public.js 123456789101112var myPublic = &#123; fun1() &#123; console.log(&quot;执行fun1&quot;); &#125;, fun2(p) &#123; console.log(&quot;执行fun2,参数：&quot; + p); &#125;&#125;module.exports = myPublic demo08.js 123456const myPublic = require(&#x27;../../utils/public.js&#x27;)onLoad: function (options) &#123; myPublic.fun1(); myPublic.fun2(&quot;param&quot;);&#125;, 小程序上线 修改测试号为AppID 小程序 (qq.com)管理服务器域名，取消不检验合法域名 上传代码 小程序 (qq.com)提交审核","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"【集训】微信小程序(一)","slug":"【集训】微信小程序(一)","date":"2021-07-22T01:00:03.478Z","updated":"2021-07-23T05:50:01.078Z","comments":true,"path":"2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-yi/","link":"","permalink":"http://example.com/2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-yi/","excerpt":"","text":"自定义组件Component(Object object) | 微信开放文档 (qq.com) 将部分重复代码抽取出来 商品分类 (taobao.com) 创建自定义组件 类似于页面，一个自定义组件由json、wxml、wxss、js 4个文件组成 可以在微信开发者⼯具中快速创建组件的⽂件结构 声明组件、引入组件tabs.json 123&#123; &quot;component&quot;: true&#125; demo01.json 12345&#123; &quot;usingComponents&quot;: &#123; &quot;Tabs&quot;: &quot;/components/Tabs/Tabs&quot; &#125;&#125; 简单编辑组件Tabs.wxml 123456789101112&lt;!--components/Tabs/Tabs.wxml--&gt;&lt;view class=&quot;tabs&quot;&gt; &lt;view class=&quot;tabs_title&quot;&gt; &lt;view class=&quot;title_item active&quot;&gt;首页&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;原创&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;分类&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;关于&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tabs_content&quot;&gt; &lt;/view&gt;&lt;/view&gt; Tabs.wxss 12345678910111213141516171819202122/* components/Tabs/Tabs.wxss */.tabs &#123;&#125;.tabs_title &#123; display: flex; padding: 10rpx 0;&#125;.title_item &#123; flex: 1; display: flex; justify-content: center; align-items: center;&#125;/* 选中时的样式 */.active &#123; color: #b81d24; border-bottom: 5rpx solid currentColor;&#125;.tabs_content &#123;&#125; 以上数据都写在组件的wxml中，接下来来实现js动态数据 填入初始数据Tabs.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// components/Tabs/Tabs.jsComponent(&#123; /** * 组件的属性列表 */ properties: &#123; &#125;, /** * 组件的初始数据 */ data: &#123; tabs: [ &#123; id: 0, name: &quot;首页&quot;, isActive: true &#125;, &#123; id: 1, name: &quot;原创&quot;, isActive: false &#125; , &#123; id: 2, name: &quot;分类&quot;, isActive: false &#125; , &#123; id: 3, name: &quot;关于&quot;, isActive: false &#125; ] &#125;, /** * 组件的方法列表 */ methods: &#123; &#125;&#125;) Tab.wxml 12345678910111213&lt;view class=&quot;tabs&quot;&gt; &lt;view class=&quot;tabs_title&quot;&gt; &lt;!-- 列表渲染 --&gt; &lt;!-- class中三元表达式，根据item的isActive属性判断是否选中，选中则添加类名以显示样式 --&gt; &lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tabs_content&quot;&gt;&lt;/view&gt; &lt;/view&gt; 绑定点击事件Tab.wxml 123456789&lt;view class=&quot;tabs_title&quot;&gt; &lt;!-- 列表渲染 --&gt; &lt;!-- class中三元表达式，根据item的isActive属性判断是否选中，选中则添加类名以显示样式 --&gt; &lt;!-- data-index自定义属性，用于传递当前的索引值 --&gt; &lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot; bindtap=&quot;handleItemTap&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/view&gt;&lt;/view&gt; 注意自定义组件的方法写在methods中 Tabs.js 123456789101112131415161718192021222324252627methods: &#123; handleItemTap(e) &#123; // 查看索引所在的位置 console.log(e); // 1.获取被点击的索引 // ES6常量const,只读不可改 // ES6解构赋值:const &#123; index &#125; = e.currentTarget.dataset; const index = e.currentTarget.dataset.index; // 2.获取原数组 // ES6变量let,块级作用域 // ES6解构赋值:let &#123; tabs &#125; = this.data; let tabs = this.data.tabs; // 3.循环数组：为当前索引项设置isActive：true,其余false // ES6箭头函数 tabs.forEach((v, i) =&gt; &#123; i === index ? v.isActive = true : v.isActive = false &#125;); // 修改数据 this.setData(&#123; tabs &#125;) &#125;&#125; 以上数据都写在组件中，接下来来实现父向子传递数据 父向子传递数据demo01.wxml 123456&lt;!-- 父组件demo01，子组件Tabs 父组件通过标签属性传递数据 子组件在properties中接收--&gt;&lt;Tabs abc=&quot;要传递的数据&quot;&gt;&lt;/Tabs&gt; Tabs.js 123456789properties: &#123; // 属性名 abc: &#123; // 接收的数据的类型 type: String, // 默认值 value: &quot;&quot; &#125;&#125;, Tabs.wxml 12&lt;!-- 相当于data中的数据使，用&#123;&#123;&#125;&#125;渲染 --&gt;&lt;view&gt;&#123;&#123;abc&#125;&#125;&lt;/view&gt; 接下来修改案例代码 将要传递的数据放在父组件的data中，即原先写在Tabs.js的data中的数据放在demo01.js的data中 1234567891011121314151617181920212223242526data: &#123; tabs: [ &#123; id: 0, name: &quot;首页&quot;, isActive: true &#125;, &#123; id: 1, name: &quot;原创&quot;, isActive: false &#125; , &#123; id: 2, name: &quot;分类&quot;, isActive: false &#125; , &#123; id: 3, name: &quot;关于&quot;, isActive: false &#125; ]&#125;, 父组件通过标签属性传递数据 demo01.wxml 1&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot;&gt;&lt;/Tabs&gt; 子组件在properties中接收，最后效果与之前相同 Tabs.js 123456properties: &#123; tabs: &#123; type: Array, value: [] &#125;&#125;, 此时Tabs.js中代码仍然是在子组件当中修改tab数组，而不是在父组件的data中修改tab（可以在AppData窗口查看） 123456// this.data中找不到数据，则在properties中寻找let tabs = this.data.tabs;// 将tabs放入data当中this.setData(&#123; tabs&#125;) 所以需要将处理数据放在父组件当中，而所需要的索引值则由子组件传递给父组件（子向父传递数据） 子向父传递数据Tabs.js 12345678methods: &#123; handleItemTap(e) &#123; // 1.获取被点击的索引 const index = e.currentTarget.dataset.index; // 2.触发父组件中的自定义事件，并传递数据 this.triggerEvent(&quot;itemChange&quot;, &#123; index &#125;); //triggerEvent(&quot;自定义事件名&quot;, 要传递的数据) &#125;&#125; demo01.wxml 123456&lt;!-- 子组件Tabs -&gt; 父组件demo01 在子组件的标签中添加自定义事件 编写父组件js事件方法--&gt;&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tabs&gt; demo01.js 1234567891011121314// 自定义事件方法handleItemChange(e) &#123; console.log(e); // 接收传递的数据 const index = e.detail.index; // 以下代码相同 let tabs = this.data.tabs; tabs.forEach((v, i) =&gt; &#123; i === index ? v.isActive = true : v.isActive = false &#125;); this.setData(&#123; tabs &#125;)&#125;, AppData窗口查看即可 slot标签 slot占位符（插槽），父组件调用子组件传递一些标签来替换slot的位置 Tabs.wxml 123&lt;view class=&quot;tabs_content&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/view&gt; demo01.wxml 123456&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt; &lt;block wx:if=&quot;&#123;&#123;tabs[0].isActive&#125;&#125;&quot;&gt;内容1&lt;/block&gt; &lt;block wx:elif=&quot;&#123;&#123;tabs[1].isActive&#125;&#125;&quot;&gt;内容2&lt;/block&gt; &lt;block wx:elif=&quot;&#123;&#123;tabs[2].isActive&#125;&#125;&quot;&gt;内容3&lt;/block&gt; &lt;block wx:else&gt;内容4&lt;/block&gt;&lt;/Tabs&gt; 生命周期应用 12345678910111213141516171819202122232425262728293031323334// app.jsApp(&#123; // 应用 第一次启动 的时候触发，可用于最开始获取用户的个人信息等 onLaunch() &#123; console.log(&quot;onLaunch&quot;); &#125;, // 应用 显示 的时候触发，可用于对页面数据、页面效果进行重置 onShow() &#123; console.log(&quot;onShow&quot;); // 可调用多次 &#125;, // 应用 隐藏 的时候触发，可用于暂停或清除定时器 onHide() &#123; console.log(&quot;onHide&quot;); &#125;, // 应用 代码报错 的时候触发，可用于收集错误信息并发送到后台 onError(error) &#123; console.log(&quot;onError&quot;); console.log(error); &#125;, // 应用 第一次启动找不到入口页面 的时候触发，可用于跳转 onPageNotFound() &#123; console.log(&quot;onPageNotFound&quot;); wx.navigateTo(&#123; url: &#x27;/pages/demo01/demo01&#x27;, &#125;) &#125;&#125;) 页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// pages/demo02/demo02.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 * 发送异步请求初始化页面数据 */ onLoad: function (options) &#123; console.log(&quot;onLoad&quot;); &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; console.log(&quot;onShow&quot;); &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; console.log(&quot;onReady&quot;); &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; console.log(&quot;onHide&quot;); &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; console.log(&quot;onUnload&quot;); &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 * 对页面初始化 */ onPullDownRefresh: function () &#123; console.log(&quot;onPullDownRefresh&quot;); &#125;, /** * 页面上拉触底事件的处理函数 * 触底加载更多数据 */ onReachBottom: function () &#123; console.log(&quot;onReachBottom&quot;); &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; console.log(&quot;onShareAppMessage&quot;); &#125;, /** * 页面滚动 */ onPageScroll() &#123; console.log(&quot;onPageScroll&quot;); &#125;, /** * 页面尺寸改变 */ onResize() &#123; console.log(&quot;onResize&quot;); &#125;, /** * 当前是tab页，点击当前页的tab时触发 */ onTabItemTap() &#123; console.log(&quot;onTabItemTap&quot;); &#125;&#125;)","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"【学习笔记】SpringBoot2","slug":"【学习笔记】SpringBoot2","date":"2021-07-20T10:31:35.005Z","updated":"2021-08-18T04:48:58.808Z","comments":true,"path":"2021/07/20/xue-xi-bi-ji-springboot2/","link":"","permalink":"http://example.com/2021/07/20/xue-xi-bi-ji-springboot2/","excerpt":"","text":"教程与文档SpringBoot2核心技术与响应式编程 · 语雀 (yuque.com) Spring与SpringBoot201、Spring与SpringBoot · 语雀 (yuque.com) HelloWorld 导入依赖 pom.xml 1234567891011121314&lt;!-- 父项目配置 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- web场景启动器 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写controller HelloController.java 12345678910// @Controller // 注明controller// @ResponseBody // 注明将java对象转为json格式的数据@RestController // 代替以上两者public class HelloController &#123; // 映射请求的地址 @RequestMapping(&quot;/hello&quot;) public String handle1() &#123; return &quot;Hello,SpringBoot2&quot;; &#125;&#125; 编写主程序类并测试 MainApplication.java 1234567891011/** * 主程序类 */// 表明这是一个SpringBoot应用@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // run声明主程序类，返回一个IoC容器 SpringApplication.run(MainApplication.class, args); &#125;&#125; resources文件夹下application.properties，可根据文档自定义配置 Common Application properties (spring.io) 创建可执行jar包，添加build依赖，然后点击maven中的lifecycle中的clean与package并执行 pom.xml 123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行jar包，在target目录下执行以下命令 java -jar 包名.jar 依赖管理与自动配置特性雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 底层注解@Configuration、@Bean 配置对象原原Spring使用xml配置文件配置bean对象如下 bean.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user01&quot; class=&quot;com.myspringboot2.bean.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.myspringboot2.bean.Pet&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;mimi&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 现编写配置MyConfig.java 1234567891011121314151617/** * 1、配置类里面使用@Bean添加对象，默认是单实例 * 2、配置类本身也是对象 * 3、proxyBeanMethods: 代理bean的方法。默认为true(full模式)，使用代理对象调用方法，保证对象是单实例；否则(lite模式)非单实例 */@Configuration(proxyBeanMethods = true) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; // 无论外部对这个配置类中的方法调用多少次，获得的都是容器中的单实例对象 @Bean //向容器中添加组件，id为方法名(可以自定义)，组件类型为返回类型，组件在容器中的实例为返回地值 public User user01() &#123; return new User(&quot;zhangsan&quot;, 18); &#125; @Bean(&quot;pet01&quot;) //自定义id public Pet cat() &#123; return new Pet(&quot;mimi&quot;); &#125;&#125; 测试类MainApplication.java 123456789101112131415/** * 主程序类 */// 表明这是一个SpringBoot应用@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类,返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 从容器中获取bean,默认是单实例 User user01 = run.getBean(&quot;user01&quot;, User.class); Pet pet01 = run.getBean(&quot;pet01&quot;, Pet.class); MyConfig myConfig = run.getBean(MyConfig.class); &#125;&#125; Full模式与Lite模式 配置类组件之间无依赖关系用Lite模式加速客器启动过程,减少判断 配置类组件之间有依赖关系,方法会被调用得到之前单实例组件,用Full模式 @ComponentScan 包扫描1234// 一下三者相当于@SpringBootApplication@ComponentScan(&quot;com.myspringboot2&quot;) //包扫描地址@EnableAutoConfiguration@SpringBootConfiguration @Import 注入对象1@Import(&#123;User.class, DBHelper.class&#125;) //向容器中添加对应类型的对象,默认对象名为对应类的全类名 @Conditional 条件装配使用 MyConfig.java 12345678@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; @ConditionalOnBean(name = &quot;pet02&quot;) // 按条件执行向容器中注入对象,可放在类上(则按条件执行是否注入类中所有的对象) @Bean //向容器中添加组件，id为方法名(可以自定义)，组件类型为返回类型，组件在容器中的实例为返回地值 public User user01() &#123; return new User(&quot;zhangsan&quot;, 18); &#125;&#125; 测试 MainApplication.java 123456789@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类，返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 由于user01配置的是由添加了ConditinalOnBean,而其中的条件pet02对象并不在容器当中，所以未注入user01 System.out.println(run.containsBean(&quot;user01&quot;)); &#125;&#125; @ImportResource 导入xml配置文件1234@ImportResource(&quot;classpath:beans.xml&quot;) //兼容xml配置@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123;&#125; 123456789@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类，返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 使用@ImportResource成功注入beans.xml中的对象 System.out.println(run.containsBean(&quot;user01&quot;)); &#125;&#125; @ConfigurationProperties 配置绑定编写属性， application.properties，注意使用全小写 12mycar.brand=ABCmycar.price=100000 第一种方法：需要在容器中的组件上使用， Car.java 1234567@Component //声明为组件，只有容器中的组件才能使用@ConfigurationProperties(prefix = &quot;mycar&quot;) //绑定配置文件中的属性，prefix指定对应前缀public class Car &#123; String brand; Integer price; // ……&#125; 第二种方法：不使用@Component声明Car为组件，而是在配置类种开启指定对象的属性配置功能 12345@EnableConfigurationProperties(Car.class) //开启指定对象的属性配置功能@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; // ……&#125; 测试， HelloController.java 123456789@RestControllerpublic class HelloController &#123; @Autowired Car car; @RequestMapping(&quot;/car&quot;) public Car car() &#123; return car; &#125;&#125; 自动配置原理（源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili @SpringBootApplication 声明当前是一个配置类 @ComponentScan 指定扫描路径 @EnableAutoConfiguration@AutoConfigurationPackage 利用Registrar将当前包下的所有组件全部导入进容器 @Import 导入默认组件 便捷使用Lombok 简化JavaBean编写等 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 编写JavaBean 1234567@NoArgsConstructor //自动编写无参构造器@AllArgsConstructor //自动编写全参构造器@Data //自动编写set/get/toString方法public class Car &#123; String brand; Integer price;&#125; 编写controller的日志打印 12345678910@Slf4j //引入日志接口@RestControllerpublic class HelloController &#123; // 映射请求的地址 @RequestMapping(&quot;/hello&quot;) public String handle1() &#123; log.info(&quot;hello&quot;); //日志打印信息 return &quot;Hello,SpringBoot2&quot;; &#125;&#125; Dev-tools、JRebel 自动重启、热更新 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 使用 Ctrl+F9 更新 Spring Initializr 快速创建springboot应用，创建应用时选择即可 配置文件propertiesyaml基本语法 key: value #注意空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进空格数无影响，同层级的元素需要左对齐 #编写注释 “”双引号内\\n等不转义，仍然是回车的本意显示为回车，’’单引号内转义，\\n显示为字符串 数据类型 字面量 1key: value 对象 123456k: &#123;k1: v1,k2: v2,k3: v3&#125;# 或k: k1: v1 k2: v2 k3: v3 数组 123456k: [v1,v2,v3]# 或k: - v1 - v2 - v3 示例雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili configuration-processor 配置处理器 添加依赖 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;!-- 打包的时候不带这个包 --&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; web开发简单功能静态资源访问 静态资源目录 存放路径：类路径(resources资源根目录)下的/static or /public or /resources or /META-INF/resources 访问路径：项目根路径/静态资源名 原理： 静态映射/**。请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面 改变默认的静态资源访问路径和存放路径，在配置文件application.yaml中编写 12345spring: mvc: static-path-pattern: /res/** #res为自定义前缀，即访问地址须在项目根路径/res/静态资源名 resources: static-locations: [classpath:/自定义文件夹名/] 欢迎页命名为index.html放在静态资源目录下即可。 自定义Favicon命名为favicon.ico 放在静态资源目录下即可。 源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 请求处理@xxxMapping 请求映射 Rest风格支持（使用HTTP请求方式动词来表示对资源的操作） 以前：**/getUser 获取用户 /deleteUser 删除用户 /editUser 修改用户 /saveUser 保存用户 现在： /user GET-获取用户 DELETE-删除用户 PUT-修改用户 POST-保存用户 编写controller类 1234567891011121314151617181920212223@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET) public String getUser() &#123; return &quot;getUser GET&quot;; &#125; @PostMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST) public String saveUser() &#123; return &quot;saveUser POST&quot;; &#125; @PutMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT) public String modifiedUser() &#123; return &quot;modifiedUser PUT&quot;; &#125; @DeleteMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE) public String deleteUser() &#123; return &quot;deleteUser DELETE&quot;; &#125;&#125; 编写页面 12345678910111213141516&lt;form action=&quot;/user&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;get提交&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;post提交&quot;&gt;&lt;/form&gt;&lt;!-- form表单中method只能写get/post --&gt;&lt;!-- 使用隐藏域传递_method方法参数的值 --&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;PUT提交&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;DELETE提交&quot;&gt;&lt;/form&gt; 在配置文件中开启hiddenmethod-filter(默认为false)，如果前端不是使用表单发送请求则不需要开启filter 12345spring: mvc: hiddenmethod: filter: enabled: true 自定义HiddenMethodFilter编写配置类，自定义filter 12345678@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; public HiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; HiddenHttpMethodFilter filter = new HiddenHttpMethodFilter(); filter.setMethodParam(&quot;_m&quot;); //修改方法参数名为_m return filter; &#125;&#125; 请求映射原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 参数注解@PathVariable、@RequestHeader、@RequestParam、@CookieValue、@RequestBody12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@RestControllerpublic class ParamTestController &#123; // 测试url: http://localhost:8080/test1/1/lisi?age=10&amp;inters=%E5%90%83%E9%A5%AD&amp;inters=%E7%9D%A1%E8%A7%89 @GetMapping(&quot;/test1/&#123;id&#125;/&#123;username&#125;&quot;) public Map&lt;String, Object&gt; test1(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String, String&gt; variables, @RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader Map&lt;String, String&gt; headers, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, @RequestParam Map&lt;String,String&gt; params1, @RequestParam MultiValueMap&lt;String, String&gt; params2, @CookieValue(&quot;_xsrf&quot;) String _xsrf, @CookieValue(&quot;_xsrf&quot;) Cookie cookie) &#123; /** * @PathVariable(&quot;&quot;) 获得指定路径变量名的值 * @PathVariable 获得所有路径变量名以及值，存放到Map&lt;String, String&gt;中 * 注意后者键值对对应的是地址栏中的username参数名，而前者是形参名name * * @RequestHeader(&quot;&quot;) 获得请求头中指定key的值 * @RequestHeader 获得请求头中所有的key及其值 * * @RequestParam(&quot;&quot;) 获得指定请求参数名的值 * @RequestParam 获得所有请求参数名以及值，存放到Map&lt;String, String&gt;中 * 注意后者存放在map中，kv只有一对，可使用MultiValueMap获取到一对多的键值对。 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 以下是测试 map.put(&quot;id&quot;, id); map.put(&quot;name&quot;, name); map.put(&quot;pv&quot;, variables); map.put(&quot;userAgent&quot;, userAgent); map.put(&quot;rh&quot;, headers); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params1&quot;,params1); map.put(&quot;params2&quot;,params2); map.put(&quot;_xsrf&quot;,_xsrf); System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;/test2&quot;) public Map&lt;String, Object&gt; test2(@RequestBody String content)&#123; /** * @RequestBody 获得请求体中所有的key及对应值 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 以下是测试 map.put(&quot;content&quot;, content); return map; &#125;&#125; @RequestAttribute 获取域对象参数值1234567891011121314151617181920212223@Controller //注意RestController写return &quot;forward:/success&quot;只会解析成字符串public class RequestController &#123; @GetMapping(&quot;/goto&quot;) public String gotoPage(HttpServletRequest req) &#123; req.setAttribute(&quot;msg&quot;, &quot;信息&quot;); req.setAttribute(&quot;code&quot;, &quot;信息123123&quot;); return &quot;forward:/success&quot;; //转发到/success请求 &#125; @ResponseBody @GetMapping(&quot;/success&quot;) public Map&lt;String, Object&gt; success(@RequestAttribute(&quot;msg&quot;) String msg, @RequestAttribute(&quot;code&quot;) String code) &#123; /** * @RequestAttribute 获得request域对象中的指定值 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;, msg); map.put(&quot;code&quot;, code); return map; &#125; &#125; @MatrixVariable 获取矩阵变量12345678910111213141516171819202122232425262728//1、矩阵变量语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd //2、SpringBoot默认是禁用了矩阵变量的功能 // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。 // removeSemicolonContent（移除分号内容）支持矩阵变量的 //3、矩阵变量必须有url路径变量才能被解析 @GetMapping(&quot;/cars/&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; // /boss/1;age=20/2;age=10 @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125; 12345678910111213141516171819202122@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; public HiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; HiddenHttpMethodFilter filter = new HiddenHttpMethodFilter(); filter.setMethodParam(&quot;_m&quot;); //修改_method return filter; &#125; @Bean // 自定义其中的功能,此处演示启用矩阵变量功能 public WebMvcConfigurer webMvcConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper = new UrlPathHelper(); // 设置不删除分号内容 urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125; &#125;; &#125;&#125; ServletAPI WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 参数注解源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 直接看困了，以后再看吧。 自定义参数绑定 编写两个bean 12345678@Datapublic class User &#123; String username; String password; Integer age; Date birthday; Pet pet;&#125; 12345@Datapublic class Pet &#123; String name; Integer age;&#125; 编写表单 12345678&lt;form action=&quot;/saveuser&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot;&gt; 生日：&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt; 宠物名字：&lt;input type=&quot;text&quot; name=&quot;pet.name&quot;&gt; 宠物年龄：&lt;input type=&quot;number&quot; name=&quot;pet.age&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;POST提交&quot;&gt;&lt;/form&gt; 编写controller测试 1234@PostMapping(&quot;/saveuser&quot;)public User saveuser(User user) &#123; return user;&#125; 自定义转换器12345678910111213141516171819202122232425@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; @Bean // 自定义其中的功能 public WebMvcConfigurer webMvcConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new Converter&lt;String, Date&gt;() &#123; @Override public Date convert(String s) &#123; SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try &#123; date = sf.parse(s); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; &#125;); &#125; &#125;; &#125;&#125; 数据响应与内容协商响应JSON数据 引入jackson.jar，已包含在starter-web场景启动器中 使用注解@ResponseBody 响应原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 内容协商 根据客户端接收能力不同，返回不同媒体类型的数据。 以xml为示例，引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt; 请求头里accept字段，设置了接收数据以xml格式为优先 开启基于请求参数的内容协商原理，同时url中添加请求参数format=xxx即可 1234spring: mvc: contentnegotiation: favor-parameter: true 内容协商原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 自定义MessageConvertor雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 视图解析与模板引擎thymeleaf java模板引擎 基本语法 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 编写模板 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;默认的值&lt;/h1&gt; &lt;h2&gt; &lt;a href=&quot;www.google.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;跳转百度&lt;/a&gt; &lt;a href=&quot;www.google.com&quot; th:href=&quot;@&#123;link&#125;&quot;&gt;跳转百度&lt;/a&gt; &lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 编写controller 1234567891011@Controllerpublic class ViewTestController &#123; @GetMapping(&quot;/testsuccess&quot;) public String test(Model model) &#123; // model中的数据会被放在请求域中 model.addAttribute(&quot;msg&quot;, &quot;msgTest&quot;); model.addAttribute(&quot;link&quot;, &quot;https://www.baidu.com&quot;); // 跳转页面写页面的前名 return &quot;success&quot;; &#125;&#125; 拦截器雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 编写Interceptor 123456789101112131415161718192021222324252627282930313233343536/** * 登陆检查 */@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; /** * 目标方法执行之前 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info(&quot;Run LoginInterceptor.preHandle&quot;); HttpSession session = request.getSession(); Object loginUser = session.getAttribute(&quot;loginUser&quot;); if (loginUser != null) &#123; return true; &#125; else &#123; session.setAttribute(&quot;msg&quot;, &quot;当前尚未登录&quot;); response.sendRedirect(&quot;/&quot;); return false; &#125; &#125; /** * 目标方法执行之后 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;Run LoginInterceptor.postHandle&quot;,modelAndView); &#125; /** * 页面渲染以后 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info(&quot;Run LoginInterceptor.afterCompletion&quot;,ex); &#125;&#125; 编写WebConfig类，添加interceptor 12345678910@Configurationpublic class AdminWebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 添加拦截器，并且设置拦截地址与不拦截地址 // /**拦截目录下所有资源，静态资源也会被拦截 registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/js/**&quot;,&quot;/font/**&quot;,&quot;/images/**&quot;); // 设置exlucde不拦截，或者在配置文件中编写static-path-pattern=/static/**，注意此时需要修改标签中的href &#125;&#125; 文件上传雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 编写controller 1234567891011121314151617181920212223242526272829303132333435/** * 文件上传测试 */@Slf4j@Controllerpublic class FormTestController &#123; @GetMapping(&quot;/form_layouts&quot;) public String formLayouts() &#123; return &quot;form/form_layouts&quot;; &#125; /** * MultipartFile自动封装上传过来的文件 */ @PostMapping(&quot;/upload&quot;) public String upload(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;name&quot;) String name, @RequestPart(&quot;headImg&quot;) MultipartFile headImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123; // 获取的信息 log.info(&quot;上传的信息：email=&#123;&#125;,name=&#123;&#125;,headImg=&#123;&#125;,photos=&#123;&#125;&quot;, email, name, headImg.getSize(), photos.length); if (!headImg.isEmpty()) &#123; // 获取原文件名、保存到服务器 headImg.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\test1\\\\&quot;+headImg.getOriginalFilename())); &#125; if (photos.length &gt; 0) &#123; for (MultipartFile photo : photos) &#123; if (!photo.isEmpty()) &#123; photo.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\test2\\\\&quot;+photo.getOriginalFilename())); &#125; &#125; &#125; return &quot;index&quot;; &#125;&#125; 编写配置文件 123#修改上传文件的最大大小spring.servlet.multipart.max-file-size=10MBspring.servlet.multipart.max-request-size=100MB 异常处理 默认情况下，Spring Boot提供/error处理所有错误的映射 对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。 对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据 自定义错误页在将400.html、500.html等页面放在resources &gt; templates &gt;error下即可 自定义异常处理@ControllerAdvice+@ExceptionHandler1234567891011121314151617/** * 处理整个web controller的异常 */@Slf4j@ControllerAdvice //注明这是一个增强的controllerpublic class GlobalExceptionHandler &#123; /** * 处理数学异常、空指针异常 * @param e * @return */ @ExceptionHandler(&#123;ArithmeticException.class, NullPointerException.class&#125;) // 表明用于处理指定异常 public String handleArithException(Exception e) &#123; log.error(&quot;异常是：&#123;&#125;&quot;, e); return &quot;error/404&quot;; // 指定返回视图的地址 &#125;&#125; @ResponseStatus+自定义Exception123456789@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;用户数量太多&quot;) //注明异常返回状态码和原因public class UserTooManyException extends RuntimeException &#123; public UserTooManyException() &#123; &#125; public UserTooManyException(String msg) &#123; super(msg); &#125;&#125; 自定义HandlerExceptionResolver123456789101112@Componentpublic class CustomerHandlerExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; try &#123; httpServletResponse.sendError(511, &quot;自定义错误&quot;); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return new ModelAndView(); &#125;&#125; 原生组件注入ServletAPI@ServletComponentScan主应用类中使用@ServletComponentScan配置扫描路径 1234567@ServletComponentScan(basePackages = &quot;com.spb_adminex.servlet&quot;) //配置servlet、filter、listener扫描地址@SpringBootApplicationpublic class SpbAdminexApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpbAdminexApplication.class, args); &#125;&#125; @WebServlet1234567@WebServlet(urlPatterns = &quot;/my&quot;)public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write(&quot;MyServlet running&quot;); &#125;&#125; @WebFilter1234567891011121314151617@Slf4j@WebFilter(urlPatterns = &#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;)public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; log.info(&quot;MyFilter初始化&quot;); &#125; @Override public void destroy() &#123; log.info(&quot;MyFilter销毁&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; log.info(&quot;MyFilter running&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; @WebListener123456789101112@Slf4j@WebListenerpublic class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; log.info(&quot;MyListener监听到项目初始化完成&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; log.info(&quot;MyListener监听到项目销毁&quot;); &#125;&#125; RegisterBean编写一个配置类 1234567891011121314151617@Configurationpublic class MyRegisterConfig &#123; @Bean public ServletRegistrationBean myServlet() &#123; return new ServletRegistrationBean(new MyServlet(), &quot;/my&quot;); &#125; @Bean public FilterRegistrationBean myFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new MyFilter()); filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;)); return filterRegistrationBean; &#125; @Bean public ServletListenerRegistrationBean myListener() &#123; return new ServletListenerRegistrationBean(new MyListener()); &#125;&#125; 数据访问SQL使用默认数据源、jdbcTemplate 导入starter场景和数据库驱动 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 编写配置文件application.yaml 123456spring: datasource: url: jdbc:mysql://localhost:3306/online_bookstore username: root password: 123456789 driver-class-name: com.mysql.cj.jdbc.Driver 使用jdbcTemplate测试 1234567891011@Slf4j@SpringBootTestclass SpbAdminexApplicationTests &#123; @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() &#123; Long count = jdbcTemplate.queryForObject(&quot;select count(*) from admin&quot;, Long.class); log.info(&quot;当前表的记录数为&quot; + count); &#125;&#125; 使用Druid数据源 引入数据源 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 编写数据源配置类 12345678910@Configurationpublic class MyDataSourceConfig &#123; // 引入自己的数据源之后，自动配置的默认DataSource失效 @ConfigurationProperties(&quot;spring.datasource&quot;) //将组件与配置文件中的属性绑定 @Bean public DataSource dataSource() &#123; DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; &#125;&#125; 测试 12345678910@Slf4j@SpringBootTestclass SpbAdminexApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() &#123; log.info(&quot;当前数据源类型为&#123;&#125;&quot;, dataSource.getClass()); &#125;&#125; 其他👉雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 使用xml配置文件整合MyBatis 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt; 编写application.yaml配置文件 123mybatis: config-location: classpath:mybatis/mybatis-config.xml #全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 编写mybatis-config.xml全局配置文件/或者编写application配置文件(此时不能同时配置全局配置文件位置) 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;settings&gt;&lt;!-- 开启下划线转驼峰命名法 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;&lt;/configuration&gt; 1234mybatis: mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 configuration: map-underscore-to-camel-case: true #开启下划线转驼峰命名法 编写beanMapper接口 12345@Mapper //注明这是一个mapper接口public interface AdminMapper &#123; public Admin getAdmin(Integer id); public Boolean insertAdmin(Admin admin);&#125; 编写beanMapper.xml配置文件 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.spb_adminex.mapper.AdminMapper&quot;&gt; &lt;select id=&quot;getAdmin&quot; resultType=&quot;com.spb_adminex.bean.Admin&quot; &gt; select * from admin where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;insertAdmin&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into admin(`account`,`password`) values(#&#123;account&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 编写service层 123456789101112@Servicepublic class AdminService &#123; @Autowired AdminMapper adminMapper; public Admin getAdminById(Integer id) &#123; return adminMapper.getAdmin(id); &#125; public Boolean insertAdmin(Admin admin) &#123; return adminMapper.insertAdmin(admin); &#125;&#125; 编写controller层 1234567891011@Controllerpublic class AdminController &#123; @Autowired AdminService adminService; @ResponseBody @GetMapping(&quot;/getAdmin&quot;) public Admin getAdminById(@RequestParam(&quot;id&quot;) Integer id) &#123; return adminService.getAdminById(id); &#125;&#125; 使用注解整合MyBatis 其余文件，且不需要beanMapper.xml 编写beanMapper接口 12345@Mapper //注明这是一个mapper接口public interface AdminMapper &#123; @Select(&quot;select * from admin where id=#&#123;id&#125;&quot;) //注解替换beanMapper.xml文件 public Admin getAdmin(Integer id);&#125; 整合MyBatis-Plus快速开始 | MyBatis-Plus (baomidou.com) 获取数据 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt; 为启动类添加@MapperScan，注明扫描Mapper文件的地址 123456789@SpringBootApplication@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(QuickStartApplication.class, args); &#125;&#125; 编写全局配置文件 123456spring: datasource: url: jdbc:mysql://localhost:3306/spb_adminex username: root password: 123456789 driver-class-name: com.mysql.cj.jdbc.Driver 编写Bean类 12345678910111213@NoArgsConstructor@AllArgsConstructor@Data@TableName(&quot;user&quot;) //可以指定表名，不知道则默认为类名public class User &#123; private Long id; private String name; private String age; private String email; @TableField(exist = false) //注明当前字段在表中不存在 private String test;&#125; 编写BeanMapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 编写BeanService接口 123public interface UserService extends IService&lt;User&gt; &#123;&#125; 编写BeanServiceImpl实现类 1234@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;&#125; 编写controller 12345678910111213141516171819@Controllerpublic class TableController &#123; @Autowired UserService userService = new UserServiceImpl(); @GetMapping(&quot;/dynamic_table&quot;) public String dynamicTable(Model model) &#123; List&lt;User&gt; userList = userService.list(); model.addAttribute(&quot;userList&quot;, userList); return &quot;table/dynamic_table&quot;; &#125; @GetMapping(&quot;/responsive_table&quot;) public String responsiveTable() &#123; return &quot;table/responsive_table&quot;; &#125; @GetMapping(&quot;/editable_table&quot;) public String editableTable() &#123; return &quot;table/editable_table&quot;; &#125;&#125; 分页操作 编写MybatisPlugConfig 12345678910@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; // 创建MybatisPlusInterceptor MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 编写controller 12345678910111213141516171819202122232425@Controllerpublic class TableController &#123; @Autowired UserService userService = new UserServiceImpl(); // 进入dynamic_table并展示分页数据 @GetMapping(&quot;/dynamic_table&quot;) public String dynamicTable(@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)Integer pn, Model model) &#123; // 获得分页结果对象，并设置分页 Page&lt;User&gt; page = userService.page(new Page&lt;User&gt;(pn, 2)); model.addAttribute(&quot;page&quot;, page); // page.getRecords获得所有记录，page.current获得当前页数，page.pages获得总页数，page.getTotal获得总条数…… return &quot;table/dynamic_table&quot;; &#125; @GetMapping(&quot;/user/delete/&#123;id&#125;&quot;) // 删除用户功能 public String deleteUser(@PathVariable(&quot;id&quot;) Long id, @RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn, RedirectAttributes ra) &#123; userService.removeById(id); ra.addAttribute(&quot;pn&quot;, pn); return &quot;redirect:/dynamic_table&quot;; &#125;&#125; 编写html页面，thymeleaf语法详见雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 123456789101112131415161718192021222324252627282930313233343536373839&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,status:$&#123;page.getRecords()&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;status.count&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td&gt; &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;&quot; class=&quot;btn btn-primary&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;row-fluid&quot;&gt; &lt;div&gt; &lt;div class=&quot;dataTables_info&quot;&gt;当前第[[$&#123;page.current&#125;]]页 总计[[$&#123;page.pages&#125;]]页 总[[$&#123;page.getTotal&#125;]]条记录 &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class=&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt; &lt;ul&gt; &lt;li class=&quot;prev disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;← Previous&lt;/a&gt;&lt;/li&gt; &lt;li th:class=&quot;$&#123;num == page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;&quot; th:each=&quot;num:$&#123;#numbers.sequence(1,page.pages)&#125;&quot;&gt; &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;Next → &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; NoSQL(Redis)不尝试了没钱 单元测试@SpringBootTest123456@SpringBootTestclass MyTest &#123; @Test public void test() &#123; &#125;&#125; 常用注解 **@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 **@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍 **@RepeatedTest :**表示方法可重复执行，下方会有详细介绍 **@DisplayName :**为测试类或者测试方法设置展示名称 **@BeforeEach :**表示在每个单元测试之前执行 **@AfterEach :**表示在每个单元测试之后执行 **@BeforeAll :**表示在所有单元测试之前执行 **@AfterAll :**表示在所有单元测试之后执行 **@Tag :**表示单元测试类别，类似于JUnit4中的@Categories **@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore **@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误 **@ExtendWith :**为测试类或测试方法提供扩展类引用 断言机制雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili ……指标监控雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 高级特性后会有期源码和其他部分到时候(也不知道啥时候)会再去看的，but not today","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"【学习笔记】MyBatis","slug":"【学习笔记】MyBatis","date":"2021-07-16T11:12:59.990Z","updated":"2021-07-23T05:49:19.787Z","comments":true,"path":"2021/07/16/xue-xi-bi-ji-mybatis/","link":"","permalink":"http://example.com/2021/07/16/xue-xi-bi-ji-mybatis/","excerpt":"","text":"概述 mybatis是一个优秀的基于java的持久层框架,它内部封装了jdbc,使开发者只需要关注sq语句本身,而不需要花费精力去处理加载驱动、创建连接、创建 statement等繁杂的过程。 mybatis通过xm或注解的方式将要执行的各种 statement配置起来,并通过java对象和 statement中sq的动态参数进行映射生成最终执行的sq语句。 最后 mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题,对jdbc进行了封装,屏蔽了 jdbc api底层访问细节,使我们不用与 jdbc api打交道,就可以完成对数据库的持久化操作。 开发步骤 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 编写数据表与Bean类 创建并编写mapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.myspring.bean.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 创建并编写sqlMapConfig.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456789&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 调用操作 123456789101112// 获得核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis/sqlMapConfig.xml&quot;);// 获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);// 获得session会话对象SqlSession sqlSession = sqlSessionFactory.openSession();// 执行操作,参数即mapper.xml中的namespace.idList&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);// 测试System.out.println(userList);// 释放资源sqlSession.close(); 增删改查操作代码123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.myspring.bean.User&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 插入 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; insert into user values (#&#123;name&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; update user set age=#&#123;age&#125; where name = #&#123;name&#125; &lt;/update&gt;&lt;/mapper&gt; 1234567891011121314151617181920// 获得核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis/sqlMapConfig.xml&quot;);// 获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);// 获得session会话对象SqlSession sqlSession = sqlSessionFactory.openSession();// 查询List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);// 插入sqlSession.insert(&quot;userMapper.save&quot;, new User(&quot;李52四&quot;, 11));// 修改sqlSession.update(&quot;userMapper.update&quot;, new User(&quot;李52四&quot;, 110));// 删除sqlSession.delete(&quot;userMapper.delete&quot;, &quot;李52四&quot;);// 执行更新操作需要提交事务sqlSession.commit();// 释放资源sqlSession.close(); 配置文件常用标签environments标签 配置数据库环境，支持多环境 transactionManager事务管理器属性 JDBC: 这个配置就是直接使用了JDBC的提交和回滚设置,它依赖于从数据源得到的连接来管理事务作用域 MANAGED: 这个配置几乎没做什么。它从来不提交或回滚一个连接,而是让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文)。默认情况下它会关闭连接,然而一些容器并不希望这样,因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 daraSource数据源属性 UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。 JNDI:这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用,容器可以集中或在外部配置数据源,然后放置一个JNDI上下文的引用。 Mapper标签 加载映射，加载方式有多种。 使用相对于类路径的资源引用,例如:&lt; mapper resource=”org/ mybatis/ builder/ AuthorMapperxm”/&gt; 使用完全限定资源定位符(URL),例如:&lt; mapper url=”file//ar/ mappers/ Author Mapper.xm”/ 使用映射器接口实现类的完全限定类名,例如:&lt; mapper class=” org. mybatis builder. AuthorMapper”/&gt; 将包内的映射器接口实现全部注主册为映射器,例如:&lt; package name=” org. mybatis. builder”/&gt; Properties标签 实际开发中,习惯将数据源的配置信息单独抽取成个 properties文件,该标签可以加载额外配置的 properties文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 加载properties文件 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; typeAliases标签 起别名，有已经设置好的常用的类型的别名，也可自定义 1234&lt;!-- 自定义别名，注意标签在config.xml中的顺序 --&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.myspring.bean.User&quot; alias=&quot;user&quot;/&gt;&lt;/typeAliases&gt; MyBatis相关APISqlSession工厂构建器SqlSessionFactoryBuilder SqlSession工厂对象SqlSessionFactory SqlSession会话对象 DAO层实现 采用 Mybatis的代理开发方式实现DAO层的开发,这种方式是我们后面进入企业的主流。 Mapper接口开发方法只需要程序员编写 Mapper接口(相当于Dao接口),由 Mybatis框架根据接口定义创建接口的动态代理对象,代理对象的方法体同上边Dao接口实现类方法。 Mapper.xm文件中的 namespace与 mapper接口的全限定名相同 Mapper接口方法名和 Mapper. xm中定义的每个 statement的id相同 Mapper接口方法的输入参数类型和 mapper. xn中定义的毎个sql的 parameter Type的类型相同 Mapper接口方法的辅出参数类型和 mapper. xm中定义的每个sq的 resultType的类型相同 创建并编写Mapper.xml文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.myspring.dao.UserMapper&quot;&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据name查询所有 --&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 创建并编写Mapper接口 123456public interface UserMapper &#123; // 查询所有 List&lt;User&gt; findAll() throws Exception; // 根据id查询所有 User findById(int id);&#125; 调用 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;myBatis/sqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();User user = mapper.findById(2); 映射文件：动态sql语句123456789101112131415161718192021222324252627282930313233&lt;!-- sql语句抽取 --&gt;&lt;sql id=&quot;selectUser&quot;&gt; select * from user&lt;/sql&gt;&lt;!-- 动态条件 --&gt;&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-- 动态条件 --&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;where&gt; -- select * from user where id in(?,?) -- collection写list或array等 &lt;foreach collection=&quot;list&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 配置文件类型转换TypeHandler标签黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 插件plugins标签 添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 在配置文件中添加标签 12345&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 调用 12345678910111213141516171819// 分页助手，设置分页信息以分页，startPage(pageNum,pageSize)PageHelper.startPage(1, 1);// 当前页List&lt;User&gt; userList = mapper.findAll();// 分页信息PageInfo&lt;User&gt; userPageInfo = new PageInfo&lt;&gt;(userList);for (User user : userList) &#123; System.out.println(user);&#125;System.out.println(&quot;上一页：&quot; + userPageInfo.getPrePage());System.out.println(&quot;当前页：&quot; + userPageInfo.getPageNum());System.out.println(&quot;下一页：&quot; + userPageInfo.getNextPage());System.out.println(&quot;总页数：&quot; + userPageInfo.getPages());System.out.println(&quot;当前条数：&quot; + userPageInfo.getPageSize());System.out.println(&quot;总条数：&quot; + userPageInfo.getTotal());System.out.println(&quot;是否第一页：&quot; + userPageInfo.isIsFirstPage());System.out.println(&quot;是否末页：&quot; + userPageInfo.isIsLastPage()); 多表操作黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 注解开发使用xml开发crud1234&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.myspring.dao.UserMapper&quot;&gt; &lt;!-- sql语句抽取 --&gt; &lt;sql id=&quot;selectUser&quot;&gt; select * from user &lt;/sql&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;/select&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; -- select * from user where id in(?,?) -- collection写list或array等 &lt;foreach collection=&quot;list&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 插入 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; insert into user (name, age) values (#&#123;name&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; update user set age=#&#123;age&#125;, name=#&#123;name&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除 --&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 123456789101112131415public interface UserMapper &#123; List&lt;User&gt; findAll(); User findById(int id); List&lt;User&gt; findByCondition(User user); List&lt;User&gt; findByIds(List&lt;Integer&gt; ids); void save(User user); void update(User user); void delete(int id);&#125; 123456789101112131415161718192021222324252627282930313233343536373839public class UserMapperTest &#123; private UserMapper userMapper; @Before public void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;myBatis/sqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class); &#125; @Test public void testSave() throws Exception &#123; User user = new User(); user.setName(&quot;钱老板&quot;); user.setAge(90); userMapper.save(user); &#125; @Test public void testUpdate() throws Exception &#123; User user = userMapper.findById(3); user.setAge(99); userMapper.update(user); &#125; @Test public void testDelete() throws Exception &#123; userMapper.delete(4); &#125; @Test public void testFindById() throws Exception &#123; User user = userMapper.findById(3); System.out.println(user); &#125;&#125; 注解开发CRUD12345678910111213141516public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User findById(int id); @Insert(&quot;insert into user (name, age) values (#&#123;name&#125;, #&#123;age&#125;)&quot;) void save(User user); @Update(&quot;update user set age=#&#123;age&#125;, name=#&#123;name&#125; where id = #&#123;id&#125;&quot;) void update(User user); @Update(&quot; delete from user where id = #&#123;id&#125;&quot;) void delete(int id);&#125; 12345&lt;!-- 加载映射关系 --&gt;&lt;mappers&gt; &lt;!-- 指定接口所在的包 --&gt; &lt;package name=&quot;com.myspring.dao&quot;/&gt;&lt;/mappers&gt; 调用不变","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"}]},{"title":"【项目笔记】ssm整合练习简单CRUD项目","slug":"【项目笔记】ssm整合练习","date":"2021-07-16T07:09:38.168Z","updated":"2021-09-19T12:40:33.243Z","comments":true,"path":"2021/07/16/xiang-mu-bi-ji-ssm-zheng-he-lian-xi/","link":"","permalink":"http://example.com/2021/07/16/xiang-mu-bi-ji-ssm-zheng-he-lian-xi/","excerpt":"","text":"项目简介功能点 分页 数据校验 jQuery前端校验 JSR303后端校验 AJAX REST风格 技术点 基础框架ssm 数据库MySQL 请阿丹框架bootstrap 项目管理maven 分页插件pagehelper 逆向工程mybatis generator 基础环境搭建创建项目​ 创建maven项目，添加javaee-web application framework support 引入maven相关依赖​ 引入spring springmvc mybatis等相关依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssm_crud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!-- spring springmvc --&gt; &lt;dependencies&gt; &lt;!-- springmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring aspects aop面向切面编程 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池、驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 其他 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 引入前端框架​ 引入jQuery、Bootstrap 12345678&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; ssm整合配置文件web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 1、启动spring的容器 --&gt; &lt;!-- 设置全局参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 2、springmvc前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置xml地址 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 3、全局字符编码过滤器，注意这个过滤器一定要放在所有过滤器之前 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 4、过滤器：使用REST风格的URI 将页面普通的POST请求转为指定的delete或者put请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; spring-mvc.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- springMVC的配置文件 --&gt; &lt;!-- 配置组件扫描路径 --&gt; &lt;context:component-scan base-package=&quot;com.sss_crud&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- 只扫描controller(即所有注释controller的类) --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 过滤静态资源 （将springmvc不能处理的请求交给Tomcat，该标签表示当spring找不到资源时交由原始容器(tomcat)寻找） --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- mvc注解驱动 以及其他一些功能支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- spring配置文件 --&gt; &lt;!-- 配置组件扫描路径 --&gt; &lt;context:component-scan base-package=&quot;com.sss_crud&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- 不扫描controller(即所有注释controller的类) --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- 加载外部的properties文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源，事务控制 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; &lt;!-- mybatis整合 --&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- mybatis全局配置文件、数据源、mapper配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置扫描器，将mybatis接口的实现加入到IOC容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.sss_crud.mapper&quot; /&gt; &lt;/bean&gt; &lt;!-- 事务控制 --&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 开启基于注解的事务 --&gt; &lt;aop:config&gt; &lt;!-- 切入点表达式 --&gt; &lt;aop:pointcut id=&quot;txPoint&quot; expression=&quot;execution(* com.sss_crud.service..*(..))&quot; /&gt; &lt;!-- 配置事务增强 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPoint&quot; /&gt; &lt;/aop:config&gt; &lt;!-- 配置事务增强，事务如何切入 --&gt; &lt;tx:advice id=&quot;txAdvice&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 切入点切入的所有方法（连接点）都是事务方法 --&gt; &lt;tx:method name=&quot;*&quot; /&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;/beans&gt; jdbc.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=123456789 mybatis-config.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 开启驼峰命名 --&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt; &lt;/settings&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 自动扫描路径下的类并且起别名 --&gt; &lt;package name=&quot;com.sss_crud.bean&quot; /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 数据库构建ssm_crud.sql1234567891011121314151617181920212223242526272829SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tbl_dept-- ----------------------------DROP TABLE IF EXISTS `tbl_dept`;CREATE TABLE `tbl_dept` ( `dept_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;部门id&#x27;, `dept_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, PRIMARY KEY (`dept_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for tbl_emp-- ----------------------------DROP TABLE IF EXISTS `tbl_emp`;CREATE TABLE `tbl_emp` ( `emp_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;员工id&#x27;, `emp_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `gender` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `d_id` int NULL DEFAULT NULL, PRIMARY KEY (`emp_id`) USING BTREE, INDEX `fk_emp_dept`(`d_id`) USING BTREE, CONSTRAINT `fk_emp_dept` FOREIGN KEY (`d_id`) REFERENCES `tbl_dept` (`dept_id`) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; 基础模块mybatis逆向工程生成bean、mappergeneratorConfig.xml mybatis generator的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--注意targetProject中使用反斜杠，connectionURL需要添加useSSL=true--&gt; &lt;!--配置要链接的数据库的数据源--&gt; &lt;!-- &lt;classPathEntry location=&quot;E:/GARBAGE_TEMP_SPACE/mysql-connector-java-5.1.46.jar&quot; /&gt;--&gt; &lt;!---Mybatis上下文--&gt; &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- 取消生成的文件的全部自动注释 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--配置数据库的链接信息--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssm_crud?useSSL=false&quot; userId=&quot;root&quot; password=&quot;123456789&quot; /&gt; &lt;!--数据库BigDecimals字段在java中定义--&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!--实体类生成信息 指定javabean生成位置--&gt; &lt;javaModelGenerator targetPackage=&quot;com.sss_crud.bean&quot; targetProject=&quot;src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!--指定mybatis的mapper.xml映射文件地址--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!--指定mybatis的mapper接口生成地址--&gt; &lt;javaClientGenerator targetPackage=&quot;com.sss_crud.mapper&quot; targetProject=&quot;src\\main\\java&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!--要生成的表结构--&gt; &lt;table tableName=&quot;tbl_emp&quot; domainObjectName=&quot;Employee&quot; /&gt; &lt;table tableName=&quot;tbl_dept&quot; domainObjectName=&quot;Department&quot; /&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; MBGTest.class 运行mybatis generator以自动生成bean和mapper，可能需要手动添加构造器 123456789101112131415161718192021import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class MBGTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 当前项目结构 MapperTest单元测试引入maven123456&lt;!-- spring test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt;&lt;/dependency&gt; 添加可以批量操作的sqlSession 注意在applicationContext.xml文件中添加可以批量操作的sqlSession 12345&lt;!-- 一个可以执行批量操作的SQLSession --&gt;&lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;constructor-arg name=&quot;executorType&quot; value=&quot;BATCH&quot; /&gt;&lt;/bean&gt; MapperTest类编写123456789101112131415161718192021222324252627282930313233343536373839import com.sss_crud.bean.Employee;import com.sss_crud.mapper.DepartmentMapper;import com.sss_crud.mapper.EmployeeMapper;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.UUID;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class MapperTest &#123; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Autowired SqlSession session; @Test public void test() &#123; // departmentMapper.insertSelective(new Department(null, &quot;开发&quot;)); // departmentMapper.insertSelective(new Department(null, &quot;测试&quot;)); // employeeMapper.insertSelective(new Employee(null, &quot;Jerry&quot;, &quot;M&quot;, &quot;Jerry@qq.com&quot;, 1)); // employeeMapper.insertSelective(new Employee(null, &quot;Cat&quot;, &quot;W&quot;, &quot;Cat@qq.com&quot;, 2)); // 使用可以批量操作的session获得mapper,从而进行批量操作 EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); for (int i = 0; i &lt; 1000; i++) &#123; String uid = UUID.randomUUID().toString().substring(0, 5) + i; mapper.insertSelective(new Employee(null, uid, &quot;M&quot;, uid + &quot;@qq.com&quot;, 1)); &#125; &#125;&#125; 查询功能 此功能需要使用分页插件pageHelper pagehelper分页插件引入maven依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt; 配置mybatis-config.xml以使用插件1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- ...... --&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; viewsindex.jsp12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 跳转至展示所有员工信息 --%&gt; &lt;jsp:forward page=&quot;/emps&quot;&gt;&lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; serviceEmployeeServiceImpl.java123456789101112131415161718192021package com.sss_crud.service.impl;import com.sss_crud.bean.Employee;import com.sss_crud.mapper.EmployeeMapper;import com.sss_crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; public List&lt;Employee&gt; getAll() &#123; return employeeMapper.selectByExampleWithDept(null); &#125;&#125; controllerEmployeeController.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.sss_crud.controller;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.sss_crud.bean.Employee;import com.sss_crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import java.util.List;/** * 处理员工CRUD请求 */@Controllerpublic class EmployeeController &#123; @Autowired EmployeeService employeeService; /** * 查询员工数据（分页） * url请求参数“pn”为请求页数 * * @return */ @RequestMapping(&quot;/emps&quot;) public ModelAndView getEmps(@RequestParam(value = &quot;pn&quot;, defaultValue = &quot;1&quot;) Integer pn) &#123; ModelAndView mav = new ModelAndView(); // 使用pageHelper实现分页功能 PageHelper.startPage(pn, 5); // 查询（此时的数据已经是分页后的数据） List&lt;Employee&gt; emps = employeeService.getAll(); // 使用pageInfo包装（加入其他更多的信息，所有页，当前页等等） PageInfo pageInfo = new PageInfo(emps, 5); mav.addObject(&quot;pageInfo&quot;, pageInfo); mav.setViewName(&quot;list&quot;); return mav; &#125;&#125; Test单元测试12345678910111213141516171819202122232425262728293031323334353637383940import com.github.pagehelper.PageInfo;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@WebAppConfiguration(value = &quot;src/main/web&quot;)@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;, &quot;classpath:spring-mvc.xml&quot;&#125;)public class MvcTest &#123; //传入springmvc的ioc @Autowired WebApplicationContext context; // 虚拟MVC请求 获得请求结果 MockMvc mockMvc; @Before public void initMockMvc() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void test() throws Exception &#123; MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/emps&quot;).param(&quot;pn&quot;, &quot;1&quot;)).andReturn(); MockHttpServletRequest request = result.getRequest(); PageInfo pageInfo = (PageInfo) request.getAttribute(&quot;pageInfo&quot;); System.out.println(pageInfo); &#125;&#125; 没有成功，返回为null，我不理解，都spring了还用nm的jsp呢，不弄了！反正结构都差不多了实现逻辑也就那样，拜拜了您嘞！","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"【学习笔记】SpringMVC","slug":"【学习笔记】SpringMVC","date":"2021-07-15T05:37:42.134Z","updated":"2021-09-19T12:45:12.814Z","comments":true,"path":"2021/07/15/xue-xi-bi-ji-springmvc/","link":"","permalink":"http://example.com/2021/07/15/xue-xi-bi-ji-springmvc/","excerpt":"","text":"SpringMVC概述 SpringMVC是种基于Java的实现MVc设计模型的请求驱动类型的轻量级Web框架,属于Spring FrameWork的后续产品,已经融合在 Spring Web Flow中。 SpringMvC已经成为目前最主流的MVC框架之一,并且随着 Spring30的发布,全面超越 Struts2,成为最优秀的MVC框架。它通过一套注解,让一个简单的Java类成为处理请求的控制器,而无须实现任何接口。同时它还支持RESTful编程风格的请求。 SpringMVC快速开发步骤 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 123456789101112131415&lt;!-- springMVC前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置xml地址 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写controller 12345678910@Controllerpublic class UserController &#123; // 使用RequestMapping映射controller地址 @RequestMapping(&quot;/myController&quot;) public String save() &#123; System.out.println(&quot;Controller save running&quot;); // return要跳转的视图页面 return &quot;success.jsp&quot;; &#125;&#125; 在resources下新增spring-mvc.xmld的spring config文件 12345xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- controller的组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring.controller&quot;/&gt; SpringMVC组件解析@RequestMapping用于建立请求URL和处理请求方法之间的对应关系 位置 类上,请求URL的第一级访问目录。此处不写的话,就相当于应用的根目录 方法上,请求URL的第二级访问目录,与类上的使用@ ReqquestMapping标主的级目录起组成访问虚拟路径 return 后跟的路径：不加”/“，则从相对路径查询，否则从web路径下查询。 属性 value：用于指定请求的URL。它和path属性的作用是一样的 method：用于指定请求的方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和vaue必须和配置的一模一样 MVC命名空间引入12345&lt;!-- 命名空间 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;&lt;!-- 约束地址 --&gt;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; 组件扫描1&lt;context:component-scan base-package=&quot;com.myspring.controller&quot;/&gt; XML配置return重定义与请求转发12return &quot;forward:/success.jsp&quot;;return &quot;redirect:/success.jsp&quot;; 内部资源（视图）解析器 在spring-mvc.xml中配置如下 12345678910111213&lt;!-- 内部资源解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt; &lt;!-- 配置后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;2. 编写controller ```java // return &quot;/jsp/success.jsp&quot;; return &quot;success&quot; //效果与上述相同 SpringMVC数据响应页面跳转返回字符串1return &quot;/jsp/success.jsp&quot;; 返回ModelAndview对象在controller中编写如下 1234567891011121314151617181920212223242526272829// 第一种@RequestMapping(&quot;/myController1&quot;)public ModelAndView save2() &#123; ModelAndView modelAndView = new ModelAndView(); // 设置视图 modelAndView.setViewName(&quot;success&quot;); // 设置模型 modelAndView.addObject(&quot;username&quot;, &quot;qqq&quot;); return modelAndView;&#125;// 第二种@RequestMapping(&quot;/myController2&quot;)public ModelAndView save3(ModelAndView modelAndView) &#123; modelAndView.setViewName(&quot;success&quot;); modelAndView.addObject(&quot;username&quot;, &quot;qqq&quot;); return modelAndView;&#125;// 第三种@RequestMapping(&quot;/myController3&quot;)public ModelAndView save4(Model model) &#123; model.setAttribute(&quot;username&quot;, &quot;qqq&quot;); return &quot;success&quot;;&#125;// 第四种@RequestMapping(&quot;/myController4&quot;)public String save4(HttpServletRequest request) &#123; request.setAttribute(&quot;username&quot;, &quot;qqq&quot;); return &quot;success&quot;;&#125; 回写数据返回字符串（@ResponseBody）1234567891011// 第一种@RequestMapping(&quot;/myController1&quot;)public void save1(HttpServletResponse resp) throws IOException &#123; resp.getWriter().print(&quot;hello!!!&quot;);&#125;// 第二种,使用ResponseBody，用于区分页面跳转@RequestMapping(&quot;/myController2&quot;)@ResponseBodypublic String save2() &#123; return &quot;hello!!!&quot;;&#125; 返回JSON格式字符串 添加依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; 转换为JSON 1234567891011@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic String save() throws Exception &#123; // 获得bean User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); // 转换为JSON String userJson = new ObjectMapper().writeValueAsString(user); return userJson;&#125; 返回Spring自动转换Bean-&gt;JSON 配置spring-mvc.xml 12345678&lt;!-- 处理器映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 或者使用mvc注解驱动如下配置： 123456xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&lt;!-- mvc注解驱动 --&gt;&lt;mvc:annotation-driven/&gt; 编写controller 123456789// 第二种,使用ResponseBody，用于区分页面跳转@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic User save() throws Exception &#123; User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); return user;&#125; SpringMVC请求获取请求参数获取基本类型参数1234567@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(String username, int age) &#123; // 使用形参接收数据，注意此处参数名与表单中input的name值对应 System.out.println(username); System.out.println(age);&#125; 获取Bean类型参数123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(User user) &#123; // 实际上是使用了Bean对象里的set方法，所以要让参数的名字与set方法名对应，否则接收不到 System.out.println(user);&#125; 获取数据类型参数12345@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(String[] strs) &#123; System.out.println(Arrays.toString(strs));&#125; 获取集合类型参数 前端传输数据 123456789101112&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var userList = new Array(); userList.push(&#123;name: &quot;张三&quot;, age: 10&#125;); userList.push(&#123;name: &quot;李四&quot;, age: 20&#125;); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;$&#123;pageContext.request.contextPath&#125;/test/myController&quot;, data: JSON.stringify(userList), contentType: &quot;application/json;charset=utf-8&quot; &#125;)&lt;/script&gt; controller获得数据 123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(@RequestBody List&lt;User&gt; userList) &#123; // 注意 @RequestBody List&lt;User&gt; userList System.out.println(userList);&#125; 静态资源访问权限开放spring-mvc.xml中配置如下 1234&lt;!-- 开放资源访问，设置可访问地址 --&gt;&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;&lt;!-- 该标签表示当spring找不到时交由原始容器(tomcat)寻找 --&gt;&lt;mvc:default-servlet-handler/&gt; 全局编码过滤（防止中文乱码）12345678910111213&lt;!-- 全局编码过滤 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 参数绑定注解@RequestParam value: 与请求参数名称 required: 此在指定的请求参数是否必须包括,默认是true,提交时如果没有此参数则报错 defaultvalue: 当没有指定请求参数时,则使用指定的默认值赋值 123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(@RequestParam(value=&quot;name&quot;, required=false，defaultvalue=&quot;000&quot;) String username) &#123; // 将获得的参数name映射为所需要的username System.out.println(username);&#125; 获得Restfil风格参数 Restful是一种软件架构风格、设计风格,而不是标准,只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件,基于这个风格设计的软件可以更简洁,更有层次,更易于实现缓存机制等。 Restful风格的请求是使用“”ur+请求方式”表示次请求目的的,HTP协议里面四个表示操作方式的动词如下： GET: 用于获取资源 POST: 用于新建资源 PUT: 用于更新资源 DELETE: 用于删除资源 123456@RequestMapping(&quot;/myController/&#123;name&#125;&quot;)// 使用占位符&#123;&#125;@ResponseBodypublic void save(@PathVariable(&quot;name&quot;) String username) &#123; System.out.println(username);&#125; 自定义类型转换器黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 获得请求头@RequestHeader 文件上传 导入依赖 1234567891011dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 在spring-mvc.xml中配置文件上传解析器 12345678&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 上传文件的编码类型 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 上传文件总大小 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242800&quot;/&gt; &lt;!-- 上传单个文件的大小 --&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;5242800&quot;/&gt;&lt;/bean&gt; 编写controller 12345@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(MultipartFile uploadedFile) throws Exception &#123; uploadedFile.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\&quot; + uploadedFile.getOriginalFilename()));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(MultipartFile[] files) throws Exception &#123; for (MultipartFile file : files) &#123; file.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\&quot; + file.getOriginalFilename())); &#125;&#125;## SpringMVC拦截器interceptor&gt; Spring Mvc的拦截器类似于 Servlet开发中的过滤器 Filter,用于对处理器进行预处理和后处理。&gt;&gt; 将拦截器按一定的顺序联结成条链,这条链称为拦截器链( interceptor Chain)。在访问被拦截的方法或字段时,拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。### 开发步骤1. 编写interceptor ```java public class MyInterceptor implements HandlerInterceptor &#123; // 在目标方法执行之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); String param = request.getParameter(&quot;param&quot;); if (&quot;yes&quot;.equals(param)) &#123; return true; &#125; else &#123; request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request, response); return false; &#125; &#125; // 在目标方法执行之后，试图返回之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); // 可以对model进行修改 modelAndView.addObject(&quot;name&quot;, &quot;newName&quot;); &#125; // 在流程执行完毕之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion&quot;); &#125; &#125; 在spring-mvc.xml中配置interceptor 123456789101112131415&lt;mvc:interceptors&gt; &lt;!-- 对应执行顺序 --&gt; &lt;mvc:interceptor&gt; &lt;!-- 对哪些资源执行拦截操作 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 对应interceptor --&gt; &lt;bean class=&quot;com.myspring.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 对哪些资源执行拦截操作 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 对应interceptor --&gt; &lt;bean class=&quot;com.myspring.interceptor.MyInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 方法说明 SpringMVC异常处理简单异常处理器1234567891011&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 默认错误视图 --&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error1&quot;/&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;map&gt; &lt;!-- key:异常类型 value:错误视图 --&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error2&quot;/&gt; &lt;entry key=&quot;java.io.IOException&quot; value=&quot;error3&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 自定义异常处理器 黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 1listener","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"【学习笔记】Spring","slug":"【学习笔记】Spring","date":"2021-07-13T12:59:14.495Z","updated":"2021-09-19T07:07:36.261Z","comments":true,"path":"2021/07/13/xue-xi-bi-ji-spring/","link":"","permalink":"http://example.com/2021/07/13/xue-xi-bi-ji-spring/","excerpt":"","text":"什么是SpringSpring用来干什么 Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成。 Spring是分层的 Java SE/EE应用 full-stack轻量级开源框架,以loC(Inverse of Control:反转控制)和Aop(Aspect Oriented Programming:面向切面编程)为内核。 提供了展现层 Spring MVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库,逐渐成为使用最多的 Java EE企业应用开源框架。 Spring发展历程 1997年,BM提出了EB的思想1998年,SUN制定开发标准规范E丿B1.01999年,EB1.1发布2001年,EB2.0发布2003年,EB2.1发布2006年,EB3.0发布 Spring之父 Rod Johnson( Spring之父) 《Expert One-to-One J2EE Design and development(2002)》阐述了J2EE使用EB开发设计的优点及解决方案《Expert One-to-One J2EE Development without EJB(2004)》阐述了2E开发不使用EB的解决方式( Spring维形) Spring的优势 方便解耦,简化开发 通过 Spring提供的loC容器,可以将对象间的依赖关系交由 Spring进行控制,避免硬编码所造成的过度耦合。 用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码,可以更专注于上层的应用。 AOP编程的支持 通过 Spring的AOP功能,方便进行面向切面编程,许多不容易用传统OOP实现的功能可以通过AOP轻松实现。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来,通过声明式方式灵活的进行事务管理,提高发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作,测试不再是昂贵的操作,而是随手可做的事情。 方便集成各种优秀框架 Spring对各种优秀框架( Struts、 Hibernate、 Hessian、Quartz等)的支持。 降低 JavaEE AP的使用难度 Spring对 JavaEE API(如JDBC、 JavaMail、远程调用等)进行了薄薄的封装层,使这些APl的使用难度大为降低。 Spring体系结构 Spring快速开发步骤 导入maven依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Spring conf配置文件（通常命名为applicationContext） 配置如下 1&lt;bean id=&quot;userDao&quot; class=&quot;com.myspring.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 实现 1234567public class UserDaoDemo &#123; public static void main(String[] args) &#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; Spring配置文件Bean标签 用于配置对象交由 Spring来创建。默认情况下它调用的是类中的**无参构造函数,**如果没有无参构造函数则不能创建成功。 基本属性 id: Bean实例在 Spring容器中的唯一标识 class: Bean的全限定名称 scope：指对象的作用范围，取值如下 singleton、prototype下bean对象的不同创建时间singleton、prototype下bean对象的不同创建时间 Bean实例化三种方法 无参构造方法实例化 1234// 创建容器ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 从容器中获得对象UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); 工厂静态方法实例化 工厂实例方法实例化 演示视频 Bean的依赖注入 依赖注入( Dependency Injection)：它是 Spring框架核心|OC的具体实现在编写程序时,通过控制反转,把对象的创健建交给了 Spring,但是代码中不可能出现没有依赖的情况。OC解耦只是降低他们的依赖关系,但不会消除。例如:业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系,在使用 Spring之后,就让 Spring来维护了简单的说,就是坐等框架把持久层对象传入业务层,而不用我们自己去获取。 set方法（property标签）12345678&lt;!-- 第一种 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;!-- name属性值对应set方法名 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 第二种 --&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot; /&gt; 123456// UserServiceImpl中依赖注入，获得userDao对象private UserDao userDao;// set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 构造（有参）方法（constructor-arg标签）1234&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;!-- name属性值对应userServiceImpl内UserDao的属性名 --&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123456// 依赖注入，获得userDao对象private UserDao userDao;// 构造方法public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao;&#125; 注入数据的数据类型 普通数据类型 引用数据类型 集合数据类型 演示视频 分模块开发（import标签） 实际开发中, Spring的配置内容非常多,这就导致 Spring配置很繁杂且体积很大,所以,可以将部分配置拆解到其他配置文件中,而在 Spring主配置文件通过impor标签进行加载。 1&lt;import resource=&quot;applicationContext-user.xml&quot;&gt;&lt;/import&gt; Spring相关APIApplicationContext application Context：接口类型,代表应用上下文,可以通过其实例获得 Spring容器中的Bean对象 三种实现类 ClassPathXmlApplicationContext它是从类的根路径下加载配置文件推荐使用这种 FileSystemXmlApplicationContext它是从磁盘路径上加载配置文件,配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext当使用注解配置容器对象时,需要使用此类来创建 spring容器。它用来读取注解。 getBean()方法 12UserService userService1 = (UserService) app.getBean(&quot;userService&quot;);UserService userService2 = app.getBean(UserService.class); Spring配置数据源数据源（连接池）的作用 数据源(连接池)是提高程序性能如出现的 事先实例化数据源,初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 手动创建数据源的开发步骤 导入Maven依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 创建jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/数据库名jdbc.username=rootjdbc.password=123456789 加载properties配置文件 12345ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;);String driver = rb.getString(&quot;jdbc.driver&quot;);String url = rb.getString(&quot;jdbc.url&quot;);String username = rb.getString(&quot;jdbc.username&quot;);String password = rb.getString(&quot;jdbc.password&quot;); 创建数据源 1234567// 创建c3p0数据源ComboPooledDataSource dataSource = new ComboPooledDataSource();dataSource.setDriverClass(driver);dataSource.setJdbcUrl(url);dataSource.setUser(username);dataSource.setPassword(password);Connection connection = dataSource.getConnection(); 1234567// 创建Druid数据源DruidDataSource dataSource = new DruidDataSource();dataSource.setDriverClassName(driver);dataSource.setUrl(url);dataSource.setUsername(username);dataSource.setPassword(password);DruidPooledConnection connection = dataSource.getConnection(); 使用Spring创建数据源的开发步骤 导入相关依赖 在applicationContext中配置数据源bean 12345678910111213141516171819202122&lt;!-- 引入context命名空间和约束路径 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 加载外部的properties文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;&lt;!-- c3p0 --&gt;&lt;bean id=&quot;dataSource1&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- Driud --&gt;&lt;bean id=&quot;dataSource2&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/property&gt;&lt;/bean&gt; 创建数据源对象 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);DataSource dataSource = applicationContext.getBean(DataSource.class);Connection connection = dataSource.getConnection(); Spring注解开发 Spring原始注解主要是替代的配置 原始注解 组件扫描使用注解进行开发时,需要在 applicationContext. xm中配置组件扫描,作用是指定哪个包及其子包下的Bean，需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!-- 配置组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt; Dao类12&lt;!-- 配置文件 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.myspring.dao.impl.UserDaoImpl&quot; scope=&quot;prototype&quot;&gt; &lt;/bean&gt; 1234// 注解配置，写在类名之上@Component(&quot;userDao&quot;)// 第二种可读性更强@Repository(&quot;userDao&quot;) Service类1234&lt;!-- 配置文件 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot; /&gt;&lt;/bean&gt; 1234// 注解配置，写在类名之上@Component(&quot;userService&quot;)// 第二种可读性更强@Service(&quot;userService&quot;) 1234567891011// 注解配置，写在字段之前// Autowired从spring容器中根据 数据类型 进行匹配，所以同一数据类型只有单个bean可以只写Autowired@Autowired// Qualifier从spring容器中根据 id值类型 进行匹配，但是必须结合Autowired一起使用@Qualifier(&quot;userDao&quot;)// @Resource(name = &quot;userDao&quot;) 相当于前两者结合private UserDao userDao;// 此时类中可以不写set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 普通属性注入12@Value(&quot;$&#123;jdbc.driver&#125;&quot;)private String driver; 新注解 整合在一起的样子，如下： 1234567891011121314151617181920212223@Configuration // 标志该类是Spring的核心配置类@ComponentScan(&quot;com.myspring&quot;) // 配置组件扫描,替换&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt;@PropertySource(&quot;classpath:jdbc.properties&quot;) // 加载外部的properties文件,替换&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;public class SpringConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) // spring会将当前方法的返回值以指定名称存储到spring容器当中 public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 分模块如下（推荐）： 123456@Configuration // 标志该类是Spring的核心配置类@ComponentScan(&quot;com.myspring&quot;) // 配置组件扫描,替换&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt;@Import(&#123;DataSourceConfiguration.class,&#125;) //括号内写数组&#123;xxx.class,xxx.class&#125;,替换&lt;import resource=&quot;&quot;/&gt;public class SpringConfiguration &#123; &#125; 123456789101112131415161718192021@PropertySource(&quot;classpath:jdbc.properties&quot;) // 加载外部的properties文件,替换&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) // spring会将当前方法的返回值以指定名称存储到spring容器当中 public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; Spring集成junit 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 编写测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)// @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) // 非注解方式注入配置@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) // 注解方式注入配置public class SpringJunitTest &#123; @Resource(name = &quot;userService&quot;) private UserService userService; @Test public void test1() &#123; userService.save(); &#125;&#125; Spring集成web环境 应用上下文对象是通过 new ClasspathXmlApplication Context( spring配置文件)方式获取的,但是每次从容器中获得Bean时都要编写 new ClasspathXmlApplication Context( spring配置文件),这样的弊端是配置文件加载多次,应用上下文对象创建多次。 在Web项目中,可以使用 ServletcontextListener监听Web应用的启动,我们可以在Web应用启动时,就加载 Spring的配置文件,创建应用上下文对象 Application Context,在将其存储到最大的域 servletContext域中,这样就可以在任意位置从域中获得应用上下文 Application Context对象了 手动使用listener获取应用上下文对象 创建listener类 123456789101112131415public class ContextLoaderListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; // ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //使用非注解时用该方法创建 ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfiguration.class); // 使用注解时用该方法创建 // 将Spring的应用上下文对象存储到ServletContext域对象中 servletContextEvent.getServletContext().setAttribute(&quot;app&quot;, app); System.out.println(&quot;spring容器创建完毕&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; &#125;&#125; 在web.xml中配置listener 123&lt;listener&gt; &lt;listener-class&gt;com.myspring.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取servletContext域对象中的应用上下文对象 1ApplicationContext app = (ApplicationContext) this.getServletContext().getAttribute(&quot;app&quot;); 使用Spring获取应用上下文对象 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 123456789&lt;!-- 设置全局参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 配置监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取应用上下文对象 1WebApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(req.getServletContext()); JdbcTemplate概述 它是 spring框架中提供的个对象,是对原始繁琐的 dbc API对象的简单封装。 spring框架为我们提供了很多的操作模板类。例如:操作关系型数据的 dbcTemplate和 bernate Template,操作nosq数据库的 RedisTemplate,操作消息队列的 UmsTemplate等等。 手动开发步骤 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建数据库表和javaBean 创建jdbcTemplate对象、执行数据库操作 12345678910111213141516public class JdbcTemplateTest &#123; @Test // 测试dbcTemplate开发步骤 public void test() &#123; // 创建Druid数据源 DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456789&quot;); // 创建jdbcTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 数据库操作 jdbcTemplate.update(&quot;insert into test1 values(?,?)&quot;, &quot;张三&quot;, 18); &#125;&#125; Spring使用JdbcTemplate开发步骤 添加依赖 编写jdbc.properties文件 编写spring-config文件applicationContext.xml，添加数据源对象，jdbcTemplate对象 12345678910111213141516171819&lt;!-- 引入context命名空间和约束路径 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 加载外部的properties文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!-- Druid DataSource --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring JdbcTemplate --&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 编写代码 123456// 获得applicationContextApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 从容器中获得jdbcTemplate对象JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class);// 数据库操作jdbcTemplate.update(&quot;insert into test1 values(?,?)&quot;, &quot;张三&quot;, 18); 常用操作1234jdbcTemplate.update(&quot;update test1 set age=? where name =?&quot;, 10, &quot;张三&quot;);List&lt;User&gt; userList = jdbcTemplate.query(&quot;select * from test1&quot;, new BeanPropertyRowMapper&lt;&gt;(User.class));User user = jdbcTemplate.queryForObject(&quot;select * from test1 where age=?&quot;, new BeanPropertyRowMapper&lt;&gt;(User.class), 18);Long count = jdbcTemplate.queryForObject(&quot;select count(*) from test1&quot;, Long.class); AOP概述 AOP为 Aspect Oriented Programming的缩写,意思为面向切面编程,是通过预编译方式和运行期动态代理现程序功能的同统一维护的一种技术。 AOP是OOP的延续,是软件开发中的一个热点,也是 Spring框架中的个重要内容,是函数式编程的种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 作用与优势黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili JDK动态代理、cglib动态代理黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 概念 Target(目标对象):代理的目标对象。 Proxy(代理):—个类被AOP织入增强后,就产生一个结果代理类。 Joinpoint(连接点):所谓连接点是指那些被拦截到的点。在 spring中这些点指的是方法,因为 spring只支持方法类型的连接点。 Pointcut(切入点):所谓切入点是指我们要对哪些 Joinpoint迸行拦截的定义。 Advice(通知/增强):所谓通知是指拦截到 Joinpoint之后所要做的事情就是通知。 Aspect(切面):是切入点和通知(引介个)的结合。 eaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring釆用动态代理织入,而Aspect采用编译期织入和类装载期织入。 基于XML开发AOP步骤 导入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.7&lt;/version&gt;&lt;/dependency&gt; 创建目标接口和目标类 创建切面类（含增强方法） 123456789101112public class MyAspect &#123; public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125; public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;前置增强。。。&quot;); Object proceed = pjp.proceed(); System.out.println(&quot;后置增强。。。&quot;); return proceed; &#125;&#125; 配置applicationContext.xml 12345678910111213141516xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&lt;!-- 目标对象 --&gt;&lt;bean id=&quot;target&quot; class=&quot;com.myspring.aop.Target&quot;/&gt;&lt;!-- 切面对象 --&gt;&lt;bean id=&quot;myAspect&quot; class=&quot;com.myspring.aop.MyAspect&quot;/&gt;&lt;!-- 配置织入，即哪些方法需要哪些增强(前置后置增强等) --&gt;&lt;aop:config&gt; &lt;!-- 声明切面 --&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 切点+通知(增强) --&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(* com.myspring.aop.*.*(..))&quot;&gt;&lt;/aop:before&gt; &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.myspring.aop.*.*(..))&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) // 非注解方式注入配置public class SpringJunitTest &#123; @Autowired private TargetInterface target; @Test public void test1() &#123; target.save(); &#125;&#125; 切点表达式 12345678910&lt;aop:config&gt; &lt;!-- 声明切面 --&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 切点表达式的抽取 --&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.myspring.aop.*.*(..))&quot;/&gt; &lt;!-- 切点+通知(增强) --&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知类型 基于注解开发AOP 目标类、切面类 配置目标类、切面类 1234@Component(&quot;target&quot;)public class Target implements TargetInterface &#123;&#125; 12345678@Component(&quot;myAspect&quot;)@Aspect //标注当前是一个切面类public class MyAspect &#123; @Before(&quot;execution(* com.myspring.aop.*.*(..))&quot;) public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125;&#125; 配置applicationContext.xml 1234&lt;!-- 注解开发组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring.aop&quot;/&gt;&lt;!-- aop自动代理 --&gt;&lt;aop:aspectj-autoproxy/&gt; 切点表达式抽取12345678910111213@Component(&quot;myAspect&quot;)@Aspect //标注当前是一个切面类public class MyAspect &#123; @Before(&quot;pointCut()&quot;) public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125; // 定义切点表达式 @Pointcut(&quot;execution(* com.myspring.aop.*.*(..))&quot;) public void pointCut() &#123; &#125;&#125; 事务控制黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"【集训】Servlet","slug":"【集训】servlet","date":"2021-07-11T11:56:48.738Z","updated":"2021-07-23T05:50:22.649Z","comments":true,"path":"2021/07/11/ji-xun-servlet/","link":"","permalink":"http://example.com/2021/07/11/ji-xun-servlet/","excerpt":"","text":"什么是Servlet？ Servlet 是运行在 Web 服务器或应用服务器上的java程序，是Java EE规范之一（一种接口）。 它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层，即接收客户端发送过来的请求并且响应数据给客户端。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 💡配置Servlet 创建一个Java类并实现Servlet接口（一般通过继承HTTPServlet类去实现servlet） 重写方法，实现逻辑操作 在web.xml中配置这个servlet的访问地址 1234567891011121314&lt;!-- 给tomcat配置servlet相关信息 --&gt;&lt;servlet&gt; &lt;!-- 写明servlet的名字（一般使用类名即可） --&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;!-- 写明servlet的全类名 --&gt; &lt;servlet-class&gt;servlet.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 给servlet配置访问地址 --&gt;&lt;servlet-mapping&gt; &lt;!-- 写明需要配置访问地址的servlet --&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;!-- 写明为该servlet配置的访问地址 --&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;标签中 / 的作用：相当于拼接到 http://ip:port/工程路径后，即http://ip:port/工程路径/myServlet HTTP协议什么是HTTP协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准，即客户端与服务器之间通信、传输数据需要遵守的规则。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 请求与响应 客户端给服务器发送数据为请求，请求分为GET、POST请求 服务器给客户端回传数据为响应 💡HTTP协议内容 请求/响应行 请求/响应头： 属性名：属性值 请求/响应体： 重要，自行阅读学习 常见响应码 200：表示请求成功 302：表示请求重定向 404：表示服务器找不到该请求地址（地址有错） 500：表示服务器内部错误（代码有错） 💡表单处理、常用API request对象常用方法 方法介绍 getParameter(String name) 返回name指定参数的参数值 getParameterValues(String name) 返回包含参数name的所有值的数组 setAttribute(String,Object) 存储此请求中的属性 getAttribute(String name) 返回指定属性的属性值 getContextPath() 返回当前WEB项目相对路径 getMethod() 获取请求类型 getSession() 获取Session对象 getCookies() 获取所有Cookie,返回一个Cookie数组 request对象常用方法 方法介绍 setHeader() 设置消息头 setStatus() 设置状态码 addCookie() 添加Cookie getWriter() 获取通向浏览器的字符流 获取/回传数据123456789&lt;form action=&quot;http://localhost:8080/jsp_war_exploded/myServlet&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;画画&quot;&gt;画画 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;打篮球&quot;&gt;打篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;敲代码&quot;&gt;敲代码 &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345String username = req.getParameter(&quot;username&quot;);String password = req.getParameter(&quot;password&quot;);String[] hobby = req.getParameterValues(&quot;hobby&quot;);System.out.println(&quot;用户名：&quot;+username+&quot;,密码：&quot;+password);System.out.println(Arrays.toString(hobby)); 1resp.getWriter().println(&quot;&lt;div&gt;这是一个div&lt;/div&gt;&quot;); http://localhost:8080/jsp_war_exploded/myServlet?username=111&amp;password=222使用?传递参数 请求转发与重定向 1234String username = req.getParameter(&quot;username&quot;);req.setAttribute(&quot;key&quot;, &quot;MyServlet处理的信息:&quot;);System.out.println(&quot;MyServlet中的request获得的数据&quot;+username);req.getRequestDispatcher(&quot;/myServlet2&quot;).forward(req, resp); 123String username = req.getParameter(&quot;username&quot;);System.out.println(&quot;MyServlet2中的request获得的数据:&quot;+username);System.out.println(&quot;MyServlet2中显示之前处理并保存的数据:&quot;+req.getAttribute(&quot;key&quot;)); 请求转发的特点： 浏览器地址栏没有变化 一次请求 共享request中的数据 可以转发到WEB-INF目录下（工程路径下） 1234resp.sendRedirect(req.getContextPath()+&quot;/myServlet2&quot;);// req.getContextPath()获得当前WEB项目相对路径resp.sendRedirect(&quot;http://www.baidu.com&quot;);// 访问外部资源必写http 重定向的特点： 浏览器地址栏发生变化 两次请求 不共享request中的数据 不能访问WEB-INF目录下资源 可以访问工程外的资源 💡Filter过滤器自行学习 中文乱码问题12req.setCharacterEncoding(&quot;UTF-8&quot;);resp.setContentType(&quot;text/html;charset=UTF-8&quot;); 相关阅读材料 Web开发 - 廖雪峰的官方网站 (liaoxuefeng.com) 尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版_哔哩哔哩_bilibili 作业 熟悉servlet、jsp并实现一些功能，并写一篇博文。 博文内容要求（必须要求）： 写一篇博文记录你使用servlet、jsp实现功能时遇到了哪些困难、不理解、不知道该如何实现的地方，以及写上解决的过程与结果（未解决的也可以写上有哪些疑惑），或者学习笔记等等皆可。 功能实例（仅参考，不是最低/最高标准）： 含有登陆/注册页面、其他页面。 登录功能：手动输入信息，符合已存在的用户信息则成功登录。 注册功能：手动输入信息，不能重复注册已存在的用户名，否则注册失败。 用户展示：在页面上展示所有已经注册的用户的信息。 登陆过滤：其他页面，只有登陆成功后才可访问，否则跳转至登陆页面。 其他页面：利用循环控制语句或其他工具功能输出由后台传递而来的数据。 等等 提交内容与时间： 提交内容：程序源码+博文链接 提交时间：7.27日晚零点前，将压缩包命名为班级+姓名+学号发送至&#x37;&#x30;&#x37;&#x38;&#x32;&#x33;&#x38;&#49;&#52;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d; 可能时间太短无法实现太多功能，没有关系，程序源码附上自己实现了的东西就行，没有实现完整也没关系，实现了更多功能也挺好，这个作业打分主要看你的博文里面写的记录内容，程序主要是用来练习以熟悉servlet和jsp的，毕竟大作业会用到。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"}]},{"title":"【集训】jsp","slug":"【集训】jsp","date":"2021-07-11T07:14:09.093Z","updated":"2021-07-23T05:51:57.089Z","comments":true,"path":"2021/07/11/ji-xun-jsp/","link":"","permalink":"http://example.com/2021/07/11/ji-xun-jsp/","excerpt":"","text":"什么是JSP JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。 JSP全称Java Server Pages，是建立在JAVA基础上的一种网络编程语言，JSP是一种Java servlet（JSP在执行前首先被编译成一个Servlet），主要用于实现Java web应用程序的用户界面部分。 网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。 jsp &lt;-&gt; java(servlet)C:\\Users\\卢荟\\AppData\\Local\\JetBrains\\IntelliJIdea2021.1\\tomcat\\20e10a3d-4da9-4eee-b7fa-327b2feb3d84\\work\\Catalina\\localhost\\jsp_war_exploded\\org\\apache\\jsp 类似于上述文件目录（tomcat下的webapp目录下存放工程项目，只不过现在tomcat在idea里用）即找到生成的java文件。 可见JSP本质上就是一个Servlet，只不过无需配置映射路径，Web Server会根据路径查找对应的.jsp文件，如果找到了，就自动编译成Servlet再执行。 JSP语法JSP注释 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 HTML注释，通过浏览器查看网页源代码时可以看见注释内容 💡脚本（在JSP中编写Java代码）先导入jsp-api.jar和servlet-api.jar（tomcat自带，但是IDE并无提示会报红） 语法 描述 &lt;% 代码片段 %&gt; 一般定义变量和编写语句。 &lt;%! 声明代码 %&gt; 可以声明常量，编写方法，编写类 &lt;%= 表达式 %&gt; 表达式被转化成String，然后插入到表达式出现的地方 123456789101112131415161718192021&lt;%! public class MyMath &#123; int a,b; public MyMath(int a, int b) &#123; this.a = a; this.b = b; &#125; int doMath()&#123; return a+b; &#125; &#125;%&gt;&lt;% out.println(&quot;打印语句&quot;); MyMath myMath = new MyMath(1, 1); int num = myMath.doMath();%&gt;&lt;h1&gt; 和为&lt;%= num %&gt; &lt;/h1&gt;&lt;div&gt; &lt;%= &quot;&lt;h2&gt;这是一个标签&lt;/h2&gt;&quot; %&gt; &lt;/div&gt; 对于流程控制语句的编写可能稍微繁琐 123456789101112&lt;% int day = 1 %&gt;&lt;% if (day == 1 || day == 7) &#123; %&gt;&lt;p&gt;今天是周末&lt;/p&gt;&lt;% &#125; else &#123; %&gt;&lt;p&gt;今天不是周末&lt;/p&gt;&lt;% &#125; %&gt; &lt;%for ( int fontSize = 1; fontSize &lt;= 3; fontSize++)&#123; %&gt; &lt;font color=&quot;green&quot; size=&quot;&lt;%= fontSize %&gt;&quot;&gt; 菜鸟教程 &lt;/font&gt;&lt;br /&gt;&lt;%&#125;%&gt; 当然也可以用out对象输出 12345678&lt;% int fontSize; for ( fontSize = 10; fontSize &lt;= 13; fontSize++) &#123; out.write(&quot;&lt;div&gt;&quot;); out.write(fontSize+&quot;&quot;); out.write(&quot;&lt;/div&gt;&lt;br&gt;&quot;); &#125;%&gt; JSP指令JSP指令用来设置与整个JSP页面相关的属性。 JSP指令 描述 &lt;%@ page 属性名=”属性值” %&gt; 定义页面的依赖属性，导包 &lt;%@ include 属性名=”属性值” %&gt; 包含其他文件（静态包含） &lt;%@ taglib 属性名=”属性值” %&gt; 引入标签库的定义，可以是自定义标签 123&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot; &quot; %&gt; &lt;%@ include file=&quot; &quot;%&gt; JSP行为自行学习 1&lt;jsp:行为名 属性名=&quot;属性值&quot; /&gt; 中文编码问题1&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; 💡JSP九大内置对象与四大作用域四大域对象 对象 作用域 变化操作 pageContext 当前页面有效，当当前页面关闭或转到其他页面时，page对象将在响应回馈给客户端后释放。 跳转页面 request 当次请求有效，可以跨越forward()不重定向跳转前后的两页，可以通过setAttribute()方法实现页面中的信息传递。 两次请求 session 当前会话有效，指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应 关闭浏览器 application 所有应用程序中有效，整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。 关闭服务器 12345678910&lt;% pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;); request.setAttribute(&quot;key&quot;, &quot;request&quot;); session.setAttribute(&quot;key&quot;, &quot;session&quot;); application.setAttribute(&quot;key&quot;, &quot;application&quot;);%&gt;pageContext的值：&lt;%=pageContext.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;request的值：&lt;%=request.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;session的值：&lt;%=session.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;application的值：&lt;%=application.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt; 九大内置对象在生成的java文件中可以找到 对象 描述 作用域 request javax.servlet.http.HttpServletRequest 类的实例 request response javax.servlet.http.HttpServletResponse类的实例 pageContext out javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。 pageContext session javax.servlet.http.HttpSession 类的实例 session application javax.servlet.ServletContext 类的实例。与应用上下文有关 application config javax.servlet.ServletConfig 类的实例。这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 pageContext pageContext javax.servlet.jsp.PageContext 类的实例，提供对JSP页面所有对象以及命名空间的访问 pageContext page 指向当前JSP对象 pageContext exception exception 类的对象，代表发生错误的 JSP 页面中对应的异常对象，&lt;%@ page …… isErrorPage=”true” %&gt; pageContext EL表达式与JSTL标准标签库自行学习 💡MVC框架MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。 Model（模型）：如一个存取数据的对象或 JavaBean View（视图）：如jsp动态页面 Controller（控制器）：控制数据流向模型对象，并在数据变化时更新视图，使视图与模型分离开，如servlet MVC重要特点就是两种分离： 视图和数据模型的分离：使用不同的视图对相同的数据进行展示；分离可视和不可视的组件，能够对模型进行独立测试。因为分离了可视组件减少了外部（数据库也是一种外部组件）依赖利于测试。 视图和表现逻辑(Controller)的分离：Controller是一个表现逻辑的组件，并非一个业务逻辑组件。MVC可以作为表现模式也可以作为建构模式，意味这Controller也可以是业务逻辑。分离逻辑和具体展示，能够对逻辑进行独立测试。 MVC优缺点： 优点：低耦合、重用性高、生命周期成本低、部署快、可维护性高 缺点：没有明确的定义、不适合小、中型应用程序、增加系统结构和实现的复杂性、视图对模型数据的低效率访问 作业在上一个文档中已经声明，这两节课只要交一个作业就行。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"jsp","slug":"jsp","permalink":"http://example.com/tags/jsp/"}]}],"categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"http://example.com/tags/springcloud/"},{"name":"mybatisplus","slug":"mybatisplus","permalink":"http://example.com/tags/mybatisplus/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"Unity2D","slug":"Unity2D","permalink":"http://example.com/tags/Unity2D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"},{"name":"jsp","slug":"jsp","permalink":"http://example.com/tags/jsp/"}]}