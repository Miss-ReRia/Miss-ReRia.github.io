{"meta":{"title":"Reria's BLOG","subtitle":"","description":"","author":"reria","url":"http://example.com","root":"/"},"pages":[{"title":"【】","date":"2021-09-22T12:12:40.562Z","updated":"2021-09-20T03:38:29.350Z","comments":true,"path":"模板.html","permalink":"http://example.com/%E6%A8%A1%E6%9D%BF.html","excerpt":"","text":""},{"title":"","date":"2021-09-22T12:12:27.438Z","updated":"2021-09-22T12:12:27.438Z","comments":false,"path":"notice.html","permalink":"http://example.com/notice.html","excerpt":"","text":"本站默认替换了右键菜单，如需唤醒原系统菜单请使用： ctrl + 右键"},{"title":"404 Not Found","date":"2021-07-23T06:13:25.410Z","updated":"2021-07-23T06:13:25.410Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-07-26T05:59:04.234Z","updated":"2021-07-26T05:59:04.234Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T03:29:26.295Z","updated":"2021-07-29T03:29:26.295Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"正在维护(其实是懒得写介绍🤭"},{"title":"","date":"2021-07-27T01:43:04.243Z","updated":"2021-07-27T01:43:04.243Z","comments":true,"path":"bangumis/index.html","permalink":"http://example.com/bangumis/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-27T01:43:04.243Z","updated":"2021-07-27T01:43:04.243Z","comments":true,"path":"cinema/index.html","permalink":"http://example.com/cinema/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-07-29T09:43:44.508Z","updated":"2021-07-29T09:43:44.508Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-29T03:28:37.138Z","updated":"2021-07-29T03:28:37.138Z","comments":true,"path":"bb/index.html","permalink":"http://example.com/bb/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-29T09:43:17.916Z","updated":"2021-07-29T09:43:17.916Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-08-24T08:21:05.250Z","updated":"2021-08-24T08:21:05.250Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"🧡💛💚💙💜🤎🖤🤍"}],"posts":[{"title":"【项目笔记】在线教育项目实战7","slug":"【项目笔记】在线教育项目实战7","date":"2021-10-05T07:16:37.992Z","updated":"2021-10-07T09:44:59.733Z","comments":true,"path":"2021/10/05/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-7/","link":"","permalink":"http://example.com/2021/10/05/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-7/","excerpt":"","text":"统计分析后台（后端+前端）环境搭建 老样子 生成统计数据（后端） 注意，要查询什么数据要在对应模块中查询，然后在统计模块远程调用获取 被调用方controller12345678910111213@RestController@RequestMapping(&quot;/educenter/member&quot;)@CrossOriginpublic class UcenterMemberController &#123; @Autowired private UcenterMemberService memberService; // 查询特定天的注册人数 @GetMapping(&quot;countRegister/&#123;day&#125;&quot;) public Integer countRegister(@PathVariable String day) &#123; Integer count = memberService.countRegister(day); return count; &#125;&#125; 被调用方service12345// 查询特定天的注册人数@Overridepublic Integer countRegister(String day) &#123; return baseMapper.countRegisterByDay(day);&#125; 被调用方mapper12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.educenter.mapper.UcenterMemberMapper&quot;&gt; &lt;!-- 查询特定天的注册人数 --&gt; &lt;select id=&quot;countRegisterByDay&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT COUNT(*) FROM ucenter_member uc WHERE DATE(uc.gmt_create) = #&#123;day&#125; &lt;/select&gt;&lt;/mapper&gt; 远程调用接口1234567@Component@FeignClient(&quot;service-ucenter&quot;)public interface UcenterClient &#123; // 查询特定天的注册人数 @GetMapping(&quot;/educenter/member/countRegister/&#123;day&#125;&quot;) public Integer countRegister(@PathVariable(&quot;day&quot;) String day);&#125; 调用方controller123456789101112131415@RestController@RequestMapping(&quot;/staservice/sta&quot;)@CrossOriginpublic class StatisticsDailyController &#123; @Autowired private StatisticsDailyService staService; // 统计特定天的注册人数 @PostMapping(&quot;countRegister/&#123;day&#125;&quot;) public R countRegister(@PathVariable String day) &#123; staService.countRegister(day); return R.ok(); &#125;&#125; 调用方service1234567891011121314151617181920212223242526@Servicepublic class StatisticsDailyServiceImpl extends ServiceImpl&lt;StatisticsDailyMapper, StatisticsDaily&gt; implements StatisticsDailyService &#123; @Autowired private UcenterClient ucenterClient; @Override public void countRegister(String day) &#123; // 先删除相同日期的记录 QueryWrapper&lt;StatisticsDaily&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;date_calculated&quot;, day); baseMapper.delete(wrapper); // 获得指定日期的统计数 Integer count = ucenterClient.countRegister(day); // 把统计数据添加到统计表当中 StatisticsDaily statisticsDaily = new StatisticsDaily(); statisticsDaily.setRegisterNum(count); statisticsDaily.setDateCalculated(day); // 一下是一些随机数 statisticsDaily.setVideoViewNum(RandomUtils.nextInt(100, 200)); statisticsDaily.setLoginNum(RandomUtils.nextInt(100, 200)); statisticsDaily.setCourseNum(RandomUtils.nextInt(100, 200)); // 插入数据库 baseMapper.insert(statisticsDaily); &#125;&#125; 生成统计数据（前端）router12345678910111213141516171819202122// 统计分析模块 &#123; path: &#x27;/sta&#x27;, component: Layout, redirect: &#x27;/sta/create&#x27;, name: &#x27;统计分析&#x27;, meta: &#123; title: &#x27;统计分析&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;create&#x27;, name: &#x27;生成数据&#x27;, component: () =&gt; import(&#x27;@/views/statistics/create&#x27;), meta: &#123; title: &#x27;生成数据&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;show&#x27;, name: &#x27;图表显示&#x27;, component: () =&gt; import(&#x27;@/views/statistics/show&#x27;), meta: &#123; title: &#x27;图表显示&#x27;, icon: &#x27;tree&#x27; &#125; &#125; ] &#125;, api1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; // 统计指定日期的注册数 createCountRegister(day) &#123; return request(&#123; url: `/staservice/sta/countRegister/$&#123;day&#125;`, method: &#x27;post&#x27; &#125;) &#125;&#125; vue模板与方法1&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item label=&quot;日期&quot;&gt; &lt;!-- 这里绑定了day --&gt; &lt;el-date-picker v-model=&quot;day&quot; type=&quot;date&quot; placeholder=&quot;选择要统计的日期&quot; value-format=&quot;yyyy-MM-dd&quot; /&gt; &lt;/el-form-item&gt; &lt;el-button :disabled=&quot;btnDisabled&quot; type=&quot;primary&quot; @click=&quot;create()&quot; &gt;生成&lt;/el-button &gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import staApi from &#x27;@/api/statistics&#x27; export default &#123; data() &#123; return &#123; day: &#x27;&#x27;, btnDisabled: false &#125; &#125;, created() &#123;&#125;, methods: &#123; create() &#123; staApi.createCountRegister(this.day).then(result =&gt; &#123; // 提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;生成数据成功!&#x27; &#125;) // 跳转到图表显示页面 this.$router.push(&#123; path: &#x27;/sta/show&#x27; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 定时任务 在固定时候自动执行程序 配置 在启动类上添加注解@EnableScheduling 1@EnableScheduling // 使用自动任务public class StatisticsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StatisticsApplication.class, args); &#125;&#125; 定时任务类 使用cron表达式，设置执行规则 1@Componentpublic class ScheduledTask &#123; @Autowired private StatisticsDailyService staService; // 0/5 * * * * ?表示每隔5秒执行一次这个方法 @Scheduled(cron = &quot;0/5 * * * * ?&quot;) public void task1() &#123; System.out.println(&quot;**************task1执行了..&quot;); &#125; //在每天凌晨1点，把前一天数据进行数据查询添加 @Scheduled(cron = &quot;0 0 1 * * ?&quot;) public void task2() &#123; staService.countRegister(DateUtil.formatDate(DateUtil.addDays(new Date(), -1))); &#125;&#125; 日期工具类1public class DateUtil &#123; private static final String dateFormat = &quot;yyyy-MM-dd&quot;; /** * 格式化日期 * * @param date * @return */ public static String formatDate(Date date) &#123; SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); return sdf.format(date); &#125; /** * 在日期date上增加amount天 。 * * @param date 处理的日期，非null * @param amount 要加的天数，可能为负数 */ public static Date addDays(Date date, int amount) &#123; Calendar now =Calendar.getInstance(); now.setTime(date); now.set(Calendar.DATE,now.get(Calendar.DATE)+amount); return now.getTime(); &#125; public static void main(String[] args) &#123; System.out.println(DateUtil.formatDate(new Date())); System.out.println(DateUtil.formatDate(DateUtil.addDays(new Date(), -1))); &#125;&#125; 统计分析图表显示（后端+前端） 使用echarts 后端controller1// echatrts图表显示@GetMapping(&quot;showChartData/&#123;type&#125;/&#123;begin&#125;/&#123;end&#125;&quot;)public R getChartData(@PathVariable String begin, @PathVariable String end, @PathVariable String type) &#123; Map&lt;String, Object&gt; map = staService.getChartData(type, begin, end); return R.ok().data(map);&#125; service1// echatrts图表显示@Overridepublic Map&lt;String, Object&gt; getChartData(String type, String begin, String end) &#123; // 指定日期范围 QueryWrapper&lt;StatisticsDaily&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(&quot;date_calculated&quot;, begin, end); // 这里要求前端的传递的value和表中对应字段值相同，select指定查询列 wrapper.select(&quot;date_calculated&quot;, type); List&lt;StatisticsDaily&gt; staDataList = baseMapper.selectList(wrapper); //前端要求数组json结构，对应后端java代码是list集合 //创建两个list集合，一个日期list，一个数量list List&lt;String&gt; dateList = new ArrayList&lt;&gt;(); List&lt;Integer&gt; numList = new ArrayList&lt;&gt;(); //遍历查询所有数据list集合，进行封装 for (int i = 0; i &lt; staDataList.size(); i++) &#123; StatisticsDaily daily = staDataList.get(i); //封装日期list集合 dateList.add(daily.getDateCalculated()); //封装对应选择的数量 switch (type) &#123; case &quot;login_num&quot;: numList.add(daily.getLoginNum()); break; case &quot;register_num&quot;: numList.add(daily.getRegisterNum()); break; case &quot;video_view_num&quot;: numList.add(daily.getVideoViewNum()); break; case &quot;course_num&quot;: numList.add(daily.getCourseNum()); break; default: break; &#125; &#125; //把封装之后两个list集合放到map集合，进行返回 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;dateList&quot;, dateList); map.put(&quot;numList&quot;, numList); return map;&#125; 前端引入npm依赖 npm install –save &#x65;&#99;&#104;&#97;&#114;&#x74;&#x73;&#x40;&#x34;&#x2e;&#x31;&#46;&#x30; api 这里没有使用RequestBody传递对象，而是直接前端调用的时候传递对象取对应值 1// 获得图表数据 getChartData(searchObj) &#123; return request(&#123; url: `/staservice/sta/getChartData/$&#123;searchObj.type&#125;/$&#123;searchObj.begin&#125;/$&#123;searchObj.end&#125;`, method: &#x27;get&#x27; &#125;) &#125; vue模板和方法1&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-select v-model=&quot;searchObj.type&quot; clearable placeholder=&quot;请选择&quot;&gt; &lt;el-option label=&quot;学员登录数统计&quot; value=&quot;login_num&quot; /&gt; &lt;el-option label=&quot;学员注册数统计&quot; value=&quot;register_num&quot; /&gt; &lt;el-option label=&quot;课程播放数统计&quot; value=&quot;video_view_num&quot; /&gt; &lt;el-option label=&quot;每日课程数统计&quot; value=&quot;course_num&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;searchObj.begin&quot; type=&quot;date&quot; placeholder=&quot;选择开始日期&quot; value-format=&quot;yyyy-MM-dd&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;searchObj.end&quot; type=&quot;date&quot; placeholder=&quot;选择截止日期&quot; value-format=&quot;yyyy-MM-dd&quot; /&gt; &lt;/el-form-item&gt; &lt;el-button :disabled=&quot;btnDisabled&quot; type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;showChart()&quot; &gt;查询&lt;/el-button &gt; &lt;/el-form&gt; &lt;div class=&quot;chart-container&quot;&gt; &lt;div id=&quot;chart&quot; class=&quot;chart&quot; style=&quot;height: 500px; width: 100%&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import echarts from &#x27;echarts&#x27; import staApi from &#x27;@/api/statistics&#x27; export default &#123; data() &#123; return &#123; searchObj: &#123;&#125;, btnDisabled: false, xData: [], yData: [] &#125; &#125;, methods: &#123; showChart() &#123; staApi.getChartData(this.searchObj).then(result =&gt; &#123; this.yData = result.data.numList this.xData = result.data.dateList // 调用下面生成图表的方法，改变值 this.setChart() &#125;) &#125;, // 默认显示图表方法 setChart() &#123; // 基于准备好的dom，初始化echarts实例 this.chart = echarts.init(document.getElementById(&#x27;chart&#x27;)) // console.log(this.chart) // 指定图表的配置项和数据 var option = &#123; title: &#123; text: &#x27;数据统计&#x27; &#125;, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, dataZoom: [ &#123; show: true, height: 30, xAxisIndex: [0], bottom: 30, start: 10, end: 80, handleIcon: &#x27;path://M306.1,413c0,2.2-1.8,4-4,4h-59.8c-2.2,0-4-1.8-4-4V200.8c0-2.2,1.8-4,4-4h59.8c2.2,0,4,1.8,4,4V413z&#x27;, handleSize: &#x27;110%&#x27;, handleStyle: &#123; color: &#x27;#d3dee5&#x27; &#125;, textStyle: &#123; color: &#x27;#fff&#x27; &#125;, borderColor: &#x27;#90979c&#x27; &#125;, &#123; type: &#x27;inside&#x27;, show: true, height: 15, start: 1, end: 35 &#125; ], // x轴是类目轴（离散数据）,必须通过data设置类目数据 xAxis: &#123; type: &#x27;category&#x27;, data: this.xData &#125;, // y轴是数据轴（连续数据） yAxis: &#123; type: &#x27;value&#x27; &#125;, // 系列列表。每个系列通过 type 决定自己的图表类型 series: [ &#123; // 系列中的数据内容数组 data: this.yData, // 折线图 type: &#x27;line&#x27; &#125; ] &#125; this.chart.setOption(option) &#125; &#125; &#125;&lt;/script&gt; Canal数据同步 将远程数据库中的数据同步到本地数据库中，一般实际中项目有很多个数据库（比如说统计分析专门一个数据库），其与远程服务调用调用的区别是，该同步耦合度低，效率更高。 linux配置与开启 linux中需要安装mysql（本地Windows也需要mysql） 创建数据库表（结构需要一样） linux中docker中使用mysql一些常见命令 su root docker ps docker start mysql docker exec -it mysql bash mysql -u root -p 可以使用命令行，也可以直接用配好的Navicat（实战5中配置redis的时候已经配置好了mysql） exit docker stop CONTAINER ID 创建数据库表 数据库guli，表test_canal 注意结构需要一样 mysql开启binlog 开启并进入mysql show variables like ‘log_bin’; 查询是否开启binlog 修改my.cnf（如果使用docker，那么要去挂载的目录下修改），具体如下篇文章 https://www.freebytes.net/it/java/dokcer-mysql-binlog.htmlz 这里花了大概半个小时吧，还是个人博客文章靠谱，那些CSDN的文章都是炒来炒去的，这篇文章很清楚地讲了你挂载的目录是前半部分（我看CSDN那些文章总以为是配置挂载的时候的后半部分，所以弄了好久都没有用，看了这篇文章几分钟就解决了） 安装并配置canal linux中下载然后解压 具体配置见视频 开启canal即可，进入bin文件夹下sh startup.sh 客户端代码编写 创建模块 引入依赖123456789101112131415161718192021222324252627 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件12345678910111213# 服务端口server.port=10000# 服务名spring.application.name=canal-client# 环境设置：dev、test、prodspring.profiles.active=dev# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789 canal客户端类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197@Componentpublic class CanalClient &#123; //sql队列 private Queue&lt;String&gt; SQL_QUEUE = new ConcurrentLinkedQueue&lt;&gt;(); @Resource private DataSource dataSource; /** * canal入库方法 */ public void run() &#123; CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(&quot;192.168.128.129&quot;, 11111), &quot;example&quot;, &quot;&quot;, &quot;&quot;); int batchSize = 1000; try &#123; connector.connect(); connector.subscribe(&quot;.*\\\\..*&quot;); connector.rollback(); try &#123; while (true) &#123; //尝试从master那边拉去数据batchSize条记录，有多少取多少 Message message = connector.getWithoutAck(batchSize); long batchId = message.getId(); int size = message.getEntries().size(); if (batchId == -1 || size == 0) &#123; Thread.sleep(1000); &#125; else &#123; dataHandle(message.getEntries()); &#125; connector.ack(batchId); //当队列里面堆积的sql大于一定数值的时候就模拟执行 if (SQL_QUEUE.size() &gt;= 1) &#123; executeQueueSql(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; connector.disconnect(); &#125; &#125; /** * 模拟执行队列里面的sql语句 */ public void executeQueueSql() &#123; int size = SQL_QUEUE.size(); for (int i = 0; i &lt; size; i++) &#123; String sql = SQL_QUEUE.poll(); System.out.println(&quot;[sql]----&gt; &quot; + sql); this.execute(sql.toString()); &#125; &#125; /** * 数据处理 * * @param entrys */ private void dataHandle(List&lt;Entry&gt; entrys) throws InvalidProtocolBufferException &#123; for (Entry entry : entrys) &#123; if (EntryType.ROWDATA == entry.getEntryType()) &#123; RowChange rowChange = RowChange.parseFrom(entry.getStoreValue()); EventType eventType = rowChange.getEventType(); if (eventType == EventType.DELETE) &#123; saveDeleteSql(entry); &#125; else if (eventType == EventType.UPDATE) &#123; saveUpdateSql(entry); &#125; else if (eventType == EventType.INSERT) &#123; saveInsertSql(entry); &#125; &#125; &#125; &#125; /** * 保存更新语句 * * @param entry */ private void saveUpdateSql(Entry entry) &#123; try &#123; RowChange rowChange = RowChange.parseFrom(entry.getStoreValue()); List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList(); for (RowData rowData : rowDatasList) &#123; List&lt;Column&gt; newColumnList = rowData.getAfterColumnsList(); StringBuffer sql = new StringBuffer(&quot;update &quot; + entry.getHeader().getTableName() + &quot; set &quot;); for (int i = 0; i &lt; newColumnList.size(); i++) &#123; sql.append(&quot; &quot; + newColumnList.get(i).getName() + &quot; = &#x27;&quot; + newColumnList.get(i).getValue() + &quot;&#x27;&quot;); if (i != newColumnList.size() - 1) &#123; sql.append(&quot;,&quot;); &#125; &#125; sql.append(&quot; where &quot;); List&lt;Column&gt; oldColumnList = rowData.getBeforeColumnsList(); for (Column column : oldColumnList) &#123; if (column.getIsKey()) &#123; //暂时只支持单一主键 sql.append(column.getName() + &quot;=&quot; + column.getValue()); break; &#125; &#125; SQL_QUEUE.add(sql.toString()); &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125; /** * 保存删除语句 * * @param entry */ private void saveDeleteSql(Entry entry) &#123; try &#123; RowChange rowChange = RowChange.parseFrom(entry.getStoreValue()); List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList(); for (RowData rowData : rowDatasList) &#123; List&lt;Column&gt; columnList = rowData.getBeforeColumnsList(); StringBuffer sql = new StringBuffer(&quot;delete from &quot; + entry.getHeader().getTableName() + &quot; where &quot;); for (Column column : columnList) &#123; if (column.getIsKey()) &#123; //暂时只支持单一主键 sql.append(column.getName() + &quot;=&quot; + column.getValue()); break; &#125; &#125; SQL_QUEUE.add(sql.toString()); &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125; /** * 保存插入语句 * * @param entry */ private void saveInsertSql(Entry entry) &#123; try &#123; RowChange rowChange = RowChange.parseFrom(entry.getStoreValue()); List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList(); for (RowData rowData : rowDatasList) &#123; List&lt;Column&gt; columnList = rowData.getAfterColumnsList(); StringBuffer sql = new StringBuffer(&quot;insert into &quot; + entry.getHeader().getTableName() + &quot; (&quot;); for (int i = 0; i &lt; columnList.size(); i++) &#123; sql.append(columnList.get(i).getName()); if (i != columnList.size() - 1) &#123; sql.append(&quot;,&quot;); &#125; &#125; sql.append(&quot;) VALUES (&quot;); for (int i = 0; i &lt; columnList.size(); i++) &#123; sql.append(&quot;&#x27;&quot; + columnList.get(i).getValue() + &quot;&#x27;&quot;); if (i != columnList.size() - 1) &#123; sql.append(&quot;,&quot;); &#125; &#125; sql.append(&quot;)&quot;); SQL_QUEUE.add(sql.toString()); &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125; /** * 入库 * * @param sql */ public void execute(String sql) &#123; Connection con = null; try &#123; if (null == sql) return; con = dataSource.getConnection(); QueryRunner qr = new QueryRunner(); int row = qr.execute(con, sql); System.out.println(&quot;update: &quot; + row); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; DbUtils.closeQuietly(con); &#125; &#125;&#125; 启动类123456789101112131415@SpringBootApplicationpublic class CanalApplication implements CommandLineRunner &#123; @Resource private CanalClient canalClient; public static void main(String[] args) &#123; SpringApplication.run(CanalApplication.class, args); &#125; @Override public void run(String... strings) throws Exception &#123; //项目启动，执行canal客户端监听 canalClient.run(); &#125;&#125; 测试 TODO，这里application启动失败，去canal的log里看，说连接mysql的ip失败了，原因是address already in use, 然后我改了重启还是这个原因，本来没有被占用的端口启动了之后就被占用了，但是canal还是启动失败，就离谱， 总之原因是canal没有启动，address already in use 还是没解决，放弃了（我不理解！！！） SpringCloud微服务Gateway网关概念 微服务架构之下不同的微服务有不同的网络地址，外部客户端需要调用多个服务的接口才能完成一个业务需求，但是如果直接让客户端与各个服务器通信，会出现许多问题，所以这些问题需要借助API网关解决。 网关是结余客户端和服务端之间的之间层，所有外部请求都会先经过API网关这一层，所以网关实现安全，性能，监控等操作。 就是之前的nginx的增强版 创建模块 创建模块infrastructure，子模块api_gateway 依赖12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;common_utils&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--服务调用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 配置服务按如下配置即可 也可以使用YAML格式，更方便不用写下标 12345678910111213141516171819202122# 服务端口server.port=8222# 服务名spring.application.name=service-gateway# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#使用服务发现路由spring.cloud.gateway.discovery.locator.enabled=true#设置路由idspring.cloud.gateway.routes[0].id=service-acl#设置路由的uri lb://nacos注册服务名称spring.cloud.gateway.routes[0].uri=lb://service-acl#设置路由断言,代理servicerId为auth-service的/auth/路径spring.cloud.gateway.routes[0].predicates=Path=/*/acl/**#配置service-edu服务spring.cloud.gateway.routes[1].id=service-eduspring.cloud.gateway.routes[1].uri=lb://service-eduspring.cloud.gateway.routes[1].predicates=Path=/eduservice/**#配置service-edu服务spring.cloud.gateway.routes[2].id=service-msmspring.cloud.gateway.routes[2].uri=lb://service-msmspring.cloud.gateway.routes[2].predicates=Path=/edumsm/** 启动类1234567@SpringBootApplication@EnableDiscoveryClient //nacospublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 测试：使用网关的端口号即可访问已配置的微服务OK 跨域问题 在网关中统一开启跨域，cv一下固定config、filter、handler 注意controller中的跨域注解不能有，要不然两次跨域抵消 权限管理（后端）![07 权限管理需求](https://gitee.com/ReRia/images/raw/master/img/07 权限管理需求.png) 环境搭建模块 service_acl，spring_security 依赖1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;spring_security&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 整合接口 直接CV好家伙，好像是因为太复杂了吧，没事下个项目自己做 获取所有菜单 递归，构建树形结构（注意菜单可能有多级结构（之前做过两级的）） entity 注意这个实体类的属性，使用了递归存储children 1234567891011121314151617181920public class Permission implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = &quot;编号&quot;) @TableId(value = &quot;id&quot;, type = IdType.ID_WORKER_STR) private String id; @ApiModelProperty(value = &quot;所属上级&quot;) private String pid; @ApiModelProperty(value = &quot;层级&quot;) @TableField(exist = false) private Integer level; @ApiModelProperty(value = &quot;下级&quot;) @TableField(exist = false) private List&lt;Permission&gt; children; &#125; controller12345678910111213@RestController@RequestMapping(&quot;/admin/acl/permission&quot;)public class PermissionController &#123; @Autowired private PermissionService permissionService; //获取全部菜单 @ApiOperation(value = &quot;查询所有菜单&quot;) @GetMapping public R indexAllPermission() &#123; List&lt;Permission&gt; list = permissionService.queryAllMenuGuli(); return R.ok().data(&quot;children&quot;,list); &#125;&#125; service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//获取全部菜单@Overridepublic List&lt;Permission&gt; queryAllMenuGuli() &#123; //1 查询菜单表所有数据 QueryWrapper&lt;Permission&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.orderByDesc(&quot;id&quot;); List&lt;Permission&gt; permissionList = baseMapper.selectList(wrapper); //2 把查询所有菜单list集合按照要求进行封装 List&lt;Permission&gt; resultList = bulidPermission(permissionList); return resultList;&#125;//把返回所有菜单list集合进行封装的方法public static List&lt;Permission&gt; bulidPermission(List&lt;Permission&gt; permissionList) &#123; //创建list集合，用于数据最终封装 List&lt;Permission&gt; finalNode = new ArrayList&lt;&gt;(); //把所有菜单list集合遍历，得到顶层菜单 pid=0菜单，设置level是1 for(Permission permissionNode : permissionList) &#123; //得到顶层菜单 pid=0菜单 if(&quot;0&quot;.equals(permissionNode.getPid())) &#123; //设置顶层菜单的level是1 permissionNode.setLevel(1); //根据顶层菜单，向里面进行查询子菜单，封装到finalNode里面 finalNode.add(selectChildren(permissionNode,permissionList)); &#125; &#125; return finalNode;&#125;private static Permission selectChildren(Permission permissionNode, List&lt;Permission&gt; permissionList) &#123; //1 因为向一层菜单里面放二层菜单，二层里面还要放三层，把对象初始化 permissionNode.setChildren(new ArrayList&lt;Permission&gt;()); //2 遍历所有菜单list集合，进行判断比较，比较id和pid值是否相同 for(Permission it : permissionList) &#123; //判断 id和pid值是否相同 if(permissionNode.getId().equals(it.getPid())) &#123; //当前level=父菜单的level值+1 int level = permissionNode.getLevel()+1; it.setLevel(level); //如果children为空，进行初始化操作 //if(permissionNode.getChildren() == null) &#123; // permissionNode.setChildren(new ArrayList&lt;Permission&gt;()); //&#125; //把查询出来的子菜单放到父菜单里面 permissionNode.getChildren().add(selectChildren(it,permissionList)); &#125; &#125; return permissionNode;&#125; 测试 SwaggerConfig类中有一行代码需要注释才能测试,，表示路径中有这个关键字则不让测试，可以注释掉这行代码也可以修改controller的路径 1234567891011@Bean public Docket webApiConfig() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;webApi&quot;) .apiInfo(webApiInfo()) .select() // .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;))) .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;))) .build(); &#125; 删除菜单 递归删除，删除上级菜单下级菜单也要同时删除 controller123456@ApiOperation(value = &quot;递归删除菜单&quot;)@DeleteMapping(&quot;remove/&#123;id&#125;&quot;)public R remove(@PathVariable String id) &#123; permissionService.removeChildByIdGuli(id); return R.ok();&#125; service123456789101112131415161718192021222324252627//============递归删除菜单==================================@Overridepublic void removeChildByIdGuli(String id) &#123; //1 创建list集合，用于封装所有删除菜单id值 List&lt;String&gt; idList = new ArrayList&lt;&gt;(); //2 向idList集合设置删除菜单id this.selectPermissionChildById(id, idList); //把当前id封装到list里面 idList.add(id); baseMapper.deleteBatchIds(idList);&#125;//2 根据当前菜单id，查询菜单里面子菜单id，封装到list集合private void selectPermissionChildById(String id, List&lt;String&gt; idList) &#123; //查询菜单里面子菜单id QueryWrapper&lt;Permission&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;pid&quot;, id); wrapper.select(&quot;id&quot;); List&lt;Permission&gt; childIdList = baseMapper.selectList(wrapper); //把childIdList里面菜单id值获取出来，封装idList里面，做递归查询 childIdList.stream().forEach(item -&gt; &#123; //封装idList里面 idList.add(item.getId()); //递归查询 this.selectPermissionChildById(item.getId(), idList); &#125;);&#125; 角色分配权限controller123456@ApiOperation(value = &quot;给角色分配权限&quot;)@PostMapping(&quot;/doAssign&quot;)public R doAssign(String roleId,String[] permissionId) &#123; permissionService.saveRolePermissionRealtionShipGuli(roleId,permissionId); return R.ok();&#125; service12345678910111213141516171819//=========================给角色分配菜单=======================@Overridepublic void saveRolePermissionRealtionShipGuli(String roleId, String[] permissionIds) &#123; //roleId角色id //permissionId菜单id 数组形式 //1 创建list集合，用于封装添加数据 List&lt;RolePermission&gt; rolePermissionList = new ArrayList&lt;&gt;(); //遍历所有菜单数组 for (String perId : permissionIds) &#123; //RolePermission对象 RolePermission rolePermission = new RolePermission(); rolePermission.setRoleId(roleId); rolePermission.setPermissionId(perId); //封装到list集合 rolePermissionList.add(rolePermission); &#125; //添加到角色菜单关系表 rolePermissionService.saveBatch(rolePermissionList);&#125; SpringSecurity介绍 spring-security实现功能如下： 用户认证：用户登录时查询数据库验证用户名和密码 用户授权：登录之后给予用户对应的权限和操作功能 spring-security本质上是filter，对请求进行过滤： 基于session，则对cookie中的sessionid进行解析找到服务器存储的session信息然后判断当前用户是否符合请求的要求 基于token，则解析出token然后将当前请求加入到spring-security管理的权限信息当中 认证和授权实现思路 如果系统的模块众多，每个模块都需要就行授权与认证，所以我们选择基于token的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前请求是否有权限访问 整合依赖1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;common_utils&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Security依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 项目结构 测试 妈耶太吓人了幸好我备份了（为啥git不先讲），试了下整合，菜单栏还是显示不出来，先恢复了，以后再试 Nacos配置管理Git版本管理 创建本地git仓库：idea -&gt; VCS -&gt; Create Git Repository 将文件加到本地仓库：idea -&gt; 父项目名 -&gt; 右键 -&gt; git -&gt; add 添加远程仓库地址：idea -&gt; 父项目名 -&gt; 右键 -&gt; git -&gt; git remotes 将文件提交至远程仓库：commit 上传：push","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战6","slug":"【项目笔记】在线教育项目实战6","date":"2021-10-02T04:51:33.699Z","updated":"2021-10-05T07:14:17.776Z","comments":true,"path":"2021/10/02/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-6/","link":"","permalink":"http://example.com/2021/10/02/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-6/","excerpt":"","text":"前台讲师列表和详情（后端+前端）讲师分页列表（后端）controller1234567891011121314151617@RestController@RequestMapping(&quot;/eduservice/teacherfront&quot;)@CrossOriginpublic class TeacherController &#123; @Autowired private EduTeacherService teacherService; // 分页查询讲师列表 @GetMapping(&quot;getTeacherFront/&#123;pageNo&#125;/&#123;limit&#125;&quot;) public R getTeacherFront(@PathVariable Long limit, @PathVariable Long pageNo) &#123; // 创建page对象 Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(pageNo, limit); // 调用方法实现分类 Map&lt;String, Object&gt; map = teacherService.getTeacherFront(pageTeacher); // 返回分页所有数据 return R.ok().data(map); &#125;&#125; service123456789101112131415161718192021222324@Servicepublic class EduTeacherServiceImpl extends ServiceImpl&lt;EduTeacherMapper, EduTeacher&gt; implements EduTeacherService &#123; @Override @Cacheable(key = &quot;&#x27;indexTeacherList&#x27;&quot;, value = &quot;teacher&quot;) // redis public List&lt;EduTeacher&gt; getIndexList() &#123; return baseMapper.selectIndexList(); &#125; // 分页查询讲师列表 @Override public Map&lt;String, Object&gt; getTeacherFront(Page&lt;EduTeacher&gt; pageTeacher) &#123; QueryWrapper wrapper = new QueryWrapper&lt;&gt;(); wrapper.orderByDesc(&quot;id&quot;); baseMapper.selectPage(pageTeacher, wrapper); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;records&quot;, pageTeacher.getRecords()); map.put(&quot;total&quot;, pageTeacher.getTotal()); map.put(&quot;size&quot;, pageTeacher.getSize()); map.put(&quot;current&quot;, pageTeacher.getCurrent()); map.put(&quot;pages&quot;, pageTeacher.getPages()); map.put(&quot;hasNext&quot;, pageTeacher.hasNext()); map.put(&quot;hasPrevious&quot;, pageTeacher.hasPrevious()); return map; &#125;&#125; 讲师分页列表（前端）api12345678910import request from &#x27;@/utils/request&#x27;export default &#123; // 讲师分页列表 getTeacherList(pageNo, limit) &#123; return request(&#123; url: `/eduservice/teacherfront/getTeacherFront/$&#123;pageNo&#125;/$&#123;limit&#125;`, method: &#x27;get&#x27;, &#125;) &#125;&#125; vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- 讲师列表 开始 --&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title all-teacher-title&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;全部讲师&lt;/span&gt; &lt;/h2&gt; &lt;section class=&quot;c-tab-title&quot;&gt; &lt;a id=&quot;subjectAll&quot; title=&quot;全部&quot; href=&quot;#&quot;&gt;全部&lt;/a&gt; &lt;/section&gt; &lt;/header&gt; &lt;section class=&quot;c-sort-box unBr&quot;&gt; &lt;div&gt; &lt;!-- /无数据提示 开始--&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;listMap.total == 0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot; &gt;没有相关数据，小编正在努力整理中...&lt;/span &gt; &lt;/section&gt; &lt;!-- /无数据提示 结束--&gt; &lt;article class=&quot;i-teacher-list&quot; v-if=&quot;listMap.total &gt; 0&quot;&gt; &lt;ul class=&quot;of&quot;&gt; &lt;li v-for=&quot;teacher in listMap.records&quot; :key=&quot;teacher.id&quot;&gt; &lt;section class=&quot;i-teach-wrap&quot;&gt; &lt;div class=&quot;i-teach-pic&quot;&gt; &lt;a :href=&quot;&#x27;/teacehr/&#x27;+teacher.id&quot; :title=&quot;teacher.name&quot; target=&quot;_blank&quot;&gt; &lt;img :src=&quot;teacher.avatar&quot; alt /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mt10 hLh30 txtOf tac&quot;&gt; &lt;a :href=&quot;&#x27;/teacehr/&#x27;+teacher.id&quot; :title=&quot;teacher.name&quot; target=&quot;_blank&quot; class=&quot;fsize18 c-666&quot; &gt;&#123;&#123; teacher.name &#125;&#125;&lt;/a &gt; &lt;/div&gt; &lt;div class=&quot;hLh30 txtOf tac&quot;&gt; &lt;span class=&quot;fsize14 c-999&quot;&gt;&#123;&#123; teacher.intro &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;mt15 i-q-txt&quot;&gt; &lt;p class=&quot;c-999 f-fA&quot;&gt;&#123;&#123; teacher.career &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- /讲师列表 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import teacherApi from &#x27;@/api/teacher&#x27; export default &#123; // 这个页面模板没有使用element-ui的分页条，所以写法有所变化 // 使用异步调用（this.$route.param == params获取url中的参数值） // 该方法只调用一次 asyncData(&#123; params, error &#125;) &#123; return teacherApi.getTeacherList(1, 8).then(result =&gt; &#123; // 这里是赋值的简写方式 return &#123; listMap: result.data.data &#125; &#125;) &#125; &#125;&lt;/script&gt; 分页条1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- 公共分页 开始 --&gt; &lt;div&gt; &lt;div class=&quot;paging&quot;&gt; &lt;!-- undisable这个class是否存在，取决于数据属性hasPrevious --&gt; &lt;a :class=&quot;&#123; undisable: !listMap.hasPrevious &#125;&quot; href=&quot;#&quot; title=&quot;首页&quot; @click.prevent=&quot;gotoPage(1)&quot; &gt;首页&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !listMap.hasPrevious &#125;&quot; href=&quot;#&quot; title=&quot;前一页&quot; @click.prevent=&quot;gotoPage(listMap.current - 1)&quot; &gt;&amp;lt;&lt;/a &gt; &lt;a v-for=&quot;page in listMap.pages&quot; :key=&quot;page&quot; :class=&quot;&#123; current: listMap.current == page, undisable: listMap.current == page, &#125;&quot; :title=&quot;&#x27;第&#x27; + page + &#x27;页&#x27;&quot; href=&quot;#&quot; @click.prevent=&quot;gotoPage(page)&quot; &gt;&#123;&#123; page &#125;&#125;&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !listMap.hasNext &#125;&quot; href=&quot;#&quot; title=&quot;后一页&quot; @click.prevent=&quot;gotoPage(listMap.current + 1)&quot; &gt;&amp;gt;&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !listMap.hasNext &#125;&quot; href=&quot;#&quot; title=&quot;末页&quot; @click.prevent=&quot;gotoPage(listMap.pages)&quot; &gt;末页&lt;/a &gt; &lt;div class=&quot;clear&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 公共分页 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import teacherApi from &#x27;@/api/teacher&#x27; export default &#123; methods: &#123; // 分页切换 gotoPage(page) &#123; teacherApi.getTeacherList(page, 8).then(result =&gt; &#123; this.listMap = result.data.data &#125;) &#125; &#125; &#125;&lt;/script&gt; 讲师详情（后端）123456789// 讲师详情@GetMapping(&quot;getTeacherInfoFront/&#123;teacherId&#125;&quot;)public R getTeacherInfoFront(@PathVariable String teacherId) &#123; EduTeacher teacherInfo = teacherService.getById(teacherId); QueryWrapper wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;teacher_id&quot;, teacherId); List&lt;EduCourse&gt; courseList = courseService.list(wrapper); return R.ok().data(&quot;teacherInfo&quot;, teacherInfo).data(&quot;courseList&quot;, courseList);&#125; 讲师详情（前端）api1234567// 讲师详情getTeacherInfo(teacherId) &#123; return request(&#123; url: `/eduservice/teacherfront/getTeacherInfoFront/$&#123;teacherId&#125;`, method: &#x27;get&#x27;, &#125;)&#125; vue 注意NUXT的动态变量的页面为_xxx.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- 讲师介绍 开始 --&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;讲师介绍&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;t-infor-wrap&quot;&gt; &lt;!-- 讲师基本信息 --&gt; &lt;section class=&quot;fl t-infor-box c-desc-content&quot;&gt; &lt;div class=&quot;mt20 ml20&quot;&gt; &lt;section class=&quot;t-infor-pic&quot;&gt; &lt;img :src=&quot;teacherInfo.avatar&quot; /&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30&quot;&gt; &lt;span class=&quot;fsize24 c-333&quot; &gt;&#123;&#123; teacherInfo.name &#125;&#125;&amp;nbsp;&#123;&#123; teacherInfo.level === 1 ? &quot;高级讲师&quot; : &quot;首席讲师&quot; &#125;&#125;&lt;/span &gt; &lt;/h3&gt; &lt;section class=&quot;mt10&quot;&gt; &lt;span class=&quot;t-tag-bg&quot;&gt;&#123;&#123; teacherInfo.career &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;t-infor-txt&quot;&gt; &lt;p class=&quot;mt20&quot;&gt; &#123;&#123; teacherInfo.intro &#125;&#125; &lt;/p&gt; &lt;/section&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;section class=&quot;mt30&quot;&gt; &lt;div&gt; &lt;header class=&quot;comm-title all-teacher-title c-course-content&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;主讲课程&lt;/span&gt; &lt;/h2&gt; &lt;section class=&quot;c-tab-title&quot;&gt; &lt;a href=&quot;javascript: void(0)&quot;&gt;&amp;nbsp;&lt;/a&gt; &lt;/section&gt; &lt;/header&gt; &lt;!-- /无数据提示 开始--&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;courseList.length == 0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot; &gt;没有相关数据，小编正在努力整理中...&lt;/span &gt; &lt;/section&gt; &lt;!-- /无数据提示 结束--&gt; &lt;article class=&quot;comm-course-list&quot; v-if=&quot;courseList.length &gt; 0&quot;&gt; &lt;ul class=&quot;of&quot;&gt; &lt;li v-for=&quot;course in courseList&quot; :key=&quot;course.id&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;course-img&quot;&gt; &lt;img :src=&quot;course.cover&quot; class=&quot;img-responsive&quot; /&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;开始学习&quot; target=&quot;_blank&quot; class=&quot;comm-btn c-btn-1&quot; &gt;开始学习&lt;/a &gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a href=&quot;#&quot; :title=&quot;course.title&quot; target=&quot;_blank&quot; class=&quot;course-title fsize18 c-333&quot; &gt;&#123;&#123; course.title &#125;&#125;&lt;/a &gt; &lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- /讲师介绍 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import teacherApi from &#x27;@/api/teacher&#x27; export default &#123; asyncData(&#123; params, error &#125;) &#123; // 注意这里的params后跟的名字要和vue文件名对应（所以他是只能传一个参数吗？） return teacherApi.getTeacherInfo(params.id).then(result =&gt; &#123; return &#123; teacherInfo: result.data.data.teacherInfo, courseList: result.data.data.courseList &#125; &#125;) &#125; &#125;&lt;/script&gt; 前台课程列表和详情（后端+前端）课程列表（后端）vo类1234567891011121314151617181920212223@Datapublic class CourseFrontVo &#123; @ApiModelProperty(value = &quot;课程名称&quot;) private String title; @ApiModelProperty(value = &quot;讲师id&quot;) private String teacherId; @ApiModelProperty(value = &quot;一级类别id&quot;) private String subjectParentId; @ApiModelProperty(value = &quot;二级类别id&quot;) private String subjectId; @ApiModelProperty(value = &quot;销量排序&quot;) private String buyCountSort; @ApiModelProperty(value = &quot;最新时间排序&quot;) private String gmtCreateSort; @ApiModelProperty(value = &quot;价格排序&quot;) private String priceSort;&#125; controller12345678910111213141516@RestController@CrossOrigin@RequestMapping(&quot;/eduservice/coursefront&quot;)public class CourseController &#123; @Autowired private EduCourseService courseService; // 条件查询带分页 @PostMapping(&quot;getCourseList/&#123;pageNo&#125;/&#123;limit&#125;&quot;) public R getCourseListCondition(@PathVariable Long limit, @PathVariable Long pageNo, @RequestBody(required = false) CourseFrontVo courseFrontVo) &#123; Page&lt;EduCourse&gt; pageCourse = new Page&lt;&gt;(pageNo, limit); Map&lt;String, Object&gt; map = courseService.getCOurseFrontList(pageCourse, courseFrontVo); return R.ok().data(map); &#125; &#125; service12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic Map&lt;String, Object&gt; getCourseFrontList(Page&lt;EduCourse&gt; pageCourse, CourseFrontVo courseFrontVo) &#123; QueryWrapper wrapper = new QueryWrapper(); // 判断条件是否为空 if (!StringUtils.isEmpty(courseFrontVo.getSubjectParentId())) &#123; wrapper.eq(&quot;subject_parent_id&quot;, courseFrontVo.getSubjectParentId()); &#125; if (!StringUtils.isEmpty(courseFrontVo.getSubjectId())) &#123; wrapper.eq(&quot;subject_id&quot;, courseFrontVo.getSubjectId()); &#125; if (!StringUtils.isEmpty(courseFrontVo.getBuyCountSort())) &#123; wrapper.orderByDesc(&quot;buy_count&quot;); &#125; if (!StringUtils.isEmpty(courseFrontVo.getGmtCreateSort())) &#123; //最新 wrapper.orderByDesc(&quot;gmt_create&quot;); &#125; if (!StringUtils.isEmpty(courseFrontVo.getPriceSort())) &#123;//价格 wrapper.orderByDesc(&quot;price&quot;); &#125; baseMapper.selectPage(pageCourse, wrapper); List&lt;EduCourse&gt; records = pageCourse.getRecords(); long current = pageCourse.getCurrent(); long pages = pageCourse.getPages(); long size = pageCourse.getSize(); long total = pageCourse.getTotal(); boolean hasNext = pageCourse.hasNext();//下一页 boolean hasPrevious = pageCourse.hasPrevious();//上一页 //把分页数据获取出来，放到map集合 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;items&quot;, records); map.put(&quot;current&quot;, current); map.put(&quot;pages&quot;, pages); map.put(&quot;size&quot;, size); map.put(&quot;total&quot;, total); map.put(&quot;hasNext&quot;, hasNext); map.put(&quot;hasPrevious&quot;, hasPrevious); //map返回 return map;&#125; 课程列表（前端）api12345678910111213141516171819import request from &#x27;@/utils/request&#x27;export default &#123; // 讲师分页列表 getCourseList(pageNo, limit, queryCourse) &#123; return request(&#123; url: `/eduservice/coursefront/getCourseList/$&#123;pageNo&#125;/$&#123;limit&#125;`, method: &#x27;post&#x27;, data: queryCourse &#125;) &#125;, // 课程分类列表 getSubjectList() &#123; return request(&#123; url: `/eduservice/subject/getAllSubjects`, method: &#x27;get&#x27; &#125;)&#125;&#125; vue 这一块内容挺多的，有二级联动查询，有分页条，有条件排序等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- /课程列表 开始 --&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;fl tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;全部课程&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;section class=&quot;c-sort-box&quot;&gt; &lt;section class=&quot;c-s-dl&quot;&gt; &lt;dl&gt; &lt;dt&gt; &lt;span class=&quot;c-999 fsize14&quot;&gt;课程类别&lt;/span&gt; &lt;/dt&gt; &lt;dd class=&quot;c-s-dl-li&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li&gt; &lt;a title=&quot;全部&quot; href=&quot;#&quot;&gt;全部&lt;/a&gt; &lt;/li&gt; &lt;li v-for=&quot;(item, index) in subjectNestedList&quot; :key=&quot;index&quot; :class=&quot;&#123; active: oneIndex == index &#125;&quot; &gt; &lt;a :title=&quot;item.title&quot; href=&quot;#&quot; @click=&quot;searchOne(item.id, index)&quot; &gt;&#123;&#123; item.title &#125;&#125;&lt;/a &gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;span class=&quot;c-999 fsize14&quot;&gt;&lt;/span&gt; &lt;/dt&gt; &lt;dd class=&quot;c-s-dl-li&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li v-for=&quot;(item, index) in subSubjectList&quot; :key=&quot;index&quot; :class=&quot;&#123; active: twoIndex == index &#125;&quot; &gt; &lt;a :title=&quot;item.title&quot; href=&quot;#&quot; @click=&quot;searchTwo(item.id, index)&quot; &gt;&#123;&#123; item.title &#125;&#125;&lt;/a &gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;div class=&quot;js-wrap&quot;&gt; &lt;section class=&quot;fr&quot;&gt; &lt;span class=&quot;c-ccc&quot;&gt; &lt;i class=&quot;c-master f-fM&quot;&gt;1&lt;/i&gt;/ &lt;i class=&quot;c-666 f-fM&quot;&gt;1&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;fl&quot;&gt; &lt;ol class=&quot;js-tap clearfix&quot;&gt; &lt;li :class=&quot;&#123; &#x27;current bg-orange&#x27;: buyCountSort != &#x27;&#x27; &#125;&quot;&gt; &lt;a title=&quot;销量&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchBuyCount()&quot; &gt;销量 &lt;span :class=&quot;&#123; hide: buyCountSort == &#x27;&#x27; &#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123; &#x27;current bg-orange&#x27;: gmtCreateSort != &#x27;&#x27; &#125;&quot;&gt; &lt;a title=&quot;最新&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchGmtCreate()&quot; &gt;最新 &lt;span :class=&quot;&#123; hide: gmtCreateSort == &#x27;&#x27; &#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123; &#x27;current bg-orange&#x27;: priceSort != &#x27;&#x27; &#125;&quot;&gt; &lt;a title=&quot;价格&quot; href=&quot;javascript:void(0);&quot; @click=&quot;searchPrice()&quot; &gt;价格&amp;nbsp; &lt;span :class=&quot;&#123; hide: priceSort == &#x27;&#x27; &#125;&quot;&gt;↓&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;/div&gt; &lt;div class=&quot;mt40&quot;&gt; &lt;!-- /无数据提示 开始--&gt; &lt;section class=&quot;no-data-wrap&quot; v-if=&quot;data.total == 0&quot;&gt; &lt;em class=&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;c-666 fsize14 ml10 vam&quot; &gt;没有相关数据，小编正在努力整理中...&lt;/span &gt; &lt;/section&gt; &lt;!-- /无数据提示 结束--&gt; &lt;article v-if=&quot;data.total &gt; 0&quot; class=&quot;comm-course-list&quot;&gt; &lt;ul class=&quot;of&quot; id=&quot;bna&quot;&gt; &lt;li v-for=&quot;item in data.items&quot; :key=&quot;item.id&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;course-img&quot;&gt; &lt;img :src=&quot;item.cover&quot; class=&quot;img-responsive&quot; :alt=&quot;item.title&quot; /&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a :href=&quot;&#x27;/course/&#x27; + item.id&quot; title=&quot;开始学习&quot; class=&quot;comm-btn c-btn-1&quot; &gt;开始学习&lt;/a &gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a :href=&quot;&#x27;/course/&#x27; + item.id&quot; :title=&quot;item.title&quot; class=&quot;course-title fsize18 c-333&quot; &gt;&#123;&#123; item.title &#125;&#125;&lt;/a &gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span v-if=&quot;Number(item.price) === 0&quot; class=&quot;fr jgTag bg-green&quot; &gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot;&gt;9634人学习&lt;/i&gt; | &lt;i class=&quot;c-999 f-fA&quot;&gt;9634评论&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;!-- 公共分页 开始 --&gt; &lt;div&gt; &lt;div class=&quot;paging&quot;&gt; &lt;!-- undisable这个class是否存在，取决于数据属性hasPrevious --&gt; &lt;a :class=&quot;&#123; undisable: !data.hasPrevious &#125;&quot; href=&quot;#&quot; title=&quot;首页&quot; @click.prevent=&quot;gotoPage(1)&quot; &gt;首&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !data.hasPrevious &#125;&quot; href=&quot;#&quot; title=&quot;前一页&quot; @click.prevent=&quot;gotoPage(data.current - 1)&quot; &gt;&amp;lt;&lt;/a &gt; &lt;a v-for=&quot;page in data.pages&quot; :key=&quot;page&quot; :class=&quot;&#123; current: data.current == page, undisable: data.current == page, &#125;&quot; :title=&quot;&#x27;第&#x27; + page + &#x27;页&#x27;&quot; href=&quot;#&quot; @click.prevent=&quot;gotoPage(page)&quot; &gt;&#123;&#123; page &#125;&#125;&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !data.hasNext &#125;&quot; href=&quot;#&quot; title=&quot;后一页&quot; @click.prevent=&quot;gotoPage(data.current + 1)&quot; &gt;&amp;gt;&lt;/a &gt; &lt;a :class=&quot;&#123; undisable: !data.hasNext &#125;&quot; href=&quot;#&quot; title=&quot;末页&quot; @click.prevent=&quot;gotoPage(data.pages)&quot; &gt;末&lt;/a &gt; &lt;div class=&quot;clear&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- /课程列表 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import courseApi from &#x27;@/api/course&#x27; export default &#123; data() &#123; return &#123; page: 1, // 当前页 data: &#123;&#125;, // 课程列表 subjectNestedList: [], // 一级分类列表 subSubjectList: [], // 二级分类列表 queryObj: &#123;&#125;, // 查询表单对象 oneIndex: -1, twoIndex: -1, buyCountSort: &#x27;&#x27;, gmtCreateSort: &#x27;&#x27;, priceSort: &#x27;&#x27; &#125; &#125;, created() &#123; // 课程第一次查询 this.initCourseFirst() // 一级分类显示 this.initSubject() &#125;, methods: &#123; // 1 查询第一页数据 initCourseFirst() &#123; courseApi.getCourseList(1, 8, this.queryObj).then(response =&gt; &#123; this.data = response.data.data &#125;) &#125;, // 2 查询所有一级分类 initSubject() &#123; courseApi.getSubjectList().then(response =&gt; &#123; this.subjectNestedList = response.data.data.list &#125;) &#125;, // 3 分页切换的方法 gotoPage(page) &#123; courseApi.getCourseList(page, 8, this.queryObj).then(response =&gt; &#123; this.data = response.data.data &#125;) &#125;, // 4 点击某个一级分类，查询对应二级分类 searchOne(subjectParentId, index) &#123; // 把传递index值赋值给oneIndex,为了active样式生效 this.oneIndex = index this.twoIndex = -1 this.queryObj.subjectId = &#x27;&#x27; this.subSubjectList = [] // 把一级分类点击id值，赋值给queryObj this.queryObj.subjectParentId = subjectParentId // 点击某个一级分类进行条件查询 this.gotoPage(1) // 拿着点击一级分类id 和 所有一级分类id进行比较， // 如果id相同，从一级分类里面获取对应的二级分类 for (let i = 0; i &lt; this.subjectNestedList.length; i++) &#123; // 获取每个一级分类 var oneSubject = this.subjectNestedList[i] // 比较id是否相同 if (subjectParentId == oneSubject.id) &#123; // 从一级分类里面获取对应的二级分类 this.subSubjectList = oneSubject.children &#125; &#125; &#125;, // 5 点击某个二级分类实现查询 searchTwo(subjectId, index) &#123; // 把index赋值,为了样式生效 this.twoIndex = index // 把二级分类点击id值，赋值给queryObj this.queryObj.subjectId = subjectId // 点击某个二级分类进行条件查询 this.gotoPage(1) &#125;, // 6 根据销量排序 searchBuyCount() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &#x27;1&#x27; this.gmtCreateSort = &#x27;&#x27; this.priceSort = &#x27;&#x27; // 把值赋值到queryObj this.queryObj.buyCountSort = this.buyCountSort this.queryObj.gmtCreateSort = this.gmtCreateSort this.queryObj.priceSort = this.priceSort // 调用方法查询 this.gotoPage(1) &#125;, // 7 最新排序 searchGmtCreate() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &#x27;&#x27; this.gmtCreateSort = &#x27;1&#x27; this.priceSort = &#x27;&#x27; // 把值赋值到queryObj this.queryObj.buyCountSort = this.buyCountSort this.queryObj.gmtCreateSort = this.gmtCreateSort this.queryObj.priceSort = this.priceSort // 调用方法查询 this.gotoPage(1) &#125;, // 8 价格排序 searchPrice() &#123; // 设置对应变量值，为了样式生效 this.buyCountSort = &#x27;&#x27; this.gmtCreateSort = &#x27;&#x27; this.priceSort = &#x27;1&#x27; // 把值赋值到queryObj this.queryObj.buyCountSort = this.buyCountSort this.queryObj.gmtCreateSort = this.gmtCreateSort this.queryObj.priceSort = this.priceSort // 调用方法查询 this.gotoPage(1) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .active &#123; background: #bdbdbd; &#125; .hide &#123; display: none; &#125; .show &#123; display: block; &#125;&lt;/style&gt; 课程详情（后端）vo类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 课程基础信息VO */@Datapublic class CourseFrontInfoVo &#123; private String id; @ApiModelProperty(value = &quot;课程标题&quot;) private String title; @ApiModelProperty(value = &quot;课程销售价格，设置为0则可免费观看&quot;) private BigDecimal price; @ApiModelProperty(value = &quot;总课时&quot;) private Integer lessonNum; @ApiModelProperty(value = &quot;课程封面图片路径&quot;) private String cover; @ApiModelProperty(value = &quot;销售数量&quot;) private Long buyCount; @ApiModelProperty(value = &quot;浏览数量&quot;) private Long viewCount; @ApiModelProperty(value = &quot;课程简介&quot;) private String description; @ApiModelProperty(value = &quot;讲师ID&quot;) private String teacherId; @ApiModelProperty(value = &quot;讲师姓名&quot;) private String teacherName; @ApiModelProperty(value = &quot;讲师资历,一句话说明讲师&quot;) private String intro; @ApiModelProperty(value = &quot;讲师头像&quot;) private String avatar; @ApiModelProperty(value = &quot;课程一级类别ID&quot;) private String subjectLevelOneId; @ApiModelProperty(value = &quot;类别一级名称&quot;) private String subjectLevelOne; @ApiModelProperty(value = &quot;课程二级类别ID&quot;) private String subjectLevelTwoId; @ApiModelProperty(value = &quot;类别二级名称&quot;) private String subjectLevelTwo;&#125; controller1234567// 课程详情信息@GetMapping(&quot;getCourseInfo/&#123;courseId&#125;&quot;)public R getCourseInfo(@PathVariable String courseId) &#123; CourseFrontInfoVo courseInfo = courseService.getBaseCourseInfo(courseId); List&lt;ChapterVo&gt; chapterList = chapterService.getChapterVideoByCourseId(courseId); return R.ok().data(&quot;courseInfo&quot;, courseInfo).data(&quot;chapterList&quot;, chapterList);&#125; service12345// 根据课程id查询课程基本信息以及其章节列表@Overridepublic CourseFrontInfoVo getBaseCourseInfo(String courseId) &#123; return baseMapper.getBaseCourseInfo(courseId);&#125; mapper12345678910111213141516171819202122232425&lt;!-- 根据课程id查询课程基本信息 --&gt;&lt;select id=&quot;getBaseCourseInfo&quot; resultType=&quot;com.atguigu.eduservice.entity.frontVo.CourseFrontInfoVo&quot;&gt; select ec.id, ec.title, ec.price, ec.cover, ec.lesson_num AS lessonNum, ec.buy_count AS buyCount, ec.view_count AS viewCount, ecd.description, et.id AS teacherId, et.name AS teacherName, et.intro, et.avatar, es1.id AS subjectLevelOneId, es1.title AS subjectLevelOne, es2.id AS subjectLevelTwoId, es2.title AS subjectLevelTwo from edu_course ec left join edu_course_description ecd on ec.id = ecd.id left join edu_teacher et on ec.teacher_id = et.id left join edu_subject es1 on ec.subject_parent_id = es1.id left join edu_subject es2 on ec.subject_id = es2.id where ec.id = #&#123;courseId&#125;&lt;/select&gt; 课程详情（前端）api1234567// 获得课程信息getCourseInfo(courseId) &#123; return request(&#123; url: `/eduservice/coursefront/getCourseInfo/$&#123;courseId&#125;`, method: &#x27;get&#x27; &#125;)&#125; vue 注意这里的简介显示，需要使用v-html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;!-- /课程详情 开始 --&gt; &lt;section class=&quot;container&quot;&gt; &lt;!-- 这里是一个面包屑导航 --&gt; &lt;section class=&quot;path-wrap txtOf hLh30&quot;&gt; &lt;a href=&quot;#&quot; title class=&quot;c-999 fsize14&quot;&gt;首页&lt;/a&gt; \\ &lt;a href=&quot;#&quot; title class=&quot;c-999 fsize14&quot;&gt;&#123;&#123; courseInfo.subjectLevelOne &#125;&#125;&lt;/a&gt; \\ &lt;span class=&quot;c-333 fsize14&quot;&gt;&#123;&#123; courseInfo.subjectLevelTwo &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;div&gt; &lt;article class=&quot;c-v-pic-wrap&quot; style=&quot;height: 357px&quot;&gt; &lt;section class=&quot;p-h-video-box&quot; id=&quot;videoPlay&quot;&gt; &lt;img :src=&quot;courseInfo.cover&quot; :alt=&quot;courseInfo.title&quot; class=&quot;dis c-v-pic&quot; /&gt; &lt;/section&gt; &lt;/article&gt; &lt;aside class=&quot;c-attr-wrap&quot;&gt; &lt;section class=&quot;ml20 mr15&quot;&gt; &lt;h2 class=&quot;hLh30 txtOf mt15&quot;&gt; &lt;span class=&quot;c-fff fsize24&quot;&gt;&#123;&#123; courseInfo.title &#125;&#125;&lt;/span&gt; &lt;/h2&gt; &lt;section class=&quot;c-attr-jg&quot;&gt; &lt;span class=&quot;c-fff&quot;&gt;价格：&lt;/span&gt; &lt;b class=&quot;c-yellow&quot; style=&quot;font-size: 24px&quot; &gt;￥&#123;&#123; courseInfo.price &#125;&#125;&lt;/b &gt; &lt;/section&gt; &lt;section class=&quot;c-attr-mt c-attr-undis&quot;&gt; &lt;span class=&quot;c-fff fsize14&quot; &gt;主讲： &#123;&#123; courseInfo.teacherName &#125;&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span &gt; &lt;/section&gt; &lt;section class=&quot;c-attr-mt of&quot;&gt; &lt;span class=&quot;ml10 vam&quot;&gt; &lt;em class=&quot;icon18 scIcon&quot;&gt;&lt;/em&gt; &lt;a class=&quot;c-fff vam&quot; title=&quot;收藏&quot; href=&quot;#&quot;&gt;收藏&lt;/a&gt; &lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;c-attr-mt&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;立即观看&quot; class=&quot;comm-btn c-btn-3&quot;&gt;立即观看&lt;/a&gt; &lt;/section&gt; &lt;/section&gt; &lt;/aside&gt; &lt;aside class=&quot;thr-attr-box&quot;&gt; &lt;ol class=&quot;thr-attr-ol clearfix&quot;&gt; &lt;li&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;aside&gt; &lt;span class=&quot;c-fff f-fM&quot;&gt;购买数&lt;/span&gt; &lt;br /&gt; &lt;h6 class=&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123; courseInfo.buyCount &#125;&#125;&lt;/h6&gt; &lt;/aside&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;aside&gt; &lt;span class=&quot;c-fff f-fM&quot;&gt;课时数&lt;/span&gt; &lt;br /&gt; &lt;h6 class=&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123; courseInfo.lessonNum &#125;&#125;&lt;/h6&gt; &lt;/aside&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;aside&gt; &lt;span class=&quot;c-fff f-fM&quot;&gt;浏览数&lt;/span&gt; &lt;br /&gt; &lt;h6 class=&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123; courseInfo.viewCount &#125;&#125;&lt;/h6&gt; &lt;/aside&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- /课程封面介绍 --&gt; &lt;div class=&quot;mt20 c-infor-box&quot;&gt; &lt;article class=&quot;fl col-7&quot;&gt; &lt;section class=&quot;mr30&quot;&gt; &lt;div class=&quot;i-box&quot;&gt; &lt;div&gt; &lt;section id=&quot;c-i-tabTitle&quot; class=&quot;c-infor-tabTitle c-tab-title&quot;&gt; &lt;a name=&quot;c-i&quot; class=&quot;current&quot; title=&quot;课程详情&quot;&gt;课程详情&lt;/a&gt; &lt;/section&gt; &lt;/div&gt; &lt;article class=&quot;ml10 mr10 pt20&quot;&gt; &lt;div&gt; &lt;h6 class=&quot;c-i-content c-infor-title&quot;&gt; &lt;span&gt;课程介绍&lt;/span&gt; &lt;/h6&gt; &lt;div class=&quot;course-txt-body-wrap&quot;&gt; &lt;section class=&quot;course-txt-body&quot;&gt; &lt;!-- 由于当初编写的时候使用的富文本编辑器，所以这里显示要使用v-html --&gt; &lt;p v-html=&quot;courseInfo.description&quot;&gt; &#123;&#123; courseInfo.description &#125;&#125; &lt;/p&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /课程介绍 --&gt; &lt;div class=&quot;mt50&quot;&gt; &lt;h6 class=&quot;c-g-content c-infor-title&quot;&gt; &lt;span&gt;课程大纲&lt;/span&gt; &lt;/h6&gt; &lt;section class=&quot;mt20&quot;&gt; &lt;div class=&quot;lh-menu-wrap&quot;&gt; &lt;menu id=&quot;lh-menu&quot; class=&quot;lh-menu mt10 mr10&quot;&gt; &lt;ul&gt; &lt;!-- 文件目录 --&gt; &lt;li class=&quot;lh-menu-stair&quot; v-for=&quot;chapter in chapterList&quot; :key=&quot;chapter.id&quot; &gt; &lt;a href=&quot;javascript: void(0)&quot; :title=&quot;chapter.title&quot; class=&quot;current-1&quot; &gt; &lt;em class=&quot;lh-menu-i-1 icon18 mr10&quot;&gt;&lt;/em &gt;&#123;&#123; chapter.title &#125;&#125; &lt;/a&gt; &lt;ol class=&quot;lh-menu-ol&quot; style=&quot;display: block&quot;&gt; &lt;li class=&quot;lh-menu-second ml30&quot; v-for=&quot;video in chapter.children&quot; :key=&quot;video.id&quot; &gt; &lt;a href=&quot;#&quot; :title=&quot;video.title&quot;&gt; &lt;span class=&quot;fr&quot;&gt; &lt;i class=&quot;free-icon vam mr10&quot;&gt;免费试听&lt;/i&gt; &lt;/span&gt; &lt;em class=&quot;lh-menu-i-2 icon16 mr5&quot;&gt;&amp;nbsp;&lt;/em &gt;&#123;&#123;video.title&#125;&#125; &lt;/a&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/menu&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /课程大纲 --&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;/article&gt; &lt;aside class=&quot;fl col-3&quot;&gt; &lt;div class=&quot;i-box&quot;&gt; &lt;div&gt; &lt;section class=&quot;c-infor-tabTitle c-tab-title&quot;&gt; &lt;a title href=&quot;javascript:void(0)&quot;&gt;主讲讲师&lt;/a&gt; &lt;/section&gt; &lt;section class=&quot;stud-act-list&quot;&gt; &lt;ul style=&quot;height: auto&quot;&gt; &lt;li&gt; &lt;div class=&quot;u-face&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img :src=&quot;courseInfo.avatar&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;section class=&quot;hLh30 txtOf&quot;&gt; &lt;a class=&quot;c-333 fsize16 fl&quot; href=&quot;#&quot;&gt;&#123;&#123; courseInfo.teacherName &#125;&#125;&lt;/a&gt; &lt;/section&gt; &lt;section class=&quot;hLh20 txtOf&quot;&gt; &lt;span class=&quot;c-999&quot;&gt;&#123;&#123; courseInfo.intro &#125;&#125;&lt;/span&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- /课程详情 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import courseApi from &#x27;@/api/course&#x27; export default &#123; asyncData(&#123; params, error &#125;) &#123; return courseApi.getCourseInfo(params.id).then(result =&gt; &#123; return &#123; courseInfo: result.data.data.courseInfo, chapterList: result.data.data.chapterList &#125; &#125;) &#125; &#125;&lt;/script&gt; TODO：里面还有一些跳转还要完善 视频播放器 阿里云视频播放器，使用播放凭证播放 注意这里要写到service_vod模块，因为是和阿里云视频相关 后端controller12345678910111213// 根据视频id获取视频凭证@GetMapping(&quot;getPlayAuth/&#123;id&#125;&quot;)public R getPlayAuth(@PathVariable String id) throws ClientException &#123; // 创建初始化对象 DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET); // 创建获取凭证的request和response GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); request.setVideoId(id); // 调用方法获得凭证 GetVideoPlayAuthResponse acsResponse = client.getAcsResponse(request); String playAuth = acsResponse.getPlayAuth(); return R.ok().data(&quot;playAuth&quot;, playAuth);&#125; 前端 先去修改a标签的href值 :href=&quot;&#39;/video_player/&#39; + video.videoSourceId&quot; target=&quot;_blank&quot; 然后前端在pages文件夹下编写一个动态路由的vue视图，可以命名为_vid.vue，里面编写播放器的模板，这里还专门写了一个video的布局layout，cv即可 layout1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div class=&quot;guli-player&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;谷粒学院&quot;&gt; &lt;img class=&quot;logo&quot; src=&quot;~/assets/img/logo.png&quot; lt=&quot;谷粒学院&quot;&gt; &lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;nuxt/&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;html,body&#123; height:100%;&#125;&lt;/style&gt;&lt;style scoped&gt;.head &#123; height: 50px; position: absolute; top: 0; left: 0; width: 100%;&#125;.head .logo&#123; height: 50px; margin-left: 10px;&#125;.body &#123; position: absolute; top: 50px; left: 0; right: 0; bottom: 0; overflow: hidden;&#125;&lt;/style&gt; api12345678910import request from &#x27;@/utils/request&#x27;export default &#123; getPlayAuth(id) &#123; return request(&#123; url: `/eduvod/video/getPlayAuth/$&#123;id&#125;`, method: &#x27;get&#x27;, &#125;) &#125;,&#125; vue视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;!-- 阿里云视频播放器样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://g.alicdn.com/de/prismplayer/2.8.1/skins/default/aliplayer-min.css&quot; &gt; &lt;!-- 阿里云视频播放器脚本 --&gt; &lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://g.alicdn.com/de/prismplayer/2.8.1/aliplayer-min.js&quot; /&gt; &lt;!-- 定义播放器dom --&gt; &lt;div id=&quot;J_prismPlayer&quot; class=&quot;prism-player&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import vod from &#x27;@/api/vod&#x27;export default &#123; layout: &#x27;video&#x27;,//应用video布局 asyncData(&#123; params, error &#125;) &#123; return vod.getPlayAuth(params.vid) .then(response =&gt; &#123; return &#123; playAuth: response.data.data.playAuth, vid: params.vid &#125; &#125;) &#125;, mounted() &#123; //页面渲染之后 created new Aliplayer(&#123; id: &#x27;J_prismPlayer&#x27;, vid: this.vid, // 视频id playauth: this.playAuth, // 播放凭证 encryptType: &#x27;1&#x27;, // 如果播放加密视频，则需设置encryptType=1，非加密视频无需设置此项 width: &#x27;100%&#x27;, height: &#x27;500px&#x27;, // 以下可选设置 cover: &#x27;http://guli.shop/photo/banner/1525939573202.jpg&#x27;, // 封面 qualitySort: &#x27;asc&#x27;, // 清晰度排序 mediaType: &#x27;video&#x27;, // 返回音频还是视频 autoplay: false, // 自动播放 isLive: false, // 直播 rePlay: false, // 循环播放 preload: true, controlBarVisibility: &#x27;hover&#x27;, // 控制条的显示方式：鼠标悬停 useH5Prism: true, // 播放器类型：html5 &#125;, function(player) &#123; console.log(&#x27;播放器创建成功&#x27;) &#125;) &#125;&#125;&lt;/script&gt; 更多功能 阿里云Aliplayer播放器 (alicdn.com) 详见文档 视频评论（后端+前端） 具体实现分析： 创建课程评论表 创建后端接口 分页查询对应课程评论 添加评论 课程评论内容：输入，调用接口 课程id：进入详情页面就可以查询到课程id 用户id：根据cookie中的token查询用户信息 远程调用（edu -&gt; ucenter） 订单与支付（后端+前端） 创建子模块service_order, application.proerties里大差不差 代码生成器常规操作 后端基础搭建启动类 这个模块需要调用edu和UCenter模块中的方法查询课程和用户信息 12345678910@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@MapperScan(&quot;com.atguigu.eduorder.mapper&quot;)@EnableDiscoveryClient // nacos注册@EnableFeignClients // 使用Feignpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 依赖 微信支付接口的依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 生成订单（后端）OrderController1234567891011121314151617@RestController@RequestMapping(&quot;/eduorder/order&quot;)@CrossOriginpublic class OrderController &#123; @Autowired private OrderService orderService; // 生成订单方法 @PostMapping(&quot;createOrder/&#123;courseId&#125;&quot;) public R createOrder(@PathVariable String courseId, HttpServletRequest request) &#123; // 创建订单返回订单号 String memberId = JwtUtils.getMemberIdByJwtToken(request); String orderNo = orderService.createOrder(courseId, memberId); return R.ok().data(&quot;orderNo&quot;, orderNo); &#125; &#125; 实体类 注意这里要额外写一个vo类用于远程调用的时候返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)@ApiModel(value = &quot;UcenterMember对象&quot;, description = &quot;会员表&quot;)public class UcenterMemberForOrder implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = &quot;会员id&quot;) @TableId(value = &quot;id&quot;, type = IdType.ID_WORKER_STR) private String id; @ApiModelProperty(value = &quot;微信openid&quot;) private String openid; @ApiModelProperty(value = &quot;手机号&quot;) private String mobile; @ApiModelProperty(value = &quot;密码&quot;) private String password; @ApiModelProperty(value = &quot;昵称&quot;) private String nickname; @ApiModelProperty(value = &quot;性别 1 女，2 男&quot;) private Integer sex; @ApiModelProperty(value = &quot;年龄&quot;) private Integer age; @ApiModelProperty(value = &quot;用户头像&quot;) private String avatar; @ApiModelProperty(value = &quot;用户签名&quot;) private String sign; @ApiModelProperty(value = &quot;是否禁用 1（true）已禁用， 0（false）未禁用&quot;) private Boolean isDisabled; @ApiModelProperty(value = &quot;逻辑删除 1（true）已删除， 0（false）未删除&quot;) @TableLogic private Boolean isDeleted; @ApiModelProperty(value = &quot;创建时间&quot;) @TableField(fill = FieldFill.INSERT) private Date gmtCreate; @ApiModelProperty(value = &quot;更新时间&quot;) @TableField(fill = FieldFill.INSERT_UPDATE) private Date gmtModified;&#125; 这个实体类和UCenterMember无差别，但是放在了common模块当中，所以不同模块中的controller都可以使用该类 另一个课程相关实体类与这个类似，放在common模块中即可 UcenterMemberController 编写一个被远程调用的方法，通过id获取用户信息 12345678910111213141516@RestController@RequestMapping(&quot;/educenter/member&quot;)@CrossOriginpublic class UcenterMemberController &#123; @Autowired private UcenterMemberService memberService; // 根据用户id获取用户信息 @GetMapping(&quot;getUserInfoOrder/&#123;id&#125;&quot;) public UcenterMemberForOrder getUserInfoOrder(@PathVariable String id) &#123; // 注意这里的返回类型不要R，而是另一个统一类型 UcenterMember member = memberService.getById(id); UcenterMemberForOrder memberForOrder = new UcenterMemberForOrder(); BeanUtils.copyProperties(member, memberForOrder); return memberForOrder; &#125;&#125; CourseFrontController123456789101112131415@RestController@CrossOrigin@RequestMapping(&quot;/eduservice/coursefront&quot;)public class CourseController &#123; @Autowired private EduCourseService courseService; // 根据课程id查询课程信息 @GetMapping(&quot;getCourseInfoOrder/&#123;id&#125;&quot;) public CourseForOrder getCourseInfoOrder(@PathVariable String id) &#123; CourseInfoVo course = courseService.getCourseInfoById(id); CourseForOrder courseForOrder = new CourseForOrder(); BeanUtils.copyProperties(course, courseForOrder); return courseForOrder; &#125;&#125; 远程调用配置接口1234567@Component@FeignClient(&quot;service-edu&quot;)public interface EduClient &#123; // 根据课程id查询课程信息 @GetMapping(&quot;/eduservice/coursefront/getCourseInfoOrder/&#123;id&#125;&quot;) public CourseForOrder getCourseInfoOrder(@PathVariable(&quot;id&quot;) String id);&#125; 1234567@Component@FeignClient(&quot;service-ucenter&quot;)public interface UcenterClient &#123; // 根据用户id获取用户信息 @GetMapping(&quot;/educenter/member/getUserInfoOrder/&#123;id&#125;&quot;) public UcenterMemberForOrder getUserInfoOrder(@PathVariable(&quot;id&quot;) String id);&#125; OrderService1234567891011121314151617181920212223242526272829303132@Servicepublic class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Order&gt; implements OrderService &#123; @Autowired private EduClient eduClient; @Autowired private UcenterClient ucenterClient; // 生成订单 @Override public String createOrder(String courseId, String memberId) &#123; // 远程调用获取用户信息 UcenterMemberForOrder userInfoOrder = ucenterClient.getUserInfoOrder(memberId); // 远程调用获取课程信息 CourseForOrder courseInfoOrder = eduClient.getCourseInfoOrder(courseId); // 添加到数据库 Order order = new Order(); order.setOrderNo(OrderNoUtil.getOrderNo());//订单号 order.setCourseId(courseId); //课程id order.setCourseTitle(courseInfoOrder.getTitle()); order.setCourseCover(courseInfoOrder.getCover()); order.setTeacherName(courseInfoOrder.getTeacherName()); order.setTotalFee(courseInfoOrder.getPrice()); order.setMemberId(memberId); order.setMobile(userInfoOrder.getMobile()); order.setNickname(userInfoOrder.getNickname()); order.setStatus(0); //订单状态（0：未支付 1：已支付） order.setPayType(1); //支付类型 ，微信1 baseMapper.insert(order); //返回订单号 return order.getOrderNo(); &#125;&#125; 查询订单（后端）12345678// 根据订单id查询订单信息@GetMapping(&quot;getOrderInfo/&#123;orderNo&#125;&quot;)public R getOrderInfo(@PathVariable String orderNo) &#123; QueryWrapper&lt;Order&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_no&quot;, orderNo); Order order = orderService.getOne(wrapper); return R.ok().data(&quot;orderInfo&quot;, order);&#125; 生成订单（前端）api123456789101112131415161718import request from &#x27;@/utils/request&#x27;export default &#123; // 生成订单 createOrder(courseId) &#123; return request(&#123; url: `/eduorder/order/createOrder/$&#123;courseId&#125;`, method: &#x27;get&#x27;, &#125;) &#125;, // 查询订单信息 getOrderInfo(orderNo) &#123; return request(&#123; url: `/eduorder/order/getOrderInfo/$&#123;orderNo&#125;`, method: &#x27;get&#x27;, &#125;) &#125;&#125; 课程详情页面跳转123456789methods: &#123; // 创建订单 createOrder() &#123; orderApi.createOrder(this.courseId).then(result =&gt; &#123; // 返回订单号 跳转页面 this.$router.push(&#123; path: &#x27;/order/&#x27; + result.data.data.orderNo &#125;) &#125;) &#125;&#125; 动态路由页面模板 创建一个动态路由页面，_ono.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;div class=&quot;Page Confirm&quot;&gt; &lt;div class=&quot;Title&quot;&gt; &lt;h1 class=&quot;fl f18&quot;&gt;订单确认&lt;/h1&gt; &lt;img src=&quot;~/assets/img/cart_setp2.png&quot; class=&quot;fr&quot; /&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;form name=&quot;flowForm&quot; id=&quot;flowForm&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;table class=&quot;GoodList&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th class=&quot;name&quot;&gt;商品&lt;/th&gt; &lt;th class=&quot;price&quot;&gt;原价&lt;/th&gt; &lt;th class=&quot;priceNew&quot;&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody&gt; &lt;!-- &lt;tr&gt; &lt;td colspan=&quot;3&quot; class=&quot;Title red f18 fb&quot;&gt;&lt;p&gt;限时折扣&lt;/p&gt;&lt;/td&gt; &lt;/tr&gt; --&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot; class=&quot;teacher&quot;&gt;讲师：&#123;&#123; order.teacherName &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;good&quot;&gt; &lt;td class=&quot;name First&quot;&gt; &lt;a target=&quot;_blank&quot; :href=&quot;&#x27;https://localhost:3000/course/&#x27; + order.courseId&quot; &gt; &lt;img :src=&quot;order.courseCover&quot; /&gt;&lt;/a&gt; &lt;div class=&quot;goodInfo&quot;&gt; &lt;input type=&quot;hidden&quot; class=&quot;ids ids_14502&quot; value=&quot;14502&quot; /&gt; &lt;a target=&quot;_blank&quot; :href=&quot;&#x27;https://localhost:3000/course/&#x27; + order.courseId&quot; &gt;&#123;&#123; order.courseTitle &#125;&#125;&lt;/a &gt; &lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;price&quot;&gt; &lt;p&gt; ￥&lt;strong&gt;&#123;&#123; order.totalFee &#125;&#125;&lt;/strong&gt; &lt;/p&gt; &lt;!-- &lt;span class=&quot;discName red&quot;&gt;限时8折&lt;/span&gt; --&gt; &lt;/td&gt; &lt;td class=&quot;red priceNew Last&quot;&gt; ￥&lt;strong&gt;&#123;&#123; order.totalFee &#125;&#125;&lt;/strong&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;Billing tr&quot; colspan=&quot;3&quot;&gt; &lt;div class=&quot;tr&quot;&gt; &lt;p&gt; 共 &lt;strong class=&quot;red&quot;&gt;1&lt;/strong&gt; 件商品，合计&lt;span class=&quot;red f20&quot; &gt;￥&lt;strong&gt;&#123;&#123; order.totalFee &#125;&#125;&lt;/strong&gt;&lt;/span &gt; &lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;Finish&quot;&gt; &lt;div class=&quot;fr&quot; id=&quot;AgreeDiv&quot;&gt; &lt;label for=&quot;Agree&quot; &gt;&lt;p class=&quot;on&quot;&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;我已阅读并同意&lt;a href=&quot;javascript:&quot; target=&quot;_blank&quot; &gt;《谷粒学院购买协议》&lt;/a &gt; &lt;/p&gt;&lt;/label &gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div class=&quot;Main fl&quot;&gt; &lt;div class=&quot;fl&quot;&gt; &lt;a :href=&quot;&#x27;/course/&#x27; + order.courseId&quot;&gt;返回课程详情页&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;fr&quot;&gt; &lt;p&gt; 共 &lt;strong class=&quot;red&quot;&gt;1&lt;/strong&gt; 件商品，合计&lt;span class=&quot;red f20&quot; &gt;￥&lt;strong id=&quot;AllPrice&quot;&gt;&#123;&#123; order.totalFee &#125;&#125;&lt;/strong&gt;&lt;/span &gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;input name=&quot;score&quot; value=&quot;0&quot; type=&quot;hidden&quot; id=&quot;usedScore&quot; /&gt; &lt;button class=&quot;fr redb&quot; type=&quot;button&quot; id=&quot;submitPay&quot; @click=&quot;toPay()&quot;&gt; 去支付 &lt;/button&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ordersApi from &#x27;@/api/order&#x27; export default &#123; methods: &#123;&#125; &#125;&lt;/script&gt; 方法12345678asyncData(&#123; params, error &#125;) &#123; return ordersApi.getOrderInfo(params.ono) .then(response =&gt; &#123; return &#123; orderInfo: response.data.data.orderInfo &#125; &#125;) &#125;, 测试 这里一直在调试，发现我的courseInfo对象为null，debug了一会发现是courseController当中的被远程调用的方法中，返回的对象vo类内的值不一致，导致BeanUtils赋值的时候赋值不了，然后改一下重启就行 生成支付二维码（后端） 好家伙又要企业认证 controller1234567891011121314@RestController@RequestMapping(&quot;/eduorder/pay-log&quot;)public class PayLogController &#123; @Autowired private PayLogService logService; // 生成微信支付二维码 @GetMapping(&quot;createNative/&#123;orderNo&#125;&quot;) public R createNative(@PathVariable String orderNo) &#123; Map&lt;String, Object&gt; map = logService.createNative(orderNo); return R.ok().data(map); &#125; &#125; service主要业务逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class PayLogServiceImpl extends ServiceImpl&lt;PayLogMapper, PayLog&gt; implements PayLogService &#123; @Autowired private OrderService orderService; // 生成微信支付二维码 @Override public Map&lt;String, Object&gt; createNative(String orderNo) &#123; try &#123; // 根据订单号查询订单信息 QueryWrapper&lt;Order&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_no&quot;, orderNo); Order order = orderService.getOne(wrapper); // 使用map设置生成二维码所需的参数 Map&lt;String, String&gt; m = new HashMap(); m.put(&quot;appid&quot;, &quot;wx74862e0dfcf69954&quot;); m.put(&quot;mch_id&quot;, &quot;1558950191&quot;); m.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); m.put(&quot;body&quot;, order.getCourseTitle()); //课程标题 m.put(&quot;out_trade_no&quot;, orderNo); //订单号 m.put(&quot;total_fee&quot;, order.getTotalFee().multiply(new BigDecimal(&quot;100&quot;)).longValue() + &quot;&quot;); m.put(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;); m.put(&quot;notify_url&quot;, &quot;http://guli.shop/api/order/weixinPay/weixinNotify\\n&quot;); m.put(&quot;trade_type&quot;, &quot;NATIVE&quot;); // 发送httpclient请求，传递参数xml格式 HttpClient client = new HttpClient(&quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;); //设置xml格式的参数 client.setXmlParam(WXPayUtil.generateSignedXml(m, &quot;T6m9iK73b0kn9g5v426MKfHQH7X8rKwb&quot;)); client.setHttps(true); //执行post请求发送 client.post(); // 得到请求返回结果 String xml = client.getContent(); Map&lt;String, String&gt; resultMap = WXPayUtil.xmlToMap(xml); //最终返回数据 的封装 Map map = new HashMap(); map.put(&quot;out_trade_no&quot;, orderNo); map.put(&quot;course_id&quot;, order.getCourseId()); map.put(&quot;total_fee&quot;, order.getTotalFee()); map.put(&quot;result_code&quot;, resultMap.get(&quot;result_code&quot;)); //返回二维码操作状态码 map.put(&quot;code_url&quot;, resultMap.get(&quot;code_url&quot;)); //二维码地址 return map; &#125; catch (Exception e) &#123; throw new GuliException(20001, &quot;生成二维码失败&quot;); &#125; &#125;&#125; 查询支付状态（后端）controller123456789101112131415// 查询订单支付状态@GetMapping(&quot;getPayStatus/&#123;orderNo&#125;&quot;)public R getPayStatus(@PathVariable String orderNo) &#123; Map&lt;String, String&gt; map = logService.getPayStatus(orderNo); if (map == null) &#123; return R.error().message(&quot;支付出错了&quot;); &#125; if (map.get(&quot;trade_state&quot;).equals(&quot;SUCCESS&quot;)) &#123; logService.updateOrderStatus(map); return R.ok(); &#125; // 特定返回码，前端有拦截器判断 return R.ok().code(25000).message(&quot;支付中……&quot;);&#125; service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 查询订单支付状态@Overridepublic Map&lt;String, String&gt; getPayStatus(String orderNo) &#123; try &#123; //1、封装参数 Map&lt;String, String&gt; m = new HashMap&lt;&gt;(); m.put(&quot;appid&quot;, &quot;wx74862e0dfcf69954&quot;); m.put(&quot;mch_id&quot;, &quot;1558950191&quot;); m.put(&quot;out_trade_no&quot;, orderNo); m.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); //2 发送httpclient HttpClient client = new HttpClient(&quot;https://api.mch.weixin.qq.com/pay/orderquery&quot;); client.setXmlParam(WXPayUtil.generateSignedXml(m, &quot;T6m9iK73b0kn9g5v426MKfHQH7X8rKwb&quot;)); client.setHttps(true); client.post(); //3 得到请求返回内容 String xml = client.getContent(); //6、转成Map再返回 return WXPayUtil.xmlToMap(xml); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125;//添加支付记录和更新订单状态@Overridepublic void updateOrderStatus(Map&lt;String, String&gt; map) &#123; //从map获取订单号 String orderNo = map.get(&quot;out_trade_no&quot;); //根据订单号查询订单信息 QueryWrapper&lt;Order&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;order_no&quot;, orderNo); Order order = orderService.getOne(wrapper); //更新订单表订单状态 if (order.getStatus().intValue() == 1) &#123; // 已经支付过了 return; &#125; order.setStatus(1);//1代表已经支付 orderService.updateById(order); //向支付表添加支付记录 PayLog payLog = new PayLog(); payLog.setOrderNo(orderNo); //订单号 payLog.setPayTime(new Date()); //订单完成时间 payLog.setPayType(1);//支付类型 1微信 payLog.setTotalFee(order.getTotalFee());//总金额(分) payLog.setTradeState(map.get(&quot;trade_state&quot;));//支付状态 payLog.setTransactionId(map.get(&quot;transaction_id&quot;)); //流水号 payLog.setAttr(JSONObject.toJSONString(map)); baseMapper.insert(payLog);&#125; 支付（前端）api1234567891011121314// 生成二维码 createNative(orderNo) &#123; return request(&#123; url: `/eduorder/paylog/createNative/$&#123;orderNo&#125;`, method: &#x27;get&#x27;, &#125;) &#125;, // 查询订单状态 getPayStatus(orderNo) &#123; return request(&#123; url: `/eduorder/paylog/getPayStatus/$&#123;orderNo&#125;`, method: &#x27;get&#x27;, &#125;) &#125;, 跳转至页面方法1234// 去支付toPay() &#123; this.$router.push(&#123; path: &#x27;/pay/&#x27; + this.orderInfo.orderNo &#125;)&#125; 动态路由模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class=&quot;cart py-container&quot;&gt; &lt;!--主内容--&gt; &lt;div class=&quot;checkout py-container pay&quot;&gt; &lt;div class=&quot;checkout-tit&quot;&gt; &lt;h4 class=&quot;fl tit-txt&quot;&gt; &lt;span class=&quot;success-icon&quot;&gt;&lt;/span &gt;&lt;span class=&quot;success-info&quot; &gt;订单提交成功，请您及时付款！订单号：&#123;&#123; payObj.out_trade_no &#125;&#125;&lt;/span &gt; &lt;/h4&gt; &lt;span class=&quot;fr&quot; &gt;&lt;em class=&quot;sui-lead&quot;&gt;应付金额：&lt;/em &gt;&lt;em class=&quot;orange money&quot;&gt;￥&#123;&#123; payObj.total_fee &#125;&#125;&lt;/em&gt;&lt;/span &gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;checkout-steps&quot;&gt; &lt;div class=&quot;fl weixin&quot;&gt;微信支付&lt;/div&gt; &lt;div class=&quot;fl sao&quot;&gt; &lt;p class=&quot;red&quot;&gt;请使用微信扫一扫。&lt;/p&gt; &lt;div class=&quot;fl code&quot;&gt; &lt;!-- &lt;img id=&quot;qrious&quot; src=&quot;~/assets/img/erweima.png&quot; alt=&quot;&quot;&gt; --&gt; &lt;!-- &lt;qriously value=&quot;weixin://wxpay/bizpayurl?pr=R7tnDpZ&quot; :size=&quot;338&quot;/&gt; --&gt; &lt;qriously :value=&quot;payObj.code_url&quot; :size=&quot;338&quot; /&gt; &lt;div class=&quot;saosao&quot;&gt; &lt;p&gt;请使用微信扫一扫&lt;/p&gt; &lt;p&gt;扫描二维码支付&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;!-- &lt;p&gt;&lt;a href=&quot;pay.html&quot; target=&quot;_blank&quot;&gt;&gt; 其他支付方式&lt;/a&gt;&lt;/p&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import orderApi from &#x27;@/api/order&#x27; export default &#123; asyncData(&#123; params, error &#125;) &#123; return orderApi.createNatvie(params.pid).then(response =&gt; &#123; return &#123; payObj: response.data.data &#125; &#125;) &#125;, data() &#123; return &#123; timer1: &#x27;&#x27; &#125; &#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 注意这里需要安装vue-qriously组件 response拦截器12345678910111213141516171819202122232425262728// http response 拦截器service.interceptors.response.use( response =&gt; &#123; //debugger if (response.data.code == 28004) &#123; console.log(&quot;response.data.resultCode是28004&quot;) // 返回 错误代码-1 清除ticket信息并跳转到登录页面 //debugger window.location.href=&quot;/login&quot; return &#125;else&#123; if (response.data.code !== 20000) &#123; //25000：订单支付中，不做任何提示 if(response.data.code != 25000) &#123; Message(&#123; message: response.data.message || &#x27;error&#x27;, type: &#x27;error&#x27;, duration: 5 * 1000 &#125;) &#125; &#125; else &#123; return response; &#125; &#125; &#125;, error =&gt; &#123; return Promise.reject(error.response) // 返回接口返回的错误信息&#125;); 调用方法 这里需要用到response拦截器，后端支付中的返回码为25000，需要根据返回码判断是否支付成功 1234567891011121314151617181920212223242526272829data() &#123; return &#123; timer1: &#x27;&#x27; &#125;&#125;,// 注意这里不适用created，因为使用了异步初始化数据，mounted在页面渲染完成后执行mounted() &#123; this.timer1 = setInterval(() =&gt; &#123; this.getPayStatus(this.payObj.out_trade_no) &#125;, 3000)&#125;,methods: &#123; // 每隔一段时间查询订单状态 getPayStatus(orderNo) &#123; orderApi.getPayStatus(this.orderNo).then(result =&gt; &#123; if (result.data.success) &#123; // 清除定时器 clearInterval(this.timer1) // 提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;支付成功!&#x27; &#125;) // 跳转至课程详情页面 this.$router.push(&#123; path: &#x27;/course/&#x27; + this.payObj.course_id &#125;) &#125; &#125;) &#125;&#125; 测试 测了一次，没跳转但是状态改了，懒得测了，不想花钱 debug了一下，发现后端没啥问题，也执行了，付钱了之后也返回了R.ok，但是前端就是显示result为undefined，不理解 课程信息显示完善 免费和不免费，是否购买等页面显示需要区别 查询用户购买课程信息方法1234567891011// 根绝用户id和课程id查询 用户课程支付情况@GetMapping(&quot;getUserCourseStatus/&#123;cid&#125;/&#123;uid&#125;&quot;)public boolean getUserCourseStatus(@PathVariable String cid, @PathVariable String uid) &#123; QueryWrapper&lt;Order&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;course_id&quot;, cid); wrapper.eq(&quot;member_id&quot;, uid); wrapper.eq(&quot;status&quot;, 1); int count = orderService.count(wrapper); // 已经支付完成 return count &gt; 0;&#125; 需要修改课程详情接口的返回值，加上课程的支付状态（远程调用上述方法） 配置接口123456789// fallback = &quot;实现类的class&quot;，熔断器@FeignClient(name = &quot;service-order&quot;)// 调用服务（服务名），这里的服务名要和对应服务的配置文件中的spring.application.name对应@Componentpublic interface orderClient &#123; // 根绝用户id和课程id查询 用户课程支付情况 @GetMapping(&quot;/eduorder/order/getUserCourseStatus/&#123;cid&#125;/&#123;uid&#125;&quot;) public boolean getUserCourseStatus(@PathVariable(&quot;cid&quot;) String cid, @PathVariable(&quot;uid&quot;) String uid);&#125; 远程调用123456789101112131415161718@RestController@CrossOrigin@RequestMapping(&quot;/eduservice/coursefront&quot;)public class CourseController &#123; @Autowired private EduCourseService courseService; @Autowired private OrderClient orderClient; // 课程详情信息+课程支付状态（远程调用） @GetMapping(&quot;getCourseInfo/&#123;courseId&#125;&quot;) public R getCourseInfo(@PathVariable String courseId, HttpServletRequest request) &#123; CourseFrontInfoVo courseInfo = courseService.getBaseCourseInfo(courseId); List&lt;ChapterVo&gt; chapterList = chapterService.getChapterVideoByCourseId(courseId); // 根据课程用户id查询订单状态 boolean status = orderClient.getUserCourseStatus(courseId, JwtUtils.getMemberIdByJwtToken(request)); return R.ok().data(&quot;courseInfo&quot;, courseInfo).data(&quot;chapterList&quot;, chapterList).data(&quot;isBuy&quot;, status); &#125;&#125; 前端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div id=&quot;aCoursesList&quot; class=&quot;bg-fa of&quot;&gt; &lt;section class=&quot;c-attr-mt&quot; v-if=&quot;isBuy || Number(courseInfo.price === 0)&quot; &gt; &lt;a href=&quot;#&quot; title=&quot;立即观看&quot; class=&quot;comm-btn c-btn-3&quot; @click=&quot;createOrder()&quot; &gt;立即观看&lt;/a &gt; &lt;/section&gt; &lt;section class=&quot;c-attr-mt&quot; v-else&gt; &lt;a href=&quot;#&quot; title=&quot;立即购买&quot; class=&quot;comm-btn c-btn-3&quot; @click=&quot;createOrder()&quot; &gt;立即购买&lt;/a &gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import courseApi from &#x27;@/api/course&#x27; import orderApi from &#x27;@/api/order&#x27; export default &#123; // asyncData(&#123; params, error &#125;) &#123; // return courseApi.getCourseInfo(params.id).then(result =&gt; &#123; // return &#123; // courseInfo: result.data.data.courseInfo, // chapterList: result.data.data.chapterList, // courseId: params.id // &#125; // &#125;) // &#125;, asyncData(&#123; params, error &#125;) &#123; return &#123; courseId: params.id &#125; &#125;, data() &#123; return &#123; courseInfo: &#123;&#125;, chapterList: [], isBuy: false &#125; &#125;, created() &#123; // 这里不适用异步调用，而是created this.initCourseInfo() &#125;, methods: &#123; // 查询课程详情信息 initCourseInfo() &#123; courseApi.getCourseInfo(this.courseId).then(result =&gt; &#123; (this.courseInfo = result.data.data.courseInfo), (this.chapterList = result.data.data.chapterList), (this.isBuy = result.data.data.isBuy) &#125;) &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战5","slug":"【项目笔记】在线教育项目实战5","date":"2021-09-28T09:24:35.305Z","updated":"2021-10-02T04:40:15.713Z","comments":true,"path":"2021/09/28/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-5/","link":"","permalink":"http://example.com/2021/09/28/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-5/","excerpt":"","text":"这里开始是前台部分 搭建项目前台环境 使用服务端渲染技术NuxtJS框架 ![02 搭建项目前台环境（nuxt）](https://gitee.com/ReRia/images/raw/master/img/02 搭建项目前台环境（nuxt）.png) 搭建NuxtJS 先赋值template至工作区 修改.eslintrc.js（复制后台的即可） 修改package.json，必须修改其中的name,version,decription,author等 修改nuxt.config.js 安装依赖npm install 测试运行npm run dev NUXT目录结构 资源目录 assets用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。 组件目录 components用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。 布局目录 layouts用于组织应用的布局组件。 default.vue：设置头尾信息 页面目录 pages用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。 插件目录 plugins用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。 nuxt.config.js 文件nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。 引入基础资源和默认头尾视图 Nuxt本身基于vue，但是没有引入element-ui，所以需要引入 这里还引入了其他需要的资源，直接cv即可 assets layout -&gt; default.vue pages -&gt; index.vue default.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;template&gt; &lt;div class=&quot;in-wrap&quot;&gt; &lt;!-- 公共头引入 --&gt; &lt;header id=&quot;header&quot;&gt; &lt;section class=&quot;container&quot;&gt; &lt;h1 id=&quot;logo&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;谷粒学院&quot;&gt; &lt;img src=&quot;~/assets/img/logo.png&quot; width=&quot;100%&quot; alt=&quot;谷粒学院&quot; /&gt; &lt;/a&gt; &lt;/h1&gt; &lt;div class=&quot;h-r-nsl&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;!-- 固定路由 --&gt; &lt;router-link to=&quot;/&quot; tag=&quot;li&quot; active-class=&quot;current&quot; exact&gt; &lt;a&gt;首页&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/course&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;课程&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/teacher&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;名师&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/article&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;文章&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/qa&quot; tag=&quot;li&quot; active-class=&quot;current&quot;&gt; &lt;a&gt;问答&lt;/a&gt; &lt;/router-link&gt; &lt;/ul&gt; &lt;!-- / nav --&gt; &lt;ul class=&quot;h-r-login&quot;&gt; &lt;li v-if=&quot;!loginInfo.id&quot; id=&quot;no-login&quot;&gt; &lt;a href=&quot;/login&quot; title=&quot;登录&quot;&gt; &lt;em class=&quot;icon18 login-icon&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;span class=&quot;vam ml5&quot;&gt;登录&lt;/span&gt; &lt;/a&gt; | &lt;a href=&quot;/register&quot; title=&quot;注册&quot;&gt; &lt;span class=&quot;vam ml5&quot;&gt;注册&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li v-if=&quot;loginInfo.id&quot; id=&quot;is-login-one&quot; class=&quot;mr10&quot;&gt; &lt;a id=&quot;headerMsgCountId&quot; href=&quot;#&quot; title=&quot;消息&quot;&gt; &lt;em class=&quot;icon18 news-icon&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;/a&gt; &lt;q class=&quot;red-point&quot; style=&quot;display: none&quot;&gt;&amp;nbsp;&lt;/q&gt; &lt;/li&gt; &lt;li v-if=&quot;loginInfo.id&quot; id=&quot;is-login-two&quot; class=&quot;h-r-user&quot;&gt; &lt;a href=&quot;/ucenter&quot; title&gt; &lt;img :src=&quot;loginInfo.avatar&quot; width=&quot;30&quot; height=&quot;30&quot; class=&quot;vam picImg&quot; alt /&gt; &lt;span id=&quot;userName&quot; class=&quot;vam disIb&quot;&gt;&#123;&#123; loginInfo.nickname &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;javascript:void(0);&quot; title=&quot;退出&quot; @click=&quot;logout()&quot; class=&quot;ml5&quot; &gt;退出&lt;/a &gt; &lt;/li&gt; &lt;!-- /未登录显示第1 li；登录后显示第2，3 li --&gt; &lt;/ul&gt; &lt;aside class=&quot;h-r-search&quot;&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;label class=&quot;h-r-s-box&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入你想学的课程&quot; name=&quot;queryCourse.courseName&quot; value /&gt; &lt;button type=&quot;submit&quot; class=&quot;s-btn&quot;&gt; &lt;em class=&quot;icon18&quot;&gt;&amp;nbsp;&lt;/em&gt; &lt;/button&gt; &lt;/label&gt; &lt;/form&gt; &lt;/aside&gt; &lt;/div&gt; &lt;aside class=&quot;mw-nav-btn&quot;&gt; &lt;div class=&quot;mw-nav-icon&quot;&gt;&lt;/div&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;/header&gt; &lt;!-- /公共头引入 --&gt; &lt;nuxt /&gt; &lt;!-- 公共底引入 --&gt; &lt;footer id=&quot;footer&quot;&gt; &lt;section class=&quot;container&quot;&gt; &lt;div class&gt; &lt;h4 class=&quot;hLh30&quot;&gt; &lt;span class=&quot;fsize18 f-fM c-999&quot;&gt;友情链接&lt;/span&gt; &lt;/h4&gt; &lt;ul class=&quot;of flink-list&quot;&gt; &lt;li&gt; &lt;a href=&quot;http://www.atguigu.com/&quot; title=&quot;尚硅谷&quot; target=&quot;_blank&quot; &gt;尚硅谷&lt;/a &gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;b-foot&quot;&gt; &lt;section class=&quot;fl col-7&quot;&gt; &lt;section class=&quot;mr20&quot;&gt; &lt;section class=&quot;b-f-link&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;关于我们&quot; target=&quot;_blank&quot;&gt;关于我们&lt;/a&gt;| &lt;a href=&quot;#&quot; title=&quot;联系我们&quot; target=&quot;_blank&quot;&gt;联系我们&lt;/a&gt;| &lt;a href=&quot;#&quot; title=&quot;帮助中心&quot; target=&quot;_blank&quot;&gt;帮助中心&lt;/a&gt;| &lt;a href=&quot;#&quot; title=&quot;资源下载&quot; target=&quot;_blank&quot;&gt;资源下载&lt;/a&gt;| &lt;span&gt;服务热线：010-56253825(北京) 0755-85293825(深圳)&lt;/span&gt; &lt;span&gt;Email：info@atguigu.com&lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;b-f-link mt10&quot;&gt; &lt;span&gt;©2018课程版权均归谷粒学院所有 京ICP备17055252号&lt;/span&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;aside class=&quot;fl col-3 tac mt15&quot;&gt; &lt;section class=&quot;gf-tx&quot;&gt; &lt;span&gt; &lt;img src=&quot;~/assets/img/wx-icon.png&quot; alt /&gt; &lt;/span&gt; &lt;/section&gt; &lt;section class=&quot;gf-tx&quot;&gt; &lt;span&gt; &lt;img src=&quot;~/assets/img/wb-icon.png&quot; alt /&gt; &lt;/span&gt; &lt;/section&gt; &lt;/aside&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;/footer&gt; &lt;!-- /公共底引入 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#x27;~/assets/css/reset.css&#x27; import &#x27;~/assets/css/theme.css&#x27; import &#x27;~/assets/css/global.css&#x27; import &#x27;~/assets/css/web.css&#x27; export default &#123; &#125;&lt;/script&gt; index.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;template&gt; &lt;div&gt; &lt;!-- 幻灯片 开始 --&gt; &lt;div v-swiper:mySwiper=&quot;swiperOption&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div v-for=&quot;banner in bannerList&quot; :key=&quot;banner.id&quot; class=&quot;swiper-slide&quot; style=&quot;background: #040b1b&quot; &gt; &lt;a target=&quot;_blank&quot; :href=&quot;banner.linkUrl&quot;&gt; &lt;img :src=&quot;banner.imageUrl&quot; :alt=&quot;banner.title&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination swiper-pagination-white&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev swiper-button-white&quot; slot=&quot;button-prev&quot; &gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next swiper-button-white&quot; slot=&quot;button-next&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 幻灯片 结束 --&gt; &lt;div id=&quot;aCoursesList&quot;&gt; &lt;!-- 网校课程 开始 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;热门课程&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;comm-course-list&quot;&gt; &lt;ul class=&quot;of&quot; id=&quot;bna&quot;&gt; &lt;li v-for=&quot;course in courseList&quot; :key=&quot;course.id&quot;&gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;course-img&quot;&gt; &lt;img :src=&quot;course.cover&quot; class=&quot;img-responsive&quot; :alt=&quot;course.title&quot; /&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;开始学习&quot; class=&quot;comm-btn c-btn-1&quot; &gt;开始学习&lt;/a &gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a href=&quot;#&quot; :title=&quot;course.title&quot; class=&quot;course-title fsize18 c-333&quot; &gt;&#123;&#123; course.title &#125;&#125;&lt;/a &gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span class=&quot;fr jgTag bg-green&quot; v-if=&quot;Number(course.price) === 0&quot; &gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot;&gt;9634人学习&lt;/i&gt; | &lt;i class=&quot;c-999 f-fA&quot;&gt;9634评论&lt;/i&gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;section class=&quot;tac pt20&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;全部课程&quot; class=&quot;comm-btn c-btn-2&quot;&gt;全部课程&lt;/a&gt; &lt;/section&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /网校课程 结束 --&gt; &lt;!-- 网校名师 开始 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;名师大咖&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;i-teacher-list&quot;&gt; &lt;ul class=&quot;of&quot;&gt; &lt;li v-for=&quot;teacher in teacherList&quot; :key=&quot;teacher.id&quot;&gt; &lt;section class=&quot;i-teach-wrap&quot;&gt; &lt;div class=&quot;i-teach-pic&quot;&gt; &lt;a href=&quot;/teacher/1&quot; :title=&quot;teacher.name&quot;&gt; &lt;img :alt=&quot;teacher.name&quot; :src=&quot;teacher.avatar&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mt10 hLh30 txtOf tac&quot;&gt; &lt;a href=&quot;/teacher/1&quot; :title=&quot;teacher.name&quot; class=&quot;fsize18 c-666&quot; &gt;&#123;&#123; teacher.name &#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;hLh30 txtOf tac&quot;&gt; &lt;span class=&quot;fsize14 c-999&quot;&gt;&#123;&#123; teacher.career &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;mt15 i-q-txt&quot;&gt; &lt;p class=&quot;c-999 f-fA&quot;&gt; &#123;&#123; teacher.intro &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;section class=&quot;tac pt20&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;全部讲师&quot; class=&quot;comm-btn c-btn-2&quot;&gt;全部讲师&lt;/a&gt; &lt;/section&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /网校名师 结束 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 轮播图组件 本项目需要用到一个轮播图组件awesome-swiper（这里使用3.1.3版本） 安装 npm install vue-awesome-swiper@3.1.3 配置 在 plugins 文件夹下新建文件 nuxt-swiper-plugin.js 123import Vue from &#x27;vue&#x27;import VueAwesomeSwiper from &#x27;vue-awesome-swiper/dist/ssr&#x27;Vue.use(VueAwesomeSwiper) 在 nuxt.config.js 文件中配置插件 12345678910module.exports = &#123; // some nuxt config... // awesome-swiper插件配置引入 plugins: [ &#123; src: &#x27;~/plugins/nuxt-swiper-plugin.js&#x27;, ssr: false &#125; ], css: [ &#x27;swiper/dist/css/swiper.css&#x27; ]&#125; axios依赖与封装 npm install axios 创建utils -&gt; request.js 注意这里的baseURL要与nginx对应 1234567import axios from &#x27;axios&#x27;// 创建axios实例const service = axios.create(&#123; baseURL: &#x27;http://localhost:9001&#x27;, // api的base_url timeout: 20000 // 请求超时时间&#125;)export default service element-ui安装 npm install element-ui 配置 plugins -&gt; nuxt-swiper-plugin.js 12345678import Vue from &#x27;vue&#x27;import VueAwesomeSwiper from &#x27;vue-awesome-swiper/dist/ssr&#x27;import VueQriously from &#x27;vue-qriously&#x27;import ElementUI from &#x27;element-ui&#x27; //element-ui的全部组件import &#x27;element-ui/lib/theme-chalk/index.css&#x27;//element-ui的cssVue.use(ElementUI) //使用elementUIVue.use(VueQriously)Vue.use(VueAwesomeSwiper) 测试 必看注意，直接启动的话eslint语法检查十分严格，类似于空格是2个就不能是4个，所以要把严格检查关闭 解决vue/cli3.0 语法验证规则 ESLint: Expected indentation of 2 spaces but found 4. (indent) - 走看看 (zoukankan.com) 仔细参考上述文章内容，注意两个步骤都要执行才行（弄了我十几分钟有点烦躁，好在解决了） 首页基础搭建讲师和课程视图模板搭建固定路由 注意default.js中设置了头导航的固定路由，所以需要在pages文件夹下创建对应的视图 注意其中的router-link（即路由导航），其中的to对应的地址就是视图的地址，值为文件夹的路径，to会自动找到pages文件夹下对应名字的文件夹中的index.vue 按照这个思路创建对应视图即可，然后复制资料中已经有的视图模板 动态路由 动态路由编写有一定的规范 例如需要根据id查询一条记录，需要在对应pages的文件夹下创建_id.vue文件，（必须是以下划线开头，参数名为下划线后面的文件名） 创建视图 根据上述条件创建即可，然后内容模板cv即可 当前项目结构 后端环境搭建创建子模块 service_cms 创建并编写配置文件application.properties 注意这里的DataSource配置，如果不对可能会报springboot找不到bean的错误 123456789101112131415161718192021222324252627# 服务端口server.port=8004# 服务名spring.application.name=service-cms# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/atguigu/educms/mapper/xml/*.xmlspring.redis.host=192.168.44.132spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle=5spring.redis.lettuce.pool.min-idle=0#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 这里记得去nginx.conf里配置一下 创建数据库表 导入资料的sql文件即可 编写启动类123456789@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@MapperScan(&quot;com.atguigu.educms.mapper&quot;)@EnableDiscoveryClient // nacos注册public class CmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CmsApplication.class, args); &#125;&#125; 代码生成器 老样子改一下就行 生成之后跨域注释加一下、mapperscan加一下、配置文件中扫描mapper.xml路径加一下 一些实体类字段的注释也要加一下，比如说自动添加和逻辑删除 123@MapperScan(&quot;com.atguigu.educms.mapper&quot;)public class CmsApplication &#123;&#125; 1234@CrossOriginpublic class CrmBannerController &#123;&#125; 12#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/atguigu/educms/mapper/xml/*.xml 当前项目结构 首页轮播图（后端） 后台应该也有轮播图的管理模块，所以需要两个bannerController 编写BannerAdminController 用于后台的banner管理接口，TODO：前端页面自己写（我选择不写使用swagger测试嘿嘿😙） 1234567891011121314151617181920212223242526272829303132333435363738@RestController@RequestMapping(&quot;/educms/banneradmin&quot;)@CrossOriginpublic class BannerAdminController &#123; @Autowired private CrmBannerService bannerService; // 分页查询 @GetMapping(&quot;pageBanner/&#123;pageNo&#125;/&#123;limit&#125;&quot;) public R pageBanner(@PathVariable Long limit, @PathVariable Long pageNo) &#123; Page&lt;CrmBanner&gt; pageBanner = new Page&lt;&gt;(pageNo, limit); bannerService.page(pageBanner, null); return R.ok().data(&quot;records&quot;, pageBanner.getRecords()).data(&quot;total&quot;, pageBanner.getTotal()); &#125; //2 添加banner @PostMapping(&quot;addBanner&quot;) public R addBanner(@RequestBody CrmBanner crmBanner) &#123; bannerService.save(crmBanner); return R.ok(); &#125; @ApiOperation(value = &quot;获取Banner&quot;) @GetMapping(&quot;get/&#123;id&#125;&quot;) public R get(@PathVariable String id) &#123; CrmBanner banner = bannerService.getById(id); return R.ok().data(&quot;item&quot;, banner); &#125; @ApiOperation(value = &quot;修改Banner&quot;) @PutMapping(&quot;update&quot;) public R updateById(@RequestBody CrmBanner banner) &#123; bannerService.updateById(banner); return R.ok(); &#125; @ApiOperation(value = &quot;删除Banner&quot;) @DeleteMapping(&quot;remove/&#123;id&#125;&quot;) public R remove(@PathVariable String id) &#123; bannerService.removeById(id); return R.ok(); &#125;&#125; 编写BannerFrontController 用于前台的banner接口，主要用于显示banner 12345678910111213@RestController@RequestMapping(&quot;/educms/bannerfront&quot;)@CrossOriginpublic class BannerFrontController &#123; @Autowired private CrmBannerService bannerService; //查询banner信息 @GetMapping(&quot;getBannerList&quot;) public R getBannerList() &#123; List&lt;CrmBanner&gt; list = bannerService.selectAllBanner(); return R.ok().data(&quot;list&quot;, list); &#125;&#125; 编写Service 这里自己写了个service，结果啥也没实现，纯属脱裤子放屁，我改了 我发现我错了，我应该看完整个视频才说话，这个是为了后面的Redis做准备的 写Mapper里最好（弹幕：感谢这段代码，昨天写了，今天老板让我走） 123456789101112131415@Servicepublic class CrmBannerServiceImpl extends ServiceImpl&lt;CrmBannerMapper, CrmBanner&gt; implements CrmBannerService &#123; // 查询所有banner @Override public List&lt;CrmBanner&gt; selectAllBanner() &#123; // 根据id降序排序，显示排序后的前两条记录 QueryWrapper&lt;CrmBanner&gt; wrapper = new QueryWrapper&lt;&gt;(); // 设置排序条件 wrapper.orderByDesc(&quot;id&quot;); // 设置显示数量，last拼接sql语句 wrapper.last(&quot;limit 2&quot;); List&lt;CrmBanner&gt; crmBanners = baseMapper.selectList(wrapper); return crmBanners; &#125;&#125; 首页热门课程和名师（后端） 注意这里，controller这些又写到service_edu模块中了 编写Mapper 需求：根据id进行降序排序（或者根据表中专门的热度排序），显示排序之后的前8条数据 EduTeacherMapper123456&lt;select id=&quot;selectIndexList&quot; resultType=&quot;com.atguigu.eduservice.entity.EduTeacher&quot;&gt; select * from edu_teacher order by id desc limit 4&lt;/select&gt; EduCourseMapper123456&lt;select id=&quot;selectIndexList&quot; resultType=&quot;com.atguigu.eduservice.entity.EduCourse&quot;&gt; select * from edu_course order by id desc limit 8&lt;/select&gt; 编写service 就直接调用baseMapper中的接口即可 编写controller123456789101112131415161718@RestController@RequestMapping(&quot;/eduservice/index&quot;)@CrossOriginpublic class IndexController &#123; @Autowired private EduCourseService courseService; @Autowired private EduTeacherService teacherService; // 查询热门课程和讲师 @GetMapping(&quot;index&quot;) public R getIndex() &#123; List&lt;EduCourse&gt; courseList = courseService.getIndexList(); List&lt;EduTeacher&gt; teacherList = teacherService.getIndexList(); return R.ok().data(&quot;courseList&quot;, courseList).data(&quot;teacherList&quot;, teacherList); &#125;&#125; 首页轮播图和热门讲师课程（前端）API api -&gt; banner.js api -&gt; index.js banner.js1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; //查询前两条banner数据 getBannerList() &#123; return request(&#123; url: &#x27;/educms/bannerfront/getBannerList&#x27;, method: &#x27;get&#x27; &#125;) &#125;&#125; index.js1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; //查询热门课程和名师 getIndexList() &#123; return request(&#123; url: &#x27;/eduservice/index/getIndexList&#x27;, method: &#x27;get&#x27; &#125;) &#125;&#125; 调用接口 注意这里的response需要两个data，应为这个模板没有帮忙封装response的一些东西，之前的直接获得的是response.data 轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div&gt; &lt;!-- 幻灯片 开始 --&gt; &lt;div v-swiper:mySwiper=&quot;swiperOption&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div v-for=&quot;banner in bannerList&quot; :key=&quot;banner.id&quot; class=&quot;swiper-slide&quot; style=&quot;background: #040b1b&quot; &gt; &lt;a target=&quot;_blank&quot; :href=&quot;banner.linkUrl&quot;&gt; &lt;img :src=&quot;banner.imageUrl&quot; :alt=&quot;banner.title&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination swiper-pagination-white&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev swiper-button-white&quot; slot=&quot;button-prev&quot; &gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next swiper-button-white&quot; slot=&quot;button-next&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 幻灯片 结束 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import bannerApi from &#x27;@/api/banner&#x27; export default &#123; data() &#123; return &#123; swiperOption: &#123; // 配置分页 pagination: &#123; el: &#x27;.swiper-pagination&#x27; // 分页的dom节点 &#125;, // 配置导航 navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, // 下一页dom节点 prevEl: &#x27;.swiper-button-prev&#x27; // 前一页dom节点 &#125; &#125;, // 数组 bannerList: [], courseList: [], teacherList: [] &#125; &#125;, created() &#123; // 初始化数据 this.getBannerList() &#125;, methods: &#123; // 初始化首页轮播图课程讲师列表 getBannerList() &#123; bannerApi.getBannerList().then(result =&gt; &#123; this.bannerList = result.data.data.list &#125;) &#125; &#125; &#125;&lt;/script&gt; 热门课程讲师123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;template&gt; &lt;div&gt; &lt;div id=&quot;aCoursesList&quot;&gt; &lt;!-- 网校课程 开始 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;热门课程&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;comm-course-list&quot;&gt; &lt;ul class=&quot;of&quot; id=&quot;bna&quot;&gt; &lt;li v-for=&quot;course in courseList&quot; :key=&quot;course.id&quot; &gt; &lt;div class=&quot;cc-l-wrap&quot;&gt; &lt;section class=&quot;course-img&quot;&gt; &lt;img :src=&quot;course.cover&quot; class=&quot;img-responsive&quot; :alt=&quot;course.title&quot; /&gt; &lt;div class=&quot;cc-mask&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;开始学习&quot; class=&quot;comm-btn c-btn-1&quot; &gt;开始学习&lt;/a &gt; &lt;/div&gt; &lt;/section&gt; &lt;h3 class=&quot;hLh30 txtOf mt10&quot;&gt; &lt;a href=&quot;#&quot; :title=&quot;course.title&quot; class=&quot; course-title fsize18 c-333 &quot; &gt;&#123;&#123; course.title &#125;&#125;&lt;/a &gt; &lt;/h3&gt; &lt;section class=&quot;mt10 hLh20 of&quot;&gt; &lt;span class=&quot;fr jgTag bg-green&quot; v-if=&quot; Number(course.price) === 0 &quot; &gt; &lt;i class=&quot;c-fff fsize12 f-fA&quot; &gt;免费&lt;/i &gt; &lt;/span&gt; &lt;span class=&quot;fl jgAttr c-ccc f-fA&quot;&gt; &lt;i class=&quot;c-999 f-fA&quot; &gt;9634人学习&lt;/i &gt; | &lt;i class=&quot;c-999 f-fA&quot; &gt;9634评论&lt;/i &gt; &lt;/span&gt; &lt;/section&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;section class=&quot;tac pt20&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;全部课程&quot; class=&quot;comm-btn c-btn-2&quot; &gt;全部课程&lt;/a &gt; &lt;/section&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /网校课程 结束 --&gt; &lt;!-- 网校名师 开始 --&gt; &lt;div&gt; &lt;section class=&quot;container&quot;&gt; &lt;header class=&quot;comm-title&quot;&gt; &lt;h2 class=&quot;tac&quot;&gt; &lt;span class=&quot;c-333&quot;&gt;名师大咖&lt;/span&gt; &lt;/h2&gt; &lt;/header&gt; &lt;div&gt; &lt;article class=&quot;i-teacher-list&quot;&gt; &lt;ul class=&quot;of&quot;&gt; &lt;li v-for=&quot;teacher in teacherList&quot; :key=&quot;teacher.id&quot; &gt; &lt;section class=&quot;i-teach-wrap&quot;&gt; &lt;div class=&quot;i-teach-pic&quot;&gt; &lt;a href=&quot;/teacher/1&quot; :title=&quot;teacher.name&quot; &gt; &lt;img :alt=&quot;teacher.name&quot; :src=&quot;teacher.avatar&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mt10 hLh30 txtOf tac&quot;&gt; &lt;a href=&quot;/teacher/1&quot; :title=&quot;teacher.name&quot; class=&quot;fsize18 c-666&quot; &gt;&#123;&#123; teacher.name &#125;&#125;&lt;/a &gt; &lt;/div&gt; &lt;div class=&quot;hLh30 txtOf tac&quot;&gt; &lt;span class=&quot;fsize14 c-999&quot;&gt;&#123;&#123; teacher.career &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;mt15 i-q-txt&quot;&gt; &lt;p class=&quot;c-999 f-fA&quot;&gt; &#123;&#123; teacher.intro &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;section class=&quot;tac pt20&quot;&gt; &lt;a href=&quot;#&quot; title=&quot;全部讲师&quot; class=&quot;comm-btn c-btn-2&quot; &gt;全部讲师&lt;/a &gt; &lt;/section&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;!-- /网校名师 结束 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import bannerApi from &#x27;@/api/banner&#x27; import indexApi from &#x27;@/api/index&#x27; export default &#123; data() &#123; return &#123; swiperOption: &#123; // 配置分页 pagination: &#123; el: &#x27;.swiper-pagination&#x27; // 分页的dom节点 &#125;, // 配置导航 navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, // 下一页dom节点 prevEl: &#x27;.swiper-button-prev&#x27; // 前一页dom节点 &#125; &#125;, // 数组 bannerList: [], courseList: [], teacherList: [] &#125; &#125;, created() &#123; // 初始化数据 this.getBannerList() this.getCourseTeacher() &#125;, methods: &#123; // 初始化首页课程讲师列表 getCourseTeacher() &#123; indexApi.getIndexList().then(result =&gt; &#123; this.courseList = result.data.data.courseList this.teacherList = result.data.data.teacherList &#125;) &#125; &#125; &#125;&lt;/script&gt; 测试 这里我没有把url对应起来，所以报了Access to XMLHttpRequest at &#39;http://localhost:9001/educms/bannerfront/getBannerList&#39; from origin &#39;http://localhost:3000&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.的错误 这个错误还有可能是nginx没有配置，或者跨域注解没有加 单点登录SSO![02 单点登录三种方式介绍](https://gitee.com/ReRia/images/raw/master/img/02 单点登录三种方式介绍.png) Redis介绍 整合 该项目在common模块中配置 依赖123456789101112&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- spring2.X集成redis所需common-pool2--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt; 创建配置类123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration // 配置类@EnableCaching // 开启cashe缓存public class RedisConfig extends CachingConfigurerSupport &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory); //key序列化方式 template.setKeySerializer(redisSerializer); //value序列化 template.setValueSerializer(jackson2JsonRedisSerializer); //value hashmap序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template; &#125; @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题）,过期时间600秒 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(600)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125;&#125; springboot缓存注解 在相对应接口中添加Redis缓存使用注解即可使用Redis缓存 @Cacheable：一般用在查询方法上，根据方法对其返回结果进行缓存，下次请求时如果缓存存在，name直接读取缓存数据返回 @CachePut：一般用在新增方法上，使用该注解的方法每次都会执行，并将结果存入指定的缓存中 @CacheEvict：一般用在更新或者删除方法上，会清空指定的缓存 使用Redis服务安装Redis并启动 这里我去谷粒商城看了 配置文件 在需要使用redis的模块的配置文件application.properties中添加配置 12345678#redis配置#注意这里的host和port要和虚拟机的对应spring.redis.host=192.168.128.129spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1 首页缓存 在相关的service方法上添加注释（注意这里为什么要在service中加，因为注释自动添加到redis的话，是从返回值获取的，controller中定义了统一返回格式，不适用） 12345678@Servicepublic class CrmBannerServiceImpl extends ServiceImpl&lt;CrmBannerMapper, CrmBanner&gt; implements CrmBannerService &#123; // 查询所有banner @Override @Cacheable(key = &quot;&#x27;selectIndexList&#x27;&quot;, value = &quot;banner&quot;) // Redis缓存,注意这里key中要加单引号 public List&lt;CrmBanner&gt; selectAllBanner() &#123; &#125;&#125; redis相关命令 使用root权限：su root 查看VMwarehost：ifconfig 修改配置文件：vi /mydata/redis/conf/redis.conf 启动redis：docker start redis 进入redis：docker exec -it redis redis-cli 查看所有keyvalue：keys * 设置查看：set/get xxx JWT(Json Web Token) 依赖 先引入依赖，common_utils模块即可 1234567&lt;dependencies&gt; &lt;!-- JWT--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; utils类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jws;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.util.StringUtils;import javax.servlet.http.HttpServletRequest;import java.util.Date;public class JwtUtils &#123; public static final long EXPIRE = 1000 * 60 * 60 * 24; public static final String APP_SECRET = &quot;ukc8BDbRigUDaY6pZFfWus2jZWLPHO&quot;; public static String getJwtToken(String id, String nickname) &#123; String JwtToken = Jwts.builder() .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;) .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;) .setSubject(&quot;guli-user&quot;) .setIssuedAt(new Date()) .setExpiration(new Date(System.currentTimeMillis() + EXPIRE)) .claim(&quot;id&quot;, id) .claim(&quot;nickname&quot;, nickname) .signWith(SignatureAlgorithm.HS256, APP_SECRET) .compact(); return JwtToken; &#125; /** * 判断token是否存在与有效 * * @param jwtToken * @return */ public static boolean checkToken(String jwtToken) &#123; if (StringUtils.isEmpty(jwtToken)) return false; try &#123; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 判断token是否存在与有效 * * @param request * @return */ public static boolean checkToken(HttpServletRequest request) &#123; try &#123; String jwtToken = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(jwtToken)) return false; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /** * 根据token获取会员id * * @param request * @return */ public static String getMemberIdByJwtToken(HttpServletRequest request) &#123; String jwtToken = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(jwtToken)) return &quot;&quot;; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); Claims claims = claimsJws.getBody(); return (String) claims.get(&quot;id&quot;); &#125;&#125; 短信微服务阿里云短信服务 开启之后，申请签名管理和模板管理 ？？？必须要备案网站好家伙mua的 TODO，没有域名下次再说吧 创建子模块 service_msm模块 配置文件application.properties 基本上都是一样的写法 1234567891011121314151617181920212223242526272829# 服务端口server.port=8005# 服务名spring.application.name=service-msm# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789#redis配置spring.redis.host=192.168.128.129spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle=5spring.redis.lettuce.pool.min-idle=0#最小空闲#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/atguigu/educms/mapper/xml/*.xml 启动类1234567@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class MsmApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MsmApplication.class, args); &#125;&#125; controller TODO service TODO 登录注册（后端）基础工作创建模块 service_ucenter 数据库 ucenter_member 代码生成器 老样子 配置文件 老样子 1234567891011121314151617181920212223242526272829# 服务端口server.port=8006# 服务名spring.application.name=service-ucenter# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789#redis配置spring.redis.host=192.168.128.129spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle=5spring.redis.lettuce.pool.min-idle=0#最小空闲#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/atguigu/educenter/mapper/xml/*.xml 启动类12345678@SpringBootApplication@ComponentScan(&#123;&quot;com.atguigu&quot;&#125;)@MapperScan(&quot;com.atguigu.educenter.mapper&quot;)public class UcenterApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UcenterApplication.class, args); &#125;&#125; 还有nginx配置，跨域配置等 登录MD5Utils 加密工具 12345678910111213141516171819202122232425262728293031package com.atguigu.educenter.utils;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public final class MD5 &#123; public static String encrypt(String strSrc) &#123; try &#123; char hexChars[] = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;; byte[] bytes = strSrc.getBytes(); MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); md.update(bytes); bytes = md.digest(); int j = bytes.length; char[] chars = new char[j * 2]; int k = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; byte b = bytes[i]; chars[k++] = hexChars[b &gt;&gt;&gt; 4 &amp; 0xf]; chars[k++] = hexChars[b &amp; 0xf]; &#125; return new String(chars); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;MD5加密出错！！+&quot; + e); &#125; &#125; public static void main(String[] args) &#123; System.out.println(MD5.encrypt(&quot;111111&quot;)); &#125;&#125; controller1234567891011121314@RestController@RequestMapping(&quot;/educenter/member&quot;)@CrossOriginpublic class UcenterMemberController &#123; @Autowired private UcenterMemberService memberService; // 登录 @PostMapping(&quot;login&quot;) public R loginUser(@RequestBody UcenterMember member) &#123; // 调用service方法,并且返回token String token = memberService.login(member); return R.ok().data(&quot;token&quot;, token); &#125;&#125; service 注意使用MD5工具加密再比较密码 12345678910111213141516171819202122232425262728293031323334@Servicepublic class UcenterMemberServiceImpl extends ServiceImpl&lt;UcenterMemberMapper, UcenterMember&gt; implements UcenterMemberService &#123; // 登录 @Override public String login(UcenterMember member) &#123; // 获得手机号和密码 String mobile = member.getMobile(); String password = member.getPassword(); // 非空判断 if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password)) &#123; throw new GuliException(20001, &quot;手机或密码为空&quot;); &#125; // 查询数据库 QueryWrapper&lt;UcenterMember&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;mobile&quot;, mobile); UcenterMember mmember = baseMapper.selectOne(wrapper); if (mmember == null) &#123; throw new GuliException(20001, &quot;该账号不存在&quot;); &#125; // 判断密码是否正确 // 数据库密码为加密后的密码，所以需要转换 // 使用加密方式MD5（只能加密） if (!mmember.getPassword().equals(MD5.encrypt(password))) &#123; throw new GuliException(20001, &quot;密码错误&quot;); &#125; // 判断是否禁用 if (mmember.getIsDisabled()) &#123; throw new GuliException(20001, &quot;账号禁用&quot;); &#125; // 生成token字符串 String token = JwtUtils.getJwtToken(mmember.getId(), mmember.getNickname()); return token; &#125;&#125; swagger测试 初始值随便复制一个mobile，密码统一为111111 注册vo实体类1234567891011@Datapublic class RegisterVo &#123; @ApiModelProperty(value = &quot;昵称&quot;) private String nickname; @ApiModelProperty(value = &quot;手机号&quot;) private String mobile; @ApiModelProperty(value = &quot;密码&quot;) private String password; //@ApiModelProperty(value = &quot;验证码&quot;) //private String code;&#125; controller123456// 注册@PostMapping(&quot;register&quot;)public R registerUser(@RequestBody RegisterVo registerVo) &#123; memberService.register(registerVo); return R.ok();&#125; service12345678910111213141516171819202122232425262728// 注册@Overridepublic void register(RegisterVo registerVo) &#123; // TODO 验证码判断（暂时不写） //获取注册的数据 String mobile = registerVo.getMobile(); //手机号 String nickname = registerVo.getNickname(); //昵称 String password = registerVo.getPassword(); //密码 //非空判断 if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password) || StringUtils.isEmpty(nickname)) &#123; throw new GuliException(20001, &quot;输入为空&quot;); &#125; //判断手机号是否重复，表里面存在相同手机号不进行添加 QueryWrapper&lt;UcenterMember&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;mobile&quot;, mobile); Integer count = baseMapper.selectCount(wrapper); if (count &gt; 0) &#123; throw new GuliException(20001, &quot;手机号重复&quot;); &#125; //数据添加数据库中 UcenterMember member = new UcenterMember(); member.setMobile(mobile); member.setNickname(nickname); member.setPassword(MD5.encrypt(password));//密码需要加密的 member.setIsDisabled(false);//用户不禁用 member.setAvatar(&quot;http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoj0hHXhgJNOTSOFsS4uZs8x1ConecaVOB8eIl115xmJZcT4oCicvia7wMEufibKtTLqiaJeanU2Lpg3w/132&quot;); baseMapper.insert(member);&#125; 回显数据 根据token获得用户信息 controller12345678910// 根据token获取用户信息@GetMapping(&quot;getMemberInfo&quot;)public R getMemberInfo(HttpServletRequest request) &#123; // 调用jwt工具类方法获取request对象的头信息，获得id String memberId = JwtUtils.getMemberIdByJwtToken(request); // 获得用户信息 UcenterMember member = memberService.getById(memberId); // 这里最好额外使用vo实体类 return R.ok().data(&quot;member&quot;, member);&#125; 登录注册（前端）注册layout 创建sign.vue然后cv 这个是专门的注册登录页面的布局 api api中创建对应js即可 1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; // 注册 register(registerVo) &#123; return request(&#123; url: &#x27;/educenter/member/register&#x27;, method: &#x27;post&#x27;, data: registerVo &#125;) &#125;&#125; vue页面 先去layout -&gt; default.vue中的地址该为登录注册页面的地址 然后在pages里创建vue视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;a href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;span&gt;·&lt;/span&gt; &lt;a class=&quot;active&quot; href=&quot;/register&quot;&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;sign-up-container&quot;&gt; &lt;el-form ref=&quot;userForm&quot; :model=&quot;params&quot;&gt; &lt;el-form-item class=&quot;input-prepend restyle&quot; prop=&quot;nickname&quot; :rules=&quot;[ &#123; required: true, message: &#x27;请输入你的昵称&#x27;, trigger: &#x27;blur&#x27; &#125;, ]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;你的昵称&quot; v-model=&quot;params.nickname&quot; /&gt; &lt;i class=&quot;iconfont icon-user&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;input-prepend restyle no-radius&quot; prop=&quot;mobile&quot; :rules=&quot;[ &#123; required: true, message: &#x27;请输入手机号码&#x27;, trigger: &#x27;blur&#x27; &#125;, &#123; validator: checkPhone, trigger: &#x27;blur&#x27; &#125;, ]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;手机号&quot; v-model=&quot;params.mobile&quot; /&gt; &lt;i class=&quot;iconfont icon-phone&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;input-prepend restyle no-radius&quot; prop=&quot;code&quot; :rules=&quot;[ &#123; required: true, message: &#x27;请输入验证码&#x27;, trigger: &#x27;blur&#x27; &#125;, ]&quot; &gt; &lt;div style=&quot;width: 100%; display: block; float: left; position: relative&quot; &gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;验证码&quot; v-model=&quot;params.code&quot; /&gt; &lt;i class=&quot;iconfont icon-phone&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;btn&quot; style=&quot;position: absolute; right: 0; top: 6px; width: 40%&quot; &gt; &lt;a href=&quot;javascript:&quot; type=&quot;button&quot; @click=&quot;getCodeFun()&quot; :value=&quot;codeTest&quot; style=&quot;border: none; background-color: none&quot; &gt;&#123;&#123; codeTest &#125;&#125;&lt;/a &gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;input-prepend&quot; prop=&quot;password&quot; :rules=&quot;[&#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;password&quot; placeholder=&quot;设置密码&quot; v-model=&quot;params.password&quot; /&gt; &lt;i class=&quot;iconfont icon-password&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;sign-up-button&quot; value=&quot;注册&quot; @click=&quot;submitRegister()&quot; /&gt; &lt;/div&gt; &lt;p class=&quot;sign-up-msg&quot;&gt; 点击 “注册” 即表示您同意并愿意遵守简书 &lt;br /&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://www.jianshu.com/p/c44d171298ce&quot; &gt;用户协议&lt;/a &gt; 和 &lt;a target=&quot;_blank&quot; href=&quot;http://www.jianshu.com/p/2ov8x3&quot;&gt;隐私政策&lt;/a&gt; 。 &lt;/p&gt; &lt;/el-form&gt; &lt;!-- 更多注册方式 --&gt; &lt;div class=&quot;more-sign&quot;&gt; &lt;h6&gt;社交帐号直接注册&lt;/h6&gt; &lt;ul&gt; &lt;li&gt; &lt;a id=&quot;weixin&quot; class=&quot;weixin&quot; target=&quot;_blank&quot; href=&quot;http://huaan.free.idcfengye.com/api/ucenter/wx/login&quot; &gt;&lt;i class=&quot;iconfont icon-weixin&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a id=&quot;qq&quot; class=&quot;qq&quot; target=&quot;_blank&quot; href=&quot;#&quot; &gt;&lt;i class=&quot;iconfont icon-qq&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#x27;~/assets/css/sign.css&#x27; import &#x27;~/assets/css/iconfont.css&#x27; export default &#123; layout: &#x27;sign&#x27;, data() &#123; return &#123; params: &#123; // 封装注册输入数据 mobile: &#x27;&#x27;, code: &#x27;&#x27;, // 验证码 nickname: &#x27;&#x27;, password: &#x27;&#x27; &#125;, sending: true, // 是否发送验证码 second: 60, // 倒计时间 codeTest: &#x27;获取验证码&#x27; &#125; &#125;, methods: &#123;&#125; &#125;&lt;/script&gt; vue方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 注册提交submitRegister() &#123; registerApi.register(this.params).then(result =&gt; &#123; // 提示注册成功 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;注册成功&#x27; &#125;) // 跳转登录页面 this.$router.push(&#123; path: &#x27;/login&#x27; &#125;) &#125;)&#125;,// 发送验证码getCodeFun() &#123; if ((this.sending = false)) &#123; this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;请勿频繁点击&#x27; &#125;) return &#125; // 由于阿里云短信服务不能用，所以这里写假验证 this.sending = false // 调用倒计时的方法 this.timeDown()&#125;,// 验证手机号格式checkPhone(rule, value, callback) &#123; // debugger if (!/^1[34578]\\d&#123;9&#125;$/.test(value)) &#123; return callback(new Error(&#x27;手机号码格式不正确&#x27;)) &#125; return callback()&#125;,// 倒计时timeDown() &#123; const result = setInterval(() =&gt; &#123; --this.second this.codeTest = this.second if (this.second &lt; 1) &#123; clearInterval(result) this.sending = true this.second = 60 this.codeTest = &#x27;获取验证码&#x27; &#125; &#125;, 1000)&#125; TODO：这里有很多地方需要完善：比如点击验证码之后再次点击数字需要弹窗警告，但是现在不会而且还会加速计时器 登录cookie插件 这里需要用到cookie，需要下载 npm install js-cookie api12345678910111213141516171819import request from &#x27;@/utils/request&#x27;export default &#123; // 登录 login(member) &#123; return request(&#123; url: &#x27;/educenter/member/login&#x27;, method: &#x27;post&#x27;, data: member &#125;) &#125;, // 根据token获取用户信息 getLoginMemberInfo() &#123; return request(&#123; url: &#x27;/educenter/member/getMemberInfo&#x27;, method: &#x27;get&#x27; &#125;) &#125;&#125; vue视图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;a class=&quot;active&quot; href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;span&gt;·&lt;/span&gt; &lt;a href=&quot;/register&quot;&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;sign-up-container&quot;&gt; &lt;el-form ref=&quot;userForm&quot; :model=&quot;user&quot;&gt; &lt;el-form-item class=&quot;input-prepend restyle&quot; prop=&quot;mobile&quot; :rules=&quot;[ &#123; required: true, message: &#x27;请输入手机号码&#x27;, trigger: &#x27;blur&#x27; &#125;, &#123; validator: checkPhone, trigger: &#x27;blur&#x27; &#125;, ]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;手机号&quot; v-model=&quot;user.mobile&quot; /&gt; &lt;i class=&quot;iconfont icon-phone&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;input-prepend&quot; prop=&quot;password&quot; :rules=&quot;[&#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;]&quot; &gt; &lt;div&gt; &lt;el-input type=&quot;password&quot; placeholder=&quot;密码&quot; v-model=&quot;user.password&quot; /&gt; &lt;i class=&quot;iconfont icon-password&quot; /&gt; &lt;/div&gt; &lt;/el-form-item&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;sign-in-button&quot; value=&quot;登录&quot; @click=&quot;submitLogin()&quot; /&gt; &lt;/div&gt; &lt;/el-form&gt; &lt;!-- 更多登录方式 --&gt; &lt;div class=&quot;more-sign&quot;&gt; &lt;h6&gt;社交帐号登录&lt;/h6&gt; &lt;ul&gt; &lt;li&gt; &lt;a id=&quot;weixin&quot; class=&quot;weixin&quot; target=&quot;_blank&quot; href=&quot;http://qy.free.idcfengye.com/api/ucenter/weixinLogin/login&quot; &gt;&lt;i class=&quot;iconfont icon-weixin&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a id=&quot;qq&quot; class=&quot;qq&quot; target=&quot;_blank&quot; href=&quot;#&quot; &gt;&lt;i class=&quot;iconfont icon-qq&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#x27;~/assets/css/sign.css&#x27; import &#x27;~/assets/css/iconfont.css&#x27; export default &#123; layout: &#x27;sign&#x27;, data() &#123; return &#123; user: &#123; mobile: &#x27;&#x27;, password: &#x27;&#x27; &#125;, loginInfo: &#123;&#125; &#125; &#125;, methods: &#123;&#125; &#125;&lt;/script&gt;&lt;style&gt; .el-form-item__error &#123; z-index: 9999999; &#125;&lt;/style&gt; 拦截器 在下面的方法中有说明登录token的步骤，其中需要用到拦截器 拦截器写在utils文件夹下的request.js文件中 123456789101112131415import cookie from &#x27;js-cookie&#x27;// 每次请求中使用拦截器service.interceptors.request.use( config =&gt; &#123; if (cookie.get(&#x27;guli_token&#x27;)) &#123; // 从cookie中获得token并且放入header中 config.headers[&#x27;token&#x27;] = cookie.get(&#x27;guli_token&#x27;); &#125; return config &#125;, err =&gt; &#123; return Promise.reject(err) &#125;) vue方法 调用接口登录获取token 将token放入cookie 前端拦截器：判断cookie里是否有token，如果有则放到header中 根据header中的token调用接口获取用户信息 把获取的用户信息放入cookie login.vue中 注意这里把对象放入cookie中是要使用JSON.stringify转换为字符串才行，要不然就是object，回报错（cookie获得的json对象为undefined） 12345678910111213141516171819202122232425262728// 登录的方法submitLogin() &#123; // 1、调用接口进行登录，返回token字符串 loginApi.login(this.user).then(result =&gt; &#123; // 2、获得token,并放入cookie // 第一个参数cookie名称，第二个参数值，第三个参数作用范围 cookieApi.set(&#x27;guli_token&#x27;, result.data.data.token, &#123; domain: &#x27;localhost&#x27; &#125;) // 4、调用接口获取header中的token loginApi.getLoginMemberInfo().then(result =&gt; &#123; // 5、根据token获取用户信息放入cookie中 console.log(response.data.data.member) cookieApi.set(&#x27;guli_ucenter&#x27;, JSON.stringify(result.data.data.member), &#123; domain: &#x27;localhost&#x27; &#125;) &#125;) // 跳转页面 this.$router.push(&#123; path: &#x27;/&#x27; &#125;) &#125;)&#125;,// 验证手机号格式checkPhone(rule, value, callback) &#123; if (!/^1[34578]\\d&#123;9&#125;$/.test(value)) &#123; return callback(new Error(&#x27;手机号码格式不正确&#x27;)) &#125; return callback()&#125; default.vue中编写根据token获得用户信息 123456789101112131415161718192021222324252627created() &#123; this.showInfo() &#125;, methods: &#123; // 从cookie中获取用户信息 showInfo() &#123; // 注意这里需要转换 console.log(&#x27;从cookie中获得用户信息：&#x27; + cookieApi.get(&#x27;guli_ucenter&#x27;)) var loginInfoStr = cookieApi.get(&#x27;guli_ucenter&#x27;) console.log(cookieApi.get(&#x27;guli_ucenter&#x27;)) // 把字符串转换为JSON格式 if (loginInfoStr) &#123; this.loginInfo = JSON.parse(loginInfoStr) &#125; &#125;, // 退出登录 logout() &#123; // 清除cookie cookieApi.set(&#x27;guli_token&#x27;, &#x27;&#x27;, &#123; domain: &#x27;localhost&#x27; &#125;) cookieApi.set(&#x27;guli_ucenter&#x27;, &#x27;&#x27;, &#123; domain: &#x27;localhost&#x27; &#125;) // 清除数据 this.token = &#x27;&#x27; this.loginInfo = &#123;&#125; // 跳转至首页 this.$router.push(&#123; path: &#x27;/&#x27; &#125;) &#125; &#125; TODO：这里需要完善的地方有很多，登录校验（JWT strings must contain exactly 2 period characters. Found: 0）如果输入错误页面竟然显示cookie undefined，而且重新登录也不行，还有前端的信息提示 微信扫码登录（后端+前端）OAuth2 一种方案，解决两个问题： 开放系统间授权 分布式访问问题 ![03 OAuth2介绍](https://gitee.com/ReRia/images/raw/master/img/03 OAuth2介绍.png) 微信登录准备工作 没事了要付钱，鹅肠真有你的 没事了老师共享账号，好耶！ 配置文件 service_ucenter模块的配置文件即可（只用于登录注册） 123456# 微信开放平台 appidwx.open.app_id=wxed9954c01bb89b47# 微信开放平台 appsecretwx.open.app_secret=a7482517235173ddb4083788de60b90e# 微信开放平台 重定向urlwx.open.redirect_url=http://localhost:8160/api/ucenter/wx/callback 常量类12345678910111213141516171819202122package com.atguigu.educenter.utils;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class ConstantWxUtils implements InitializingBean &#123; @Value(&quot;$&#123;wx.open.app_id&#125;&quot;) private String appId; @Value(&quot;$&#123;wx.open.app_secret&#125;&quot;) private String appSecret; @Value(&quot;$&#123;wx.open.redirect_url&#125;&quot;) private String redirectUrl; public static String WX_OPEN_APP_ID; public static String WX_OPEN_APP_SECRET; public static String WX_OPEN_REDIRECT_URL; @Override public void afterPropertiesSet() throws Exception &#123; WX_OPEN_APP_ID = appId; WX_OPEN_APP_SECRET = appSecret; WX_OPEN_REDIRECT_URL = redirectUrl; &#125;&#125; 生成二维码controller1234567891011121314151617181920212223@Controller@CrossOrigin@RequestMapping(&quot;/api/ucenter/wx&quot;)public class WxApiController &#123; // 生成扫描二维码 @GetMapping(&quot;login&quot;) public String getWxCode() throws UnsupportedEncodingException &#123; // 参数位置都是用%s来代替，然后使用String.format String baseUrl = &quot;https://open.weixin.qq.com/connect/qrconnect&quot; + &quot;?appid=%s&quot; + &quot;&amp;redirect_uri=%s&quot; + &quot;&amp;response_type=code&quot; + &quot;&amp;scope=snsapi_login&quot; + &quot;&amp;state=%s&quot; + &quot;#wechat_redirect&quot;; // 需要进行url编码 String redirectUrl = URLEncoder.encode(ConstantWxUtils.WX_OPEN_REDIRECT_URL, &quot;UTF-8&quot;); // 传入url中的参数获得最终的url String url = String.format(baseUrl, ConstantWxUtils.WX_OPEN_APP_ID, redirectUrl, &quot;atguigu&quot;); // 重定向到微信地址 return &quot;redirect:&quot; + url; &#125;&#125; 注意这里需要修改端口号，因为用的是老师的url，所以要对应，nginx里也要改 这里我明白了一点nginx的作用，前端只需要访问nginx提供的9001端口号，而9001能够转发到8001等其他端口号，所以后端端口号改了只要该nginx就行，神奇！ 获取扫描人信息依赖1234567891011121314151617 &lt;dependencies&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; HttpClientUtils 太长不复制了 controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Autowiredprivate UcenterMemberService memberService;// 获取扫描人的信息，添加数据@GetMapping(&quot;callback&quot;)public String callback(String code, String status) throws Exception &#123; // 1、获取code，类似于验证码 // 2、请求微信api得到access_token和openid String baseAccessTokenUrl = &quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot; + &quot;?appid=%s&quot; + &quot;&amp;secret=%s&quot; + &quot;&amp;code=%s&quot; + &quot;&amp;grant_type=authorization_code&quot;; // 拼接参数，发送请求 String accessTokenUrl = String.format(baseAccessTokenUrl, ConstantWxUtils.WX_OPEN_APP_ID, ConstantWxUtils.WX_OPEN_APP_SECRET, code); String accessTokenInfo = HttpClientUtils.get(accessTokenUrl); // 转换json-&gt;map集合,获取其中的两个参数,使用json转换工具 Gson Gson gson = new Gson(); HashMap accessTokenMap = gson.fromJson(accessTokenInfo, HashMap.class); String access_token = (String) accessTokenMap.get(&quot;access_token&quot;); String openid = (String) accessTokenMap.get(&quot;openid&quot;); // 把扫描人信息添加数据库里面 // 判断数据表里面是否存在相同微信信息，根据openid判断 UcenterMember member = memberService.getOpenIdMember(openid); if (member == null) &#123; // 3、拿着得到accsess_token 和 openid，再去请求微信提供固定的地址，获取到扫描人信息 // 访问微信的资源服务器，获取用户信息 String baseUserInfoUrl = &quot;https://api.weixin.qq.com/sns/userinfo&quot; + &quot;?access_token=%s&quot; + &quot;&amp;openid=%s&quot;; // 拼接参数，发送请求 String userInfoUrl = String.format(baseUserInfoUrl, access_token, openid); String userInfo = HttpClientUtils.get(userInfoUrl); //转换并获取返回userinfo字符串扫描人信息 HashMap userInfoMap = gson.fromJson(userInfo, HashMap.class); String nickname = (String) userInfoMap.get(&quot;nickname&quot;);//昵称 String headimgurl = (String) userInfoMap.get(&quot;headimgurl&quot;);//头像 // 创建扫描member对象 member = new UcenterMember(); member.setOpenid(openid); member.setNickname(nickname); member.setAvatar(headimgurl); memberService.save(member); &#125; // 4、使用jwt根据member对象生成token字符串 String jwtToken = JwtUtils.getJwtToken(member.getId(), member.getNickname()); // 5、最后：返回首页面，通过路径传递token字符串 return &quot;redirect:http://localhost:3000?token=&quot; + jwtToken;&#125; service12345678// 根据openid查询@Overridepublic UcenterMember getOpenIdMember(String openid) &#123; QueryWrapper&lt;UcenterMember&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;openid&quot;, openid); UcenterMember member = baseMapper.selectOne(wrapper); return member;&#125; 前端 取地址栏中的带名称的参数值（而不是xx/xx/xx这种使用this.$route.params.xx）使用this.$route.query.xxx 1234567891011121314151617181920212223242526272829303132created() &#123; // 获取url中的token this.token = this.$route.query.token if (this.token) &#123; this.wxLogin() &#125; this.showInfo()&#125;,methods: &#123; // 微信登录后显示用户信息 wxLogin() &#123; // 把token放入cookie cookieApi.set(&#x27;guli_token&#x27;, this.token, &#123; domain: &#x27;localhost&#x27; &#125;) // 调用接口获取header中的token loginApi.getLoginMemberInfo().then(result =&gt; &#123; // 5、根据token获取用户信息放入cookie中 cookieApi.set(&#x27;guli_ucenter&#x27;, JSON.stringify(result.data.data.member), &#123; domain: &#x27;localhost&#x27; &#125;) &#125;) // 跳转页面 this.$router.push(&#123; path: &#x27;/&#x27; &#125;) &#125;, // 从cookie中获取用户信息 showInfo() &#123; var loginInfoStr = cookieApi.get(&#x27;guli_ucenter&#x27;) // 把字符串转换为JSON格式 if (loginInfoStr) &#123; this.loginInfo = JSON.parse(loginInfoStr) &#125; &#125;&#125; 注意把进入微信扫码的href改为http://localhost:8160/api/ucenter/wx/login即可","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战4","slug":"【项目笔记】在线教育项目实战4","date":"2021-09-25T05:55:19.301Z","updated":"2021-10-05T07:31:31.097Z","comments":true,"path":"2021/09/25/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-4/","link":"","permalink":"http://example.com/2021/09/25/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-4/","excerpt":"","text":"多表连接查询 方式如下 内连接 左外连接 右外连接 课程全部信息查询（后端）创建值封装对象类1234567891011@Datapublic class CoursePublishVo &#123; private String id; private String title; private String cover; private Integer lessonNum; private String subjectLevelOne; private String subjectLevelTwo; private String teacherName; private String price;//只用于显示&#125; 编写对应mapper接口123public interface EduCourseMapper extends BaseMapper&lt;EduCourse&gt; &#123; CoursePublishVo getCoursePublishInfo(String courseId);&#125; 编写对应mapper中sql语句 先查询完了之后再贴上来，出错率很高 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.eduservice.mapper.EduCourseMapper&quot;&gt; &lt;select id=&quot;getCoursePublishInfo&quot; resultType=&quot;com.atguigu.eduservice.entity.vo.CoursePublishVo&quot;&gt; select ec.id, ec.title, ec.price, ec.lesson_num AS lessonNum, ec.cover, et.name AS teacherName, es1.title AS subjectLevelOne, es2.title AS subjectLevelTwo from edu_course ec left join edu_course_description ecd on ec.id = ecd.id left join edu_teacher et on ec.teacher_id = et.id left join edu_subject es1 on ec.subject_parent_id = es1.id left join edu_subject es2 on ec.subject_id = es2.id where ec.id = #&#123;courseId&#125; &lt;/select&gt;&lt;/mapper&gt; 编写controller123456// 根据id查询课程全部信息@PostMapping(&quot;getCoursePublishInfo/&#123;courseId&#125;&quot;)public R getCoursePublishInfo(@PathVariable String courseId) &#123; CoursePublishVo coursePublishInfo = courseService.getCoursePublishInfo(courseId); return R.ok().data(&quot;coursePublishInfo&quot;, coursePublishInfo);&#125; 编写service 同理，直接快捷键就行 12345// 根据id查询课程全部信息@Overridepublic CoursePublishVo getCoursePublishInfo(String courseId) &#123; return baseMapper.getCoursePublishInfo(courseId);&#125; 调试 Invalid bound statement (not found): com.atguigu.eduservice.mapper.EduCourseMapper.getCoursePublishInfo 报错如上，解决如下（详见p130） mapper有没有写错 在target文件夹中xml配置文件有没有被引入 可以把mapper.xml放在resource下 配置pom.xml和application.properties（子模块的pom.xml） 1mybatis-plus.mapper-locations=classpath:com/atguigu/eduservice/mapper/xml/*.xml 123456789101112&lt;!-- 解决maven没有导入xml文件 --&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 课程全部信息查询（前端）api1234567// 课程全部信息 getCoursePublishInfo(courseId) &#123; return request(&#123; url: `/eduservice/course/getCoursePublishInfo/` + courseId, method: &#x27;get&#x27;, &#125;) &#125; vue模板和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;发布新课程&lt;/h2&gt; &lt;el-steps :active=&quot;3&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px&quot; &gt; &lt;el-step title=&quot;填写课程基本信息&quot; /&gt; &lt;el-step title=&quot;创建课程大纲&quot; /&gt; &lt;el-step title=&quot;最终发布&quot; /&gt; &lt;/el-steps&gt; &lt;div class=&quot;ccInfo&quot;&gt; &lt;img :src=&quot;coursePublishInfo.cover&quot; /&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2&gt;&#123;&#123; coursePublishInfo.title &#125;&#125;&lt;/h2&gt; &lt;p class=&quot;gray&quot;&gt; &lt;span&gt;共&#123;&#123; coursePublishInfo.lessonNum &#125;&#125;课时&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span &gt;所属分类：&#123;&#123; coursePublishInfo.subjectLevelOne &#125;&#125; — &#123;&#123; coursePublishInfo.subjectLevelTwo &#125;&#125;&lt;/span &gt; &lt;/p&gt; &lt;p&gt;课程讲师：&#123;&#123; coursePublishInfo.teacherName &#125;&#125;&lt;/p&gt; &lt;h3 class=&quot;red&quot;&gt;￥&#123;&#123; coursePublishInfo.price &#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;el-button @click=&quot;previous&quot;&gt;返回修改&lt;/el-button&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;publish&quot; &gt;发布课程&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import courseApi from &#x27;@/api/edu/course.js&#x27; export default &#123; data() &#123; return &#123; saveBtnDisabled: false, // 保存按钮是否禁用 courseId: &#x27;&#x27;, // 课程id coursePublishInfo: &#123;&#125; &#125; &#125;, created() &#123; // 获取到路由中的id值 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.courseId = this.$route.params.id this.getCoursePublishInfo(this.courseId) &#125; console.log(this.coursePublishInfo) &#125;, methods: &#123; getCoursePublishInfo(id) &#123; // 调用api courseApi.getCoursePublishInfo(id).then(result =&gt; &#123; console.log this.coursePublishInfo = result.data.coursePublishInfo &#125;) &#125;, previous() &#123; console.log(&#x27;previous&#x27;) this.$router.push(&#123; path: &#x27;/course/chapter/&#x27; + this.courseId &#125;) &#125;, publish() &#123; console.log(&#x27;publish&#x27;) this.$router.push(&#123; path: &#x27;/course/list&#x27; &#125;) &#125; &#125; &#125;&lt;/script&gt; 课程发布（后端+前端）后端 发布就是修改表中一个字段值就行 12345678// 发布课程（修改status字段值）@PostMapping(&quot;publishCourse/&#123;courseId&#125;&quot;)public R publishCourse(@PathVariable String courseId) &#123; EduCourse eduCourse = courseService.getById(courseId); eduCourse.setStatus(&quot;Normal&quot;); courseService.updateById(eduCourse); return R.ok();&#125; 前端 api 1234567 // 发布课程publishCourse(courseId) &#123; return request(&#123; url: `/eduservice/course/publishCourse/` + courseId, method: &#x27;post&#x27;, &#125;)&#125; method 12345 publish() &#123; courseApi.publishCourse(this.courseId).then(result =&gt; &#123; this.$router.push(&#123; path: &#x27;/course/list&#x27; &#125;) &#125;)&#125; 课程列表（后端+前端）后端（待完善）123456// TODO 完善条件查询带分页@GetMapping(&quot;getCourseList&quot;)public R getCourseList() &#123; List&lt;EduCourse&gt; list = courseService.list(null); return R.ok().data(&quot;courseList&quot;, list);&#125; 前端api1234567// 获得课程列表 getCourseList() &#123; return request(&#123; url: `/eduservice/course/getCourseList`, method: &#x27;get&#x27;, &#125;) &#125; vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; 课程列表 &lt;!--查询表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;courseQuery.title&quot; placeholder=&quot;课程名称&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-select v-model=&quot;courseQuery.status&quot; clearable placeholder=&quot;课程状态&quot; &gt; &lt;el-option value=&quot;Normal&quot; label=&quot;已发布&quot; /&gt; &lt;el-option value=&quot;Draft&quot; label=&quot;未发布&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;getList()&quot; &gt;查询&lt;/el-button &gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt; &lt;/el-form&gt; &lt;!-- 表格 --&gt; &lt;el-table :data=&quot;list&quot; border fit highlight-current-row&gt; &lt;el-table-column label=&quot;序号&quot; width=&quot;70&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;title&quot; label=&quot;课程名称&quot; width=&quot;80&quot; /&gt; &lt;el-table-column label=&quot;课程状态&quot; width=&quot;80&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.status === &quot;Normal&quot; ? &quot;已发布&quot; : &quot;未发布&quot; &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;lessonNum&quot; label=&quot;课时数&quot; /&gt; &lt;el-table-column prop=&quot;gmtCreate&quot; label=&quot;添加时间&quot; width=&quot;160&quot; /&gt; &lt;el-table-column prop=&quot;viewCount&quot; label=&quot;浏览数量&quot; width=&quot;60&quot; /&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;编辑课程基本信息&lt;/el-button &gt; &lt;/router-link&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;编辑课程大纲息&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除课程信息&lt;/el-button &gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页 --&gt; &lt;el-pagination :current-page=&quot;page&quot; :page-size=&quot;limit&quot; :total=&quot;total&quot; style=&quot;padding: 30px 0; text-align: center&quot; layout=&quot;total, prev, pager, next, jumper&quot; @current-change=&quot;getList&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用teacher.js文件 import courseApi from &#x27;@/api/edu/course&#x27; export default &#123; data() &#123; return &#123; list: null, // 查询之后接口返回集合(注意这里是数组用null) page: 1, // 当前页 limit: 10, // 每页记录数 total: 0, // 总记录数 courseQuery: &#123;&#125; // 条件封装对象 &#125; &#125;, created() &#123; // 页面渲染之前执行，一般调用methods定义的方法 // 调用 this.getList() &#125;, methods: &#123; getList() &#123; courseApi.getCourseList().then(response =&gt; &#123; // 请求成功 // response接口返回的数据 this.list = response.data.courseList &#125;) &#125;, resetData() &#123; // 表单输入项数据清空 this.courseQuery = &#123;&#125; this.getList() &#125; &#125; &#125;&lt;/script&gt; 课程删除（后端+前端） 删除课程：所有章节也会被删除 后端controller123456// 删除课程@DeleteMapping(&quot;&#123;courseId&#125;&quot;)public R deleteCourse(@PathVariable String courseId) &#123; courseService.deleteCourse(courseId); return R.ok();&#125; service123456789101112131415// 根据课程id删除课程及其描述和章节@Overridepublic void deleteCourse(String courseId) &#123; // 1、删除小节 videoService.removeByCourseId(courseId); // 2、删除章节 chapterService.removeByCourseId(courseId); // 3、删除描述 descriptionService.removeById(courseId); // 4、删除课程 int row = baseMapper.deleteById(courseId); if (row == 0) &#123; throw new GuliException(20001, &quot;删除课程失败&quot;); &#125;&#125; 1234567// 根据课程id删除章节@Overridepublic void removeByCourseId(String courseId) &#123; QueryWrapper&lt;EduChapter&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;course_id&quot;, courseId); baseMapper.delete(queryWrapper);&#125; 前端api1234567// 删除课程 deleteCourse(courseId) &#123; return request(&#123; url: `/eduservice/course/` + courseId, method: &#x27;delete&#x27;, &#125;) &#125;, vue123456789101112131415161718192021// 删除课程deleteCourse(courseId) &#123; courseApi .deleteCourse(courseId) .then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新页面 this.getList() &#125;) .catch(err =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;删除失败!&#x27; &#125;) &#125;)&#125; 阿里云视频点播 视频点播_音视频点播解决方案_视频转码_媒体资源管理系统-阿里云 (aliyun.com) 视频点播 (aliyun.com) 环境搭建 依赖见官网（项目环境搭建的时候已经引入了） 创建模块 子子模块service_vod 引入依赖 注意这个aliyun-java-vod-upload.version依赖未开源，需要手动下载jar包，然后使用命令行安装 mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-java-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.14.jar 注意这里的版本要和下载的jar包对应，还有包名aliyun-java-vod-upload 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 阿里云视频点播所需依赖 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 测试根据视频id获取视频播放地址123456789101112131415161718192021222324public class TestVod &#123; public static void main(String[] args) throws ClientException &#123; // 1、根据视频id获取视频播放地址 // 创建初始化对象(传入oss的id和秘钥) DefaultAcsClient client = InitObject.initVodClient(&quot;&quot;, &quot;&quot;); // 创建获取视频地址的request GetPlayInfoRequest request = new GetPlayInfoRequest(); // 向request中设置id request.setVideoId(&quot;&quot;); // 调用初始化对象的方法，传递request，获取response GetPlayInfoResponse acsResponse = client.getAcsResponse(request); // 获取response中的信息 List&lt;GetPlayInfoResponse.PlayInfo&gt; playInfoList = acsResponse.getPlayInfoList(); //播放地址 for (GetPlayInfoResponse.PlayInfo playInfo : playInfoList) &#123; System.out.print(&quot;PlayInfo.PlayURL = &quot; + playInfo.getPlayURL() + &quot;\\n&quot;); &#125; //Base信息 System.out.print(&quot;VideoBase.Title = &quot; + acsResponse.getVideoBase().getTitle() + &quot;\\n&quot;); System.out.println(acsResponse); &#125;&#125; 根据视频id获取视频播放凭证123456789101112public static void main(String[] args) throws ClientException &#123; // 根据视频id获得视频凭证 // 创建初始化对象(传入oss的id和秘钥) DefaultAcsClient client = InitObject.initVodClient(&quot;&quot;, &quot;&quot;); // 创建获取视频地址的request GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest(); // 向request中设置id request.setVideoId(&quot;&quot;); // 调用初始化对象的方法，传递request，获取response GetVideoPlayAuthResponse acsResponse = client.getAcsResponse(request); System.out.println(&quot;视频凭证: &quot; + acsResponse.getPlayAuth());&#125; 上传视频 这里注意，如果使用upload的版本为1.4.14，那么根据官方文档说明，oss-sdk的版本必须为3.9及以上，否则会显示一直上传中 12345678910111213141516171819202122232425public static void main(String[] args) throws ClientException &#123; String accessKeyId = &quot;&quot;; String accessKeySecret = &quot;&quot;; String title = &quot;6 - What If I Want to Move Faster - upload by sdk&quot;; //上传之后文件名称 String fileName = &quot;D:/MyProject/6 - What If I Want to Move Faster.mp4&quot;; //本地文件路径和名称 //上传视频的方法 UploadVideoRequest request = new UploadVideoRequest(accessKeyId, accessKeySecret, title, fileName); /* 可指定分片上传时每个分片的大小，默认为2M字节 */ request.setPartSize(2 * 1024 * 1024L); /* 可指定分片上传时的并发线程数，默认为1，(注：该配置会占用服务器CPU资源，需根据服务器情况指定）*/ request.setTaskNum(1); UploadVideoImpl uploader = new UploadVideoImpl(); UploadVideoResponse response = uploader.uploadVideo(request); if (response.isSuccess()) &#123; System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\\n&quot;); &#125; else &#123; /* 如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 */ System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\\n&quot;); System.out.print(&quot;ErrorCode=&quot; + response.getCode() + &quot;\\n&quot;); System.out.print(&quot;ErrorMessage=&quot; + response.getMessage() + &quot;\\n&quot;); &#125;&#125; 课程增加、删除小节（视频）功能（完善）后端配置文件application.properties1234567891011121314# 服务端口server.port=8003# 服务名spring.application.name=service-vod# 环境设置：dev、test、prodspring.profiles.active=dev#阿里云 vod#不同的服务器，地址不同aliyun.vod.file.keyid=aliyun.vod.file.keysecret=# 最大上传单个文件大小：默认1Mspring.servlet.multipart.max-file-size=1024MB# 最大置总上传的数据大小 ：默认10Mspring.servlet.multipart.max-request-size=1024MB 编写常量类1234567891011121314151617181920// 类存储配置文件中的数据以便调用@Componentpublic class ConstantVodUtils implements InitializingBean &#123; @Value(&quot;$&#123;aliyun.vod.file.keyid&#125;&quot;) private String keyid; @Value(&quot;$&#123;aliyun.vod.file.keysecret&#125;&quot;) private String keysecret; public static String ACCESS_KEY_SECRET; public static String ACCESS_KEY_ID; @Override public void afterPropertiesSet() throws Exception &#123; ACCESS_KEY_ID = keyid; ACCESS_KEY_SECRET = keysecret; &#125; &#125; 编写初始化VodClient1234567891011@Componentpublic class InitVodClient &#123; public static DefaultAcsClient initVodClient(String accessKeyId, String accessKeySecret) throws ClientException &#123; String regionId = &quot;cn-shanghai&quot;; // 点播服务接入区域 DefaultProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret); DefaultAcsClient client = new DefaultAcsClient(profile); return client; &#125;&#125; 创建启动类1234567@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) // 不需要引入数据库的配置@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class VodApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(VodApplication.class, args); &#125;&#125; 编写controller123456789101112131415161718192021@RestController@RequestMapping(&quot;/eduvod/video&quot;)@CrossOriginpublic class VodController &#123; @Autowired private VodService vodService; // 上传视频至阿里云 @PostMapping(&quot;uploadVideo&quot;) public R uploadVideo(MultipartFile file) &#123; String videoId = vodService.uploadVideo(file); return R.ok(); &#125; // 根据id删除视频 @DeleteMapping(&quot;removeVideo/&#123;videoId&#125;&quot;) public R removeVideo(@PathVariable String videoId) &#123; vodService.removeVideo(videoId); return R.ok(); &#125;&#125; 编写service1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Servicepublic class VodServiceImpl implements VodService &#123; // 上传视频至阿里云 @Override public String uploadVideo(MultipartFile file) &#123; try &#123; //fileName：上传文件原始名称 String fileName = file.getOriginalFilename(); //title：上传之后显示名称 String title = fileName.substring(0, fileName.lastIndexOf(&quot;.&quot;)); //inputStream：上传文件输入流 InputStream inputStream = file.getInputStream(); //accessKeyId, accessKeySecret UploadStreamRequest request = new UploadStreamRequest(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET, title, fileName, inputStream); UploadVideoImpl uploader = new UploadVideoImpl(); UploadStreamResponse response = uploader.uploadStream(request); String videoId = null; if (response.isSuccess()) &#123; videoId = response.getVideoId(); &#125; else &#123; //如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\\n&quot;); System.out.print(&quot;ErrorCode=&quot; + response.getCode() + &quot;\\n&quot;); System.out.print(&quot;ErrorMessage=&quot; + response.getMessage() + &quot;\\n&quot;); &#125; return videoId; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; // 根据id删除视频 @Override public void removeVideo(String videoId) &#123; try &#123; // 初始化对象 DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET); // 创建删除video的request对象,并设置id DeleteVideoRequest request = new DeleteVideoRequest(); request.setVideoIds(videoId); // 调用初始化对象方法 DeleteVideoResponse acsResponse = client.getAcsResponse(request); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new GuliException(20001, &quot;删除视频失败&quot;); &#125; &#125;&#125; 前端api1234567// 删除小节视频 deleteVideoAli(videoId) &#123; return request(&#123; url: `/eduvod/video/removeVideo/` + videoId, method: &#x27;delete&#x27;, &#125;) &#125; vue模板12345678910111213141516171819&lt;el-upload :on-success=&quot;handleVodUploadSuccess&quot; :on-remove=&quot;handleVodRemove&quot; :before-remove=&quot;beforeVodRemove&quot; :on-exceed=&quot;handleUploadExceed&quot; :file-list=&quot;fileList&quot; :action=&quot;BASE_API+&#x27;/eduvod/video/uploadVideo&#x27;&quot; :limit=&quot;1&quot; class=&quot;upload-demo&quot;&gt;&lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;上传视频&lt;/el-button&gt;&lt;el-tooltip placement=&quot;right-end&quot;&gt; &lt;div slot=&quot;content&quot;&gt;最大支持1G，&lt;br&gt; 支持3GP、ASF、AVI、DAT、DV、FLV、F4V、&lt;br&gt; GIF、M2T、M4V、MJ2、MJPEG、MKV、MOV、MP4、&lt;br&gt; MPE、MPG、MPEG、MTS、OGG、QT、RM、RMVB、&lt;br&gt; SWF、TS、VOB、WMV、WEBM 等视频格式上传&lt;/div&gt; &lt;i class=&quot;el-icon-question&quot;/&gt;&lt;/el-tooltip&gt;&lt;/el-upload&gt; 调用方法1234567891011121314151617181920212223242526// 删除之前beforeVodRemove(file, fileList) &#123; return this.$confirm(`确定移除$&#123;file.name&#125;?`)&#125;,// 删除上传视频handleVodRemove() &#123; // 调用接口 videoApi.deleteVideoAli(this.video.videoSourceId).then(result =&gt; &#123; // 提示 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新fileList 和 resourceId this.fileList = [] this.video.videoSourceId = &#x27;&#x27; &#125;)&#125;,// 上传vod成功handleVodUploadSuccess(response, file, fileList) &#123; this.video.videoSourceId = response.data.videoId&#125;,// 重新上传提示handleUploadExceed() &#123; this.$message.warning(&#x27;想要重新上传视频，请先删除已上传的视频&#x27;)&#125;, 测试 注意这里，要修改nginx的上传文件大小 12345http &#123; include mime.types; default_type application/octet-stream; client_max_body_size 1024m;&#125; 由于controller中返回data只有videoId，所以从后端拿不到原始文件吗，所以从前端赋值即可 删除视频后要清空sourceId，要不然不上传视频也有id存留 springcloud微服务（删除小节功能完善）springcloud 服务集合，TODO springcloud调用接口过程 Nacos服务注册 注册中心 home (nacos.io) 启动 下载并解压，然后启动startup.cmd即可，可能会启动失败，需要修改MODE为standalone Nacos 启动失败_RookieMZL 的博客-CSDN博客_nacos启动失败 依赖 先引入依赖 12345&lt;!--服务注册--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 配置 在要注册的服务的配置文件application.properties中配置 12# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 注解 在启动类上添加注解 123456@EnableDiscoveryClient // nacos注册public class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 测试 致命bug，springboot的版本要2.2.x才行，要不然application启动不起来 http://localhost:8848/nacos Feign服务调用 前提条件：将互相调用的服务在nacos注册完毕 依赖12345&lt;!--服务调用--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 添加注解 在需要调用服务的启动类上添加注解如下 123456789@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@EnableDiscoveryClient // nacos注册@EnableFeignClients // 使用Feignpublic class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 创建接口 在调用端创建接口，使用注解指定需要调用哪一个服务，并定义调用的方法和路径 注意结构（service_edu要调用service_vod的功能） @ Feignclient注解用于指定从哪个服务中调用功能,名称与被调用的服务名保持致。@ GetMapping注解用于对被调用的微服务进行地址映射@ PathVariable注解定要指定参数名称,否则出错@ Component注解防止,在其他位置注入 Codclient时idea报错 12345678@FeignClient(&quot;service-vod&quot;) // 调用服务（服务名），这里的服务名要和对应服务的配置文件中的spring.application.name对应@Componentpublic interface VodClient &#123; // 定义要调用的方法的路径（注意要完全路径） // 根据id删除视频 @DeleteMapping(&quot;/eduvod/video/removeVideo/&#123;videoId&#125;&quot;) public R removeVideo(@PathVariable(&quot;videoId&quot;) String videoId);&#125; 注意这里的@FeignClient(“service-vod”)，服务名不能使用下划线 实现调用（删除小节） 注入接口，调用接口方法即可 123456789101112131415161718@RestController@RequestMapping(&quot;/eduservice/video&quot;)@CrossOrigin // 跨域public class EduVideoController &#123; @Autowired private VodClient vodClient; // 注入接口调用其他服务 // TODO 删除小节 @DeleteMapping(&quot;&#123;videoId&#125;&quot;) public R deleteVideo(@PathVariable(&quot;videoId&quot;) String videoId) &#123; // 实现调用删除阿里云视频，这里需要的是sourceID EduVideo eduVideo = videoService.getById(videoId); String videoSourceId = eduVideo.getVideoSourceId(); vodClient.removeVideo(videoSourceId); // 删除数据库视频 videoService.removeById(videoId); return R.ok(); &#125;&#125; 如果不成功rerun一下就行了 Hystrix熔断器 提供延迟与容错功能 添加依赖1234567891011&lt;!-- ribbn负载均衡 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--hystrix依赖，主要是用 @HystrixCommand --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 调用端配置 注意是在调用端，开启熔断器配置，也可使设置超时时间 12# hytrix开启熔断机制feign.hystrix.enabled=true 创建接口对应实现类 编写出错时的输出信息，实现FeignClient接口 123456789101112@Componentpublic class VodFileDegradeFeignClient implements VodClient &#123; @Override public R removeVideo(String videoId) &#123; return R.error().message(&quot;出错了&quot;); &#125; @Override public R deleteVideoBatch(List&lt;String&gt; videoIdList) &#123; return R.error().message(&quot;出错了&quot;); &#125;&#125; 接口添加属性 feignClient添加注解和属性 123456// fallback = &quot;实现类的class&quot;，熔断器@FeignClient(name = &quot;service-vod&quot;, fallback = VodFileDegradeFeignClient.class)// 调用服务（服务名），这里的服务名要和对应服务的配置文件中的spring.application.name对应@Componentpublic interface VodClient &#123;&#125; 删除课程（功能完善） 删除视频，删除视频下的章节和小节 后端 video中的删除小节功能需要调用vod中的删除 VodController123456// 删除多个阿里云视频@DeleteMapping(&quot;deleteVideoBatch&quot;)public R deleteVideoBatch(@RequestParam(&quot;videoIdList&quot;) List&lt;String&gt; videoIdList) &#123; vodService.removeBatch(videoIdList); return R.ok();&#125; VodService1234567891011121314151617181920// 删除多个阿里云视频@Overridepublic void removeVideoBatch(List&lt;String&gt; videoIdList) &#123; try &#123; // 初始化对象 DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET); // 创建删除video的request对象,并设置id DeleteVideoRequest request = new DeleteVideoRequest(); // 将list转化成1,2,3的格式 String list = StringUtils.join(videoIdList.toArray(), &quot;,&quot;); request.setVideoIds(list); // 调用初始化对象方法 DeleteVideoResponse acsResponse = client.getAcsResponse(request); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new GuliException(20001, &quot;删除视频失败&quot;); &#125;&#125; Feign调用接口 这是service_edu中的 123456789101112@FeignClient(&quot;service-vod&quot;) // 调用服务（服务名），这里的服务名要和对应服务的配置文件中的spring.application.name对应@Componentpublic interface VodClient &#123; // 定义要调用的方法的路径（注意要完全路径） // 根据id删除视频 @DeleteMapping(&quot;/eduvod/video/removeVideo/&#123;videoId&#125;&quot;) public R removeVideo(@PathVariable(&quot;videoId&quot;) String videoId); // 删除多个阿里云视频 @DeleteMapping(&quot;/eduvod/video/deleteVideoBatch&quot;) public R deleteVideoBatch(@RequestParam(&quot;videoIdList&quot;) List&lt;String&gt; videoIdList);&#125; videoMapper123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.eduservice.mapper.EduVideoMapper&quot;&gt; &lt;select id=&quot;getVideoIdListByCourse&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT video_source_id FROM `edu_video` WHERE course_id = #&#123;courseId&#125; AND video_source_id IS NOT NULL AND video_source_id != &#x27;&#x27;; &lt;/select&gt;&lt;/mapper&gt; videoService123456789101112131415161718@Servicepublic class EduVideoServiceImpl extends ServiceImpl&lt;EduVideoMapper, EduVideo&gt; implements EduVideoService &#123; @Autowired private VodClient vodClient; // 根据课程id删除小节 @Override public void removeByCourseId(String courseId) &#123; // 删除该课程下的所有视频（阿里云） List&lt;String&gt; idList = baseMapper.getVideoIdListByCourse(courseId); vodClient.deleteVideoBatch(idList); // 删除小节（数据库） QueryWrapper wrapper = new QueryWrapper(); wrapper.eq(&quot;course_id&quot;, courseId); baseMapper.delete(wrapper); &#125;&#125; 测试 OK 前端 TODO 注意这里有个问题，由于我确定按钮没有绑定是否能够按下的boolean值，所有在文件上传完成之前按下会没有sourceId，之后再改 待续 后台还有好多TODO和完善，竟然就直接进入前台了，好吧还得靠自己","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战3","slug":"【项目笔记】在线教育项目实战3","date":"2021-09-24T02:43:17.317Z","updated":"2021-09-26T09:03:30.866Z","comments":true,"path":"2021/09/24/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-3/","link":"","permalink":"http://example.com/2021/09/24/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-3/","excerpt":"","text":"课程管理模块 数据库表关系 course相关表、chapter、video、teacher、subject……这些表都需要 代码生成器 熟悉的操作，run就完事了 贴一下项目结构 controller记得加下跨域注释，entity记得加下自动填充注释…… 添加课程信息（后端）vo表单数据封装类 需要用到表单提交数据，所以写一个vo类封装 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.eduservice.entity.vo;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.math.BigDecimal;// 表单提交数据封装对象@Datapublic class CourseInfoVo &#123; @ApiModelProperty(value = &quot;课程ID&quot;) private String id; @ApiModelProperty(value = &quot;课程讲师ID&quot;) private String teacherId; @ApiModelProperty(value = &quot;课程专业ID&quot;) private String subjectId; @ApiModelProperty(value = &quot;课程标题&quot;) private String title; @ApiModelProperty(value = &quot;课程销售价格，设置为0则可免费观看&quot;) // 0.01 private BigDecimal price; @ApiModelProperty(value = &quot;总课时&quot;) private Integer lessonNum; @ApiModelProperty(value = &quot;课程封面图片路径&quot;) private String cover; @ApiModelProperty(value = &quot;课程简介&quot;) private String description;&#125; 编写controller12345678910111213141516@RestController@RequestMapping(&quot;/eduservice/course&quot;)@CrossOrigin // 跨域public class EduCourseController &#123; @Autowired private EduCourseService courseService; // 添加课程基本信息 @PostMapping(&quot;addCourseInfo&quot;) public R addCourseInfo(@RequestBody CourseInfoVo courseInfoVo) &#123; courseService.saveCourseInfo(courseInfoVo); return R.ok(); &#125;&#125; 编写service123456789101112131415161718192021222324@Servicepublic class EduCourseServiceImpl extends ServiceImpl&lt;EduCourseMapper, EduCourse&gt; implements EduCourseService &#123; @Autowired private EduCourseDescriptionService courseDescriptionService; // 添加课程基本信息 @Override public void saveCourseInfo(CourseInfoVo courseInfoVo) &#123; // 向课程表中添加课程基本信息 EduCourse eduCourse = new EduCourse(); BeanUtils.copyProperties(courseInfoVo, eduCourse); int affectRow = baseMapper.insert(eduCourse); if (affectRow &lt;= 0) &#123; throw new GuliException(20001, &quot;添加课程失败&quot;); &#125; // 向课程简介表中添加课程简介信息 // 注意baseMapper添加的是当前service对应的表,使用对应的service即可 EduCourseDescription courseDescription = new EduCourseDescription(); courseDescription.setId(eduCourse.getId()); // 这里要保证两张表id相同（1-1关系） courseDescription.setDescription(courseInfoVo.getDescription()); courseDescriptionService.save(courseDescription); &#125;&#125; 同时需要实体类中的id属性为手动输入，而不是自动生成 123456789public class EduCourseDescription implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = &quot;课程ID&quot;) @TableId(value = &quot;id&quot;, type = IdType.INPUT) private String id; &#125; 测试 course和description表中id一样 添加课程信息（前端）添加router1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 课程信息管理模块路由&#123; path: &#x27;/course&#x27;, component: Layout, redirect: &#x27;/course/list&#x27;, name: &#x27;课程管理&#x27;, meta: &#123; title: &#x27;课程管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;课程列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/list&#x27;), meta: &#123; title: &#x27;课程分类列表&#x27;, icon: &#x27;tree&#x27; &#125; &#125;, &#123; path: &#x27;info&#x27;, name: &#x27;添加课程&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/info&#x27;), meta: &#123; title: &#x27;添加课程&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;info/:id&#x27;, name: &#x27;EduCourseInfoEdit&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/info&#x27;), meta: &#123; title: &#x27;编辑课程基本信息&#x27;, icon: &#x27;table&#x27; &#125;, // 不显示该路由(隐藏路由) hidden: true &#125;, &#123; path: &#x27;chapter/:id&#x27;, name: &#x27;EduCourseChapterEdit&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/chapter&#x27;), meta: &#123; title: &#x27;编辑课程大纲&#x27;, icon: &#x27;table&#x27; &#125;, // 不显示该路由(隐藏路由) hidden: true &#125;, &#123; path: &#x27;publish/:id&#x27;, name: &#x27;EduCoursePublishEdit&#x27;, component: () =&gt; import(&#x27;@/views/edu/course/publish&#x27;), meta: &#123; title: &#x27;发布课程&#x27;, icon: &#x27;table&#x27; &#125;, // 不显示该路由(隐藏路由) hidden: true &#125; ]&#125;, 创建vue视图模板 使用element-ui的步骤条和表单即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;发布新课程&lt;/h2&gt; &lt;el-steps :active=&quot;1&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px&quot; &gt; &lt;el-step title=&quot;填写课程基本信息&quot; /&gt; &lt;el-step title=&quot;创建课程大纲&quot; /&gt; &lt;el-step title=&quot;最终发布&quot; /&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;课程标题&quot;&gt; &lt;el-input v-model=&quot;courseInfo.title&quot; placeholder=&quot; 示例：机器学习项目课：从基础到搭建项目视频课程。专业名称注意大小写&quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 所属分类 TODO --&gt; &lt;el-form-item label=&quot;课程分类&quot;&gt; &lt;el-select v-model=&quot;courseInfo.subjectParentId&quot; placeholder=&quot;一级分类&quot; @change=&quot;subjectLevelOneChanged&quot; &gt; &lt;el-option v-for=&quot;subject in subjectOneList&quot; :key=&quot;subject.id&quot; :label=&quot;subject.title&quot; :value=&quot;subject.id&quot; /&gt; &lt;/el-select&gt; &lt;!-- 二级分类 --&gt; &lt;el-select v-model=&quot;courseInfo.subjectId&quot; placeholder=&quot;二级分类&quot; &gt; &lt;el-option v-for=&quot;subject in subjectTwoList&quot; :key=&quot;subject.id&quot; :label=&quot;subject.title&quot; :value=&quot;subject.id&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;!-- 课程讲师 TODO --&gt; &lt;!-- 课程讲师 --&gt; &lt;el-form-item label=&quot;课程讲师&quot;&gt; &lt;el-select v-model=&quot;courseInfo.teacherId&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;teacher in teacherList&quot; :key=&quot;teacher.id&quot; :label=&quot;teacher.name&quot; :value=&quot;teacher.id&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;总课时&quot;&gt; &lt;el-input-number :min=&quot;0&quot; v-model=&quot;courseInfo.lessonNum&quot; controls-position=&quot;right&quot; placeholder=&quot;请填写课程的总课时数&quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 课程简介 TODO --&gt; &lt;el-form-item label=&quot;课程简介&quot;&gt; &lt;el-input v-model=&quot;courseInfo.description&quot; placeholder=&quot; &quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 课程封面 TODO --&gt; &lt;!-- 课程封面--&gt; &lt;el-form-item label=&quot;课程封面&quot;&gt; &lt;el-upload :show-file-list=&quot;false&quot; :on-success=&quot;handleAvatarSuccess&quot; :before-upload=&quot;beforeAvatarUpload&quot; :action=&quot;BASE_API + &#x27;/eduoss/fileoss&#x27;&quot; class=&quot;avatar-uploader&quot; &gt; &lt;img :src=&quot;courseInfo.cover&quot; /&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程价格&quot;&gt; &lt;el-input-number :min=&quot;0&quot; v-model=&quot;courseInfo.price&quot; controls-position=&quot;right&quot; placeholder=&quot;免费课程请设置为0元&quot; /&gt; 元 &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot; &gt;保存并下一步&lt;/el-button &gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // import course from &#x27;@/api/edu/course&#x27; import subject from &#x27;@/api/edu/subject&#x27; export default &#123; data() &#123; return &#123; saveBtnDisabled: false, courseInfo: &#123; title: &#x27;&#x27;, subjectId: &#x27;&#x27;, // 二级分类id subjectParentId: &#x27;&#x27;, // 一级分类id teacherId: &#x27;&#x27;, lessonNum: 0, description: &#x27;&#x27;, cover: &#x27;/static/01.jpg&#x27;, price: 0 &#125;, BASE_API: process.env.BASE_API, // 接口API地址 teacherList: [], // 封装所有的讲师 subjectOneList: [], // 一级分类 subjectTwoList: [] // 二级分类 &#125; &#125;, created() &#123;&#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center;&quot;&gt;发布新课程&lt;/h2&gt; &lt;el-steps :active=&quot;2&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px;&quot;&gt; &lt;el-step title=&quot;填写课程基本信息&quot;/&gt; &lt;el-step title=&quot;创建课程大纲&quot;/&gt; &lt;el-step title=&quot;最终发布&quot;/&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item&gt; &lt;el-button @click=&quot;previous&quot;&gt;上一步&lt;/el-button&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;next&quot;&gt;下一步&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; saveBtnDisabled:false &#125; &#125;, created() &#123; &#125;, methods:&#123; previous() &#123; this.$router.push(&#123;path:&#x27;/course/info/1&#x27;&#125;) &#125;, next() &#123; //跳转到第二步 this.$router.push(&#123;path:&#x27;/course/publish/1&#x27;&#125;) &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;发布新课程&lt;/h2&gt; &lt;el-steps :active=&quot;3&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px&quot; &gt; &lt;el-step title=&quot;填写课程基本信息&quot; /&gt; &lt;el-step title=&quot;创建课程大纲&quot; /&gt; &lt;el-step title=&quot;最终发布&quot; /&gt; &lt;/el-steps&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item&gt; &lt;el-button @click=&quot;previous&quot;&gt;返回修改&lt;/el-button&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;publish&quot; &gt;发布课程&lt;/el-button &gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; saveBtnDisabled: false // 保存按钮是否禁用 &#125; &#125;, created() &#123; console.log(&#x27;publish created&#x27;) &#125;, methods: &#123; previous() &#123; console.log(&#x27;previous&#x27;) this.$router.push(&#123; path: &#x27;/course/chapter/1&#x27; &#125;) &#125;, publish() &#123; console.log(&#x27;publish&#x27;) this.$router.push(&#123; path: &#x27;/course/list&#x27; &#125;) &#125; &#125; &#125;&lt;/script&gt; 创建课程相关接口 api -&gt; edu -&gt; course.js 12345678910111213import request from &#x27;@/utils/request&#x27;export default &#123; // 新增课程信息 addCourseInfo(courseInfo) &#123; return request(&#123; url: `/eduservice/course/addCourseInfo`, method: &#x27;post&#x27;, data: courseInfo &#125;) &#125; &#125; 注意这里在后端把之前的代码修改一下，返回新增课程的id，然后重启 编写按钮方法（简单编写未实现功能） 由于表单中显示课程分类和讲师还没有写，所以先简单写一下方法 123456789101112next() &#123; // 调用后端接口传入数据 courseApi.addCourseInfo(this.courseInfo).then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加成功!&#x27; &#125;) // 跳转到第二步，同时传递id值 this.$router.push(&#123; path: &#x27;/course/chapter/&#x27; + result.data.courseId &#125;) &#125;)&#125; 添加课程信息（更多完善）显示讲师下拉列表（后端） 讲师模块写过了，不带分页查询所有讲师 显示讲师下拉列表（前端） 注意这里要现在api中创建所得所有讲师的接口（如果之前讲师模块没写的话） 1234567// 查询所有讲师（不带分页） getTeacherList() &#123; return request(&#123; url: `/eduservice/teacher/findAll`, method: &#x27;get&#x27; &#125;) &#125;, 下拉列表模板，使用循环的方法 123456789101112&lt;!-- 课程讲师 TODO --&gt;&lt;!-- 课程讲师 --&gt;&lt;el-form-item label=&quot;课程讲师&quot;&gt; &lt;el-select v-model=&quot;courseInfo.teacherId&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;teacher in teacherList&quot; :key=&quot;teacher.id&quot; :label=&quot;teacher.name&quot; :value=&quot;teacher.id&quot; /&gt; &lt;/el-select&gt;&lt;/el-form-item&gt; 然后编写vue中对应方法即可 12345getListTeacher() &#123; teacherApi.getTeacherList().then(result =&gt; &#123; this.teacherList = result.data.teacherList &#125;)&#125;, 显示二级联动下拉列表（前端） 后端课程分类模块写好了，使用之前的即可 先获得并保存并初始化显示所有一级分类 12345getOneSubject() &#123; subjectApi.getSubjectList().then(result =&gt; &#123; this.subjectOneList = result.data.list &#125;)&#125;, 实现二级联动，为一级分类下拉列表添加@change对应方法 注意此处el-option绑定了value值赋值为id，所以直接获取即可 12345678910111213// 二级联动,value为绑定的数据（:value=&quot;subject.id&quot;）subjectLevelOneChanged(value) &#123; // 根据id便利subjectOneList获得其children赋值给二级分类 for (var i = 0; i &lt; this.subjectOneList.length; i++) &#123; // 判断：所有一级分类id 和 点击一级分类id是否一样 if (value === this.subjectOneList[i].id) &#123; // 从一级分类获取里面所有的二级分类 this.subjectTwoList = this.subjectOneList[i].children // 把二级分类id值清空 this.courseInfo.subjectId = &#x27;&#x27; &#125; &#125;&#125;, 测试是有一个错误，course表上添加的数据没有父分类id，看了下是我在vo对象把这个属性注释了（因为之前有null错误），记得重启 富文本编辑器 直接整合，指cv 复制组件和静态资源 字面意思 配置变量 再配置html变量，build -&gt; webpack.dev.conf.js 中如下添加（注意所在位置，其他不要变） 12345678910111213141516171819 plugins: [ new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: require(&#x27;../config/dev.env&#x27;) &#125;), new webpack.HotModuleReplacementPlugin(), // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, template: &#x27;index.html&#x27;, inject: true, favicon: resolve(&#x27;favicon.ico&#x27;), title: &#x27;vue-admin-template&#x27;, // 修改配置 templateParameters: &#123; BASE_URL: config.dev.assetsPublicPath + config.dev.assetsSubDirectory &#125; &#125;) ]&#125;) 引入脚本文件 在index.html引入脚本文件，报错是找不到BASE_URL，之前改了配置重启就行 12&lt;script src=&lt;%=BASE_URL %&gt;/tinymce4.7.5/tinymce.min.js &gt;&lt;/script&gt;&lt;script src=&lt;%=BASE_URL %&gt;/tinymce4.7.5/langs/zh_CN.js &gt;&lt;/script&gt; 引入声明组件12345import Tinymce from &#x27;@/components/Tinymce&#x27; //引入组件 export default &#123; // 声明组件 components: &#123; Tinymce &#125;, &#125; 使用组件1&lt;tinymce :height=&quot;300&quot; v-model=&quot;courseInfo.description&quot; /&gt; 测试了一下，注意数据库中的字段属性改为longtext，要不然图片传上去后端报错Data truncation: Data too long for column &#39;description&#39; 显示课程章节（后端）创建章节实体类 类似于一级二级分类即可 编写controller12345678910111213141516@RestController@RequestMapping(&quot;/eduservice/chapter&quot;)@CrossOrigin // 跨域public class EduChapterController &#123; @Autowired private EduChapterService chapterService; // 获得课程大纲列表(根据id @GetMapping(&quot;getChapterVideo/&#123;courseId&#125;&quot;) public R getChapterVideo(@PathVariable(&quot;courseId&quot;) String courseId) &#123; List&lt;ChapterVo&gt; list = chapterService.getChapterVideoByCourseId(courseId); return R.ok().data(&quot;chapterVideoList&quot;, list); &#125; &#125; 编写service 不优雅 12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class EduChapterServiceImpl extends ServiceImpl&lt;EduChapterMapper, EduChapter&gt; implements EduChapterService &#123; @Autowired private EduVideoService videoService; @Override public List&lt;ChapterVo&gt; getChapterVideoByCourseId(String courseId) &#123; // 获得对应id课程的所有章节 QueryWrapper&lt;EduChapter&gt; chapterWrapper = new QueryWrapper&lt;&gt;(); chapterWrapper.eq(&quot;course_id&quot;, courseId); List&lt;EduChapter&gt; chapterList = baseMapper.selectList(chapterWrapper); // 获得对应id课程的所有小节 QueryWrapper&lt;EduVideo&gt; videoWrapper = new QueryWrapper&lt;&gt;(); videoWrapper.eq(&quot;course_id&quot;, courseId); List&lt;EduVideo&gt; videoList = videoService.list(videoWrapper); // 封装 List&lt;ChapterVo&gt; finalList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; chapterList.size(); i++) &#123; EduChapter eduChapter = chapterList.get(i); ChapterVo chapterVo = new ChapterVo(); BeanUtils.copyProperties(eduChapter, chapterVo); List&lt;VideoVo&gt; children = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; videoList.size(); j++) &#123; EduVideo eduVideo = videoList.get(j); if (eduVideo.getChapterId().equals(chapterVo.getId())) &#123; VideoVo videoVo = new VideoVo(); BeanUtils.copyProperties(eduVideo, videoVo); children.add(videoVo); &#125; &#125; chapterVo.setChildren(children); finalList.add(chapterVo); &#125; return finalList; &#125;&#125; 显示课程章节（前端）api1234567891011import request from &#x27;@/utils/request&#x27;export default &#123; // 获得所有以及分类 getChapterVideo(courseId) &#123; return request(&#123; url: `/eduservice/chapter/getChapterVideo/$&#123;courseId&#125;`, method: &#x27;get&#x27;, &#125;) &#125;&#125; vue视图模板和初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;发布新课程&lt;/h2&gt; &lt;!-- 步骤条 --&gt; &lt;el-steps :active=&quot;2&quot; process-status=&quot;wait&quot; align-center style=&quot;margin-bottom: 40px&quot; &gt; &lt;el-step title=&quot;填写课程基本信息&quot; /&gt; &lt;el-step title=&quot;创建课程大纲&quot; /&gt; &lt;el-step title=&quot;最终发布&quot; /&gt; &lt;/el-steps&gt; &lt;el-button type=&quot;text&quot; @click=&quot;openChapterDialog()&quot;&gt;添加章节&lt;/el-button&gt; &lt;!-- 章节列表 --&gt; &lt;ul class=&quot;chapterList&quot;&gt; &lt;li v-for=&quot;chapter in chapterVideoList&quot; :key=&quot;chapter.id&quot;&gt; &lt;p&gt; &#123;&#123; chapter.title &#125;&#125; &lt;span class=&quot;acts&quot;&gt; &lt;el-button style=&quot;&quot; type=&quot;text&quot; @click=&quot;openVideo(chapter.id)&quot; &gt;添加小节&lt;/el-button &gt; &lt;el-button style=&quot;&quot; type=&quot;text&quot; @click=&quot;openEditChatper(chapter.id)&quot; &gt;编辑&lt;/el-button &gt; &lt;el-button type=&quot;text&quot; @click=&quot;removeChapter(chapter.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/span&gt; &lt;/p&gt; &lt;!-- 视频 --&gt; &lt;ul class=&quot;chapterList videoList&quot;&gt; &lt;li v-for=&quot;video in chapter.children&quot; :key=&quot;video.id&quot;&gt; &lt;p&gt; &#123;&#123; video.title &#125;&#125; &lt;span class=&quot;acts&quot;&gt; &lt;el-button style=&quot;&quot; type=&quot;text&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; @click=&quot;removeVideo(video.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 操作 --&gt; &lt;div&gt; &lt;el-button @click=&quot;previous&quot;&gt;上一步&lt;/el-button&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;next&quot; &gt;下一步&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import chapterApi from &#x27;@/api/edu/chapter&#x27; export default &#123; data() &#123; return &#123; saveBtnDisabled: false, courseId: &#x27;&#x27;, // 课程id chapterVideoList: [] &#125; &#125;, created() &#123; // 获取到路由中的id值 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.courseId = this.$route.params.id this.getChapterVideo() &#125; &#125;, methods: &#123; // 根据id查询章节和小节 getChapterVideo() &#123; chapterApi.getChapterVideo(this.courseId).then(result =&gt; &#123; this.chapterVideoList = result.data.chapterVideoList &#125;) &#125;, previous() &#123; this.$router.push(&#123; path: &#x27;/course/info/&#x27; + this.courseId &#125;) &#125;, next() &#123; // 跳转到第二步 this.$router.push(&#123; path: &#x27;/course/publish/&#x27; + this.courseId &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .chapterList &#123; position: relative; list-style: none; margin: 0; padding: 0; &#125; .chapterList li &#123; position: relative; &#125; .chapterList p &#123; float: left; font-size: 20px; margin: 10px 0; padding: 10px; height: 70px; line-height: 50px; width: 100%; border: 1px solid #ddd; &#125; .chapterList .acts &#123; float: right; font-size: 14px; &#125; .videoList &#123; padding-left: 50px; &#125; .videoList p &#123; float: left; font-size: 14px; margin: 10px 0; padding: 10px; height: 50px; line-height: 30px; width: 100%; border: 1px dotted #ddd; &#125;&lt;/style&gt; 修改课程信息（后端） “上一步”回显方法：根据id查询课程基本信息 修改课程信息 回显课程信息编写controller123456// 根据id查询基本信息@GetMapping(&quot;getCourseInfo/&#123;courseId&#125;&quot;)public R getCourseInfo(@PathVariable String courseId) &#123; CourseInfoVo courseInfoVo = courseService.getCourseInfoById(courseId); return R.ok().data(&quot;courseInfo&quot;, courseInfoVo);&#125; 编写service12345678910111213// 根据id获得课程Vo@Overridepublic CourseInfoVo getCourseInfoById(String courseId) &#123; // 先查课程表 EduCourse eduCourse = baseMapper.selectById(courseId); // 再查课程描述表 EduCourseDescription courseDescription = courseDescriptionService.getById(courseId); // 封装 CourseInfoVo courseInfoVo = new CourseInfoVo(); BeanUtils.copyProperties(eduCourse, courseInfoVo); courseInfoVo.setDescription(courseDescription.getDescription()); return courseInfoVo;&#125; 修改课程信息编写controller123456// 修改课程信息@PostMapping(&quot;updateCourseInfo&quot;)public R updateCourseInfo(@RequestBody CourseInfoVo courseInfoVo) &#123; courseService.updateCourseInfo(courseInfoVo); return R.ok();&#125; 编写service123456789101112131415// 修改课程信息@Overridepublic void updateCourseInfo(CourseInfoVo courseInfoVo) &#123; // 修改课程表 EduCourse eduCourse = new EduCourse(); BeanUtils.copyProperties(courseInfoVo, eduCourse); int affectRow = baseMapper.updateById(eduCourse); if (affectRow &lt;= 0) &#123; throw new GuliException(20001, &quot;修改课程失败&quot;); &#125; // 修改课程描述表 EduCourseDescription courseDescription = new EduCourseDescription(); BeanUtils.copyProperties(courseInfoVo, courseDescription); courseDescriptionService.updateById(courseDescription);&#125; 修改课程信息（前端）api src -&gt; api -&gt; edu -&gt; course.js 123456789101112131415// 根据id获得课程信息 getCourseInfoById(id) &#123; return request(&#123; url: `/eduservice/course/getCourseInfo/` + id, method: &#x27;get&#x27;, &#125;) &#125;, // 修改课程信息 updateCourseInfo(courseInfo) &#123; return request(&#123; url: `/eduservice/course/updateCourseInfo`, method: &#x27;post&#x27;, data: courseInfo &#125;) &#125;, 回显vue视图和方法表单回显数据 记得在跳转到info页面的按钮上添加id的值 12345678910111213141516171819202122&lt;script&gt; import courseApi from &#x27;@/api/edu/course&#x27; export default &#123; data() &#123; &#125;, created() &#123; // 判断是否需要数据回显 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.courseId = this.$route.params.id this.getCourseInfo() &#125; &#125;, methods: &#123; // 根据id获得课程信息 getCourseInfo() &#123; courseApi.getCourseInfoById(this.courseId).then(result =&gt; &#123; this.courseInfo = result.data.courseInfo &#125;) &#125;, &#125; &#125;&lt;/script&gt; 这里需要注意，返回该页面回显数据中，courseInfo的二级分类列表subjectTwoList只有在一级分类change的时候才会重新显示，否则该列表会显示绑定的courseInfo.subjectId，所以需要完善 下拉列表数据回显123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script&gt; export default &#123; watch: &#123; // 监听路由是否发生了变化，如果是则清除当前页面的数据 $route(to, from) &#123; if (!this.$route.params || !this.$route.params.id) &#123; this.courseInfo = &#123;&#125; &#125; &#125; &#125;, created() &#123; // 获取路由id值 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; this.courseId = this.$route.params.id // 调用根据id查询课程的方法 this.getCourseInfo() &#125; else &#123; // 初始化所有讲师 this.getListTeacher() // 初始化一级分类 this.getOneSubject() &#125; &#125;, methods: &#123; // 根据id获得课程信息 getCourseInfo() &#123; courseApi.getCourseInfoById(this.courseId).then(response =&gt; &#123; // 在courseInfo课程基本信息，包含 一级分类id 和 二级分类id this.courseInfo = response.data.courseInfo // 1 查询所有的分类，包含一级和二级 subjectApi.getSubjectList().then(response =&gt; &#123; // 2 获取所有一级分类 this.subjectOneList = response.data.list // 3 把所有的一级分类数组进行遍历， for (var i = 0; i &lt; this.subjectOneList.length; i++) &#123; // 获取每个一级分类 var oneSubject = this.subjectOneList[i] // 比较当前courseInfo里面一级分类id和所有的一级分类id if (this.courseInfo.subjectParentId == oneSubject.id) &#123; // 获取一级分类所有的二级分类 this.subjectTwoList = oneSubject.children &#125; &#125; &#125;) // 初始化所有讲师 this.getListTeacher() &#125;) &#125;, &#125; &#125;&lt;/script&gt; 测试，这里很奇怪，我把获得二级列表方法封装了出来，结构顺序都一样的但是测试的时候一开始能显示，后面又不行了，我不理解 修改vue视图和方法12345678910111213141516171819202122232425262728293031323334// 点击下一步next() &#123; // 判断是添加还是修改 if (this.courseInfo.id) &#123; this.updateCourse() &#125; else &#123; this.addCourse() &#125;&#125;,// 添加courseaddCourse() &#123; // 调用后端接口传入数据 courseApi.addCourseInfo(this.courseInfo).then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加成功!&#x27; &#125;) // 跳转到第二步，同时传递id值 this.$router.push(&#123; path: &#x27;/course/chapter/&#x27; + result.data.courseId &#125;) &#125;)&#125;,// 修改courseupdateCourse() &#123; courseApi.updateCourseInfo(this.courseInfo).then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;,s message: &#x27;修改成功!&#x27; &#125;) // 跳转到第二步，同时传递id值 this.$router.push(&#123; path: &#x27;/course/chapter/&#x27; + this.courseId &#125;) &#125;)&#125; 增、删、改课程章节（后端）编写controller1234567891011121314151617181920212223242526272829303132@RestController@RequestMapping(&quot;/eduservice/chapter&quot;)@CrossOrigin // 跨域public class EduChapterController &#123; @Autowired private EduChapterService chapterService; // 根据章节id查询章节 @GetMapping(&quot;getChapterInfo/&#123;chapterId&#125;&quot;) public R getChapterInfo(@PathVariable(&quot;chapterId&quot;) String chapterId) &#123; EduChapter chapter = chapterService.getById(chapterId); return R.ok().data(&quot;chapterInfo&quot;, chapter); &#125; // 添加章节 @PostMapping(&quot;addChapter&quot;) public R addChapter(@RequestBody EduChapter eduChapter) &#123; chapterService.save(eduChapter); return R.ok(); &#125; // 修改章节 @PostMapping(&quot;updateChapter&quot;) public R updateChapter(@RequestBody EduChapter eduChapter) &#123; chapterService.updateById(eduChapter); return R.ok(); &#125; // 删除章节 @DeleteMapping(&quot;&#123;chapterId&#125;&quot;) public R deleteChapter(@PathVariable(&quot;chapterId&quot;) String chapterId) &#123; // 自定义方法，如果有小节则不让删 Boolean b = chapterService.deleteChapter(chapterId); return b ? R.ok() : R.error(); &#125;&#125; 编写service123456789101112131415// 删除章节@Overridepublic Boolean deleteChapter(String chapterId) &#123; // 根据id判断是否有小节 QueryWrapper&lt;EduVideo&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;chapter_id&quot;, chapterId); // 获得小节数 int count = videoService.count(queryWrapper); if (count &gt; 0) &#123; throw new GuliException(20001, &quot;含有小节无法删除&quot;); &#125; else &#123; int row = baseMapper.deleteById(chapterId); return row &gt; 0; &#125;&#125; 增、删、改课程章节（前端）api123456789101112131415161718192021222324252627282930313233import request from &#x27;@/utils/request&#x27;export default &#123; // 添加章节 addChapter(chapter) &#123; return request(&#123; url: `/eduservice/chapter/addChapter`, method: &#x27;post&#x27;, data: chapter &#125;) &#125;, // 根据id查询章节 getChapterInfo(chapterId) &#123; return request(&#123; url: `/eduservice/chapter/getChapterInfo/` + chapterId, method: &#x27;get&#x27;, &#125;) &#125;, // 修改章节 updateChapter(chapter) &#123; return request(&#123; url: `/eduservice/chapter/updateChapter`, method: &#x27;post&#x27;, data: chapter &#125;) &#125;, // 删除章节 deleteChapter(chapterId) &#123; return request(&#123; url: `/eduservice/chapter/` + chapterId, method: &#x27;delete&#x27;, &#125;) &#125;,&#125; vue视图模板 element-ui dialog cv就完事了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 添加章节按钮 --&gt; &lt;el-button type=&quot;text&quot; @click=&quot;dialogChapterFormVisible = true&quot; &gt;添加章节&lt;/el-button &gt; &lt;!-- 添加和修改章节表单 --&gt; &lt;el-dialog :visible.sync=&quot;dialogChapterFormVisible&quot; title=&quot;添加章节&quot;&gt; &lt;el-form :model=&quot;chapter&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;章节标题&quot;&gt; &lt;el-input v-model=&quot;chapter.title&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;章节排序&quot;&gt; &lt;el-input-number v-model=&quot;chapter.sort&quot; :min=&quot;0&quot; controls-position=&quot;right&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogChapterFormVisible = false&quot; &gt;取 消&lt;/el-button &gt; &lt;el-button type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot; &gt;确 定&lt;/el-button &gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import chapterApi from &#x27;@/api/edu/chapter&#x27; export default &#123; data() &#123; return &#123; saveBtnDisabled: false, courseId: &#x27;&#x27;, // 课程id chapterVideoList: [], chapter: &#123; // 封装章节数据 title: &#x27;&#x27;, sort: 0 &#125;, video: &#123; title: &#x27;&#x27;, sort: 0, free: 0, videoSourceId: &#x27;&#x27; &#125;, dialogChapterFormVisible: false, // 章节弹框 dialogVideoFormVisible: false // 小节弹框 &#125; &#125;, &#125;&lt;/script&gt; vue方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990saveOrUpdate() &#123; if (this.chapter.id) &#123; this.updateChapter() &#125; else &#123; this.addChapter() &#125;&#125;,// 添加章节addChapter() &#123; // 记得添加id this.chapter.courseId = this.courseId // 调用api chapterApi.addChapter(this.chapter).then(result =&gt; &#123; // 关闭弹框 this.dialogChapterFormVisible = false // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加章节成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() // 清空弹框表单内容 this.chapter = &#123; title: &#x27;&#x27;, sort: 0 &#125; &#125;)&#125;,// 修改章节,显示弹框，数据回显openEditChatper(chapterId) &#123; // 弹框 this.openChapterDialog() // api chapterApi.getChapterInfo(chapterId).then(result =&gt; &#123; this.chapter = result.data.chapterInfo &#125;)&#125;,// 修改章节updateChapter() &#123; // 调用api chapterApi.updateChapter(this.chapter).then(result =&gt; &#123; // 关闭弹框 this.dialogChapterFormVisible = false // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;修改章节成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() &#125;)&#125;,// 删除章节removeChapter(chapterId) &#123; this.$confirm(&#x27;此操作将永久删除该章节记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(result =&gt; &#123; chapterApi .deleteChapter(chapterId) .then(result =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() &#125;) .catch(err =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;删除失败!&#x27; &#125;) &#125;) &#125;)&#125;,// 弹出章节弹框openChapterDialog() &#123; // 弹框 this.dialogChapterFormVisible = true // 清空弹框表单内容 this.chapter = &#123; title: &#x27;&#x27;, sort: 0 &#125;&#125;,// 根据id查询章节和小节getChapterVideo() &#123; chapterApi.getChapterVideo(this.courseId).then(result =&gt; &#123; this.chapterVideoList = result.data.chapterVideoList &#125;)&#125;, 增、删、改小节（后端）（待完善） 已完善，详见项目笔记4 controller12345678910111213141516171819202122232425262728293031323334353637@RestController@RequestMapping(&quot;/eduservice/video&quot;)@CrossOrigin // 跨域public class EduVideoController &#123; @Autowired private EduVideoService videoService; // 添加小节 @PostMapping(&quot;addVideo&quot;) public R addVideo(@RequestBody EduVideo eduVideo) &#123; videoService.save(eduVideo); return R.ok(); &#125; // 删除小节 @DeleteMapping(&quot;&#123;videoId&#125;&quot;) public R deleteVideo(@PathVariable(&quot;videoId&quot;) String videoId) &#123; videoService.removeById(videoId); return R.ok(); &#125; // 修改小节 @PostMapping(&quot;updateVideo&quot;) public R updateVideo(@RequestBody EduVideo eduVideo) &#123; videoService.updateById(eduVideo); return R.ok(); &#125; // 根据小节id查询小节 @GetMapping(&quot;getVideoInfo/&#123;videoId&#125;&quot;) public R getVideoInfo(@PathVariable(&quot;videoId&quot;) String videoId) &#123; EduVideo video = videoService.getById(videoId); return R.ok().data(&quot;videoInfo&quot;, video); &#125;&#125; 增、删、改小节（前端）（待完善）api123456789101112131415161718192021222324252627282930313233import request from &#x27;@/utils/request&#x27;export default &#123; // 添加小节 addVideo(video) &#123; return request(&#123; url: `/eduservice/video/addVideo`, method: &#x27;post&#x27;, data: video &#125;) &#125;, // 删除小节 deleteVideo(videoId) &#123; return request(&#123; url: `/eduservice/video/` + videoId, method: &#x27;delete&#x27;, &#125;) &#125;, // 修改小节 updateVideo(video) &#123; return request(&#123; url: `/eduservice/video/updateVideo`, method: &#x27;post&#x27;, data: video &#125;) &#125;, // 根据id获得小节信息 getVideoInfo(videoId) &#123; return request(&#123; url: `/eduservice/video/getVideoInfo/` + videoId, method: &#x27;get&#x27;, &#125;) &#125;&#125; vue模板 和章节类似，有一个添加或者删除的弹窗 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 添加和修改小节表单 --&gt;&lt;el-dialog :visible.sync=&quot;dialogVideoFormVisible&quot; title=&quot;添加课时&quot;&gt; &lt;el-form :model=&quot;video&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;课时标题&quot;&gt; &lt;el-input v-model=&quot;video.title&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课时排序&quot;&gt; &lt;el-input-number v-model=&quot;video.sort&quot; :min=&quot;0&quot; controls-position=&quot;right&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;是否免费&quot;&gt; &lt;el-radio-group v-model=&quot;video.free&quot;&gt; &lt;el-radio :label=&quot;true&quot;&gt;免费&lt;/el-radio&gt; &lt;el-radio :label=&quot;false&quot;&gt;默认&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;上传视频&quot;&gt; &lt;!-- TODO --&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVideoFormVisible = false&quot; &gt;取 消&lt;/el-button &gt; &lt;el-button :disabled=&quot;saveVideoBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdateVideo&quot; &gt;确 定&lt;/el-button &gt; &lt;/div&gt;&lt;/el-dialog&gt; vue方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354methods: &#123; // ++++++++++++++++++小节操作+++++++++++++++++++++ // 打开小节编辑弹框 openEditVideo(id) &#123; // 弹框 this.dialogVideoFormVisible = true // 设置章节id this.video.chapterId = id &#125;, // 添加小节 addVideo() &#123; // 设置课程id this.video.courseId = this.courseId videoApi.addVideo(this.video).then(response =&gt; &#123; // 关闭弹框 this.dialogVideoFormVisible = false // 提示 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加小节成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() &#125;) &#125;, // 修改小节 updateVideo() &#123;&#125;, // 删除小节 removeVideo(id) &#123; this.$confirm(&#x27;此操作将删除小节, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;).then(() =&gt; &#123; // 点击确定，执行then方法 // 调用删除的方法 videoApi.deleteVideo(id).then(response =&gt; &#123; // 删除成功 // 提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除小节成功!&#x27; &#125;) // 刷新页面 this.getChapterVideo() &#125;) &#125;) // 点击取消，执行catch方法 &#125;, saveOrUpdateVideo() &#123; // 先写add，学了视频上传在修改 this.addVideo() &#125;, // ++++++++++++++++++小节操作+++++++++++++++++++++&#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【项目笔记】在线教育项目实战2","slug":"【项目笔记】在线教育项目实战2","date":"2021-09-21T07:51:30.374Z","updated":"2021-10-08T11:41:58.618Z","comments":true,"path":"2021/09/21/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-2/","link":"","permalink":"http://example.com/2021/09/21/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-2/","excerpt":"","text":"前端技术点简单介绍 一下技术点详见其官方文档或者课件，我就瞄了几眼，之前多多少少也学过了 ES6 Vue axios node.js babel 模块化 webpack 搭建前端环境与框架开发过程vscode创建工作区 新建一个空文件夹 用VSCode打开该文件夹 选择菜单栏 文件 -&gt; 将文件夹另存为工作区 即可 测试运行npm 复制template文件夹至工作区 安装依赖npm install npm run dev测试 config -&gt; index.js -&gt; useEslint = false关闭代码检查 vue项目实现 src -&gt; router -&gt; index.js 添加路由 views -&gt; xxx -&gt; xxx.vue 创建vue页面 api -&gt; xxx.js 定义接口地址和参数 在vue页面引入js文件，调用方法实现功能 用户登录和跨域（后端+前端）修改BASE_API（请求路径前缀） config -&gt; dev.env.js文件 123456module.exports = merge(prodEnv, &#123; NODE_ENV: &#x27;&quot;development&quot;&#x27;, // BASE_API: &#x27;&quot;https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin&quot;&#x27;, // 注意这里要使用http BASE_API: &#x27;&quot;http://localhost:8001&quot;&#x27;,&#125;) 编写loginController 先跳过数据库验证 12345678910111213141516171819202122232425262728293031package com.atguigu.eduservice.controller;import com.atguigu.commonutils.R;import io.swagger.annotations.Api;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Api(&quot;后台登录&quot;)@RestController@RequestMapping(&quot;/eduservice/user&quot;)@CrossOrigin // 解决跨域问题public class EduLoginController &#123; // 登录 @PostMapping(&quot;login&quot;) public R login() &#123; // 先跳过验证 // 此处token需要与前端对应 return R.ok().data(&quot;token&quot;, &quot;admin&quot;); &#125; // 获得用户数据 @GetMapping(&quot;info&quot;) public R info() &#123; return R.ok().data(&quot;roles&quot;, &quot;[admin]&quot;).data(&quot;name&quot;, &quot;admin&quot;).data(&quot;avatar&quot;, &quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;); &#125; &#125; 修改前端访问路径 修改api文件夹下的login.js里的接口路径即可 123456789101112131415161718export function login(username, password) &#123; return request(&#123; url: &#x27;/eduservice/user/login&#x27;, method: &#x27;post&#x27;, data: &#123; username, password &#125; &#125;)&#125;export function getInfo(token) &#123; return request(&#123; url: &#x27;/eduservice/user/info&#x27;, method: &#x27;get&#x27;, params: &#123; token &#125; &#125;)&#125; 跨域问题 访问地址的时候，以下任何一个地方不同，会产生跨域问题： 访问协议 IP地址 端口号 在后端controller接口上添加注解@CrossOrigin即可（常用） 使用网关解决 讲师管理模块（前端）讲师列表添加路由 src\\router\\index.js -&gt; constantRouterMap -&gt; children -&gt; component 1234567891011121314151617181920212223242526export const constantRouterMap = [ // …… &#123; path: &#x27;/teacher&#x27;, component: Layout, redirect: &#x27;/teacher/table&#x27;, name: &#x27;讲师管理&#x27;, meta: &#123; title: &#x27;讲师管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;讲师列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/list&#x27;), meta: &#123; title: &#x27;讲师列表&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加讲师&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;添加讲师&#x27;, icon: &#x27;tree&#x27; &#125; &#125; ] &#125;, // …… &#125; 创建并编写js文件（调用接口） src\\api\\edu\\teacher.js 12345678910111213141516import request from &#x27;@/utils/request&#x27;export default &#123; // 查询讲师列表（带条件分页） getTeacherListPage(current, limit, teacherQuery) &#123; return request(&#123; // url可使用字符串拼接，但是最好用反引号 url: `/eduservice/teacher/pageTeacherCondition/$&#123;current&#125;/$&#123;limit&#125;`, method: &#x27;post&#x27;, // 后端使用requestBody获取teacherQuery，此时需要用data（将teacherQuery转换为JSON格式传输） data: teacherQuery &#125;) &#125;&#125; 创建vue页面，通过接口获取数据 注意routerMap中的对应对象（即创建的router）中component对应的地址，就是vue组件的地址，在该地址下创建vue文件 src\\views\\edu\\teacher\\list.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt;讲师列表&lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; data() &#123; return &#123; list: null, // 查询接口之后获得的列表 page: 1, // 当前页 limit: 10, // 每页记录数 total: 0, // 总记录数 teacherQuery: &#123;&#125;, // 条件值对象 &#125;; &#125;, created() &#123; this.getList(); &#125;, methods: &#123; // 获得讲师列表 getList() &#123; teacher .getTeacherListPage(this.page, this.limit, this.teacherQuery) .then((response) =&gt; &#123; // console.log(response); this.list = response.data.records; this.total = response.data.total; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; 编写列表格式代码 使用element-ui表格即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 表格 --&gt; &lt;el-table :data=&quot;list&quot; border fit highlight-current-row&gt; &lt;el-table-column label=&quot;序号&quot; width=&quot;70&quot; header-align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;名称&quot; width=&quot;80&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;头衔&quot; width=&quot;80&quot; header-align=&quot;center&quot;&gt; &lt;!-- 使用template slot-scope 进行判断显示 --&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.level === 1 ? &quot;高级讲师&quot; : &quot;首席讲师&quot; &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;intro&quot; label=&quot;资历&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column prop=&quot;gmtCreate&quot; label=&quot;添加时间&quot; width=&quot;160&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column prop=&quot;sort&quot; label=&quot;排序&quot; width=&quot;60&quot; header-align=&quot;center&quot;/&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt; 添加分页条 使用element-ui分页即可 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 表格 --&gt; &lt;!-- 分页条 --&gt; &lt;!-- @current-change=&quot;getList&quot; 只需要写方法名即可，自动传入需要跳转的页数 --&gt; &lt;el-pagination :current-page=&quot;page&quot; :page-size=&quot;limit&quot; :total=&quot;total&quot; style=&quot;padding: 30px 0; text-align: center&quot; layout=&quot;total, prev, pager, next, jumper&quot; @current-change=&quot;getList&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; // …… methods: &#123; // 获得讲师列表，page默认为1 getList(page = 1) &#123; this.page = page; teacher .getTeacherListPage(this.page, this.limit, this.teacherQuery) .then((response) =&gt; &#123; // console.log(response); this.list = response.data.records; this.total = response.data.total; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; 条件查询分页 使用element-ui表单即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!--查询表单--&gt; &lt;el-form :inline=&quot;true&quot; class=&quot;demo-form-inline&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model=&quot;teacherQuery.name&quot; placeholder=&quot;讲师名&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-select v-model=&quot;teacherQuery.level&quot; clearable placeholder=&quot;讲师头衔&quot; &gt; &lt;el-option :value=&quot;1&quot; label=&quot;高级讲师&quot; /&gt; &lt;el-option :value=&quot;2&quot; label=&quot;首席讲师&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;添加时间&quot;&gt; &lt;el-date-picker v-model=&quot;teacherQuery.begin&quot; type=&quot;datetime&quot; placeholder=&quot;选择开始时间&quot; value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; default-time=&quot;00:00:00&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-date-picker v-model=&quot;teacherQuery.end&quot; type=&quot;datetime&quot; placeholder=&quot;选择截止时间&quot; value-format=&quot;yyyy-MM-dd HH:mm:ss&quot; default-time=&quot;00:00:00&quot; /&gt; &lt;/el-form-item&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot; @click=&quot;getList()&quot; &gt;查询&lt;/el-button &gt; &lt;el-button type=&quot;default&quot; @click=&quot;resetData()&quot;&gt;清空&lt;/el-button&gt; &lt;/el-form&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacher from &quot;@/api/edu/teacher.js&quot;; export default &#123; methods: &#123; // 获得讲师列表，page默认为1 getList(page = 1) &#123; &#125;, //清空表单输入项数据 resetData() &#123; this.teacherQuery = &#123;&#125;; //查询所有讲师数据 this.getList(); &#125;, &#125;, &#125;;&lt;/script&gt; 删除讲师添加页面结构按钮 记得绑定对应方法名 slot插槽，Vue - slot-scope=”scope” 的意义 - 武卡卡 - 博客园 (cnblogs.com) 12345678910111213141516171819&lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt;&lt;/el-table-column&gt; 编写接口调用方法 先去api文件夹下编写调用接口的方法 teacher.js 12345678910111213import request from &#x27;@/utils/request&#x27;export default &#123; // 根据id删除讲师 deleteTeacherById(id) &#123; return request(&#123; url: `/eduservice/teacher/$&#123;id&#125;`, method: &#x27;delete&#x27;, &#125;) &#125;&#125; 编写按钮对应方法 编写按钮对应方法，考虑到用户体验，添加element-ui弹框提示 1234567891011121314151617181920212223242526272829303132removeDataById(id) &#123; this.$confirm(&#x27;此操作将永久删除该讲师记录, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27; &#125;) .then(() =&gt; &#123; // 调用删除接口 teacher .deleteTeacherById(id) .then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;) // 刷新列表信息 // 如果是最后一页最后一个记录（total-(page-1)*limit == 1） if (this.total - (this.page - 1) * this.limit == 1) &#123; this.getList(this.page - 1) &#125; else &#123; this.getList(this.page) &#125; &#125;) &#125;) .catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;) &#125;)&#125; 当前项目结构 添加讲师添加页面结构 src\\views\\edu\\teacher\\save.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;讲师名称&quot;&gt; &lt;el-input v-model=&quot;teacher.name&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师排序&quot;&gt; &lt;el-input-number v-model=&quot;teacher.sort&quot; controls-position=&quot;right&quot; min=&quot;0&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师头衔&quot;&gt; &lt;el-select v-model=&quot;teacher.level&quot; clearable placeholder=&quot;请选择&quot; &gt; &lt;el-option :value=&quot;1&quot; label=&quot;高级讲师&quot; /&gt; &lt;el-option :value=&quot;2&quot; label=&quot;首席讲师&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师资历&quot;&gt; &lt;el-input v-model=&quot;teacher.career&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;讲师简介&quot;&gt; &lt;el-input v-model=&quot;teacher.intro&quot; :rows=&quot;10&quot; type=&quot;textarea&quot; /&gt; &lt;/el-form-item&gt; &lt;!-- 讲师头像：TODO --&gt; &lt;el-form-item&gt; &lt;el-button :disabled=&quot;saveBtnDisabled&quot; type=&quot;primary&quot; @click=&quot;saveOrUpdate&quot; &gt;保存&lt;/el-button &gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import teacherApi from &#x27;@/api/edu/teacher.js&#x27; export default &#123; data() &#123; return &#123; teacher: &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125;, saveBtnDisabled: false &#125; &#125;, created() &#123;&#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 编写接口调用方法12345678// 添加讲师addTeacher(teacher) &#123; return request(&#123; url: `/eduservice/teacher/addTeacher`, method: &#x27;post&#x27;, data: teacher &#125;)&#125; 编写按钮对应方法1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt; // 引入调用接口的js文件 import teacherApi from &#x27;@/api/edu/teacher.js&#x27; export default &#123; data() &#123; return &#123; teacher: &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125;, saveBtnDisabled: false &#125; &#125;, created() &#123;&#125;, methods: &#123; // 添加和修改使用同一个页面 saveOrUpdate() &#123; this.saveTeacher() &#125;, saveTeacher() &#123; teacherApi.addTeacher(this.teacher).then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加成功!&#x27; &#125;) // 路由跳转到列表页面 this.$router.push(&#123; path: &#x27;/teacher/list&#x27; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 优化讲师列表排序 根据添加时间降序 123456789101112131415@ApiOperation(&quot;多条件组合分页&quot;)@PostMapping(&quot;pageTeacherCondition/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacherCondition(@PathVariable long current, @PathVariable long limit, @RequestBody(required = false) TeacherQuery teacherQuery) &#123; // …… // 添加排序条件 wrapper.orderByDesc(&quot;gmt_create&quot;); // 调用service方法将page对象根据条件分页 teacherService.page(pageTeacher, wrapper); // ……&#125; 修改讲师编写页面结构1234567891011121314151617181920&lt;el-table-column label=&quot;操作&quot; width=&quot;200&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!-- router跳转 --&gt; &lt;router-link :to=&quot;&#x27;/teacher/edit/&#x27; + scope.row.id&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; icon=&quot;el-icon-edit&quot; &gt;修改&lt;/el-button &gt; &lt;/router-link&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; icon=&quot;el-icon-delete&quot; @click=&quot;removeDataById(scope.row.id)&quot; &gt;删除&lt;/el-button &gt; &lt;/template&gt;&lt;/el-table-column&gt; 隐藏路由 此处需要额外添加router，且不显示 123456789101112131415161718192021222324252627282930313233export const constantRouterMap = [&#123; path: &#x27;/teacher&#x27;, component: Layout, redirect: &#x27;/teacher/table&#x27;, name: &#x27;讲师管理&#x27;, meta: &#123; title: &#x27;讲师管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;讲师列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/list&#x27;), meta: &#123; title: &#x27;讲师列表&#x27;, icon: &#x27;table&#x27; &#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加讲师&#x27;, component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;添加讲师&#x27;, icon: &#x27;tree&#x27; &#125; &#125;, &#123; // 带有id参数，：为占位符 path: &#x27;edit/:id&#x27;, name: &#x27;EduTeacherEdit&#x27;, // 此处进入的vue组件为save.vue component: () =&gt; import(&#x27;@/views/edu/teacher/save&#x27;), meta: &#123; title: &#x27;编辑讲师&#x27;, icon: &#x27;tree&#x27; &#125;, // 不显示该路由 hidden: true &#125; ] &#125;,] 数据回显 编写后端接口调用方法 1234567// 根据id获取讲师信息getTeacherInfo(id) &#123; return request(&#123; url: `/eduservice/teacher/getTeacher/$&#123;id&#125;`, method: &#x27;get&#x27;, &#125;)&#125; 编写调用该方法，注意要在需要显示该信息的组件中调用该方法 1234567891011121314151617181920&lt;script&gt;export default &#123; created() &#123; // 判断当前路径是否含有id，有则为修改，否则为添加 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; // 从路径中获取参数值 const id = this.$route.params.id this.getTeacherInfo(id) &#125; &#125;, methods: &#123; // 根据id获得讲师信息 getTeacherInfo(id) &#123; teacherApi.getTeacherInfo(id).then(response =&gt; &#123; this.teacher = response.data.teacher &#125;) &#125; &#125;&#125;&lt;/script&gt; 保存修改 编写后端接口调用方法 12345678// 修改讲师信息updateTeacher(teacher) &#123; return request(&#123; url: `/eduservice/teacher/updateTeacher`, method: &#x27;post&#x27;, data: teacher &#125;)&#125; 页面调用该方法，需要判断是修改还是添加 123456789101112131415161718192021222324252627&lt;script&gt; export default &#123; methods: &#123; // 添加和修改使用同一个页面 saveOrUpdate() &#123; // 判断是否有id if (this.teacher.id) &#123; this.updateTeacher() &#125; else &#123; this.saveTeacher() &#125; &#125;, // 修改讲师信息 updateTeacher() &#123; teacherApi.updateTeacher(this.teacher).then(response =&gt; &#123; // 显示提示信息 this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;修改成功!&#x27; &#125;) // 路由跳转到列表页面 this.$router.push(&#123; path: &#x27;/teacher/list&#x27; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 路由切换存留信息问题 感谢弹幕提醒，使用监听路由的方法，可以防止当点击修改后在edit页面再次点击添加讲师，显示后的页面仍然留存讲师信息的小问题 1234567891011121314151617181920212223242526&lt;script&gt; export default &#123; // 监听 watch: &#123; // 监听路由是否发生了变化，如果是则清除当前页面的数据 $route: &#123; handler: function(val, oldVal) &#123; this.resetData() &#125; &#125; &#125;, methods: &#123; // 清空数据 resetData() &#123; this.teacher = &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125; &#125; &#125; &#125;&lt;/script&gt; 好吧原来下一集就把这个问题解决了，原因是多次跳转至同一个页面created钩子函数只会执行一次 以下是老师的方案 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; export default &#123; // 监听 watch: &#123; // 监听路由是否发生了变化，如果是则清除当前页面的数据 $route(to, from) &#123; this.init() &#125; &#125;, created() &#123; // 这里可以不用调用初始化方法，已经设置了监听 this.init() &#125;, methods: &#123; // 初始化 init() &#123; // 判断当前路径是否含有id，有则为修改，否则为添加 if (this.$route.params &amp;&amp; this.$route.params.id) &#123; // 从路径中获取参数值 const id = this.$route.params.id this.getTeacherInfo(id) &#125; else &#123; this.teacher = &#123; name: &#x27;&#x27;, sort: 0, level: 1, career: &#x27;&#x27;, intro: &#x27;&#x27;, avatar: &#x27;&#x27; &#125; &#125; &#125; &#125; &#125;&lt;/script&gt; nginx 反向代理服务器，功能如下： 请求转发 负载均衡 动静分离 基础命令 启动：nginx.exe 关闭：nginx.exe -s stop 重启：nginx.exe -s reload 配置 nginx.conf文件中配置 修改第一个server下的listen端口号 -&gt; 81 （最好改一下） 添加自己的server，其中listen监听的端口号要和前端config中的端口号(BASE_PATH)对应 例如相当于访问9001下的xxx，就会转发到8001下的xxx或者其他 1234567891011121314server &#123; listen 9001; server_name localhost; location ~ /eduservice/ &#123; proxy_pass http://localhost:8001; &#125; location ~ /eduoss/ &#123; proxy_pass http://localhost:8002; &#125; location ~ /eduvod/ &#123; proxy_pass http://localhost:8003; &#125;&#125; 记得修改前端中的BASE_PATH和监听端口一致 测试 application和npm都打开，前端测试一下，查看network中的header是否为nginx中的监听端口号 上传头像功能（后端+前端）阿里云OSS 简单来说：解决海量数据存储与弹性扩容 简单入门 开通就能进控制台了 创建bucket 文件管理中可以进行上传文件等操作 创建access key获得id和秘钥 小小的吐槽：当天给我的账户里充了1rmb（巨额，确信），配置了一些OSS的东西，第二天就来了个专属客服打电话给我，向我介绍各种产品（上次刚注册的时候也给我打了电话，里面的小姐姐说话都好好听）服务太热情了！ 后端阿里云OSS搭建 去官方文档查看详细介绍 快速入门 (aliyun.com) 创建对应子模块 service模块 -&gt; service_oss子模块即可 引入依赖12345678910111213&lt;dependencies&gt; &lt;!-- 阿里云oss依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 日期工具栏依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.properties aliyun.oss.file后配置阿里云OSS和AccessKey相关信息 1234567server.port=8002spring.application.name=service-ossspring.profiles.active=devaliyun.oss.file.endpoint=oss-cn-beijing.aliyuncs.comaliyun.oss.file.keyid=aliyun.oss.file.keysecret=aliyun.oss.file.bucketname=demo-edu-guli 创建启动类12345678910111213package com.atguigu.oss;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class OssApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OssApplication.class, args); &#125;&#125; 由于只使用上传的功能，所以不需要操作数据库，需要配置默认不加载数据库（否则会报错） 1@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) // exclude排除这个数据源配置类 编写常量类 用于获取配置文件中的常量 123456789101112131415161718192021222324252627282930313233package com.atguigu.oss.utils;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class ConstantPropertiesUtils implements InitializingBean &#123; // 读取配置文件内容 @Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;) // 自动属性注入(注意此处属性名要与properties文件中的名字对应) private String endpoint; @Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;) private String keyid; @Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;) private String keysecret; @Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;) private String bucketname; // 定义公开静态常量 public static String END_POINT; public static String ACCESS_KEY_ID; public static String ACCESS_KEY_SECRET; public static String BUCKET_NAME; // 当初始化properties完成后该方法会执行 @Override public void afterPropertiesSet() throws Exception &#123; END_POINT = endpoint; ACCESS_KEY_ID = keyid; ACCESS_KEY_SECRET = keysecret; BUCKET_NAME = bucketname; &#125;&#125; 编写Controller 实现文件获取和回传url和页面跳转 123456789101112131415161718192021222324252627package com.atguigu.oss.controller;import com.atguigu.commonutils.R;import com.atguigu.oss.service.OssService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;@RestController@RequestMapping(&quot;/eduoss/fileoss&quot;)@CrossOrigin // 解决跨域public class OssController &#123; @Autowired private OssService ossService; // 上传头像 @PostMapping() public R uploadOssFile(MultipartFile file) &#123; // 获取到上传的文件(MultipartFile) String url = ossService.uploadFileAvatar(file); return R.ok().data(&quot;url&quot;, url); &#125; &#125; 主要业务逻辑编写编写Service实现类 先创建接口和实现类，实现类中实现上传业务 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.oss.service.impl;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.atguigu.oss.service.OssService;import com.atguigu.oss.utils.ConstantPropertiesUtils;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;@Servicepublic class OssServiceImpl implements OssService &#123; @Override public String uploadFileAvatar(MultipartFile file) &#123; // 简单上传文件格式（oss文档修改即可） String endpoint = ConstantPropertiesUtils.END_POINT; String accessKeyId = ConstantPropertiesUtils.ACCESS_KEY_ID; String accessKeySecret = ConstantPropertiesUtils.ACCESS_KEY_SECRET; String bucketName = ConstantPropertiesUtils.BUCKET_NAME; String fileName = file.getOriginalFilename(); // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); // 上传文件 try &#123; //依次填写Bucket名称、Object完整路径（文件路径+文件名称）、文件流。Object完整路径中不能包含Bucket名称。 ossClient.putObject(bucketName, fileName, file.getInputStream()); // 拼接oss中文件路径 String url = &quot;https://&quot; + bucketName + &quot;.&quot; + endpoint + &quot;/&quot; + fileName; return url; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; finally &#123; // 关闭OSSClient。 ossClient.shutdown(); &#125; &#125;&#125; 完善Service 防止文件名重复 123456// 为文件名添加唯一的值String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);fileName = uuid + fileName;// 将文件进行分类管理,按照日期分类，使用工具类String datePath = new DateTime().toString(&quot;yyyy/MM/dd&quot;);fileName = datePath + &quot;/&quot; + fileName; 上传头像功能（前端）添加页面结构 element-UI里有相关组件（ImageCropper、PanThumb），cv即可 注意要把组件复制到conponents里 注意修改image-cropper中绑定的url、filed中属性值要与后端接口方法中参数名对应 在添加讲师的页面添加如下标签及代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;!-- 讲师头像 --&gt; &lt;el-form-item label=&quot;讲师头像&quot;&gt; &lt;!-- 头衔缩略图 --&gt; &lt;pan-thumb :image=&quot;teacher.avatar&quot; /&gt; &lt;!-- 文件上传按钮 --&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-upload&quot; @click=&quot;imagecropperShow = true&quot; &gt;更换头像 &lt;/el-button&gt; &lt;!-- v-show：是否显示上传组件 :key：类似于id，如果一个页面多个图片上传控件，可以做区分 :url：后台上传的url地址 @close：关闭上传组件 @crop-upload-success：上传成功后的回调 &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; --&gt; &lt;image-cropper v-show=&quot;imagecropperShow&quot; :width=&quot;300&quot; :height=&quot;300&quot; :key=&quot;imagecropperKey&quot; :url=&quot;BASE_API + &#x27;/eduoss/fileoss&#x27;&quot; field=&quot;file&quot; @close=&quot;close&quot; @crop-upload-success=&quot;cropSuccess&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 上传头像所需组件 import ImageCropper from &#x27;@/components/ImageCropper&#x27; import PanThumb from &#x27;@/components/PanThumb&#x27; export default &#123; // 声明组件 components: &#123; ImageCropper, PanThumb &#125;, data() &#123; return &#123; // 上传弹框组件是否显示 imagecropperShow: false, // 上传组件key值 imagecropperKey: 0, // 获取接口API，固定写法 BASE_API: process.env.BASE_API &#125; &#125;, methods: &#123; // 关闭上传弹框 close() &#123;&#125;, // 上传成功 cropSuccess() &#123;&#125; &#125; &#125;&lt;/script&gt; 使用组件 import以及声明即可 123456789&lt;script&gt; // 上传头像所需组件 import ImageCropper from &#x27;@/components/ImageCropper&#x27; import PanThumb from &#x27;@/components/PanThumb&#x27; export default &#123; // 声明组件 components: &#123; ImageCropper, PanThumb &#125;, &#125;&lt;/script&gt; 编写按钮方法1234567891011// 关闭上传弹框close() &#123; this.imagecropperShow = false // 上传组件初始化 this.imagecropperKey = this.imagecropperKey + 1&#125;,// 上传成功(获得头像url并显示)cropSuccess(data) &#123; this.teacher.avatar = data.url this.close()&#125; 测试，报错与解决✅ 报了一个错，显示上传失败，去看network里的请求URL里的地址不对，中间多了一个undefined，想到可能变量名写错了，稍微对比了一下，BASE_API写成BASE_PATH了，改了就可以了 课程分类管理模块（后端+前端） 记得先导入数据库 添加使用上传excel文件的形式 EasyExcel入门 EasyExcel · 语雀 (yuque.com) 记得引入依赖坐标，同时需要poi的，不过父模块已经引入了 1234567891011121314151617181920212223242526&lt;!-- EasyExcel依赖 --&gt;&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;!--以下是父模块中的相关依赖--&gt; &lt;!--xls--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;/dependency&gt; 写Excel 先创建实体类（一级分类、二级分类） 属性需要全小写 12345678@Datapublic class DemoData &#123; // 实体类，其中属性和Excel表格对应 @ExcelProperty(&quot;学生编号&quot;) // 该注释用于定义表头 private Integer sno; @ExcelProperty(&quot;学生姓名&quot;) private String sname;&#125; 测试代码 12345678910111213141516171819202122public class TestEasyExcel &#123; public static void main(String[] args) &#123; // 写Excel // 1、设置文件地址和名称 String filename = &quot;D:\\\\MyProject\\\\excel\\\\test.xlsx&quot;; // 调用easyExcel方法写入, 可以设置sheet, 执行doWrite传入数据 EasyExcel.write(filename, DemoData.class).sheet(&quot;学生列表&quot;).doWrite(getData()); &#125; private static List&lt;DemoData&gt; getData() &#123; List&lt;DemoData&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; DemoData data = new DemoData(); data.setSname(&quot;aaa&quot; + i); data.setSno(i); list.add(data); &#125; return list; &#125;&#125; 读Excel 稍微修改一下实体类 12345678@Datapublic class DemoData &#123; // 实体类，其中属性和Excel表格对应 @ExcelProperty(value = &quot;学生编号&quot;, index = 0) // 该注释用于定义表头 private Integer sno; @ExcelProperty(value = &quot;学生姓名&quot;, index = 1) // index标记第几列，读操作需要 private String sname;&#125; 创建监听器对excel文件的读取（一行一行的读取需要） 1234567891011121314151617181920// 监听器public class ExcelListener extends AnalysisEventListener&lt;DemoData&gt; &#123; // 读取行数据到实体类对象中 @Override public void invoke(DemoData demoData, AnalysisContext analysisContext) &#123; System.out.println(&quot;*****&quot; + demoData + &quot;*****&quot;); &#125; // 读取完成之后执行 @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; &#125; // 读取表头内容 @Override public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) &#123; System.out.println(&quot;表头：&quot; + headMap); &#125;&#125; 测试代码 12String filename = &quot;D:\\\\MyProject\\\\excel\\\\test.xlsx&quot;;EasyExcel.read(filename, DemoData.class, new ExcelListener()).sheet().doRead(); 代码生成器 先生成entity、service、mapper、controller再说 操作还是一样，详细代码见1，只需要修改表名运行即可 12// 一半不同模块需要修改的地方就是表名strategy.setInclude(&quot;edu_subject&quot;); //加载表 记得为自动生成的实体类添加自动填充（@TableField(fill = FieldFill.INSERT)等）的注解 注意controller添加注释@CrossOrigin解决跨域 添加课程分类（后端）创建表格实体类12345678910111213/** * subject表格实体类 */@Datapublic class SubjectData &#123; @ExcelProperty(index = 0) private String oneSubjectName; @ExcelProperty(index = 1) private String twoSubjectName;&#125; 编写service123456789101112131415@Servicepublic class EduSubjectServiceImpl extends ServiceImpl&lt;EduSubjectMapper, EduSubject&gt; implements EduSubjectService &#123; @Override public void saveSubject(MultipartFile file) &#123; try &#123; // 获得文件输入流 InputStream inputStream = file.getInputStream(); // 调用方法读取 EasyExcel.read(inputStream, SubjectData.class, new SubjectExcelListener()).sheet().doRead(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编写监听器 注意DataListener 不能被spring管理（官方说的），如果使用spring需要使用特定构造器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.atguigu.eduservice.listener;import com.alibaba.excel.context.AnalysisContext;import com.alibaba.excel.event.AnalysisEventListener;import com.atguigu.eduservice.entity.EduSubject;import com.atguigu.eduservice.entity.excel.SubjectData;import com.atguigu.eduservice.service.EduSubjectService;import com.atguigu.servicebase.ExceptionHandler.GuliException;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;public class SubjectExcelListener extends AnalysisEventListener&lt;SubjectData&gt; &#123; public EduSubjectService subjectService; public SubjectExcelListener() &#123; &#125; // 当new当前对象的时候同时注入service public SubjectExcelListener(EduSubjectService subjectService) &#123; this.subjectService = subjectService; &#125; // 读取excel内容，写入数据库 @Override public void invoke(SubjectData subjectData, AnalysisContext analysisContext) &#123; if (subjectData == null) &#123; throw new GuliException(20001, &quot;文件数据为空&quot;); &#125; // 添加一级分类，先判断一级分类是否已经存在 EduSubject existOneSubject = this.existSubject(subjectData.getOneSubjectName(), &quot;0&quot;); if (existOneSubject == null) &#123; // 此时没有相同的一级分类，需要添加 EduSubject eduSubject = new EduSubject(); eduSubject.setParentId(&quot;0&quot;); eduSubject.setTitle(subjectData.getOneSubjectName()); subjectService.save(eduSubject); &#125; else &#123; //添加二级分类，先判断 EduSubject eduTwoSubject = this.existSubject(subjectData.getTwoSubjectName(), existOneSubject.getId()); if (eduTwoSubject == null) &#123; // 此时没有相同的一级分类，需要添加 EduSubject eduSubject = new EduSubject(); eduSubject.setParentId(existOneSubject.getId()); eduSubject.setTitle(subjectData.getTwoSubjectName()); subjectService.save(eduSubject); &#125; &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; &#125; // 用于判断分类是否存在 public EduSubject existSubject(String title, String pid) &#123; // 添加查询条件 QueryWrapper&lt;EduSubject&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;title&quot;, title); // pid=0为一级分类 wrapper.eq(&quot;parent_id&quot;, pid); return subjectService.getOne(wrapper); &#125;&#125; 同时修改一下service中方法的参数 其实这里有点奇怪，listener做了主要业务逻辑，等做完了再试试别的方法 编写controller1234567891011121314151617@RestController@RequestMapping(&quot;/eduservice/subject&quot;)@CrossOriginpublic class EduSubjectController &#123; @Autowired private EduSubjectService subjectService; // 添加课程分类 // 获取上传过来的文件，把文件内容读取出来即可 @PostMapping(&quot;addSubject&quot;) public R addSubject(MultipartFile file) &#123; // 获得上传过来的excel文件 subjectService.saveSubject(file, subjectService); return R.ok(); &#125;&#125; 测试，报错与解决✅ swagger成功，后台报错，看了下说gtm_time没有默认值，然后想到自动注入可能没加，果然。 然后是能够写入数据库了但是一级写到二级去了，看了下是添加二级分类的时候的get方法成getOneSubjectName而不是getTwoSubjectName，改一下就解决了 添加课程分类（前端）配置router src -&gt; router -&gt; index.js 当中添加即可 12345678910111213141516171819202122// 课程管理模块路由 &#123; path: &#x27;/subject&#x27;, component: Layout, redirect: &#x27;/subject/list&#x27;, name: &#x27;课程分类管理&#x27;, meta: &#123; title: &#x27;课程分类管理&#x27;, icon: &#x27;example&#x27; &#125;, children: [ &#123; path: &#x27;list&#x27;, name: &#x27;课程分类列表&#x27;, component: () =&gt; import(&#x27;@/views/edu/subject/list&#x27;), meta: &#123; title: &#x27;课程分类列表&#x27;, icon: &#x27;tree&#x27; &#125; &#125;, &#123; path: &#x27;save&#x27;, name: &#x27;添加课程分类&#x27;, component: () =&gt; import(&#x27;@/views/edu/subject/add&#x27;), meta: &#123; title: &#x27;添加课程分类&#x27;, icon: &#x27;table&#x27; &#125; &#125;, ] &#125;, 编写添加课程分类视图 element-ui 中 cv一下（文件上传相关） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;信息描述&quot;&gt; &lt;el-tag type=&quot;info&quot;&gt;excel模版说明&lt;/el-tag&gt; &lt;el-tag&gt; &lt;i class=&quot;el-icon-download&quot; /&gt; &lt;!-- 这里模板放在了本地static文件夹里，也可以放在OSS当中 --&gt; &lt;a :href=&quot;&#x27;/static/demo.xlsx&#x27;&quot;&gt;点击下载模版&lt;/a&gt; &lt;/el-tag&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;选择Excel&quot;&gt; &lt;el-upload ref=&quot;upload&quot; :auto-upload=&quot;false&quot; :on-success=&quot;fileUploadSuccess&quot; :on-error=&quot;fileUploadError&quot; :disabled=&quot;importBtnDisabled&quot; :limit=&quot;1&quot; :action=&quot;BASE_API + &#x27;/eduservice/subject/addSubject&#x27;&quot; name=&quot;file&quot; accept=&quot;application/vnd.ms-excel&quot; &gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot; &gt;选取文件&lt;/el-button &gt; &lt;el-button :loading=&quot;loading&quot; style=&quot;margin-left: 10px&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot; &gt;上传到服务器&lt;/el-button &gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; BASE_API: process.env.BASE_API, // 接口API地址 OSS_PATH: process.env.OSS_PATH, // 阿里云OSS地址 importBtnDisabled: false, // 按钮是否禁用, loading: false &#125; &#125;, created() &#123;&#125;, methods: &#123;&#125; &#125;&lt;/script&gt; 编写调用方法12345678910111213141516171819202122232425methods: &#123; // 上传文件 submitUpload() &#123; this.importBtnDisabled = true this.loading = true // 使用vue的提交，而不是Ajax请求 this.$refs.upload.submit() &#125;, // 上传成功 fileUploadSuccess() &#123; this.loading = false this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加课程分类成功！&#x27; &#125;) &#125;, // 上传失败 fileUploadError() &#123; this.loading = false this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;添加课程分类失败！&#x27; &#125;) &#125;&#125; 完善 el-upload添加一个 :before-upload=”beforeUpload”，用于上传前判断文件后缀格式 上传文件时判断文件是否为空 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;选择Excel&quot;&gt; &lt;el-upload ref=&quot;upload&quot; :auto-upload=&quot;true&quot; :before-upload=&quot;beforeUpload&quot; :on-success=&quot;fileUploadSuccess&quot; :on-error=&quot;fileUploadError&quot; :disabled=&quot;importBtnDisabled&quot; :limit=&quot;1&quot; :action=&quot;BASE_API + &#x27;/eduservice/subject/addSubject&#x27;&quot; name=&quot;file&quot; accept=&quot;application.xlsx&quot; &gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot; &gt;选取文件&lt;/el-button &gt; &lt;el-button :loading=&quot;loading&quot; style=&quot;margin-left: 10px&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot; &gt;上传到服务器&lt;/el-button &gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; // 上传前判断格式 beforeUpload() &#123; const fileName = this.$refs.upload.uploadFiles[0].name const suffix = fileName.substring(fileName.lastIndexOf(&#x27;.&#x27;) + 1) if (suffix != &#x27;xlsx&#x27;) &#123; this.fileSuffixError() return false &#125; &#125;, // 上传文件 submitUpload() &#123; if (this.$refs.upload.uploadFiles.length == 0) &#123; this.fileUploadError() return &#125; this.importBtnDisabled = true this.loading = true // 使用vue的提交，而不是Ajax请求 this.$refs.upload.submit() &#125;, // 文件格式错误失败 fileSuffixError() &#123; this.loading = false this.$message(&#123; type: &#x27;error&#x27;, message: &#x27;文件格式错误！&#x27; &#125;) &#125; &#125; &#125;&lt;/script&gt; 课程分类列表（后端）针对返回的数据创建对应实体类 一级分类、二级分类都要创建对应实体类 1234567// 一级分类@Datapublic class OneSubject &#123; private String id; private String title; private List&lt;TwoSubject&gt; children = new ArrayList&lt;&gt;();&#125; 123456// 二级分类@Datapublic class TwoSubject &#123; private String id; private String title;&#125; 编写controller123456// 课程分类列表（树形）@GetMapping(&quot;getAllSubjects&quot;)public R getAllSubjects() &#123; List&lt;OneSubject&gt; list = subjectService.getAllSubjects(); return R.ok().data(&quot;list&quot;, &quot;list&quot;);&#125; 编写service service继承的ServiceImpl已经自动注入了baseMapper 这里的代码不够优雅 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic List&lt;OneSubject&gt; getAllSubjects() &#123; // 查询所有一级分类 QueryWrapper&lt;EduSubject&gt; wrapperOne = new QueryWrapper&lt;&gt;(); wrapperOne.eq(&quot;parent_id&quot;, &quot;0&quot;); List&lt;EduSubject&gt; oneSubjectList = baseMapper.selectList(wrapperOne); // 查询所有二级分类 QueryWrapper&lt;EduSubject&gt; wrapperTwo = new QueryWrapper&lt;&gt;(); wrapperTwo.ne(&quot;parent_id&quot;, &quot;0&quot;); List&lt;EduSubject&gt; twoSubjectList = baseMapper.selectList(wrapperTwo); List&lt;OneSubject&gt; finalList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; oneSubjectList.size(); i++) &#123; // 封装一级 EduSubject eduSubjectOne = oneSubjectList.get(i); OneSubject oneSubject = new OneSubject(); BeanUtils.copyProperties(eduSubjectOne, oneSubject); finalList.add(oneSubject); //封装二级分类 List&lt;TwoSubject&gt; childrenList = new ArrayList&lt;&gt;(); //遍历二级分类list集合 for (int m = 0; m &lt; twoSubjectList.size(); m++) &#123; //获取每个二级分类 EduSubject eduSubjectTwo = twoSubjectList.get(m); //判断二级分类parentid和一级分类id是否一样 if (eduSubjectTwo.getParentId().equals(eduSubjectOne.getId())) &#123; //把tSubject值复制到TwoSubject里面，放到twoFinalSubjectList里面 TwoSubject twoSubject = new TwoSubject(); BeanUtils.copyProperties(eduSubjectTwo, twoSubject); childrenList.add(twoSubject); &#125; &#125; //把一级下面所有二级分类放到一级分类里面 oneSubject.setChildren(childrenList); &#125; return finalList;&#125; 课程分类列表（前端）树形结构模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 检索 --&gt; &lt;el-input v-model=&quot;filterText&quot; placeholder=&quot;Filter keyword&quot; style=&quot;margin-bottom: 30px&quot; /&gt; &lt;!-- 树形结构 --&gt; &lt;el-tree ref=&quot;tree2&quot; :data=&quot;data2&quot; :props=&quot;defaultProps&quot; :filter-node-method=&quot;filterNode&quot; class=&quot;filter-tree&quot; default-expand-all /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; filterText: &#x27;&#x27;, data2: [ &#123; id: 1, label: &#x27;Level one 1&#x27;, children: [ &#123; id: 4, label: &#x27;Level two 1-1&#x27;, children: [ &#123; id: 9, label: &#x27;Level three 1-1-1&#x27; &#125;, &#123; id: 10, label: &#x27;Level three 1-1-2&#x27; &#125; ] &#125; ] &#125;, &#123; id: 2, label: &#x27;Level one 2&#x27;, children: [ &#123; id: 5, label: &#x27;Level two 2-1&#x27; &#125;, &#123; id: 6, label: &#x27;Level two 2-2&#x27; &#125; ] &#125;, &#123; id: 3, label: &#x27;Level one 3&#x27;, children: [ &#123; id: 7, label: &#x27;Level two 3-1&#x27; &#125;, &#123; id: 8, label: &#x27;Level two 3-2&#x27; &#125; ] &#125; ], defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;label&#x27; &#125; &#125; &#125;, watch: &#123; filterText(val) &#123; this.$refs.tree2.filter(val) &#125; &#125;, methods: &#123; filterNode(value, data) &#123; if (!value) return true return data.label.indexOf(value) !== -1 &#125; &#125; &#125;&lt;/script&gt; 需要稍微修改 后端接口调用 api -&gt; edu -&gt; subject.js 12345678910111213import request from &#x27;@/utils/request&#x27;export default &#123; // 课程分类列表 getSubjectList() &#123; return request(&#123; url: `/eduservice/subject/getAllSubjects`, method: &#x27;get&#x27; &#125;) &#125;&#125; 记得在vue视图中引入 vue视图和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;!-- 检索 --&gt; &lt;el-input v-model=&quot;filterText&quot; placeholder=&quot;Filter keyword&quot; style=&quot;margin-bottom: 30px&quot; /&gt; &lt;!-- 树形结构 --&gt; &lt;el-tree ref=&quot;tree2&quot; :data=&quot;list&quot; :props=&quot;defaultProps&quot; :filter-node-method=&quot;filterNode&quot; class=&quot;filter-tree&quot; default-expand-all /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入调用接口的js文件 import subjectApi from &#x27;@/api/edu/subject.js&#x27; export default &#123; data() &#123; return &#123; // 索引文本 filterText: &#x27;&#x27;, list: [], defaultProps: &#123; children: &#x27;children&#x27;, label: &#x27;title&#x27; &#125; &#125; &#125;, watch: &#123; filterText(val) &#123; this.$refs.tree2.filter(val) &#125; &#125;, created() &#123; this.getAllSubjectList() &#125;, methods: &#123; // 获得所有subject getAllSubjectList() &#123; subjectApi.getSubjectList().then(result =&gt; &#123; this.list = result.data.list &#125;) &#125;, // 过滤文本（不区分大小写） filterNode(value, data) &#123; if (!value) return true return data.title.toLowerCase().indexOf(value.toLowerCase()) !== -1 &#125; &#125; &#125;&lt;/script&gt; 测试 记得开nginx 待续 进度1/3","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【学习笔记】MyBatisPlus","slug":"【学习笔记】MyBatisPlus","date":"2021-09-20T03:38:01.615Z","updated":"2021-09-23T09:58:17.229Z","comments":true,"path":"2021/09/20/xue-xi-bi-ji-mybatisplus/","link":"","permalink":"http://example.com/2021/09/20/xue-xi-bi-ji-mybatisplus/","excerpt":"","text":"官网MyBatis-Plus (baomidou.com) 创建并初始化数据库见课件 快速创建工程创建springboot工程 new project -&gt; spring Initializr mybatisplus依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.properties123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789# mybatis日志，可以查看更多详细信息mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 创建实体类123456789101112131415package com.example.mybatisplus_demo.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 创建Mapepr接口123456789package com.example.mybatisplus_demo.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.mybatisplus_demo.entity.User;@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; mapper扫描 注意这里有个易错点，mappersan内填写到Mapper文件存放的文件夹，而不是mapper文件 123456789@SpringBootApplication@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MybatisplusDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisplusDemoApplication.class, args); &#125;&#125; 单元测试12345678910111213141516171819package com.example.mybatisplus_demo;import com.example.mybatisplus_demo.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass MybatisplusDemoApplicationTests &#123; @Autowired private UserMapper userMapper; // 此处如果报错，则在UserMapper接口处添加注释@Repository即可 @Test void contextLoads() &#123; &#125;&#125; 当前项目结构 基础CRUD接口添加 不需要设置id主键的值，mybatisplus自动生成19位id 12345@Testvoid addUser() &#123; int insert = userMapper.insert(new User(null, &quot;爱丽丝&quot;, 12, &quot;Alice@qq.com&quot;)); System.out.println(&quot;insert: &quot; + insert);&#125; 主键生成策略分布式系统唯一ID生成方案汇总 - nick hao - 博客园 (cnblogs.com) 自动增长 UUID Redis生成 snowflake雪花算法 mybatisplus中指定策略如下 12@TableId(type = IdType.AUTO)private Long id; 修改1234@Testvoid updateUser() &#123; userMapper.updateById(new User(2L, &quot;Jacks&quot;, 11, &quot;Jacks@qq.com&quot;));&#125; 自动填充 为实体类添加带有注解的属性 1234567//create_time@TableField(fill = FieldFill.INSERT)private Date createTime;//update_time 注意这里是INSERT_UPDATE@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 创建handler类，并实现接口MetaObjectHandler的方法 123456789101112131415161718192021222324package com.example.mybatisplus_demo.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;// 需要交给spring@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; // 当使用mp实现添加操作时，这个方法会执行 @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); &#125;&#125; 测试 123456789101112131415161718192021222324 @Test void addUser() &#123; User user = new User(); user.setName(&quot;岳不群1&quot;); user.setAge(70); user.setEmail(&quot;lucy@qq.com&quot;);// user.setCreateTime(new Date());// user.setUpdateTime(new Date()); int insert = userMapper.insert(user); System.out.println(&quot;insert:&quot; + insert); &#125; @Test void updateUser() &#123; User user = new User(); user.setId(1439818355027558402L); user.setAge(120); int row = userMapper.updateById(user); System.out.println(row); &#125; 乐观锁 主要解决：丢失更新 为实体类添加带注解的属性 123@Version@TableField(fill = FieldFill.INSERT)private Integer version; 配置乐观锁插件，可以写在独立的配置类中（MapperScan也可以写在该配置类中） 12345678910111213@Configuration@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MpConfig &#123; /** * 乐观锁插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; &#125;&#125; 编写handler类 1234567@Overridepublic void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); // 默认初始值1 this.setFieldValByName(&quot;version&quot;, 1, metaObject);&#125; 测试 12345678@Testvoid testOptimisticLockerInnerInterceptor() &#123; // 先查 User user = userMapper.selectById(1439842460539846658L); // 后改 user.setAge(44); userMapper.updateById(user);&#125; 查询批量查询12345@Testvoid testSelect() &#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1L, 2L, 3L)); System.out.println(users);&#125; 分页查询 在配置类中配置分页插件 123456789101112131415@Configuration@MapperScan(&quot;com.example.mybatisplus_demo.mapper&quot;)public class MpConfig &#123; /** * 插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 测试 123456789@Testvoid testPage() &#123; // 创建page对象 Page&lt;User&gt; page = new Page&lt;&gt;(1, 2); // 查询 Page&lt;User&gt; page1 = userMapper.selectPage(page, null); System.out.println(page1); // 获得的page对象有许多方法可以获得对应值&#125; 删除 物理删除：真实删除，将数据从数据库中删除逻辑删除：假删除，根据字段状态判断 批量删除（物理删除）1234@Testvoid testDelete() &#123; userMapper.deleteBatchIds(Arrays.asList(1L, 2L));&#125; 逻辑删除 在实体类中添加带注释的属性（可以再加上TableField设置默认值等） 12@TableLogicprivate Integer deleted; 高版本已不需要在配置文件中添加插件 测试 1234@Testvoid testDelete() &#123; userMapper.deleteBatchIds(Arrays.asList(1L, 2L));&#125; 逻辑删除之后的数据在查询的时候不会被查询到（添加了额外的条件deleted=0） 条件构造器123456789@Testvoid testWrapper() &#123; // 创建对象 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 设置条件(更多条件详见官网) wrapper.ge(&quot;age&quot;, 20).le(&quot;age&quot;, 40); List&lt;User&gt; users = userMapper.selectList(wrapper); System.out.println(users);&#125; 代码生成器","categories":[],"tags":[{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://example.com/tags/MyBatisPlus/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"【项目笔记】在线教育项目实战1","slug":"【项目笔记】在线教育项目实战1","date":"2021-09-19T13:01:14.432Z","updated":"2021-09-23T08:05:54.517Z","comments":true,"path":"2021/09/19/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-1/","link":"","permalink":"http://example.com/2021/09/19/xiang-mu-bi-ji-zai-xian-jiao-yu-xiang-mu-shi-zhan-1/","excerpt":"","text":"背景​ 今天准备写一个ssm整合的crud简单项目，然后顺便应付一下学校课程，然后被spring的注释气到了（注释代码什么都写得一模一样，就是idea报找不到bean，结果我重写了几遍之后莫名的好了，离谱！），被jsp气到了（这个错误之前遇到好几次了，也是代码一模一样，就是报404，离谱！），实在是不想在这些上面折腾了，今天在实验室有一半的时间都在叹气，于是果断放弃了它，投入了springboot+vue的怀抱。 项目简介项目商业模式B2C（当前项目） Business To Customers 两个角色： 管理员：添加、修改、删除 普通用户：查询 B2B2C Business To Business To Customers 例子：淘宝 项目实现功能模块后台（管理员） 讲师管理 课程分类管理 课程管理 视频 统计分析 课程相关 订单管理 banner（轮播图）管理 权限管理 前台（普通用户） 首页数据显示 讲师列表和详情 课程列表和详情 视频在线播放 登录和注册 微信扫码登录 微信支付 项目使用的技术点后端技术 SpringBoot SpringCloud MyBatisPlus SpringSecurity redis，maven，easyExcel，jwt，OAuth2 …… 前端技术 vue element-ui axios node.js …… 其他技术 阿里云oss 阿里云视频点播服务 阿里云短信服务 微信支付和登录 docker，git，Jenkins …… MyBatisPlus介绍 详见单独的文档说明 搭建项目环境数据库 详见资料 项目结构 父工程：pom类型，用于管理以来版本和放公共依赖 子模块n：实现各个模块 创建springboot父项目配置父项目的pom.xml 配置打包方式、删除dependencies、添加properties和dependencyManagement、删除src文件夹等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;guli_parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;guli_parent&lt;/name&gt; &lt;description&gt;guli_parent&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;guli.version&gt;0.0.1-SNAPSHOT&lt;/guli.version&gt; &lt;mybatis-plus.version&gt;3.0.5&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt; &lt;aliyun.oss.version&gt;2.8.3&lt;/aliyun.oss.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;poi.version&gt;3.17&lt;/poi.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-sdk-oss.version&gt;3.1.0&lt;/aliyun-sdk-oss.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-java-vod-upload.version&gt;1.4.11&lt;/aliyun-java-vod-upload.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.11&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;cloud-alibaba.version&gt;0.2.2.RELEASE&lt;/cloud-alibaba.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;$&#123;velocity.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyunOSS--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun.oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期时间工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;jodatime.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--xlsx--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;$&#123;poi.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;$&#123;jwt.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyun--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-core.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-oss.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-sdk-vod.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-java-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-vod-upload&lt;/artifactId&gt; &lt;version&gt;$&#123;aliyun-sdk-vod-upload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-dbutils.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;$&#123;canal.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建子模块 右键new model创建即可，子项目service等 配置pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;dependencies&gt; &lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;com.atguigu&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;service_base&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--hystrix依赖，主要是用 @HystrixCommand --&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--服务注册--&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!--服务调用--&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建子子模块 service_edu、service_vod 当前项目结构 common模块swagger工具创建子模块 命名为common，该模块不需要src文件夹 配置依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;guli_parent&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring2.X集成redis所需common-pool2 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建子子模块 service_base 创建SwaggerConfig.java配置类12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.servicebase;import com.google.common.base.Predicates;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2 // swagger注解public class SwaggerConfig &#123; // 一些固定配置 @Bean public Docket webApiConfig() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;webApi&quot;) .apiInfo(webApiInfo()) .select() .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;))) .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;))) .build(); &#125; // 文档提示信息 private ApiInfo webApiInfo() &#123; return new ApiInfoBuilder() .title(&quot;网站-课程中心API文档&quot;) .description(&quot;本文档描述了课程中心微服务接口定义&quot;) .version(&quot;1.0&quot;) .contact(new Contact(&quot;java&quot;, &quot;http://atguigu.com&quot;, &quot;1123@qq.com&quot;)) .build(); &#125;&#125; 引入swagger子模块 需要在service模块中引入swagger模块的子模块servicebase模块，即在service模块的pom.xml文件中添加依赖即可（因为想要在service模块的子模块中使用，且都写上了pom打包，所以只要在service模块的pom.xml中添加即可） 12345&lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;service_base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 启动类添加组件扫描 EduApplication是service_edu模块下的启动类，由于service_base模块中的swaggerconfig配置类所在包地址也是com.atguigu.xxx，所以可以通过这个扫描到，否则只会扫描启动类所在及子包下的类（所以启动类要放在所有package的同级），如果是别的地址再额外添加即可（{“com.atguigu”,”com.xxx”}） 123456789@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 测试（访问）swagger 启动xxxApplication启动类 http://localhost:8001/swagger-ui.html API文档提示编写 一下以controller为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.eduservice.controller;import com.atguigu.eduservice.entity.EduTeacher;import com.atguigu.eduservice.service.EduTeacherService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * &lt;p&gt; * 讲师 前端控制器 * &lt;/p&gt; * * @author testjava * @since 2021-09-20 */@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag; &#125;&#125; 当前项目结构 统一结果返回格式统一结果的格式123456&#123; &quot;success&quot;: 布尔, //响应是否成功 &quot;code&quot;: 数字, //响应码 &quot;message&quot;: 字符串, //返回消息 &quot;data&quot;: HashMap //返回数据，放在键值对中&#125; 创建子模块 common模块下创建common_utils模块 设定状态码 可以写成接口，或者其他形式 1234567package com.atguigu.commonutils;public interface ResultCode &#123; // 状态码 public static Integer SUCCESS = 20000; //成功 public static Integer ERROR = 20001; //失败&#125; 定义返回数据格式 创建一个统一返回结果类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.atguigu.commonutils;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.util.HashMap;import java.util.Map;//统一返回结果的类@Datapublic class R &#123; // 以下属性为返回内容key @ApiModelProperty(value = &quot;是否成功&quot;) private Boolean success; @ApiModelProperty(value = &quot;返回码&quot;) private Integer code; @ApiModelProperty(value = &quot;返回消息&quot;) private String message; @ApiModelProperty(value = &quot;返回数据&quot;) private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); //把构造方法私有 private R() &#123; &#125; //成功静态方法 public static R ok() &#123; R r = new R(); r.setSuccess(true); r.setCode(ResultCode.SUCCESS); r.setMessage(&quot;成功&quot;); return r; &#125; //失败静态方法 public static R error() &#123; R r = new R(); r.setSuccess(false); r.setCode(ResultCode.ERROR); r.setMessage(&quot;失败&quot;); return r; &#125; // 以下的return this返回的是r // 可以实现链式编程（R.success().message().……） public R success(Boolean success) &#123; this.setSuccess(success); return this; &#125; public R message(String message) &#123; this.setMessage(message); return this; &#125; public R code(Integer code) &#123; this.setCode(code); return this; &#125; public R data(String key, Object value) &#123; this.data.put(key, value); return this; &#125; public R data(Map&lt;String, Object&gt; map) &#123; this.setData(map); return this; &#125;&#125; 使用统一返回结果格式 先在模块的pom.xml中引入已经定义好的统一返回结果类所在 将接口方法（controller中的方法）返回结果改为R即可 12345678910111213141516171819202122232425262728// 未使用统一结果格式@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag; &#125;&#125; 12345678910111213141516171819202122232425262728// 使用统一结果格式@Api(tags = &#123;&quot;讲师管理&quot;&#125;)@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping(&quot;findAll&quot;) public R findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return R.ok().data(&quot;teacherList&quot;, list); &#125; // 2、逻辑删除讲师 @ApiOperation(value = &quot;根据id逻辑删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public R removeTeacher(@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag ? R.ok() : R.error(); &#125;&#125; 当前项目结构 统一异常处理统一异常处理类 在common模块中的service_base中添加即可 123456789101112131415/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理public class GlobalExceptionHandler &#123; // 全局异常处理 @ExceptionHandler(Exception.class) // 指定出现什么异常才会执行这个方法 @ResponseBody // 用于返回数据 public R error(Exception e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了异常!&quot;); &#125;&#125; 这里有一个依赖的问题，需要注意 特定异常处理1234567891011121314151617181920212223/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理public class GlobalExceptionHandler &#123; // 全局异常处理 @ExceptionHandler(Exception.class) // 指定出现什么异常才会执行这个方法 @ResponseBody // 用于返回数据 public R error(Exception e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了异常!&quot;); &#125; // 特定异常处理 @ExceptionHandler(ArithmeticException.class) @ResponseBody public R error(ArithmeticException e) &#123; e.printStackTrace(); return R.error().message(&quot;产生了ArithmeticException异常!&quot;); &#125;&#125; 自定义异常处理 创建自定义异常类 1234567891011@Data@NoArgsConstructor@AllArgsConstructorpublic class GuliException extends RuntimeException &#123; private Integer code; // 状态码 private String msg; // 异常信息 //……&#125; 在统一异常处理类中创建方法 1234567// 自定义异常处理@ExceptionHandler(GuliException.class)@ResponseBodypublic R error(GuliException e) &#123; e.printStackTrace(); return R.error().code(e.getCode()).message(e.getMsg());&#125; 抛出自定义异常 12345try &#123; int i = 1 / 0;&#125; catch (Exception e) &#123; throw new GuliException(20001, &quot;zzzzz&quot;);&#125; 当前项目结构 统一日志处理配置日志级别 application.properties文件中配置即可 1logging.level.root=INFO logback日志工具 log4j，logback等可以将日志输出到文件中 注意：需要先将application.properties中的有关日志的配置注释掉 配置工具的配置文件 在resource文件夹下创建logback-spring.xml配置文件 注意 的路径即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt; &lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt; &lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt; &lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt; &lt;property name=&quot;log.path&quot; value=&quot;D:/MyProject/log/guli_edu&quot; /&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;!-- boldMagenta:粗红--&gt; &lt;!-- cyan:青色 --&gt; &lt;!-- white:白色 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)&quot; /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/Pattern&gt; &lt;!-- 设置字符集 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt; &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_info.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录info级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 WARN 日志 --&gt; &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_warn.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录warn级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt; &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_error.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录ERROR级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。 &lt;logger&gt;仅有一个name属性， 一个可选的level和一个可选的addtivity属性。 name:用来指定受此logger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 如果未设置此属性，那么当前logger将会继承上级的级别。 --&gt; &lt;!-- 使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=&quot;INFO&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息 第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别： --&gt; &lt;!--开发环境:打印控制台--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;!--可以输出项目中的debug日志，包括mybatis的sql日志--&gt; &lt;logger name=&quot;com.guli&quot; level=&quot;INFO&quot; /&gt; &lt;!-- root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG 可以包含零个或多个appender元素。 --&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境:输出到文件--&gt; &lt;springProfile name=&quot;pro&quot;&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 输出错误日志 在统一异常处理类上添加注释，并且在异常处理的时候调用log.error() 12345678910111213141516/** * 统一异常处理类 */@ControllerAdvice // 增强的controller，可以用于全局异常处理@Slf4j // 输出错误日志public class GlobalExceptionHandler &#123; // 特定异常处理 @ExceptionHandler(ArithmeticException.class) @ResponseBody public R error(ArithmeticException e) &#123; e.printStackTrace(); log.error(e.getMessage()); // 将错误日志的内容输出到文件当中 return R.error().message(&quot;产生了ArithmeticException异常!&quot;); &#125; // ……&#125; 在配置的路径中即可看到日志文件 当前目录结构 service_edu讲师管理模块（后端）快速前置配置配置文件application.properties12345678910111213141516# 端口号server.port=8001# 服务名spring.application.name=service-edu# 环境spring.profiles.active=dev# mysql数据库信息spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456789# 返回JSON的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl mybatisplus代码生成器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import org.junit.Test;public class CodeGenerator &#123; @Test public void run() &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); // String projectPath = System.getProperty(&quot;user.dir&quot;); // gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); // 建议写成绝对路径 gc.setOutputDir(&quot;D:\\\\MyProject\\\\springboot\\\\guli_parent\\\\service\\\\service_edu&quot; + &quot;/src/main/java&quot;); gc.setAuthor(&quot;testjava&quot;); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(false); //重新生成时文件是否覆盖 gc.setServiceName(&quot;%sService&quot;); //去掉Service接口的首字母I // id类型如果是Long则改为ID_WORKER gc.setIdType(IdType.ID_WORKER_STR); //主键策略 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123456789&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(&quot;eduservice&quot;); //模块名 pc.setParent(&quot;com.atguigu&quot;); pc.setController(&quot;controller&quot;); pc.setEntity(&quot;entity&quot;); pc.setService(&quot;service&quot;); pc.setMapper(&quot;mapper&quot;); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;edu_teacher&quot;); //加载表 strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setTablePrefix(pc.getModuleName() + &quot;_&quot;); //生成实体时去掉表前缀 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; 当前项目结构 创建配置类 配置包扫描等 123456789package com.atguigu.eduservice.config;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123;&#125; 创建启动类 启动类位置要放在controller、entity等package的同级，然后run即可启动 12345678910111213package com.atguigu.eduservice;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class EduApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EduApplication.class, args); &#125;&#125; 简单查询所有讲师编写controller12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.eduservice.controller;import com.atguigu.eduservice.entity.EduTeacher;import com.atguigu.eduservice.service.EduTeacherService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * &lt;p&gt; * 讲师 前端控制器 * &lt;/p&gt; * * @author testjava * @since 2021-09-20 */@RestController@RequestMapping(&quot;/eduservice/edu-teacher&quot;)public class EduTeacherController &#123; @Autowired private EduTeacherService teacherService; // REST风格 // 1、查询讲师表的所有数据 // 地址：localhost:8001//eduservice/edu-teacher/findAll @GetMapping(&quot;findAll&quot;) public List&lt;EduTeacher&gt; findAllTeacher() &#123; // 调用Service的方法 List&lt;EduTeacher&gt; list = teacherService.list(null); return list; &#125;&#125; 测试localhost:8001//eduservice/edu-teacher/findAll 逻辑删除讲师实体类属性添加注解 为EduTeacher实体类添加相应的注释@TableLogic 123@ApiModelProperty(value = &quot;逻辑删除 1（true）已删除， 0（false）未删除&quot;)@TableLogicprivate Integer isDeleted; 创建mybatisplus配置类 添加逻辑删除插件（注意mybatis版本，低版本是需要添加的，高版本不用，而且TableId自动识别Type AutoGenerator写法也有区别等） 123456789101112131415161718192021package com.atguigu.eduservice.config;import com.baomidou.mybatisplus.core.injector.ISqlInjector;import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123; /** * 逻辑删除插件 */ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125;&#125; 编写controller 注意使用REST风格URI，pathVariable对应路径参数 123456// 2、逻辑删除讲师@DeleteMapping(&quot;&#123;id&#125;&quot;)public boolean removeTeacher(@PathVariable(&quot;id&quot;) String id) &#123; boolean flag = teacherService.removeById(id); return flag;&#125; 测试（swagger工具） 整合swagger可以用于接口测试、生成在线接口文档等 分页功能配置类导入插件123456789101112131415161718192021@Configuration@MapperScan(&quot;com.atguigu.eduservice.mapper&quot;)public class EduConfig &#123; /** * 逻辑删除插件 */ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125; /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125;&#125; 编写controller123456789101112131415161718192021/** * 3、分页功能 * * @param current 当前页 * @param limit 每页记录数 * @return */@GetMapping(&quot;pageTeacher/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacher(@PathVariable long current, @PathVariable long limit) &#123; // 创建page对象 Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(current, limit); // 调用方法实现分类 teacherService.page(pageTeacher, null); long total = pageTeacher.getTotal(); List&lt;EduTeacher&gt; records = pageTeacher.getRecords(); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;total&quot;, total); map.put(&quot;records&quot;, records); return R.ok().data(map);&#125; 多条件组合查询分页创建VO实体对象 把条件值传递到接口里（将条件值封装到VO(ViewObject)实体对象当中，再把对象vo传递到接口中）浅析VO、DTO、DO、PO的概念、区别和用处_zjrbiancheng的专栏-CSDN博客实体类（VO，DO，DTO）的划分_xin.wang的博客-CSDN博客 123456789101112131415161718192021222324package com.atguigu.eduservice.entity.vo;import io.swagger.annotations.ApiModelProperty;import lombok.Data;// 条件封装对象@Datapublic class TeacherQuery &#123; // 一下属性是对应的可被依据的查询条件（注意和表中字段名对应） @ApiModelProperty(value = &quot;教师名称,模糊查询&quot;) private String name; @ApiModelProperty(value = &quot;头衔 1高级讲师 2首席讲师&quot;) private Integer level; @ApiModelProperty(value = &quot;查询开始时间&quot;, example = &quot;2019-01-01 10:10:10&quot;) private String begin;//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换 @ApiModelProperty(value = &quot;查询结束时间&quot;, example = &quot;2019-12-01 10:10:10&quot;) private String end; &#125; 编写controller123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 4、多条件组合分页 * 参数中可以使用@RequestBody TeacherQuery teacherQuery * 该注释表示使用JSON格式向后端传递数据，会自动封装到对应对象中， * 且需要使用POSTMapping才能获取数据，且如果数据有空需要加上(required = false) * * @param current 当前页 * @param limit 每页记录数 * @param teacherQuery 条件值（以对象的形式） * @return */@ApiOperation(&quot;多条件组合分页&quot;)@PostMapping(&quot;pageTeacherCondition/&#123;current&#125;/&#123;limit&#125;&quot;)public R pageListTeacherCondition(@PathVariable long current, @PathVariable long limit, @RequestBody(required = false) TeacherQuery teacherQuery) &#123; // 创建page对象 Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(current, limit); // 创建wrapper对象 QueryWrapper&lt;EduTeacher&gt; wrapper = new QueryWrapper&lt;&gt;(); // 设定条件 String name = teacherQuery.getName(); Integer level = teacherQuery.getLevel(); String begin = teacherQuery.getBegin(); String end = teacherQuery.getEnd(); if (StringUtils.hasLength(name)) &#123; wrapper.like(&quot;name&quot;, name); &#125; if (level != null) &#123; wrapper.eq(&quot;level&quot;, level); &#125; if (StringUtils.hasLength(begin)) &#123; wrapper.ge(&quot;gmt_create&quot;, begin); &#125; if (StringUtils.hasLength(end)) &#123; wrapper.le(&quot;gmt_create&quot;, end); &#125; // 调用service方法将page对象根据条件分页 teacherService.page(pageTeacher, wrapper); long total = pageTeacher.getTotal(); List&lt;EduTeacher&gt; records = pageTeacher.getRecords(); return R.ok().data(&quot;total&quot;, total).data(&quot;records&quot;, records);&#125; 添加讲师实体类属性添加注解 @TableField（fill = FieldFill.xxx）自动填充注解 1234567@ApiModelProperty(value = &quot;创建时间&quot;)@TableField(fill = FieldFill.INSERT)private Date gmtCreate;@ApiModelProperty(value = &quot;更新时间&quot;)@TableField(fill = FieldFill.INSERT_UPDATE)private Date gmtModified; 创建自定义handler类 可以放到service_base模块，然后需要使用导入依赖即可 当对应方法被使用的使用会被调用 123456789101112131415161718192021package com.atguigu.servicebase.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;gmtCreate&quot;, new Date(), metaObject); this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject); &#125;&#125; 注意结构 编写controller123456789101112/** * 5、添加讲师 * * @param eduTeacher * @return */@ApiOperation(&quot;添加讲师&quot;)@PostMapping(&quot;addTeacher&quot;)public R addTeacher(@RequestBody EduTeacher eduTeacher) &#123; boolean save = teacherService.save(eduTeacher); return save ? R.ok() : R.error();&#125; 修改讲师编写controller12345678910111213@ApiOperation(&quot;根据id查询讲师&quot;)@GetMapping(&quot;getTeacher/&#123;id&#125;&quot;)public R getTeacher(@PathVariable String id) &#123; EduTeacher teacher = teacherService.getById(id); return R.ok().data(&quot;teacher&quot;, teacher);&#125;@ApiOperation(&quot;修改讲师&quot;)@PostMapping(&quot;updateTeacher&quot;)public R updateTeacher(@RequestBody EduTeacher teacher) &#123; boolean flag = teacherService.updateById(teacher); return flag ? R.ok() : R.error();&#125; 使用@PutMapping如下 12345678@ApiOperation(&quot;修改讲师&quot;)@PutMapping(&quot;&#123;id&#125;&#125;&quot;)public R updateTeacher(@PathVariable String id, @RequestBody EduTeacher teacher) &#123; teacher.setId(id); boolean flag = teacherService.updateById(teacher); return flag ? R.ok() : R.error();&#125; 待续","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"}]},{"title":"【Unity】从独立游戏学习开发","slug":"【Unity2D】从独立游戏学习开发","date":"2021-08-24T07:54:59.786Z","updated":"2021-08-25T13:10:56.313Z","comments":true,"path":"2021/08/24/unity2d-cong-du-li-you-xi-xue-xi-kai-fa/","link":"","permalink":"http://example.com/2021/08/24/unity2d-cong-du-li-you-xi-xue-xi-kai-fa/","excerpt":"","text":"感谢感谢bilibili视频网站M_Studio麦口老师系列视频教学，Unity2D都是从他这学的。 创建项目与导入素材 创建新项目 导入素材，点击菜单栏Assets -&gt; ImportPackage 导入并编辑Tiles 点击菜单栏window -&gt; 2D -&gt; tile palette ，点击createNewPalette创建palette 导入Level文件夹下Spirit文件夹中的素材，并且适当编辑 TileMap 在Hierarchy窗口，创建所需要的2dObject -&gt; tilemap 在Tile Palette窗口，选中相应Active Tile Map并绘制 在Inspector窗口设置Sorting Layer，如下 ​ Sorting Layer中Layer越靠下越显示在前方，位于同一Layer中Order in Layer数值越大越显示在前方 其中 Background Details用于在Background中再添加相应tile（在同一个TileMap上绘制只能显示一个tile，即使tile是含有透明背景，也会完全替换） 2D Extra插件RuleTile 在Tiles文件夹下右键点击 Create -&gt; tiles -&gt; rule tile，并在Inspector窗口中设置 Default Sprite默认图片 在Inspector窗口中，设置Tiling Rules，并将新tile拖拽进Tile Palette并绘制，如下 ​ 每一个Tiling Rules中，右侧图片为符合该规则就显示的tile，九宫格中设置规则，绿色箭头表示在该方向上有tile，红色叉号表示不能有tile，同时列表中越靠上的rule优先级越高​ 如上设置可快速填充封闭图形的对应tile 如下规则解决内角问题，注意这四个角的额外rule要放在横竖两个tile的上方 Brush 想要添加贴合格子的物件prefab，可以使用创建brush的方式 创建brush，右键点击 create -&gt; Brush -&gt; prefab Brush 添加Element 在 Tile Palette 窗口中左下角使用自定义brush即可 添加的对象别忘了设置Layer以判断，同时可以使用Override使得同一物品相同设置 Collider和RigidbodyPlatform设置Collider和Rigidbody 选中Platform对象，在Inspector窗口下方点击 add component -&gt; Tilemap Collider 2D 勾选collider中的 user By Composite，即使用复合碰撞体，按照提示添加 Composite Collider 2D，则整个Platform为一个整体碰撞体 将随之添加的 rigidbody -&gt; bodytype设置为static，即可保持Platform固定，而不会因为gravity重力下落 同时也可以将Platform本身设置为static Player设置Collider和Rigidbody 选中Player对象，点击 add component -&gt; rigidbody 2D，并设置参数如下 ​ 注意Colllision Detection 碰撞方式设置为Continuous，即可持续判断是否产生碰撞； Interpolate差值设置为Interpolate，即可当下落碰撞时对碰撞体产生一定效果（基于上一帧物体位置来插值模拟） 点击 add component -&gt; Box Collider 2D，并点击Edit设置碰撞体范围 同时在 Constraints限制选项中选择Freeze Rotation Z，即可防止当角色处于Platform角上时会绕着Z轴旋转掉落 同时为Collider添加Materail Layer为Platform和Player添加不同的Layer，用于日后判断 Player左右移动和形象翻转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // 创建rigidbody private Rigidbody2D rb; [Header(&quot;移动参数&quot;)] public float speed = 8f; // public float crouchSpeedDivisor = 3f; // 蹲下速度减缓量 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 float xVelocity; // 轴速度 void Start() &#123; // 获取rigidbody rb = GetComponent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; GroundMovement(); &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入并设置移动 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125;&#125; Player下蹲点击 Edit -&gt; Project Setting -&gt; Input Manager -&gt; 复制JumpElement并修改为Crouch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; // public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 float xVelocity; // 轴速度 // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // Update is called once per frame void Update() &#123; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; GroundMovement(); &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否按下下蹲按钮、是否未按下按钮并处于下蹲状态 if (Input.GetButton(&quot;Crouch&quot;)) &#123; // 控制角色下蹲 Crouch(); &#125;else if(isCrouch) &#123; // 控制角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125;&#125; Player跳跃123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isJump; // 是否跳跃 [Header(&quot;环境检测&quot;)] public LayerMask groundLayer; // 地面层 float xVelocity; // 轴速度 float jumpTime; // 跳跃时间，与duration相关 // 按键 bool jumpPressed, jumpHeld, crouchHeld; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; // 是否接触地面层 if (coll.IsTouchingLayers(groundLayer)) &#123; isOnGround = true; &#125; else &#123; isOnGround = false; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否 if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if(!crouchHeld &amp;&amp; isCrouch) &#123; // 未按下按钮并处于下蹲状态 --》 角色起身 StandUp(); &#125; else if(!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色跳跃 void MidAirMovement() &#123; if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125;&#125; Raycast射线检测实现移动跳跃下蹲检测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isHeadBlocked; // 是否头顶遮挡 public bool isJump; // 是否跳跃 [Header(&quot;环境检测&quot;)] public float footOffset = 0.35f; // 单脚的偏移值，即整体xoffset的一半 public float headClearance = 0.5f; public float groundDistance = 0.2f; public LayerMask groundLayer; // 地面层 float xVelocity; // 轴速度 float jumpTime; // 跳跃时间，与duration相关 // 按键 bool jumpPressed, jumpHeld, crouchHeld; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; /* // 当前角色的位置和单脚左右点的offset Vector2 pos = transform.position; Vector2 offset = new Vector2(-footOffset, 0f); // leftCheck/rightCheck即单脚左右点检测 RaycastHit2D leftCheck = Physics2D.Raycast(pos+offset,Vector2.down,groundDistance,groundLayer); // 显示射线 Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f); */ // 1、左右脚检测是否接触地面 // 获得射线检测 RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0f), Vector2.down, groundDistance, groundLayer); RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0f), Vector2.down, groundDistance, groundLayer); // 是否接触地面层 //if (coll.IsTouchingLayers(groundLayer)) if (leftCheck || rightCheck) &#123; isOnGround = true; &#125; else &#123; isOnGround = false; &#125; // 2、头顶检测是否有阻挡 RaycastHit2D headCheck = Raycast(new Vector2(0f, coll.size.y), Vector2.up, headClearance, groundLayer); if (headCheck) &#123; isHeadBlocked = true; &#125; else &#123; isHeadBlocked = false; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 判断是否 if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if(!crouchHeld &amp;&amp; isCrouch &amp;&amp; !isHeadBlocked) &#123; // 未按下按钮,处于下蹲状态,头顶无遮挡 --》 角色起身 StandUp(); &#125; else if(!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色跳跃 void MidAirMovement() &#123; if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125; // 增强Raycast函数 RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer) &#123; // 当前角色的位置 Vector2 pos = transform.position; // 创建射线 RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer); // 显示射线,hit返回是否碰撞布尔值 Color color = hit ? Color.red : Color.green; Debug.DrawRay(pos + offset, rayDirection, color); return hit; &#125;&#125; 实现悬挂功能以及下蹲跳跃的优化 判断Raycast射线是否为TRUE的条件：为射线中有接触碰撞体，但是射线起点没有接触碰撞体； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerMovement : MonoBehaviour&#123; // 通过 “Header”, “Tooltip” and “Space” 属性来组织Inspector中的属性显示，即在Inspector窗口上有小标题分区显示 // rigidbody,collider private Rigidbody2D rb; private BoxCollider2D coll; // 使用BoxCollider可以直接获得其中的size、offset参数 [Header(&quot;移动参数&quot;)] public float speed = 8f; public float crouchSpeedDivisor = 3f; // 蹲下时的速度减缓量 [Header(&quot;跳跃参数&quot;)] public float jumpForce = 6.3f; // 跳跃力 public float jumpHoldForce = 1.9f; // 长按跳跃的力 public float jumpHoldDuration = 0.1f; // 长按跳跃加成 public float crouchJumpBoost = 2.5f; // 下蹲跳跃的加成 public float hangingJumpForce = 15f; // 悬挂时跳跃的力 [Header(&quot;状态&quot;)] public bool isCrouch; // 是否下蹲 public bool isOnGround; // 是否接触地面 public bool isHeadBlocked; // 是否头顶遮挡 public bool isJump; // 是否跳跃 public bool isHanging; // 是否悬挂 [Header(&quot;环境检测&quot;)] public LayerMask groundLayer; // 地面层 public float headClearance = 0.25f; public float groundDistance = 0.2f; public float grabDistance = 0.4f; // 抓取距离 public float reachOffset = 0.7f; // 接触偏移值 float footOffset; // 单脚的偏移值，即整体xsize的一半 float xVelocity; // 轴加速度 float jumpTime; // 跳跃时间，与duration相关 float playerHeight; // 角色高度 float eyeHeight; // 角色眼睛高度 // 按键 bool jumpPressed, jumpHeld, crouchHeld, crouchPressed; // 碰撞体尺寸 (站立、下蹲时的大小、位置) Vector2 colliderStandSize, colliderStandOffset,colliderCrouchSize, colliderCrouchOffset; // 初始化参数 void Start() &#123; // rigidbody,collider rb = GetComponent&lt;Rigidbody2D&gt;(); coll = GetComponent&lt;BoxCollider2D&gt;(); footOffset = coll.size.x / 2; playerHeight = coll.size.y; eyeHeight = playerHeight - 0.4f; // 碰撞体尺寸 colliderStandSize = coll.size; colliderStandOffset = coll.offset; colliderCrouchSize = new Vector2(coll.size.x, coll.size.y / 2f); colliderCrouchOffset = new Vector2(coll.offset.x, coll.offset.y / 2f); &#125; // 获取GetButton最好放在此函数中 void Update() &#123; // GetButton参数对应Project Setting -&gt; Input Manager的设置 jumpPressed = Input.GetButtonDown(&quot;Jump&quot;); jumpHeld = Input.GetButton(&quot;Jump&quot;); crouchHeld = Input.GetButton(&quot;Crouch&quot;); crouchPressed = Input.GetButtonDown(&quot;Crouch&quot;); playerHeight = coll.size.y; eyeHeight = playerHeight - 0.4f; &#125; // 固定帧速率下每帧都调用该函数 private void FixedUpdate() &#123; // 相关物理控制 GroundMovement(); PhysicsCheck(); MidAirMovement(); CrouchMovement(); HangdingMovement(); &#125; // 环境检测 void PhysicsCheck() &#123; /* // 当前角色的位置和单脚左右点的offset Vector2 pos = transform.position; Vector2 offset = new Vector2(-footOffset, 0f); // leftCheck/rightCheck即单脚左右点检测 RaycastHit2D leftCheck = Physics2D.Raycast(pos+offset,Vector2.down,groundDistance,groundLayer); // 显示射线 Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f); */ // 1、左右脚射线检测 是否接触地面 // 获得射线检测 RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0f), Vector2.down, groundDistance, groundLayer); RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0f), Vector2.down, groundDistance, groundLayer); // 是否接触地面层 //if (coll.IsTouchingLayers(groundLayer)) if (leftCheck || rightCheck) isOnGround = true; else isOnGround = false; // 2、头顶射线检测 是否有阻挡 RaycastHit2D headCheck = Raycast(new Vector2(0f, playerHeight), Vector2.up, headClearance, groundLayer); if (headCheck) isHeadBlocked = true; else isHeadBlocked = false; // 3、头前方区域射线检测 是否悬挂 float diraction = transform.localScale.x; RaycastHit2D blockedCheck = Raycast(new Vector2(footOffset * diraction, playerHeight), new Vector2(diraction,0f), grabDistance, groundLayer); RaycastHit2D wallCheck = Raycast(new Vector2(footOffset * diraction, eyeHeight), new Vector2(diraction, 0f), grabDistance, groundLayer); RaycastHit2D ledgeCheck = Raycast(new Vector2(reachOffset * diraction, playerHeight), Vector2.down, grabDistance, groundLayer); if (!isOnGround &amp;&amp; rb.velocity.y &lt; 0f &amp;&amp; ledgeCheck &amp;&amp; wallCheck &amp;&amp; !blockedCheck) &#123; // 将player固定在一个位置 Vector3 pos = transform.position; pos.x += (wallCheck.distance - 0.05f) * diraction; // RaycastHit2D下的distance为起始点到接触点的距离 pos.y -= ledgeCheck.distance; transform.position = pos; rb.bodyType = RigidbodyType2D.Static; // 让角色静止 isHanging = true; &#125; &#125; // 控制角色左右移动 void GroundMovement() &#123; // 悬挂时不允许移动 if (isHanging) return; // 获取键盘输入 xVelocity = Input.GetAxis(&quot;Horizontal&quot;); // 返回值-1f ~ 1f，当不按下方向键时为0 // 控制角色速度以移动 rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y); // 控制朝向 FlipDiraction(); &#125; // 控制角色下蹲起立 void CrouchMovement() &#123; if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) &#123; // 按下下蹲按钮，不处于下蹲状态，接触地面 --》 角色下蹲 Crouch(); &#125; else if (!crouchHeld &amp;&amp; isCrouch &amp;&amp; !isHeadBlocked) &#123; // 未按下按钮,处于下蹲状态,头顶无遮挡 --》 角色起身 StandUp(); &#125; else if (!isOnGround &amp;&amp; isCrouch) &#123; // 不接触地面但是处于下蹲状态 ——》 处于空中 --》 角色起身 StandUp(); &#125; &#125; // 控制角色跳跃 void MidAirMovement() &#123; // 跳跃检测 if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump &amp;&amp; !isHeadBlocked) &#123; // isOnGround &amp;&amp; !isJump 防止蹭墙无限跳 // 按下了跳跃，接触地面，未处于跳跃状态 ——》 控制跳跃 // 下蹲状态跳跃，有额外力的加成 if (isCrouch &amp;&amp; !isHeadBlocked) &#123; // 控制起身 StandUp(); // 添加额外力 rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse); &#125; isJump = true; isOnGround = false; // 计算跳跃时的时间，Time.time获取游戏真实持续时间(不断增长) jumpTime = Time.time + jumpHoldDuration; // 修改rb.velocity也可以实现 rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse); &#125; else if (isJump) &#123; // 长按跳跃，获得额外的力jumpHoldForce加成 if (jumpHeld) &#123; rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse); &#125; // 当Time.time获取的时间比jumpTime大，即之间的时间差已经大于jumpHoldDuration的值时，即可恢复isJump if (jumpTime &lt; Time.time) &#123; isJump = false; &#125; &#125; &#125; // 控制角色悬挂时跳跃与下蹲 void HangdingMovement() &#123; // 悬挂时检测 if (isHanging) &#123; if (jumpPressed) &#123; rb.bodyType = RigidbodyType2D.Dynamic; rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse); isHanging = false; &#125; else if (crouchPressed) &#123; rb.bodyType = RigidbodyType2D.Dynamic; isHanging = false; &#125; &#125; &#125; // 控制角色面向方向 void FlipDiraction() &#123; if(xVelocity &lt; 0) &#123; transform.localScale = new Vector2(-1, 1); &#125;else if(xVelocity &gt; 0) &#123; transform.localScale = new Vector2(1, 1); &#125; &#125; // 控制角色下蹲 void Crouch() &#123; isCrouch = true; // 下蹲时速度减缓 xVelocity /= crouchSpeedDivisor; // 改变collider的尺寸 coll.size = colliderCrouchSize; coll.offset = colliderCrouchOffset; &#125; // 控制角色起立 void StandUp() &#123; isCrouch = false; // 改变collider的尺寸 coll.size = colliderStandSize; coll.offset = colliderStandOffset; &#125; // 增强Raycast函数 RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer) &#123; // 当前角色的位置 Vector2 pos = transform.position; // 创建射线 RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer); // 显示射线,hit返回是否碰撞布尔值 Color color = hit ? Color.red : Color.green; Debug.DrawRay(pos + offset, rayDirection, color); return hit; &#125;&#125; 2D透视效果与摄像机 PackageManager -&gt; CineMachines插件导入，添加Follow选项 body -&gt; dead zone锁死范围，在该范围内移动不会跟着移动摄像机 body -&gt; Screen 设置follow角色在摄像机的哪个位置 body -&gt; CameraDistance 设置摄像机包括范围 Main Camera -&gt; Projection -&gt; Perspective，即可模拟正常摄像机效果（切换Scene 2D即可查看） Extension -&gt; Confiner添加摄像机移动边界，为Background添加Collider，注意一定要点选is trigger选项 灯光 对Object右键light -&gt; point light 添加点光源 为Plateform、Background添加materail Window -&gt; Rendering -&gt;light -&gt;Enviroment -&gt; Ambient Color，设置主场景灯光 动画 Window -&gt; Animator/Animation，打开窗口 添加script：PlayerAnimation如下 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; int groundID; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); groundID = Animator.StringToHash(&quot;isOnGround&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); &#125; void Update() &#123; // 设置animatior的状态值 animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); // 使用编号对应赋值、字符串对应赋值 animator.SetBool(groundID, movement.isOnGround); animator.SetBool(&quot;isJumping&quot;, movement.isJump); animator.SetBool(&quot;isCrouching&quot;, movement.isCrouch); animator.SetBool(&quot;isHanging&quot;, movement.isHanging); &#125;&#125; 使用BlendTree 在Animator的BaseLayer中右键 Create State -&gt; From New Blend Tree 点击新的BlendTreeState，在Inspector -&gt; Motion 添加Motion，添加每一个motion对应的animation，且将Parameter设置为自定义的state Threshold临界值选项，当对应parameter值复合某一threshold值时会播放该animation，注意垂直向上水平向右为正 ​ 上图中MidAir1~7为起跳到下落的动画 修改动画脚本如下 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; Rigidbody2D rb; int speedID, groundID, jumpingID, crouchingID, hangingID, fallId; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); // animatior parameter对应编号 speedID = Animator.StringToHash(&quot;speed&quot;); groundID = Animator.StringToHash(&quot;isOnGround&quot;); jumpingID = Animator.StringToHash(&quot;isJumping&quot;); crouchingID = Animator.StringToHash(&quot;isCrouching&quot;); hangingID = Animator.StringToHash(&quot;isHanging&quot;); fallId = Animator.StringToHash(&quot;verticalVelocity&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); rb = GetComponentInParent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; // 设置animatior的状态值，两种方法（使用编号对应赋值、字符串对应赋值） // animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); animator.SetFloat(speedID, Mathf.Abs(movement.xVelocity)); animator.SetBool(groundID, movement.isOnGround); animator.SetBool(jumpingID, movement.isJump); animator.SetBool(crouchingID, movement.isCrouch); animator.SetBool(hangingID, movement.isHanging); animator.SetFloat(fallId, rb.velocity.y); &#125;&#125; 音效 注意Animation窗口中对应动画，含有特定的animation event需要添加 添加AudioManager(Prefab)，并为其添加script如下 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; static AudioManager current; [Header(&quot;环境声音&quot;)] public AudioClip ambientCilip; public AudioClip musicClip; [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; public void Awake() &#123; current = this; &#125;&#125; ​ 同时在AudioManager(Prefab)中选择相应的音效 添加AudioSource 12345678910111213141516171819202122232425262728293031323334353637383940414243using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; // ... AudioSource ambientSource, musicSource, fxSource, playerSource, voiceSource; public void Awake() &#123; // 单例模式 if(current != null) &#123; Destroy(gameObject); return; &#125; // 方便在static方法中使用this current = this; // 防止场景加载时被销毁 DontDestroyOnLoad(gameObject); // 使用代码添加AudioSource组件 ambientSource = gameObject.AddComponent&lt;AudioSource&gt;(); musicSource = gameObject.AddComponent&lt;AudioSource&gt;(); fxSource = gameObject.AddComponent&lt;AudioSource&gt;(); playerSource = gameObject.AddComponent&lt;AudioSource&gt;(); voiceSource = gameObject.AddComponent&lt;AudioSource&gt;(); &#125; public static void PlayFootstepAudio() &#123; // 获得随机数 int index = Random.Range(0, current.walkStepClips.Length); // 指定source的clip声音片段 current.playerSource.clip = current.walkStepClips[index]; // 播放 current.playerSource.Play(); &#125;&#125; 在PlayerAnimation中调用方法 1234public void StepAudio()&#123; AudioManager.PlayFootstepAudio();&#125; 其他音效同理，完整如下 AudioManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Audio;public class AudioManager : MonoBehaviour&#123; static AudioManager current; [Header(&quot;环境声音&quot;)] public AudioClip ambientClip; public AudioClip musicClip; [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; // clip声音片段，source声音源 AudioSource ambientSource, musicSource, fxSource, playerSource, voiceSource; public void Awake() &#123; // 单例模式 if(current != null) &#123; Destroy(gameObject); return; &#125; // 方便在static方法中使用this current = this; // 防止场景加载时被销毁 DontDestroyOnLoad(gameObject); // 使用代码添加AudioSource组件 ambientSource = gameObject.AddComponent&lt;AudioSource&gt;(); musicSource = gameObject.AddComponent&lt;AudioSource&gt;(); fxSource = gameObject.AddComponent&lt;AudioSource&gt;(); playerSource = gameObject.AddComponent&lt;AudioSource&gt;(); voiceSource = gameObject.AddComponent&lt;AudioSource&gt;(); // 背景音乐不需要触发，直接播放 StartLevelAudio(); &#125; // 背景音乐 void StartLevelAudio() &#123; // 打开循环 current.ambientSource.clip = current.ambientClip; current.ambientSource.loop = true; current.ambientSource.Play(); current.musicSource.clip = current.musicClip; current.musicSource.loop = true; current.musicSource.Play(); &#125; // 角色走动音效 public static void PlayFootstepAudio() &#123; // 获得随机数 int index = Random.Range(0, current.walkStepClips.Length); // 指定source的clip声音片段 current.playerSource.clip = current.walkStepClips[index]; // 播放 current.playerSource.Play(); &#125; // 角色下蹲音效 public static void PlayCrouchFootstepAudio() &#123; int index = Random.Range(0, current.crouchStepClips.Length); current.playerSource.clip = current.crouchStepClips[index]; current.playerSource.Play(); &#125; // 角色跳跃音效 public static void PlayJumpAudio() &#123; current.playerSource.clip = current.jumpClip; current.playerSource.Play(); current.voiceSource.clip = current.jumpVoiceClip; current.voiceSource.Play(); &#125;&#125; PlayerAnimation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerAnimation : MonoBehaviour&#123; Animator animator; PlayerMovement movement; Rigidbody2D rb; int speedID, groundID, jumpingID, crouchingID, hangingID, fallId; void Start() &#123; animator = GetComponent&lt;Animator&gt;(); // animatior parameter对应编号 speedID = Animator.StringToHash(&quot;speed&quot;); groundID = Animator.StringToHash(&quot;isOnGround&quot;); jumpingID = Animator.StringToHash(&quot;isJumping&quot;); crouchingID = Animator.StringToHash(&quot;isCrouching&quot;); hangingID = Animator.StringToHash(&quot;isHanging&quot;); fallId = Animator.StringToHash(&quot;verticalVelocity&quot;); // 获取父组件的脚本 movement = GetComponentInParent&lt;PlayerMovement&gt;(); rb = GetComponentInParent&lt;Rigidbody2D&gt;(); &#125; void Update() &#123; // 设置animatior的状态值，两种方法（使用编号对应赋值、字符串对应赋值） // animator.SetFloat(&quot;speed&quot;, Mathf.Abs(movement.xVelocity)); animator.SetFloat(speedID, Mathf.Abs(movement.xVelocity)); animator.SetBool(groundID, movement.isOnGround); animator.SetBool(jumpingID, movement.isJump); animator.SetBool(crouchingID, movement.isCrouch); animator.SetBool(hangingID, movement.isHanging); animator.SetFloat(fallId, rb.velocity.y); &#125; public void StepAudio() &#123; AudioManager.PlayFootstepAudio(); &#125; public void CrouchStepAudio() &#123; AudioManager.PlayCrouchFootstepAudio(); &#125;&#125; ​ 由于Animation中没有添加jump的event，所以直接在playerMovement中调用音效即可 死亡机制 添加新的cs代码如下，应用于角色，用于死亡条件判断 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerHealth : MonoBehaviour&#123; // 预制死亡特效 public GameObject deathVFXPrefab; int trapsLayer; void Start() &#123; // 获得对应Layer的编号 trapsLayer = LayerMask.NameToLayer(&quot;Traps&quot;); &#125; // 如果一个碰撞体进入了触发器（当前角色已经被设定为isTrigger）则调用 private void OnTriggerEnter2D(Collider2D collision) &#123; if (collision.gameObject.layer == trapsLayer) &#123; // Instantiate实例化，此处让特效显示 Instantiate(deathVFXPrefab,transform.position,transform.rotation); // 让角色消失 gameObject.SetActive(false); // 播放死亡音效 AudioManager.PlayDeathAudio(); &#125; &#125;&#125; 添加死亡音效，注意在Inspector窗口中选择对应片段 1234567891011121314151617181920212223 [Header(&quot;角色音效&quot;)] public AudioClip[] walkStepClips; public AudioClip[] crouchStepClips; public AudioClip jumpClip; public AudioClip jumpVoiceClip; public AudioClip deathClip; public AudioClip deathVoiceClip; [Header(&quot;特效音效&quot;)] public AudioClip deathFXClip;// 死亡音效public static void PlayDeathAudio()&#123; current.playerSource.clip = current.deathClip; current.playerSource.Play(); current.voiceSource.clip = current.deathVoiceClip; current.voiceSource.Play(); current.fxSource.clip = current.deathFXClip; current.fxSource.Play();&#125; 设置场景重置，在file -&gt; build settings 中设置scene 123456using UnityEngine.SceneManagement;private void OnTriggerEnter2D(Collider2D collision)&#123; // 重置场景为当前场景 SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);&#125; 视觉效果与相机抖动Post Processing Window -&gt; PackageManager -&gt; 搜索插件Post Processing 为 Main Camera 添加Component -&gt; Post-process Layer，创建一个专门的Layer并添加 创建一个Empty Object，命名为Global Post Processing同时添加上一步骤中的Layer，用于承载视觉效果（如果是单独物件添加特效直接添加即可） 为该对象添加组件 Post-process Volume，其中is Global 用于影响全局，否则添加collider设置影响范围即可 为该对象添加Profile，同时Add effect Camera Shake 在之前添加的Cinemachine中， Inspector -&gt; Extension -&gt;Cinemachine Impulse Listener 在触发相机抖动效果的物件上添加组件 Cinemachine Collision Impulse Source(此为碰撞触发，可选其他source)， 为该组件添加Raw Signal即触发抖动时的效果，可以自行设置，选择TriggerObjectFilter中的LayerMask，即碰撞当前对象的Layer 其余如SignalShape中的FrequencyGain越大速度越快…… GameManager死亡过渡以及相关计数 添加Script，一定命名为GameManager，如下编写 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; DontDestroyOnLoad(this); &#125; public static void PlayerDied() &#123; // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.5f); &#125; // 重启场景 void RestartScene() &#123; SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 添加Empty Object并应用GameManager Script 添加SceneFader Script，编写如下，应用于Fader(UI -&gt; Image对象，含有过渡动画，其中Animator中有Fade参数) 12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;public class SceneFader : MonoBehaviour&#123; Animator anim; int faderID; private void Start() &#123; anim = GetComponent&lt;Animator&gt;(); faderID = Animator.StringToHash(&quot;Fade&quot;); &#125; public void fadeOut() &#123; anim.SetTrigger(faderID); &#125;&#125; 在GameManager中添加如下代码，这里mark一下，上网搜了其他的模式和方法，都可以实现，视频里讲的是观察者模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; SceneFader sceneFader; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; DontDestroyOnLoad(this); &#125; // 用于通知GameManager接收一个SceneFader实例 //public static void RegisterSceneFader(SceneFader fader) //&#123; // gm.sceneFader = fader; //&#125; public static void PlayerDied() &#123; //SceneFader.sf.fadeOut(); SceneFader.sf.fadeOut(); // 以下为另一种调用其他类的方法实现方法，还有其他方法或模式可以实现 //GameObject.Find(&quot;Fader&quot;).SendMessage(&quot;fadeOut&quot;); // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.2f); &#125; // 重启场景 void RestartScene() &#123; SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 123456789101112131415161718192021222324252627282930313233using System.Collections;using System.Collections.Generic;using UnityEngine;public class SceneFader : MonoBehaviour&#123; // 这里使用单例模式，能让其他类调用 public static SceneFader sf; Animator anim; int faderID; private void Awake() &#123; if (sf != null) &#123; return; &#125; sf = this; &#125; private void Start() &#123; anim = GetComponent&lt;Animator&gt;(); faderID = Animator.StringToHash(&quot;Fade&quot;); //GameManager.RegisterSceneFader(this); &#125; public void fadeOut() &#123; anim.SetTrigger(faderID); &#125;&#125; 添加收集物的相关脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class GameManager : MonoBehaviour&#123; static GameManager gm; //SceneFader sceneFader; List&lt;Orb&gt; orbs; public int orbNum,deathNum; private void Awake() &#123; if(gm != null) &#123; Destroy(gameObject); return; &#125; gm = this; orbs = new List&lt;Orb&gt;(); DontDestroyOnLoad(this); &#125; private void Update() &#123; orbNum = gm.orbs.Count; &#125; // 用于通知GameManager接收一个SceneFader实例 //public static void RegisterSceneFader(SceneFader fader) //&#123; // gm.sceneFader = fader; //&#125; public static void RegisterOrb(Orb orb) &#123; if (!gm.orbs.Contains(orb)) &#123; gm.orbs.Add(orb); &#125; &#125; public static void PlayerDied() &#123; //SceneFader.sf.fadeOut(); SceneFader.sf.fadeOut(); // 以下为另一种调用其他类的方法实现方法，还有其他方法或模式可以实现 //GameObject.Find(&quot;Fader&quot;).SendMessage(&quot;fadeOut&quot;); // 经过一段时间后调用方法 gm.Invoke(&quot;RestartScene&quot;, 1.2f); gm.deathNum++; &#125; public static void PlayerGetOrb(Orb orb) &#123; if (gm.orbs.Count == 0 || !gm.orbs.Contains(orb)) return; gm.orbs.Remove(orb); &#125; // 重启场景 void RestartScene() &#123; gm.orbs.Clear(); SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); &#125;&#125; 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;public class Orb : MonoBehaviour&#123; int playerLayer; public GameObject explosionVFXPrefab; void Start() &#123; playerLayer = LayerMask.NameToLayer(&quot;Player&quot;); GameManager.RegisterOrb(this); &#125; private void OnTriggerEnter2D(Collider2D collision) &#123; if(collision.gameObject.layer == playerLayer) &#123; GameManager.PlayerGetOrb(this); Instantiate(explosionVFXPrefab, transform.position, transform.rotation); gameObject.SetActive(false); AudioManager.PlayOrbAudio(); &#125; &#125;&#125; Door机关收集物品到一定数量后打开机关 编写Door Script 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class Door : MonoBehaviour&#123; Animator anim; int openID; void Start() &#123; anim = GetComponent&lt;Animator&gt;(); openID = Animator.StringToHash(&quot;Open&quot;); GameManager.RegisterDoor(this); &#125; public void Open() &#123; anim.SetTrigger(openID); AudioManager.PlayOpenDoorAudio(); &#125;&#125; 编写AudioManager 123456// 打开门音效 public static void PlayOpenDoorAudio() &#123; current.fxSource.clip = current.doorFXClip; current.fxSource.PlayDelayed(1f); &#125; UI Manager显示text 编写一个UI Manager Object，添加script如下 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;using TMPro;public class UIManager : MonoBehaviour&#123; static UIManager instance; // 获得Text文本框,记得在Inspector中选择相应的text public TextMeshProUGUI orbText, timeText, deathText, gameOverText; private void Awake() &#123; if(instance != null) &#123; Destroy(gameObject); return; &#125; instance = this; DontDestroyOnLoad(this); &#125; // 更新Orb数量 public static void UpdateOrbUI(int orbCount) &#123; // 设置text instance.orbText.text = orbCount.ToString(); &#125; // 其余text类似&#125; 在GameManager中适当位置调用UIManager相应方法即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System.Collections;using System.Collections.Generic;using UnityEngine;using TMPro;public class UIManager : MonoBehaviour&#123; static UIManager instance; // 获得Text文本框,记得在Inspector中选择相应的text public TextMeshProUGUI orbText, timeText, deathText, gameOverText; private void Awake() &#123; if(instance != null) &#123; Destroy(gameObject); return; &#125; instance = this; DontDestroyOnLoad(this); &#125; // 更新Orb数量 public static void UpdateOrbUI(int orbCount) &#123; // 设置text instance.orbText.text = orbCount.ToString(); &#125; // 更新Death数量 public static void UpdateDeathUI(int deathNum) &#123; // 设置text instance.deathText.text = deathNum.ToString(); &#125; // 更新Time public static void UpdateTimeUI(int time) &#123; int minutes = time / 60; int seconds = time % 60; // 设置text instance.timeText.text = minutes.ToString(&quot;00&quot;)+&quot;:&quot;+seconds.ToString(&quot;00&quot;); &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Unity2D","slug":"Unity2D","permalink":"http://example.com/tags/Unity2D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"}]},{"title":"【学习笔记】Vue","slug":"【学习笔记】Vue","date":"2021-08-04T03:44:20.728Z","updated":"2021-08-24T07:55:46.470Z","comments":true,"path":"2021/08/04/xue-xi-bi-ji-vue/","link":"","permalink":"http://example.com/2021/08/04/xue-xi-bi-ji-vue/","excerpt":"","text":"感谢【尚硅谷】2021最新Vue迅速上手教程丨vue3.0入门到精通_张天禹老师 前言​ 昨天看完springboot2的教学视频，计划着接下来要学什么，毕竟休息一天，就会一直偷懒下去。早上刚看到群里发企业项目要找个会vue，再结合结合vue的热度，虽然自己并不像和前端有太多纠葛（因为强迫症），但是大势所趋，都向着全栈靠呢，而且个人项目肯定也得自己做，所以学了都是好处没坏处。 其实七月初的时候看过两天的vue语法视频（为了暑假集训教学，其实并没有什么用，还忘光了），也没有记笔记，现在正式的看，好好学，好好记，目测两个星期看完？（毕竟也是学了点vue和微信小程序的，上手应该快）看完之后得做个项目了，vue+springboot，不过学期开学也要做个人项目，到时候做也是可以的。 Vue简介什么是Vue 一套用于构建用户界面的渐进式JavaScript框架。 Vue特点 采用组件化模式, 提高代码复用率、且让代码更好维护。 声明式编码,让编码人员无需直接操作DOM, 提高开发效率。 使用虛拟DOM+优秀的Diff算法, 尽量复用DOM节点。 basic容器与Vue实例 其实感觉不用写什么，直接看官方文档或者看代码👌 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 初识Vue： 1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象； 2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法； 3.root容器里的代码被称为【Vue模板】； 4.Vue实例和容器是一一对应的； 5.真实开发中只有一个Vue实例，并且会配合着组件一起使用； 6.&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性； 7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新； 注意区分：js表达式 和 js代码(语句) 1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方： (1). a (2). a+b (3). demo(1) (4). x === y ? &#x27;a&#x27; : &#x27;b&#x27; 2.js代码(语句) (1). if()&#123;&#125; (2). for()&#123;&#125;--&gt;&lt;!-- 准备好一个容器 --&gt;&lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; &gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //创建Vue实例 new Vue(&#123; el:&#x27;#demo&#x27;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。 data:&#123; //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。 name:&#x27;atguigu&#x27;, address:&#x27;北京&#x27; &#125; &#125;)&lt;/script&gt; 单向双向绑定1234567891011121314151617181920212223242526272829303132333435&lt;!-- Vue模板语法有2大类： 1.插值语法： 功能：用于解析标签体内容。 写法：&#123;&#123;xxx&#125;&#125;，xxx是js表达式，且可以直接读取到data中的所有属性。 2.指令语法： 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。 举例：v-bind:href=&quot;xxx&quot; 或 简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式， 且可以直接读取到data中的所有属性。 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。 --&gt;&lt;!-- 准备好一个容器--&gt;&lt;div id=&quot;root&quot;&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;hr/&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习1&lt;/a&gt; &lt;a :href=&quot;school.url&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习2&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;jack&#x27;, school:&#123; name:&#x27;尚硅谷&#x27;, url:&#x27;http://www.atguigu.com&#x27;, &#125; &#125; &#125;)&lt;/script&gt; MVVM 后面写代码去了没写笔记，笔记都在代码上","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"【集训】微信小程序(二)","slug":"【集训】微信小程序(二)","date":"2021-07-22T01:00:03.480Z","updated":"2021-07-23T05:35:01.858Z","comments":true,"path":"2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-er/","link":"","permalink":"http://example.com/2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-er/","excerpt":"","text":"API系统信息Object wx.getSystemInfoSync() | 微信开放文档 (qq.com) 1234567// 获取系统信息wx.getSystemInfo(&#123; success: (result) =&gt; &#123; console.log(result); console.log(result.model); &#125;,&#125;) 交互wx.showToast(Object object) | 微信开放文档 (qq.com) 12345678910111213141516// loading提示框wx.showLoading(&#123; title: &#x27;数据加载中&#x27;,&#125;)setTimeout(res =&gt; &#123; wx.hideLoading(&#123; success: (res) =&gt; &#123; console.log(&quot;加载完成&quot;); &#125;, &#125;)&#125;, 2000)// 消息提示wx.showToast(&#123; title: &#x27;提示信息&#x27;,&#125;) 路由跳转页面wx.navigateTo(Object object) | 微信开放文档 (qq.com) 1&lt;button type=&quot;primary&quot; bindtap=&quot;clickBtn&quot;&gt;跳转到demo01&lt;/button&gt; 123456789clickBtn() &#123; // 可带参数,调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会 wx.navigateTo(&#123; url: &#x27;/pages/demo05/demo05?id=111&#x27;, success: (res) =&gt; &#123; console.log(res); &#125; &#125;) &#125; 返回页面wx.navigateBack(Object object) | 微信开放文档 (qq.com) 1&lt;button bindtap=&quot;clickBack&quot; type=&quot;primary&quot;&gt;返回上一页&lt;/button&gt; 12345clickBack() &#123; wx.navigateBack(&#123; delta: 1, &#125;) &#125; 事件传值EventChannel | 微信开放文档 (qq.com) demo04.js 1234567891011121314151617clickBtn() &#123; // 可带参数,调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会 wx.navigateTo(&#123; url: &#x27;/pages/demo05/demo05?id=111&#x27;, events: &#123; // 为指定事件添加一个监听器 myBackData(data) &#123; console.log(data); &#125; &#125;, // 成功的回调函数 success: (res) =&gt; &#123; // 触发一个事件 res.eventChannel.emit(&quot;myGetData&quot;, &#123; data: &quot;传递的数据&quot; &#125;) &#125; &#125;) &#125; demo05.js 1234567891011121314151617181920onLoad() &#123; // 获取所有打开的EventChannel事件 const eventChannel = this.getOpenerEventChannel(); // 监听index页面的myGetData事件 eventChannel.on(&quot;myGetData&quot;, (res) =&gt; &#123; // 被触发后的操作 console.log(res); &#125;); eventChannel.emit(&quot;myBackData&quot;, &#123; data: &quot;返回的数据&quot; &#125;)&#125;,clickBack() &#123; //const eventChannel = this.getOpenerEventChannel(); //eventChannel.emit(&quot;myBackData&quot;, &#123; data: &quot;返回的数据&quot; &#125;) // 通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。 wx.navigateBack(&#123; delta: 1, &#125;)&#125; 网络临时数据demo06.wxml 123456789101112&lt;!--pages/demo06/demo06.wxml--&gt;&lt;view class=&quot;out&quot;&gt; &lt;view class=&quot;row&quot; wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; wx:key=&quot;*this&quot;&gt; &lt;view class=&quot;pic&quot;&gt; &lt;image src=&quot;&#123;&#123;item.url&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;text&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;item.time&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; demo06.js 12345678910111213141516171819data: &#123; dataList: [ &#123; title: &quot;标题1&quot;, time: &quot;2020-01-01&quot;, url: &quot;/images/image1.png&quot; &#125;, &#123; title: &quot;标题2&quot;, time: &quot;2020-01-02&quot;, url: &quot;/images/image1.png&quot; &#125;, &#123; title: &quot;标题3&quot;, time: &quot;2020-01-03&quot;, url: &quot;/images/image1.png&quot; &#125; ]&#125;, 请求数据RequestTask | 微信开放文档 (qq.com) 使用wx.request获取数据 1234567891011121314151617181920onLoad: function (options) &#123; wx.request(&#123; // 接口地址 url: &#x27;http://edu.newsight.cn/wxList.php&#x27;, // 请求的参数 data: &#123; num: 5, page: 1 &#125;, // 接口调用成功的回调函数 success: (res) =&gt; &#123; console.log(res); console.log(res.data); // 设置数据 this.setData(&#123; reqData: res.data &#125;) &#125;, &#125;)&#125;, 修改之前的代码 demo06.wxml 123456789101112&lt;!--pages/demo06/demo06.wxml--&gt;&lt;view class=&quot;out&quot;&gt; &lt;view class=&quot;row&quot; wx:for=&quot;&#123;&#123;reqData&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;view class=&quot;pic&quot;&gt; &lt;image src=&quot;&#123;&#123;item.picurl&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;text&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;item.posttime&#125;&#125; - &#123;&#123;item.author&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 如果域名检验不合法，可以在微信公众平台的开发中管理添加所需要使用的域名，或者开发者工具在设置不检测合法。 事件绑定刷新数据demo06.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// pages/demo06/demo06.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; reqData: [], scrollTop: 0 &#125;, reqParam: &#123; page: 1 &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.getReqData(1); &#125;, // 下一页 clickToNextPage() &#123; this.reqParam.page++; this.getReqData(this.reqParam.page) &#125;, getReqData(page) &#123; wx.request(&#123; // 接口地址 url: &#x27;http://edu.newsight.cn/wxList.php&#x27;, // 请求的参数 data: &#123; num: 4, page: page &#125;, // 接口调用成功的回调函数 success: (res) =&gt; &#123; console.log(res); console.log(res.data); // 设置数据 this.setData(&#123; reqData: res.data &#125;) &#125;, &#125;) &#125;&#125;) demo06.wxml 1&lt;button bindtap=&quot;clickToNextPage&quot; type=&quot;primary&quot;&gt;下一页&lt;/button&gt; 用户信息wx.getUserProfile(Object object) | 微信开放文档 (qq.com) demo07.wxml 123&lt;button bindtap=&quot;login&quot; type=&quot;primary&quot;&gt;授权登录&lt;/button&gt;&lt;view&gt;&#123;&#123;nickName&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt; demo07.js 12345678910111213141516171819202122data: &#123; nickName: &quot;&quot;, avatar: &quot;&quot;,&#125;,// 授权登录login() &#123; wx.getUserProfile(&#123; // 声明获取用户个人信息后的用途，不超过30个字符 desc: &#x27;声明获取用户信息后的用途&#x27;, success: (res) =&gt; &#123; console.log(res); this.setData(&#123; nickName: res.userInfo.nickName, avatar: res.userInfo.avatarUrl &#125;) &#125;, fail: (res) =&gt; &#123; console.log(res); &#125; &#125;)&#125; 缓存wx.setStorageSync(string key, any data) | 微信开放文档 (qq.com) 存123456789101112131415161718login() &#123; wx.getUserProfile(&#123; // 声明获取用户个人信息后的用途，不超过30个字符 desc: &#x27;声明获取用户信息后的用途&#x27;, success: (res) =&gt; &#123; console.log(res); this.setData(&#123; nickName: res.userInfo.nickName, avatar: res.userInfo.avatarUrl &#125;); // 存信息 wx.setStorageSync(&#x27;userInfo&#x27;, res.userInfo); &#125;, fail: (res) =&gt; &#123; console.log(res); &#125; &#125;)&#125; 取123&lt;button bindtap=&quot;login&quot; type=&quot;primary&quot; wx:if=&quot;&#123;&#123;!nickName&#125;&#125;&quot;&gt;授权登录&lt;/button&gt;&lt;view&gt;&#123;&#123;nickName&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt; 123456789onLoad: function (options) &#123; // 取缓存 let userInfo = wx.getStorageSync(&#x27;userInfo&#x27;); console.log(userInfo); this.setData(&#123; nickName: userInfo.nickName, avatar: userInfo.avatarUrl &#125;)&#125;, 模块化Object module | 微信开放文档 (qq.com) public.js 123456789101112var myPublic = &#123; fun1() &#123; console.log(&quot;执行fun1&quot;); &#125;, fun2(p) &#123; console.log(&quot;执行fun2,参数：&quot; + p); &#125;&#125;module.exports = myPublic demo08.js 123456const myPublic = require(&#x27;../../utils/public.js&#x27;)onLoad: function (options) &#123; myPublic.fun1(); myPublic.fun2(&quot;param&quot;);&#125;, 小程序上线 修改测试号为AppID 小程序 (qq.com)管理服务器域名，取消不检验合法域名 上传代码 小程序 (qq.com)提交审核","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"【集训】微信小程序(一)","slug":"【集训】微信小程序(一)","date":"2021-07-22T01:00:03.478Z","updated":"2021-07-23T05:50:01.078Z","comments":true,"path":"2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-yi/","link":"","permalink":"http://example.com/2021/07/22/ji-xun-wei-xin-xiao-cheng-xu-yi/","excerpt":"","text":"自定义组件Component(Object object) | 微信开放文档 (qq.com) 将部分重复代码抽取出来 商品分类 (taobao.com) 创建自定义组件 类似于页面，一个自定义组件由json、wxml、wxss、js 4个文件组成 可以在微信开发者⼯具中快速创建组件的⽂件结构 声明组件、引入组件tabs.json 123&#123; &quot;component&quot;: true&#125; demo01.json 12345&#123; &quot;usingComponents&quot;: &#123; &quot;Tabs&quot;: &quot;/components/Tabs/Tabs&quot; &#125;&#125; 简单编辑组件Tabs.wxml 123456789101112&lt;!--components/Tabs/Tabs.wxml--&gt;&lt;view class=&quot;tabs&quot;&gt; &lt;view class=&quot;tabs_title&quot;&gt; &lt;view class=&quot;title_item active&quot;&gt;首页&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;原创&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;分类&lt;/view&gt; &lt;view class=&quot;title_item&quot;&gt;关于&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tabs_content&quot;&gt; &lt;/view&gt;&lt;/view&gt; Tabs.wxss 12345678910111213141516171819202122/* components/Tabs/Tabs.wxss */.tabs &#123;&#125;.tabs_title &#123; display: flex; padding: 10rpx 0;&#125;.title_item &#123; flex: 1; display: flex; justify-content: center; align-items: center;&#125;/* 选中时的样式 */.active &#123; color: #b81d24; border-bottom: 5rpx solid currentColor;&#125;.tabs_content &#123;&#125; 以上数据都写在组件的wxml中，接下来来实现js动态数据 填入初始数据Tabs.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// components/Tabs/Tabs.jsComponent(&#123; /** * 组件的属性列表 */ properties: &#123; &#125;, /** * 组件的初始数据 */ data: &#123; tabs: [ &#123; id: 0, name: &quot;首页&quot;, isActive: true &#125;, &#123; id: 1, name: &quot;原创&quot;, isActive: false &#125; , &#123; id: 2, name: &quot;分类&quot;, isActive: false &#125; , &#123; id: 3, name: &quot;关于&quot;, isActive: false &#125; ] &#125;, /** * 组件的方法列表 */ methods: &#123; &#125;&#125;) Tab.wxml 12345678910111213&lt;view class=&quot;tabs&quot;&gt; &lt;view class=&quot;tabs_title&quot;&gt; &lt;!-- 列表渲染 --&gt; &lt;!-- class中三元表达式，根据item的isActive属性判断是否选中，选中则添加类名以显示样式 --&gt; &lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tabs_content&quot;&gt;&lt;/view&gt; &lt;/view&gt; 绑定点击事件Tab.wxml 123456789&lt;view class=&quot;tabs_title&quot;&gt; &lt;!-- 列表渲染 --&gt; &lt;!-- class中三元表达式，根据item的isActive属性判断是否选中，选中则添加类名以显示样式 --&gt; &lt;!-- data-index自定义属性，用于传递当前的索引值 --&gt; &lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;title_item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot; bindtap=&quot;handleItemTap&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/view&gt;&lt;/view&gt; 注意自定义组件的方法写在methods中 Tabs.js 123456789101112131415161718192021222324252627methods: &#123; handleItemTap(e) &#123; // 查看索引所在的位置 console.log(e); // 1.获取被点击的索引 // ES6常量const,只读不可改 // ES6解构赋值:const &#123; index &#125; = e.currentTarget.dataset; const index = e.currentTarget.dataset.index; // 2.获取原数组 // ES6变量let,块级作用域 // ES6解构赋值:let &#123; tabs &#125; = this.data; let tabs = this.data.tabs; // 3.循环数组：为当前索引项设置isActive：true,其余false // ES6箭头函数 tabs.forEach((v, i) =&gt; &#123; i === index ? v.isActive = true : v.isActive = false &#125;); // 修改数据 this.setData(&#123; tabs &#125;) &#125;&#125; 以上数据都写在组件中，接下来来实现父向子传递数据 父向子传递数据demo01.wxml 123456&lt;!-- 父组件demo01，子组件Tabs 父组件通过标签属性传递数据 子组件在properties中接收--&gt;&lt;Tabs abc=&quot;要传递的数据&quot;&gt;&lt;/Tabs&gt; Tabs.js 123456789properties: &#123; // 属性名 abc: &#123; // 接收的数据的类型 type: String, // 默认值 value: &quot;&quot; &#125;&#125;, Tabs.wxml 12&lt;!-- 相当于data中的数据使，用&#123;&#123;&#125;&#125;渲染 --&gt;&lt;view&gt;&#123;&#123;abc&#125;&#125;&lt;/view&gt; 接下来修改案例代码 将要传递的数据放在父组件的data中，即原先写在Tabs.js的data中的数据放在demo01.js的data中 1234567891011121314151617181920212223242526data: &#123; tabs: [ &#123; id: 0, name: &quot;首页&quot;, isActive: true &#125;, &#123; id: 1, name: &quot;原创&quot;, isActive: false &#125; , &#123; id: 2, name: &quot;分类&quot;, isActive: false &#125; , &#123; id: 3, name: &quot;关于&quot;, isActive: false &#125; ]&#125;, 父组件通过标签属性传递数据 demo01.wxml 1&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot;&gt;&lt;/Tabs&gt; 子组件在properties中接收，最后效果与之前相同 Tabs.js 123456properties: &#123; tabs: &#123; type: Array, value: [] &#125;&#125;, 此时Tabs.js中代码仍然是在子组件当中修改tab数组，而不是在父组件的data中修改tab（可以在AppData窗口查看） 123456// this.data中找不到数据，则在properties中寻找let tabs = this.data.tabs;// 将tabs放入data当中this.setData(&#123; tabs&#125;) 所以需要将处理数据放在父组件当中，而所需要的索引值则由子组件传递给父组件（子向父传递数据） 子向父传递数据Tabs.js 12345678methods: &#123; handleItemTap(e) &#123; // 1.获取被点击的索引 const index = e.currentTarget.dataset.index; // 2.触发父组件中的自定义事件，并传递数据 this.triggerEvent(&quot;itemChange&quot;, &#123; index &#125;); //triggerEvent(&quot;自定义事件名&quot;, 要传递的数据) &#125;&#125; demo01.wxml 123456&lt;!-- 子组件Tabs -&gt; 父组件demo01 在子组件的标签中添加自定义事件 编写父组件js事件方法--&gt;&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tabs&gt; demo01.js 1234567891011121314// 自定义事件方法handleItemChange(e) &#123; console.log(e); // 接收传递的数据 const index = e.detail.index; // 以下代码相同 let tabs = this.data.tabs; tabs.forEach((v, i) =&gt; &#123; i === index ? v.isActive = true : v.isActive = false &#125;); this.setData(&#123; tabs &#125;)&#125;, AppData窗口查看即可 slot标签 slot占位符（插槽），父组件调用子组件传递一些标签来替换slot的位置 Tabs.wxml 123&lt;view class=&quot;tabs_content&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/view&gt; demo01.wxml 123456&lt;Tabs tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt; &lt;block wx:if=&quot;&#123;&#123;tabs[0].isActive&#125;&#125;&quot;&gt;内容1&lt;/block&gt; &lt;block wx:elif=&quot;&#123;&#123;tabs[1].isActive&#125;&#125;&quot;&gt;内容2&lt;/block&gt; &lt;block wx:elif=&quot;&#123;&#123;tabs[2].isActive&#125;&#125;&quot;&gt;内容3&lt;/block&gt; &lt;block wx:else&gt;内容4&lt;/block&gt;&lt;/Tabs&gt; 生命周期应用 12345678910111213141516171819202122232425262728293031323334// app.jsApp(&#123; // 应用 第一次启动 的时候触发，可用于最开始获取用户的个人信息等 onLaunch() &#123; console.log(&quot;onLaunch&quot;); &#125;, // 应用 显示 的时候触发，可用于对页面数据、页面效果进行重置 onShow() &#123; console.log(&quot;onShow&quot;); // 可调用多次 &#125;, // 应用 隐藏 的时候触发，可用于暂停或清除定时器 onHide() &#123; console.log(&quot;onHide&quot;); &#125;, // 应用 代码报错 的时候触发，可用于收集错误信息并发送到后台 onError(error) &#123; console.log(&quot;onError&quot;); console.log(error); &#125;, // 应用 第一次启动找不到入口页面 的时候触发，可用于跳转 onPageNotFound() &#123; console.log(&quot;onPageNotFound&quot;); wx.navigateTo(&#123; url: &#x27;/pages/demo01/demo01&#x27;, &#125;) &#125;&#125;) 页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// pages/demo02/demo02.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 * 发送异步请求初始化页面数据 */ onLoad: function (options) &#123; console.log(&quot;onLoad&quot;); &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; console.log(&quot;onShow&quot;); &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; console.log(&quot;onReady&quot;); &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; console.log(&quot;onHide&quot;); &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; console.log(&quot;onUnload&quot;); &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 * 对页面初始化 */ onPullDownRefresh: function () &#123; console.log(&quot;onPullDownRefresh&quot;); &#125;, /** * 页面上拉触底事件的处理函数 * 触底加载更多数据 */ onReachBottom: function () &#123; console.log(&quot;onReachBottom&quot;); &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; console.log(&quot;onShareAppMessage&quot;); &#125;, /** * 页面滚动 */ onPageScroll() &#123; console.log(&quot;onPageScroll&quot;); &#125;, /** * 页面尺寸改变 */ onResize() &#123; console.log(&quot;onResize&quot;); &#125;, /** * 当前是tab页，点击当前页的tab时触发 */ onTabItemTap() &#123; console.log(&quot;onTabItemTap&quot;); &#125;&#125;)","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"【学习笔记】SpringBoot2","slug":"【学习笔记】SpringBoot2","date":"2021-07-20T10:31:35.005Z","updated":"2021-08-18T04:48:58.808Z","comments":true,"path":"2021/07/20/xue-xi-bi-ji-springboot2/","link":"","permalink":"http://example.com/2021/07/20/xue-xi-bi-ji-springboot2/","excerpt":"","text":"教程与文档SpringBoot2核心技术与响应式编程 · 语雀 (yuque.com) Spring与SpringBoot201、Spring与SpringBoot · 语雀 (yuque.com) HelloWorld 导入依赖 pom.xml 1234567891011121314&lt;!-- 父项目配置 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- web场景启动器 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写controller HelloController.java 12345678910// @Controller // 注明controller// @ResponseBody // 注明将java对象转为json格式的数据@RestController // 代替以上两者public class HelloController &#123; // 映射请求的地址 @RequestMapping(&quot;/hello&quot;) public String handle1() &#123; return &quot;Hello,SpringBoot2&quot;; &#125;&#125; 编写主程序类并测试 MainApplication.java 1234567891011/** * 主程序类 */// 表明这是一个SpringBoot应用@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // run声明主程序类，返回一个IoC容器 SpringApplication.run(MainApplication.class, args); &#125;&#125; resources文件夹下application.properties，可根据文档自定义配置 Common Application properties (spring.io) 创建可执行jar包，添加build依赖，然后点击maven中的lifecycle中的clean与package并执行 pom.xml 123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行jar包，在target目录下执行以下命令 java -jar 包名.jar 依赖管理与自动配置特性雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 底层注解@Configuration、@Bean 配置对象原原Spring使用xml配置文件配置bean对象如下 bean.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user01&quot; class=&quot;com.myspringboot2.bean.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.myspringboot2.bean.Pet&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;mimi&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 现编写配置MyConfig.java 1234567891011121314151617/** * 1、配置类里面使用@Bean添加对象，默认是单实例 * 2、配置类本身也是对象 * 3、proxyBeanMethods: 代理bean的方法。默认为true(full模式)，使用代理对象调用方法，保证对象是单实例；否则(lite模式)非单实例 */@Configuration(proxyBeanMethods = true) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; // 无论外部对这个配置类中的方法调用多少次，获得的都是容器中的单实例对象 @Bean //向容器中添加组件，id为方法名(可以自定义)，组件类型为返回类型，组件在容器中的实例为返回地值 public User user01() &#123; return new User(&quot;zhangsan&quot;, 18); &#125; @Bean(&quot;pet01&quot;) //自定义id public Pet cat() &#123; return new Pet(&quot;mimi&quot;); &#125;&#125; 测试类MainApplication.java 123456789101112131415/** * 主程序类 */// 表明这是一个SpringBoot应用@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类,返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 从容器中获取bean,默认是单实例 User user01 = run.getBean(&quot;user01&quot;, User.class); Pet pet01 = run.getBean(&quot;pet01&quot;, Pet.class); MyConfig myConfig = run.getBean(MyConfig.class); &#125;&#125; Full模式与Lite模式 配置类组件之间无依赖关系用Lite模式加速客器启动过程,减少判断 配置类组件之间有依赖关系,方法会被调用得到之前单实例组件,用Full模式 @ComponentScan 包扫描1234// 一下三者相当于@SpringBootApplication@ComponentScan(&quot;com.myspringboot2&quot;) //包扫描地址@EnableAutoConfiguration@SpringBootConfiguration @Import 注入对象1@Import(&#123;User.class, DBHelper.class&#125;) //向容器中添加对应类型的对象,默认对象名为对应类的全类名 @Conditional 条件装配使用 MyConfig.java 12345678@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; @ConditionalOnBean(name = &quot;pet02&quot;) // 按条件执行向容器中注入对象,可放在类上(则按条件执行是否注入类中所有的对象) @Bean //向容器中添加组件，id为方法名(可以自定义)，组件类型为返回类型，组件在容器中的实例为返回地值 public User user01() &#123; return new User(&quot;zhangsan&quot;, 18); &#125;&#125; 测试 MainApplication.java 123456789@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类，返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 由于user01配置的是由添加了ConditinalOnBean,而其中的条件pet02对象并不在容器当中，所以未注入user01 System.out.println(run.containsBean(&quot;user01&quot;)); &#125;&#125; @ImportResource 导入xml配置文件1234@ImportResource(&quot;classpath:beans.xml&quot;) //兼容xml配置@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123;&#125; 123456789@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; // 获取IoC容器,run声明主程序类，返回一个IoC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); // 使用@ImportResource成功注入beans.xml中的对象 System.out.println(run.containsBean(&quot;user01&quot;)); &#125;&#125; @ConfigurationProperties 配置绑定编写属性， application.properties，注意使用全小写 12mycar.brand=ABCmycar.price=100000 第一种方法：需要在容器中的组件上使用， Car.java 1234567@Component //声明为组件，只有容器中的组件才能使用@ConfigurationProperties(prefix = &quot;mycar&quot;) //绑定配置文件中的属性，prefix指定对应前缀public class Car &#123; String brand; Integer price; // ……&#125; 第二种方法：不使用@Component声明Car为组件，而是在配置类种开启指定对象的属性配置功能 12345@EnableConfigurationProperties(Car.class) //开启指定对象的属性配置功能@Configuration(proxyBeanMethods = false) //声明这是一个配置类（即替换掉配置文件public class MyConfig &#123; // ……&#125; 测试， HelloController.java 123456789@RestControllerpublic class HelloController &#123; @Autowired Car car; @RequestMapping(&quot;/car&quot;) public Car car() &#123; return car; &#125;&#125; 自动配置原理（源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili @SpringBootApplication 声明当前是一个配置类 @ComponentScan 指定扫描路径 @EnableAutoConfiguration@AutoConfigurationPackage 利用Registrar将当前包下的所有组件全部导入进容器 @Import 导入默认组件 便捷使用Lombok 简化JavaBean编写等 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 编写JavaBean 1234567@NoArgsConstructor //自动编写无参构造器@AllArgsConstructor //自动编写全参构造器@Data //自动编写set/get/toString方法public class Car &#123; String brand; Integer price;&#125; 编写controller的日志打印 12345678910@Slf4j //引入日志接口@RestControllerpublic class HelloController &#123; // 映射请求的地址 @RequestMapping(&quot;/hello&quot;) public String handle1() &#123; log.info(&quot;hello&quot;); //日志打印信息 return &quot;Hello,SpringBoot2&quot;; &#125;&#125; Dev-tools、JRebel 自动重启、热更新 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 使用 Ctrl+F9 更新 Spring Initializr 快速创建springboot应用，创建应用时选择即可 配置文件propertiesyaml基本语法 key: value #注意空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进空格数无影响，同层级的元素需要左对齐 #编写注释 “”双引号内\\n等不转义，仍然是回车的本意显示为回车，’’单引号内转义，\\n显示为字符串 数据类型 字面量 1key: value 对象 123456k: &#123;k1: v1,k2: v2,k3: v3&#125;# 或k: k1: v1 k2: v2 k3: v3 数组 123456k: [v1,v2,v3]# 或k: - v1 - v2 - v3 示例雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili configuration-processor 配置处理器 添加依赖 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;!-- 打包的时候不带这个包 --&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; web开发简单功能静态资源访问 静态资源目录 存放路径：类路径(resources资源根目录)下的/static or /public or /resources or /META-INF/resources 访问路径：项目根路径/静态资源名 原理： 静态映射/**。请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面 改变默认的静态资源访问路径和存放路径，在配置文件application.yaml中编写 12345spring: mvc: static-path-pattern: /res/** #res为自定义前缀，即访问地址须在项目根路径/res/静态资源名 resources: static-locations: [classpath:/自定义文件夹名/] 欢迎页命名为index.html放在静态资源目录下即可。 自定义Favicon命名为favicon.ico 放在静态资源目录下即可。 源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 请求处理@xxxMapping 请求映射 Rest风格支持（使用HTTP请求方式动词来表示对资源的操作） 以前：**/getUser 获取用户 /deleteUser 删除用户 /editUser 修改用户 /saveUser 保存用户 现在： /user GET-获取用户 DELETE-删除用户 PUT-修改用户 POST-保存用户 编写controller类 1234567891011121314151617181920212223@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET) public String getUser() &#123; return &quot;getUser GET&quot;; &#125; @PostMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST) public String saveUser() &#123; return &quot;saveUser POST&quot;; &#125; @PutMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT) public String modifiedUser() &#123; return &quot;modifiedUser PUT&quot;; &#125; @DeleteMapping(&quot;/user&quot;) // 即@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE) public String deleteUser() &#123; return &quot;deleteUser DELETE&quot;; &#125;&#125; 编写页面 12345678910111213141516&lt;form action=&quot;/user&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;get提交&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;post提交&quot;&gt;&lt;/form&gt;&lt;!-- form表单中method只能写get/post --&gt;&lt;!-- 使用隐藏域传递_method方法参数的值 --&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;PUT提交&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;DELETE提交&quot;&gt;&lt;/form&gt; 在配置文件中开启hiddenmethod-filter(默认为false)，如果前端不是使用表单发送请求则不需要开启filter 12345spring: mvc: hiddenmethod: filter: enabled: true 自定义HiddenMethodFilter编写配置类，自定义filter 12345678@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; public HiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; HiddenHttpMethodFilter filter = new HiddenHttpMethodFilter(); filter.setMethodParam(&quot;_m&quot;); //修改方法参数名为_m return filter; &#125;&#125; 请求映射原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 参数注解@PathVariable、@RequestHeader、@RequestParam、@CookieValue、@RequestBody12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@RestControllerpublic class ParamTestController &#123; // 测试url: http://localhost:8080/test1/1/lisi?age=10&amp;inters=%E5%90%83%E9%A5%AD&amp;inters=%E7%9D%A1%E8%A7%89 @GetMapping(&quot;/test1/&#123;id&#125;/&#123;username&#125;&quot;) public Map&lt;String, Object&gt; test1(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String, String&gt; variables, @RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader Map&lt;String, String&gt; headers, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, @RequestParam Map&lt;String,String&gt; params1, @RequestParam MultiValueMap&lt;String, String&gt; params2, @CookieValue(&quot;_xsrf&quot;) String _xsrf, @CookieValue(&quot;_xsrf&quot;) Cookie cookie) &#123; /** * @PathVariable(&quot;&quot;) 获得指定路径变量名的值 * @PathVariable 获得所有路径变量名以及值，存放到Map&lt;String, String&gt;中 * 注意后者键值对对应的是地址栏中的username参数名，而前者是形参名name * * @RequestHeader(&quot;&quot;) 获得请求头中指定key的值 * @RequestHeader 获得请求头中所有的key及其值 * * @RequestParam(&quot;&quot;) 获得指定请求参数名的值 * @RequestParam 获得所有请求参数名以及值，存放到Map&lt;String, String&gt;中 * 注意后者存放在map中，kv只有一对，可使用MultiValueMap获取到一对多的键值对。 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 以下是测试 map.put(&quot;id&quot;, id); map.put(&quot;name&quot;, name); map.put(&quot;pv&quot;, variables); map.put(&quot;userAgent&quot;, userAgent); map.put(&quot;rh&quot;, headers); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params1&quot;,params1); map.put(&quot;params2&quot;,params2); map.put(&quot;_xsrf&quot;,_xsrf); System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;/test2&quot;) public Map&lt;String, Object&gt; test2(@RequestBody String content)&#123; /** * @RequestBody 获得请求体中所有的key及对应值 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 以下是测试 map.put(&quot;content&quot;, content); return map; &#125;&#125; @RequestAttribute 获取域对象参数值1234567891011121314151617181920212223@Controller //注意RestController写return &quot;forward:/success&quot;只会解析成字符串public class RequestController &#123; @GetMapping(&quot;/goto&quot;) public String gotoPage(HttpServletRequest req) &#123; req.setAttribute(&quot;msg&quot;, &quot;信息&quot;); req.setAttribute(&quot;code&quot;, &quot;信息123123&quot;); return &quot;forward:/success&quot;; //转发到/success请求 &#125; @ResponseBody @GetMapping(&quot;/success&quot;) public Map&lt;String, Object&gt; success(@RequestAttribute(&quot;msg&quot;) String msg, @RequestAttribute(&quot;code&quot;) String code) &#123; /** * @RequestAttribute 获得request域对象中的指定值 */ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;, msg); map.put(&quot;code&quot;, code); return map; &#125; &#125; @MatrixVariable 获取矩阵变量12345678910111213141516171819202122232425262728//1、矩阵变量语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd //2、SpringBoot默认是禁用了矩阵变量的功能 // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。 // removeSemicolonContent（移除分号内容）支持矩阵变量的 //3、矩阵变量必须有url路径变量才能被解析 @GetMapping(&quot;/cars/&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; // /boss/1;age=20/2;age=10 @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125; 12345678910111213141516171819202122@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; public HiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; HiddenHttpMethodFilter filter = new HiddenHttpMethodFilter(); filter.setMethodParam(&quot;_m&quot;); //修改_method return filter; &#125; @Bean // 自定义其中的功能,此处演示启用矩阵变量功能 public WebMvcConfigurer webMvcConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper = new UrlPathHelper(); // 设置不删除分号内容 urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125; &#125;; &#125;&#125; ServletAPI WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 参数注解源码分析雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 直接看困了，以后再看吧。 自定义参数绑定 编写两个bean 12345678@Datapublic class User &#123; String username; String password; Integer age; Date birthday; Pet pet;&#125; 12345@Datapublic class Pet &#123; String name; Integer age;&#125; 编写表单 12345678&lt;form action=&quot;/saveuser&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot;&gt; 生日：&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt; 宠物名字：&lt;input type=&quot;text&quot; name=&quot;pet.name&quot;&gt; 宠物年龄：&lt;input type=&quot;number&quot; name=&quot;pet.age&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;POST提交&quot;&gt;&lt;/form&gt; 编写controller测试 1234@PostMapping(&quot;/saveuser&quot;)public User saveuser(User user) &#123; return user;&#125; 自定义转换器12345678910111213141516171819202122232425@Configuration(proxyBeanMethods = false)public class MyWebConfig &#123; @Bean // 自定义其中的功能 public WebMvcConfigurer webMvcConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new Converter&lt;String, Date&gt;() &#123; @Override public Date convert(String s) &#123; SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try &#123; date = sf.parse(s); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; &#125;); &#125; &#125;; &#125;&#125; 数据响应与内容协商响应JSON数据 引入jackson.jar，已包含在starter-web场景启动器中 使用注解@ResponseBody 响应原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 内容协商 根据客户端接收能力不同，返回不同媒体类型的数据。 以xml为示例，引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt; 请求头里accept字段，设置了接收数据以xml格式为优先 开启基于请求参数的内容协商原理，同时url中添加请求参数format=xxx即可 1234spring: mvc: contentnegotiation: favor-parameter: true 内容协商原理雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 自定义MessageConvertor雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 视图解析与模板引擎thymeleaf java模板引擎 基本语法 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 编写模板 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;默认的值&lt;/h1&gt; &lt;h2&gt; &lt;a href=&quot;www.google.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;跳转百度&lt;/a&gt; &lt;a href=&quot;www.google.com&quot; th:href=&quot;@&#123;link&#125;&quot;&gt;跳转百度&lt;/a&gt; &lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 编写controller 1234567891011@Controllerpublic class ViewTestController &#123; @GetMapping(&quot;/testsuccess&quot;) public String test(Model model) &#123; // model中的数据会被放在请求域中 model.addAttribute(&quot;msg&quot;, &quot;msgTest&quot;); model.addAttribute(&quot;link&quot;, &quot;https://www.baidu.com&quot;); // 跳转页面写页面的前名 return &quot;success&quot;; &#125;&#125; 拦截器雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 编写Interceptor 123456789101112131415161718192021222324252627282930313233343536/** * 登陆检查 */@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; /** * 目标方法执行之前 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info(&quot;Run LoginInterceptor.preHandle&quot;); HttpSession session = request.getSession(); Object loginUser = session.getAttribute(&quot;loginUser&quot;); if (loginUser != null) &#123; return true; &#125; else &#123; session.setAttribute(&quot;msg&quot;, &quot;当前尚未登录&quot;); response.sendRedirect(&quot;/&quot;); return false; &#125; &#125; /** * 目标方法执行之后 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;Run LoginInterceptor.postHandle&quot;,modelAndView); &#125; /** * 页面渲染以后 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info(&quot;Run LoginInterceptor.afterCompletion&quot;,ex); &#125;&#125; 编写WebConfig类，添加interceptor 12345678910@Configurationpublic class AdminWebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 添加拦截器，并且设置拦截地址与不拦截地址 // /**拦截目录下所有资源，静态资源也会被拦截 registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/js/**&quot;,&quot;/font/**&quot;,&quot;/images/**&quot;); // 设置exlucde不拦截，或者在配置文件中编写static-path-pattern=/static/**，注意此时需要修改标签中的href &#125;&#125; 文件上传雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 编写controller 1234567891011121314151617181920212223242526272829303132333435/** * 文件上传测试 */@Slf4j@Controllerpublic class FormTestController &#123; @GetMapping(&quot;/form_layouts&quot;) public String formLayouts() &#123; return &quot;form/form_layouts&quot;; &#125; /** * MultipartFile自动封装上传过来的文件 */ @PostMapping(&quot;/upload&quot;) public String upload(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;name&quot;) String name, @RequestPart(&quot;headImg&quot;) MultipartFile headImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123; // 获取的信息 log.info(&quot;上传的信息：email=&#123;&#125;,name=&#123;&#125;,headImg=&#123;&#125;,photos=&#123;&#125;&quot;, email, name, headImg.getSize(), photos.length); if (!headImg.isEmpty()) &#123; // 获取原文件名、保存到服务器 headImg.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\test1\\\\&quot;+headImg.getOriginalFilename())); &#125; if (photos.length &gt; 0) &#123; for (MultipartFile photo : photos) &#123; if (!photo.isEmpty()) &#123; photo.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\test2\\\\&quot;+photo.getOriginalFilename())); &#125; &#125; &#125; return &quot;index&quot;; &#125;&#125; 编写配置文件 123#修改上传文件的最大大小spring.servlet.multipart.max-file-size=10MBspring.servlet.multipart.max-request-size=100MB 异常处理 默认情况下，Spring Boot提供/error处理所有错误的映射 对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。 对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据 自定义错误页在将400.html、500.html等页面放在resources &gt; templates &gt;error下即可 自定义异常处理@ControllerAdvice+@ExceptionHandler1234567891011121314151617/** * 处理整个web controller的异常 */@Slf4j@ControllerAdvice //注明这是一个增强的controllerpublic class GlobalExceptionHandler &#123; /** * 处理数学异常、空指针异常 * @param e * @return */ @ExceptionHandler(&#123;ArithmeticException.class, NullPointerException.class&#125;) // 表明用于处理指定异常 public String handleArithException(Exception e) &#123; log.error(&quot;异常是：&#123;&#125;&quot;, e); return &quot;error/404&quot;; // 指定返回视图的地址 &#125;&#125; @ResponseStatus+自定义Exception123456789@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;用户数量太多&quot;) //注明异常返回状态码和原因public class UserTooManyException extends RuntimeException &#123; public UserTooManyException() &#123; &#125; public UserTooManyException(String msg) &#123; super(msg); &#125;&#125; 自定义HandlerExceptionResolver123456789101112@Componentpublic class CustomerHandlerExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; try &#123; httpServletResponse.sendError(511, &quot;自定义错误&quot;); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return new ModelAndView(); &#125;&#125; 原生组件注入ServletAPI@ServletComponentScan主应用类中使用@ServletComponentScan配置扫描路径 1234567@ServletComponentScan(basePackages = &quot;com.spb_adminex.servlet&quot;) //配置servlet、filter、listener扫描地址@SpringBootApplicationpublic class SpbAdminexApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpbAdminexApplication.class, args); &#125;&#125; @WebServlet1234567@WebServlet(urlPatterns = &quot;/my&quot;)public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write(&quot;MyServlet running&quot;); &#125;&#125; @WebFilter1234567891011121314151617@Slf4j@WebFilter(urlPatterns = &#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;)public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; log.info(&quot;MyFilter初始化&quot;); &#125; @Override public void destroy() &#123; log.info(&quot;MyFilter销毁&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; log.info(&quot;MyFilter running&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; @WebListener123456789101112@Slf4j@WebListenerpublic class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; log.info(&quot;MyListener监听到项目初始化完成&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; log.info(&quot;MyListener监听到项目销毁&quot;); &#125;&#125; RegisterBean编写一个配置类 1234567891011121314151617@Configurationpublic class MyRegisterConfig &#123; @Bean public ServletRegistrationBean myServlet() &#123; return new ServletRegistrationBean(new MyServlet(), &quot;/my&quot;); &#125; @Bean public FilterRegistrationBean myFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new MyFilter()); filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;)); return filterRegistrationBean; &#125; @Bean public ServletListenerRegistrationBean myListener() &#123; return new ServletListenerRegistrationBean(new MyListener()); &#125;&#125; 数据访问SQL使用默认数据源、jdbcTemplate 导入starter场景和数据库驱动 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 编写配置文件application.yaml 123456spring: datasource: url: jdbc:mysql://localhost:3306/online_bookstore username: root password: 123456789 driver-class-name: com.mysql.cj.jdbc.Driver 使用jdbcTemplate测试 1234567891011@Slf4j@SpringBootTestclass SpbAdminexApplicationTests &#123; @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() &#123; Long count = jdbcTemplate.queryForObject(&quot;select count(*) from admin&quot;, Long.class); log.info(&quot;当前表的记录数为&quot; + count); &#125;&#125; 使用Druid数据源 引入数据源 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 编写数据源配置类 12345678910@Configurationpublic class MyDataSourceConfig &#123; // 引入自己的数据源之后，自动配置的默认DataSource失效 @ConfigurationProperties(&quot;spring.datasource&quot;) //将组件与配置文件中的属性绑定 @Bean public DataSource dataSource() &#123; DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; &#125;&#125; 测试 12345678910@Slf4j@SpringBootTestclass SpbAdminexApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() &#123; log.info(&quot;当前数据源类型为&#123;&#125;&quot;, dataSource.getClass()); &#125;&#125; 其他👉雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 使用xml配置文件整合MyBatis 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt; 编写application.yaml配置文件 123mybatis: config-location: classpath:mybatis/mybatis-config.xml #全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 编写mybatis-config.xml全局配置文件/或者编写application配置文件(此时不能同时配置全局配置文件位置) 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;settings&gt;&lt;!-- 开启下划线转驼峰命名法 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;&lt;/configuration&gt; 1234mybatis: mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 configuration: map-underscore-to-camel-case: true #开启下划线转驼峰命名法 编写beanMapper接口 12345@Mapper //注明这是一个mapper接口public interface AdminMapper &#123; public Admin getAdmin(Integer id); public Boolean insertAdmin(Admin admin);&#125; 编写beanMapper.xml配置文件 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.spb_adminex.mapper.AdminMapper&quot;&gt; &lt;select id=&quot;getAdmin&quot; resultType=&quot;com.spb_adminex.bean.Admin&quot; &gt; select * from admin where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;insertAdmin&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into admin(`account`,`password`) values(#&#123;account&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 编写service层 123456789101112@Servicepublic class AdminService &#123; @Autowired AdminMapper adminMapper; public Admin getAdminById(Integer id) &#123; return adminMapper.getAdmin(id); &#125; public Boolean insertAdmin(Admin admin) &#123; return adminMapper.insertAdmin(admin); &#125;&#125; 编写controller层 1234567891011@Controllerpublic class AdminController &#123; @Autowired AdminService adminService; @ResponseBody @GetMapping(&quot;/getAdmin&quot;) public Admin getAdminById(@RequestParam(&quot;id&quot;) Integer id) &#123; return adminService.getAdminById(id); &#125;&#125; 使用注解整合MyBatis 其余文件，且不需要beanMapper.xml 编写beanMapper接口 12345@Mapper //注明这是一个mapper接口public interface AdminMapper &#123; @Select(&quot;select * from admin where id=#&#123;id&#125;&quot;) //注解替换beanMapper.xml文件 public Admin getAdmin(Integer id);&#125; 整合MyBatis-Plus快速开始 | MyBatis-Plus (baomidou.com) 获取数据 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt; 为启动类添加@MapperScan，注明扫描Mapper文件的地址 123456789@SpringBootApplication@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(QuickStartApplication.class, args); &#125;&#125; 编写全局配置文件 123456spring: datasource: url: jdbc:mysql://localhost:3306/spb_adminex username: root password: 123456789 driver-class-name: com.mysql.cj.jdbc.Driver 编写Bean类 12345678910111213@NoArgsConstructor@AllArgsConstructor@Data@TableName(&quot;user&quot;) //可以指定表名，不知道则默认为类名public class User &#123; private Long id; private String name; private String age; private String email; @TableField(exist = false) //注明当前字段在表中不存在 private String test;&#125; 编写BeanMapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 编写BeanService接口 123public interface UserService extends IService&lt;User&gt; &#123;&#125; 编写BeanServiceImpl实现类 1234@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;&#125; 编写controller 12345678910111213141516171819@Controllerpublic class TableController &#123; @Autowired UserService userService = new UserServiceImpl(); @GetMapping(&quot;/dynamic_table&quot;) public String dynamicTable(Model model) &#123; List&lt;User&gt; userList = userService.list(); model.addAttribute(&quot;userList&quot;, userList); return &quot;table/dynamic_table&quot;; &#125; @GetMapping(&quot;/responsive_table&quot;) public String responsiveTable() &#123; return &quot;table/responsive_table&quot;; &#125; @GetMapping(&quot;/editable_table&quot;) public String editableTable() &#123; return &quot;table/editable_table&quot;; &#125;&#125; 分页操作 编写MybatisPlugConfig 12345678910@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; // 创建MybatisPlusInterceptor MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 编写controller 12345678910111213141516171819202122232425@Controllerpublic class TableController &#123; @Autowired UserService userService = new UserServiceImpl(); // 进入dynamic_table并展示分页数据 @GetMapping(&quot;/dynamic_table&quot;) public String dynamicTable(@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)Integer pn, Model model) &#123; // 获得分页结果对象，并设置分页 Page&lt;User&gt; page = userService.page(new Page&lt;User&gt;(pn, 2)); model.addAttribute(&quot;page&quot;, page); // page.getRecords获得所有记录，page.current获得当前页数，page.pages获得总页数，page.getTotal获得总条数…… return &quot;table/dynamic_table&quot;; &#125; @GetMapping(&quot;/user/delete/&#123;id&#125;&quot;) // 删除用户功能 public String deleteUser(@PathVariable(&quot;id&quot;) Long id, @RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn, RedirectAttributes ra) &#123; userService.removeById(id); ra.addAttribute(&quot;pn&quot;, pn); return &quot;redirect:/dynamic_table&quot;; &#125;&#125; 编写html页面，thymeleaf语法详见雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 123456789101112131415161718192021222324252627282930313233343536373839&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,status:$&#123;page.getRecords()&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;status.count&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;xxx&lt;/td&gt; &lt;td&gt; &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;&quot; class=&quot;btn btn-primary&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;row-fluid&quot;&gt; &lt;div&gt; &lt;div class=&quot;dataTables_info&quot;&gt;当前第[[$&#123;page.current&#125;]]页 总计[[$&#123;page.pages&#125;]]页 总[[$&#123;page.getTotal&#125;]]条记录 &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class=&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt; &lt;ul&gt; &lt;li class=&quot;prev disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;← Previous&lt;/a&gt;&lt;/li&gt; &lt;li th:class=&quot;$&#123;num == page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;&quot; th:each=&quot;num:$&#123;#numbers.sequence(1,page.pages)&#125;&quot;&gt; &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;Next → &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; NoSQL(Redis)不尝试了没钱 单元测试@SpringBootTest123456@SpringBootTestclass MyTest &#123; @Test public void test() &#123; &#125;&#125; 常用注解 **@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 **@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍 **@RepeatedTest :**表示方法可重复执行，下方会有详细介绍 **@DisplayName :**为测试类或者测试方法设置展示名称 **@BeforeEach :**表示在每个单元测试之前执行 **@AfterEach :**表示在每个单元测试之后执行 **@BeforeAll :**表示在所有单元测试之前执行 **@AfterAll :**表示在所有单元测试之后执行 **@Tag :**表示单元测试类别，类似于JUnit4中的@Categories **@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore **@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误 **@ExtendWith :**为测试类或测试方法提供扩展类引用 断言机制雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili ……指标监控雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili 高级特性后会有期源码和其他部分到时候(也不知道啥时候)会再去看的，but not today","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"【学习笔记】MyBatis","slug":"【学习笔记】MyBatis","date":"2021-07-16T11:12:59.990Z","updated":"2021-07-23T05:49:19.787Z","comments":true,"path":"2021/07/16/xue-xi-bi-ji-mybatis/","link":"","permalink":"http://example.com/2021/07/16/xue-xi-bi-ji-mybatis/","excerpt":"","text":"概述 mybatis是一个优秀的基于java的持久层框架,它内部封装了jdbc,使开发者只需要关注sq语句本身,而不需要花费精力去处理加载驱动、创建连接、创建 statement等繁杂的过程。 mybatis通过xm或注解的方式将要执行的各种 statement配置起来,并通过java对象和 statement中sq的动态参数进行映射生成最终执行的sq语句。 最后 mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题,对jdbc进行了封装,屏蔽了 jdbc api底层访问细节,使我们不用与 jdbc api打交道,就可以完成对数据库的持久化操作。 开发步骤 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 编写数据表与Bean类 创建并编写mapper.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.myspring.bean.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 创建并编写sqlMapConfig.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456789&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 调用操作 123456789101112// 获得核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis/sqlMapConfig.xml&quot;);// 获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);// 获得session会话对象SqlSession sqlSession = sqlSessionFactory.openSession();// 执行操作,参数即mapper.xml中的namespace.idList&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);// 测试System.out.println(userList);// 释放资源sqlSession.close(); 增删改查操作代码123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.myspring.bean.User&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 插入 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; insert into user values (#&#123;name&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; update user set age=#&#123;age&#125; where name = #&#123;name&#125; &lt;/update&gt;&lt;/mapper&gt; 1234567891011121314151617181920// 获得核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis/sqlMapConfig.xml&quot;);// 获得session工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);// 获得session会话对象SqlSession sqlSession = sqlSessionFactory.openSession();// 查询List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);// 插入sqlSession.insert(&quot;userMapper.save&quot;, new User(&quot;李52四&quot;, 11));// 修改sqlSession.update(&quot;userMapper.update&quot;, new User(&quot;李52四&quot;, 110));// 删除sqlSession.delete(&quot;userMapper.delete&quot;, &quot;李52四&quot;);// 执行更新操作需要提交事务sqlSession.commit();// 释放资源sqlSession.close(); 配置文件常用标签environments标签 配置数据库环境，支持多环境 transactionManager事务管理器属性 JDBC: 这个配置就是直接使用了JDBC的提交和回滚设置,它依赖于从数据源得到的连接来管理事务作用域 MANAGED: 这个配置几乎没做什么。它从来不提交或回滚一个连接,而是让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文)。默认情况下它会关闭连接,然而一些容器并不希望这样,因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 daraSource数据源属性 UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。 JNDI:这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用,容器可以集中或在外部配置数据源,然后放置一个JNDI上下文的引用。 Mapper标签 加载映射，加载方式有多种。 使用相对于类路径的资源引用,例如:&lt; mapper resource=”org/ mybatis/ builder/ AuthorMapperxm”/&gt; 使用完全限定资源定位符(URL),例如:&lt; mapper url=”file//ar/ mappers/ Author Mapper.xm”/ 使用映射器接口实现类的完全限定类名,例如:&lt; mapper class=” org. mybatis builder. AuthorMapper”/&gt; 将包内的映射器接口实现全部注主册为映射器,例如:&lt; package name=” org. mybatis. builder”/&gt; Properties标签 实际开发中,习惯将数据源的配置信息单独抽取成个 properties文件,该标签可以加载额外配置的 properties文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 加载properties文件 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- 配置数据源环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; typeAliases标签 起别名，有已经设置好的常用的类型的别名，也可自定义 1234&lt;!-- 自定义别名，注意标签在config.xml中的顺序 --&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.myspring.bean.User&quot; alias=&quot;user&quot;/&gt;&lt;/typeAliases&gt; MyBatis相关APISqlSession工厂构建器SqlSessionFactoryBuilder SqlSession工厂对象SqlSessionFactory SqlSession会话对象 DAO层实现 采用 Mybatis的代理开发方式实现DAO层的开发,这种方式是我们后面进入企业的主流。 Mapper接口开发方法只需要程序员编写 Mapper接口(相当于Dao接口),由 Mybatis框架根据接口定义创建接口的动态代理对象,代理对象的方法体同上边Dao接口实现类方法。 Mapper.xm文件中的 namespace与 mapper接口的全限定名相同 Mapper接口方法名和 Mapper. xm中定义的每个 statement的id相同 Mapper接口方法的输入参数类型和 mapper. xn中定义的毎个sql的 parameter Type的类型相同 Mapper接口方法的辅出参数类型和 mapper. xm中定义的每个sq的 resultType的类型相同 创建并编写Mapper.xml文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.myspring.dao.UserMapper&quot;&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from user &lt;/select&gt; &lt;!-- 根据name查询所有 --&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 创建并编写Mapper接口 123456public interface UserMapper &#123; // 查询所有 List&lt;User&gt; findAll() throws Exception; // 根据id查询所有 User findById(int id);&#125; 调用 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;myBatis/sqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();User user = mapper.findById(2); 映射文件：动态sql语句123456789101112131415161718192021222324252627282930313233&lt;!-- sql语句抽取 --&gt;&lt;sql id=&quot;selectUser&quot;&gt; select * from user&lt;/sql&gt;&lt;!-- 动态条件 --&gt;&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-- 动态条件 --&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;where&gt; -- select * from user where id in(?,?) -- collection写list或array等 &lt;foreach collection=&quot;list&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 配置文件类型转换TypeHandler标签黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 插件plugins标签 添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 在配置文件中添加标签 12345&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 调用 12345678910111213141516171819// 分页助手，设置分页信息以分页，startPage(pageNum,pageSize)PageHelper.startPage(1, 1);// 当前页List&lt;User&gt; userList = mapper.findAll();// 分页信息PageInfo&lt;User&gt; userPageInfo = new PageInfo&lt;&gt;(userList);for (User user : userList) &#123; System.out.println(user);&#125;System.out.println(&quot;上一页：&quot; + userPageInfo.getPrePage());System.out.println(&quot;当前页：&quot; + userPageInfo.getPageNum());System.out.println(&quot;下一页：&quot; + userPageInfo.getNextPage());System.out.println(&quot;总页数：&quot; + userPageInfo.getPages());System.out.println(&quot;当前条数：&quot; + userPageInfo.getPageSize());System.out.println(&quot;总条数：&quot; + userPageInfo.getTotal());System.out.println(&quot;是否第一页：&quot; + userPageInfo.isIsFirstPage());System.out.println(&quot;是否末页：&quot; + userPageInfo.isIsLastPage()); 多表操作黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 注解开发使用xml开发crud1234&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;mybatis/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.myspring.dao.UserMapper&quot;&gt; &lt;!-- sql语句抽取 --&gt; &lt;sql id=&quot;selectUser&quot;&gt; select * from user &lt;/sql&gt; &lt;!-- 查询 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;/&gt; &lt;/select&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; -- select * from user where id in(?,?) -- collection写list或array等 &lt;foreach collection=&quot;list&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=0&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 插入 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; insert into user (name, age) values (#&#123;name&#125;, #&#123;age&#125;) &lt;/insert&gt; &lt;!-- 修改 --&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.myspring.bean.User&quot;&gt; update user set age=#&#123;age&#125;, name=#&#123;name&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除 --&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 123456789101112131415public interface UserMapper &#123; List&lt;User&gt; findAll(); User findById(int id); List&lt;User&gt; findByCondition(User user); List&lt;User&gt; findByIds(List&lt;Integer&gt; ids); void save(User user); void update(User user); void delete(int id);&#125; 123456789101112131415161718192021222324252627282930313233343536373839public class UserMapperTest &#123; private UserMapper userMapper; @Before public void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;myBatis/sqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class); &#125; @Test public void testSave() throws Exception &#123; User user = new User(); user.setName(&quot;钱老板&quot;); user.setAge(90); userMapper.save(user); &#125; @Test public void testUpdate() throws Exception &#123; User user = userMapper.findById(3); user.setAge(99); userMapper.update(user); &#125; @Test public void testDelete() throws Exception &#123; userMapper.delete(4); &#125; @Test public void testFindById() throws Exception &#123; User user = userMapper.findById(3); System.out.println(user); &#125;&#125; 注解开发CRUD12345678910111213141516public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User findById(int id); @Insert(&quot;insert into user (name, age) values (#&#123;name&#125;, #&#123;age&#125;)&quot;) void save(User user); @Update(&quot;update user set age=#&#123;age&#125;, name=#&#123;name&#125; where id = #&#123;id&#125;&quot;) void update(User user); @Update(&quot; delete from user where id = #&#123;id&#125;&quot;) void delete(int id);&#125; 12345&lt;!-- 加载映射关系 --&gt;&lt;mappers&gt; &lt;!-- 指定接口所在的包 --&gt; &lt;package name=&quot;com.myspring.dao&quot;/&gt;&lt;/mappers&gt; 调用不变","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"}]},{"title":"【项目笔记】ssm整合练习简单CRUD项目","slug":"【项目笔记】ssm整合练习","date":"2021-07-16T07:09:38.168Z","updated":"2021-09-19T12:40:33.243Z","comments":true,"path":"2021/07/16/xiang-mu-bi-ji-ssm-zheng-he-lian-xi/","link":"","permalink":"http://example.com/2021/07/16/xiang-mu-bi-ji-ssm-zheng-he-lian-xi/","excerpt":"","text":"项目简介功能点 分页 数据校验 jQuery前端校验 JSR303后端校验 AJAX REST风格 技术点 基础框架ssm 数据库MySQL 请阿丹框架bootstrap 项目管理maven 分页插件pagehelper 逆向工程mybatis generator 基础环境搭建创建项目​ 创建maven项目，添加javaee-web application framework support 引入maven相关依赖​ 引入spring springmvc mybatis等相关依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssm_crud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!-- spring springmvc --&gt; &lt;dependencies&gt; &lt;!-- springmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring aspects aop面向切面编程 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池、驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 其他 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 引入前端框架​ 引入jQuery、Bootstrap 12345678&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; ssm整合配置文件web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 1、启动spring的容器 --&gt; &lt;!-- 设置全局参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 2、springmvc前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置xml地址 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 3、全局字符编码过滤器，注意这个过滤器一定要放在所有过滤器之前 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 4、过滤器：使用REST风格的URI 将页面普通的POST请求转为指定的delete或者put请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; spring-mvc.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- springMVC的配置文件 --&gt; &lt;!-- 配置组件扫描路径 --&gt; &lt;context:component-scan base-package=&quot;com.sss_crud&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- 只扫描controller(即所有注释controller的类) --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 过滤静态资源 （将springmvc不能处理的请求交给Tomcat，该标签表示当spring找不到资源时交由原始容器(tomcat)寻找） --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- mvc注解驱动 以及其他一些功能支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- spring配置文件 --&gt; &lt;!-- 配置组件扫描路径 --&gt; &lt;context:component-scan base-package=&quot;com.sss_crud&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- 不扫描controller(即所有注释controller的类) --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- 加载外部的properties文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源，事务控制 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; &lt;!-- mybatis整合 --&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- mybatis全局配置文件、数据源、mapper配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置扫描器，将mybatis接口的实现加入到IOC容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.sss_crud.mapper&quot; /&gt; &lt;/bean&gt; &lt;!-- 事务控制 --&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 开启基于注解的事务 --&gt; &lt;aop:config&gt; &lt;!-- 切入点表达式 --&gt; &lt;aop:pointcut id=&quot;txPoint&quot; expression=&quot;execution(* com.sss_crud.service..*(..))&quot; /&gt; &lt;!-- 配置事务增强 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPoint&quot; /&gt; &lt;/aop:config&gt; &lt;!-- 配置事务增强，事务如何切入 --&gt; &lt;tx:advice id=&quot;txAdvice&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 切入点切入的所有方法（连接点）都是事务方法 --&gt; &lt;tx:method name=&quot;*&quot; /&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;/beans&gt; jdbc.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=123456789 mybatis-config.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 开启驼峰命名 --&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt; &lt;/settings&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 自动扫描路径下的类并且起别名 --&gt; &lt;package name=&quot;com.sss_crud.bean&quot; /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 数据库构建ssm_crud.sql1234567891011121314151617181920212223242526272829SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tbl_dept-- ----------------------------DROP TABLE IF EXISTS `tbl_dept`;CREATE TABLE `tbl_dept` ( `dept_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;部门id&#x27;, `dept_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, PRIMARY KEY (`dept_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Table structure for tbl_emp-- ----------------------------DROP TABLE IF EXISTS `tbl_emp`;CREATE TABLE `tbl_emp` ( `emp_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;员工id&#x27;, `emp_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `gender` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `d_id` int NULL DEFAULT NULL, PRIMARY KEY (`emp_id`) USING BTREE, INDEX `fk_emp_dept`(`d_id`) USING BTREE, CONSTRAINT `fk_emp_dept` FOREIGN KEY (`d_id`) REFERENCES `tbl_dept` (`dept_id`) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; 基础模块mybatis逆向工程生成bean、mappergeneratorConfig.xml mybatis generator的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--注意targetProject中使用反斜杠，connectionURL需要添加useSSL=true--&gt; &lt;!--配置要链接的数据库的数据源--&gt; &lt;!-- &lt;classPathEntry location=&quot;E:/GARBAGE_TEMP_SPACE/mysql-connector-java-5.1.46.jar&quot; /&gt;--&gt; &lt;!---Mybatis上下文--&gt; &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- 取消生成的文件的全部自动注释 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--配置数据库的链接信息--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssm_crud?useSSL=false&quot; userId=&quot;root&quot; password=&quot;123456789&quot; /&gt; &lt;!--数据库BigDecimals字段在java中定义--&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!--实体类生成信息 指定javabean生成位置--&gt; &lt;javaModelGenerator targetPackage=&quot;com.sss_crud.bean&quot; targetProject=&quot;src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!--指定mybatis的mapper.xml映射文件地址--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!--指定mybatis的mapper接口生成地址--&gt; &lt;javaClientGenerator targetPackage=&quot;com.sss_crud.mapper&quot; targetProject=&quot;src\\main\\java&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!--要生成的表结构--&gt; &lt;table tableName=&quot;tbl_emp&quot; domainObjectName=&quot;Employee&quot; /&gt; &lt;table tableName=&quot;tbl_dept&quot; domainObjectName=&quot;Department&quot; /&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; MBGTest.class 运行mybatis generator以自动生成bean和mapper，可能需要手动添加构造器 123456789101112131415161718192021import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class MBGTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 当前项目结构 MapperTest单元测试引入maven123456&lt;!-- spring test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.16.RELEASE&lt;/version&gt;&lt;/dependency&gt; 添加可以批量操作的sqlSession 注意在applicationContext.xml文件中添加可以批量操作的sqlSession 12345&lt;!-- 一个可以执行批量操作的SQLSession --&gt;&lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;constructor-arg name=&quot;executorType&quot; value=&quot;BATCH&quot; /&gt;&lt;/bean&gt; MapperTest类编写123456789101112131415161718192021222324252627282930313233343536373839import com.sss_crud.bean.Employee;import com.sss_crud.mapper.DepartmentMapper;import com.sss_crud.mapper.EmployeeMapper;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.UUID;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class MapperTest &#123; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Autowired SqlSession session; @Test public void test() &#123; // departmentMapper.insertSelective(new Department(null, &quot;开发&quot;)); // departmentMapper.insertSelective(new Department(null, &quot;测试&quot;)); // employeeMapper.insertSelective(new Employee(null, &quot;Jerry&quot;, &quot;M&quot;, &quot;Jerry@qq.com&quot;, 1)); // employeeMapper.insertSelective(new Employee(null, &quot;Cat&quot;, &quot;W&quot;, &quot;Cat@qq.com&quot;, 2)); // 使用可以批量操作的session获得mapper,从而进行批量操作 EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); for (int i = 0; i &lt; 1000; i++) &#123; String uid = UUID.randomUUID().toString().substring(0, 5) + i; mapper.insertSelective(new Employee(null, uid, &quot;M&quot;, uid + &quot;@qq.com&quot;, 1)); &#125; &#125;&#125; 查询功能 此功能需要使用分页插件pageHelper pagehelper分页插件引入maven依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt; 配置mybatis-config.xml以使用插件1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- ...... --&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; viewsindex.jsp12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 跳转至展示所有员工信息 --%&gt; &lt;jsp:forward page=&quot;/emps&quot;&gt;&lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; serviceEmployeeServiceImpl.java123456789101112131415161718192021package com.sss_crud.service.impl;import com.sss_crud.bean.Employee;import com.sss_crud.mapper.EmployeeMapper;import com.sss_crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; public List&lt;Employee&gt; getAll() &#123; return employeeMapper.selectByExampleWithDept(null); &#125;&#125; controllerEmployeeController.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.sss_crud.controller;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.sss_crud.bean.Employee;import com.sss_crud.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import java.util.List;/** * 处理员工CRUD请求 */@Controllerpublic class EmployeeController &#123; @Autowired EmployeeService employeeService; /** * 查询员工数据（分页） * url请求参数“pn”为请求页数 * * @return */ @RequestMapping(&quot;/emps&quot;) public ModelAndView getEmps(@RequestParam(value = &quot;pn&quot;, defaultValue = &quot;1&quot;) Integer pn) &#123; ModelAndView mav = new ModelAndView(); // 使用pageHelper实现分页功能 PageHelper.startPage(pn, 5); // 查询（此时的数据已经是分页后的数据） List&lt;Employee&gt; emps = employeeService.getAll(); // 使用pageInfo包装（加入其他更多的信息，所有页，当前页等等） PageInfo pageInfo = new PageInfo(emps, 5); mav.addObject(&quot;pageInfo&quot;, pageInfo); mav.setViewName(&quot;list&quot;); return mav; &#125;&#125; Test单元测试12345678910111213141516171819202122232425262728293031323334353637383940import com.github.pagehelper.PageInfo;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;@WebAppConfiguration(value = &quot;src/main/web&quot;)@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;, &quot;classpath:spring-mvc.xml&quot;&#125;)public class MvcTest &#123; //传入springmvc的ioc @Autowired WebApplicationContext context; // 虚拟MVC请求 获得请求结果 MockMvc mockMvc; @Before public void initMockMvc() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void test() throws Exception &#123; MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/emps&quot;).param(&quot;pn&quot;, &quot;1&quot;)).andReturn(); MockHttpServletRequest request = result.getRequest(); PageInfo pageInfo = (PageInfo) request.getAttribute(&quot;pageInfo&quot;); System.out.println(pageInfo); &#125;&#125; 没有成功，返回为null，我不理解，都spring了还用nm的jsp呢，不弄了！反正结构都差不多了实现逻辑也就那样，拜拜了您嘞！","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"【学习笔记】SpringMVC","slug":"【学习笔记】SpringMVC","date":"2021-07-15T05:37:42.134Z","updated":"2021-09-19T12:45:12.814Z","comments":true,"path":"2021/07/15/xue-xi-bi-ji-springmvc/","link":"","permalink":"http://example.com/2021/07/15/xue-xi-bi-ji-springmvc/","excerpt":"","text":"SpringMVC概述 SpringMVC是种基于Java的实现MVc设计模型的请求驱动类型的轻量级Web框架,属于Spring FrameWork的后续产品,已经融合在 Spring Web Flow中。 SpringMvC已经成为目前最主流的MVC框架之一,并且随着 Spring30的发布,全面超越 Struts2,成为最优秀的MVC框架。它通过一套注解,让一个简单的Java类成为处理请求的控制器,而无须实现任何接口。同时它还支持RESTful编程风格的请求。 SpringMVC快速开发步骤 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 123456789101112131415&lt;!-- springMVC前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置xml地址 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写controller 12345678910@Controllerpublic class UserController &#123; // 使用RequestMapping映射controller地址 @RequestMapping(&quot;/myController&quot;) public String save() &#123; System.out.println(&quot;Controller save running&quot;); // return要跳转的视图页面 return &quot;success.jsp&quot;; &#125;&#125; 在resources下新增spring-mvc.xmld的spring config文件 12345xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- controller的组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring.controller&quot;/&gt; SpringMVC组件解析@RequestMapping用于建立请求URL和处理请求方法之间的对应关系 位置 类上,请求URL的第一级访问目录。此处不写的话,就相当于应用的根目录 方法上,请求URL的第二级访问目录,与类上的使用@ ReqquestMapping标主的级目录起组成访问虚拟路径 return 后跟的路径：不加”/“，则从相对路径查询，否则从web路径下查询。 属性 value：用于指定请求的URL。它和path属性的作用是一样的 method：用于指定请求的方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和vaue必须和配置的一模一样 MVC命名空间引入12345&lt;!-- 命名空间 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;&lt;!-- 约束地址 --&gt;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; 组件扫描1&lt;context:component-scan base-package=&quot;com.myspring.controller&quot;/&gt; XML配置return重定义与请求转发12return &quot;forward:/success.jsp&quot;;return &quot;redirect:/success.jsp&quot;; 内部资源（视图）解析器 在spring-mvc.xml中配置如下 12345678910111213&lt;!-- 内部资源解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt; &lt;!-- 配置后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;2. 编写controller ```java // return &quot;/jsp/success.jsp&quot;; return &quot;success&quot; //效果与上述相同 SpringMVC数据响应页面跳转返回字符串1return &quot;/jsp/success.jsp&quot;; 返回ModelAndview对象在controller中编写如下 1234567891011121314151617181920212223242526272829// 第一种@RequestMapping(&quot;/myController1&quot;)public ModelAndView save2() &#123; ModelAndView modelAndView = new ModelAndView(); // 设置视图 modelAndView.setViewName(&quot;success&quot;); // 设置模型 modelAndView.addObject(&quot;username&quot;, &quot;qqq&quot;); return modelAndView;&#125;// 第二种@RequestMapping(&quot;/myController2&quot;)public ModelAndView save3(ModelAndView modelAndView) &#123; modelAndView.setViewName(&quot;success&quot;); modelAndView.addObject(&quot;username&quot;, &quot;qqq&quot;); return modelAndView;&#125;// 第三种@RequestMapping(&quot;/myController3&quot;)public ModelAndView save4(Model model) &#123; model.setAttribute(&quot;username&quot;, &quot;qqq&quot;); return &quot;success&quot;;&#125;// 第四种@RequestMapping(&quot;/myController4&quot;)public String save4(HttpServletRequest request) &#123; request.setAttribute(&quot;username&quot;, &quot;qqq&quot;); return &quot;success&quot;;&#125; 回写数据返回字符串（@ResponseBody）1234567891011// 第一种@RequestMapping(&quot;/myController1&quot;)public void save1(HttpServletResponse resp) throws IOException &#123; resp.getWriter().print(&quot;hello!!!&quot;);&#125;// 第二种,使用ResponseBody，用于区分页面跳转@RequestMapping(&quot;/myController2&quot;)@ResponseBodypublic String save2() &#123; return &quot;hello!!!&quot;;&#125; 返回JSON格式字符串 添加依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; 转换为JSON 1234567891011@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic String save() throws Exception &#123; // 获得bean User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); // 转换为JSON String userJson = new ObjectMapper().writeValueAsString(user); return userJson;&#125; 返回Spring自动转换Bean-&gt;JSON 配置spring-mvc.xml 12345678&lt;!-- 处理器映射器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 或者使用mvc注解驱动如下配置： 123456xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&lt;!-- mvc注解驱动 --&gt;&lt;mvc:annotation-driven/&gt; 编写controller 123456789// 第二种,使用ResponseBody，用于区分页面跳转@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic User save() throws Exception &#123; User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); return user;&#125; SpringMVC请求获取请求参数获取基本类型参数1234567@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(String username, int age) &#123; // 使用形参接收数据，注意此处参数名与表单中input的name值对应 System.out.println(username); System.out.println(age);&#125; 获取Bean类型参数123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(User user) &#123; // 实际上是使用了Bean对象里的set方法，所以要让参数的名字与set方法名对应，否则接收不到 System.out.println(user);&#125; 获取数据类型参数12345@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(String[] strs) &#123; System.out.println(Arrays.toString(strs));&#125; 获取集合类型参数 前端传输数据 123456789101112&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var userList = new Array(); userList.push(&#123;name: &quot;张三&quot;, age: 10&#125;); userList.push(&#123;name: &quot;李四&quot;, age: 20&#125;); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;$&#123;pageContext.request.contextPath&#125;/test/myController&quot;, data: JSON.stringify(userList), contentType: &quot;application/json;charset=utf-8&quot; &#125;)&lt;/script&gt; controller获得数据 123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(@RequestBody List&lt;User&gt; userList) &#123; // 注意 @RequestBody List&lt;User&gt; userList System.out.println(userList);&#125; 静态资源访问权限开放spring-mvc.xml中配置如下 1234&lt;!-- 开放资源访问，设置可访问地址 --&gt;&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;&lt;!-- 该标签表示当spring找不到时交由原始容器(tomcat)寻找 --&gt;&lt;mvc:default-servlet-handler/&gt; 全局编码过滤（防止中文乱码）12345678910111213&lt;!-- 全局编码过滤 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 参数绑定注解@RequestParam value: 与请求参数名称 required: 此在指定的请求参数是否必须包括,默认是true,提交时如果没有此参数则报错 defaultvalue: 当没有指定请求参数时,则使用指定的默认值赋值 123456@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(@RequestParam(value=&quot;name&quot;, required=false，defaultvalue=&quot;000&quot;) String username) &#123; // 将获得的参数name映射为所需要的username System.out.println(username);&#125; 获得Restfil风格参数 Restful是一种软件架构风格、设计风格,而不是标准,只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件,基于这个风格设计的软件可以更简洁,更有层次,更易于实现缓存机制等。 Restful风格的请求是使用“”ur+请求方式”表示次请求目的的,HTP协议里面四个表示操作方式的动词如下： GET: 用于获取资源 POST: 用于新建资源 PUT: 用于更新资源 DELETE: 用于删除资源 123456@RequestMapping(&quot;/myController/&#123;name&#125;&quot;)// 使用占位符&#123;&#125;@ResponseBodypublic void save(@PathVariable(&quot;name&quot;) String username) &#123; System.out.println(username);&#125; 自定义类型转换器黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 获得请求头@RequestHeader 文件上传 导入依赖 1234567891011dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 在spring-mvc.xml中配置文件上传解析器 12345678&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 上传文件的编码类型 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;!-- 上传文件总大小 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242800&quot;/&gt; &lt;!-- 上传单个文件的大小 --&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;5242800&quot;/&gt;&lt;/bean&gt; 编写controller 12345@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(MultipartFile uploadedFile) throws Exception &#123; uploadedFile.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\&quot; + uploadedFile.getOriginalFilename()));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@RequestMapping(&quot;/myController&quot;)@ResponseBodypublic void save(MultipartFile[] files) throws Exception &#123; for (MultipartFile file : files) &#123; file.transferTo(new File(&quot;C:\\\\Users\\\\卢荟\\\\Desktop\\\\&quot; + file.getOriginalFilename())); &#125;&#125;## SpringMVC拦截器interceptor&gt; Spring Mvc的拦截器类似于 Servlet开发中的过滤器 Filter,用于对处理器进行预处理和后处理。&gt;&gt; 将拦截器按一定的顺序联结成条链,这条链称为拦截器链( interceptor Chain)。在访问被拦截的方法或字段时,拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。### 开发步骤1. 编写interceptor ```java public class MyInterceptor implements HandlerInterceptor &#123; // 在目标方法执行之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); String param = request.getParameter(&quot;param&quot;); if (&quot;yes&quot;.equals(param)) &#123; return true; &#125; else &#123; request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request, response); return false; &#125; &#125; // 在目标方法执行之后，试图返回之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); // 可以对model进行修改 modelAndView.addObject(&quot;name&quot;, &quot;newName&quot;); &#125; // 在流程执行完毕之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion&quot;); &#125; &#125; 在spring-mvc.xml中配置interceptor 123456789101112131415&lt;mvc:interceptors&gt; &lt;!-- 对应执行顺序 --&gt; &lt;mvc:interceptor&gt; &lt;!-- 对哪些资源执行拦截操作 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 对应interceptor --&gt; &lt;bean class=&quot;com.myspring.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 对哪些资源执行拦截操作 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!-- 对应interceptor --&gt; &lt;bean class=&quot;com.myspring.interceptor.MyInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 方法说明 SpringMVC异常处理简单异常处理器1234567891011&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 默认错误视图 --&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error1&quot;/&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;map&gt; &lt;!-- key:异常类型 value:错误视图 --&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error2&quot;/&gt; &lt;entry key=&quot;java.io.IOException&quot; value=&quot;error3&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 自定义异常处理器 黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 1listener","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"【学习笔记】Spring","slug":"【学习笔记】Spring","date":"2021-07-13T12:59:14.495Z","updated":"2021-09-19T07:07:36.261Z","comments":true,"path":"2021/07/13/xue-xi-bi-ji-spring/","link":"","permalink":"http://example.com/2021/07/13/xue-xi-bi-ji-spring/","excerpt":"","text":"什么是SpringSpring用来干什么 Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成。 Spring是分层的 Java SE/EE应用 full-stack轻量级开源框架,以loC(Inverse of Control:反转控制)和Aop(Aspect Oriented Programming:面向切面编程)为内核。 提供了展现层 Spring MVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库,逐渐成为使用最多的 Java EE企业应用开源框架。 Spring发展历程 1997年,BM提出了EB的思想1998年,SUN制定开发标准规范E丿B1.01999年,EB1.1发布2001年,EB2.0发布2003年,EB2.1发布2006年,EB3.0发布 Spring之父 Rod Johnson( Spring之父) 《Expert One-to-One J2EE Design and development(2002)》阐述了J2EE使用EB开发设计的优点及解决方案《Expert One-to-One J2EE Development without EJB(2004)》阐述了2E开发不使用EB的解决方式( Spring维形) Spring的优势 方便解耦,简化开发 通过 Spring提供的loC容器,可以将对象间的依赖关系交由 Spring进行控制,避免硬编码所造成的过度耦合。 用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码,可以更专注于上层的应用。 AOP编程的支持 通过 Spring的AOP功能,方便进行面向切面编程,许多不容易用传统OOP实现的功能可以通过AOP轻松实现。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来,通过声明式方式灵活的进行事务管理,提高发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作,测试不再是昂贵的操作,而是随手可做的事情。 方便集成各种优秀框架 Spring对各种优秀框架( Struts、 Hibernate、 Hessian、Quartz等)的支持。 降低 JavaEE AP的使用难度 Spring对 JavaEE API(如JDBC、 JavaMail、远程调用等)进行了薄薄的封装层,使这些APl的使用难度大为降低。 Spring体系结构 Spring快速开发步骤 导入maven依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Spring conf配置文件（通常命名为applicationContext） 配置如下 1&lt;bean id=&quot;userDao&quot; class=&quot;com.myspring.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 实现 1234567public class UserDaoDemo &#123; public static void main(String[] args) &#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); userDao.save(); &#125;&#125; Spring配置文件Bean标签 用于配置对象交由 Spring来创建。默认情况下它调用的是类中的**无参构造函数,**如果没有无参构造函数则不能创建成功。 基本属性 id: Bean实例在 Spring容器中的唯一标识 class: Bean的全限定名称 scope：指对象的作用范围，取值如下 singleton、prototype下bean对象的不同创建时间singleton、prototype下bean对象的不同创建时间 Bean实例化三种方法 无参构造方法实例化 1234// 创建容器ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 从容器中获得对象UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;); 工厂静态方法实例化 工厂实例方法实例化 演示视频 Bean的依赖注入 依赖注入( Dependency Injection)：它是 Spring框架核心|OC的具体实现在编写程序时,通过控制反转,把对象的创健建交给了 Spring,但是代码中不可能出现没有依赖的情况。OC解耦只是降低他们的依赖关系,但不会消除。例如:业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系,在使用 Spring之后,就让 Spring来维护了简单的说,就是坐等框架把持久层对象传入业务层,而不用我们自己去获取。 set方法（property标签）12345678&lt;!-- 第一种 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;!-- name属性值对应set方法名 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 第二种 --&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot; /&gt; 123456// UserServiceImpl中依赖注入，获得userDao对象private UserDao userDao;// set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 构造（有参）方法（constructor-arg标签）1234&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;!-- name属性值对应userServiceImpl内UserDao的属性名 --&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123456// 依赖注入，获得userDao对象private UserDao userDao;// 构造方法public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao;&#125; 注入数据的数据类型 普通数据类型 引用数据类型 集合数据类型 演示视频 分模块开发（import标签） 实际开发中, Spring的配置内容非常多,这就导致 Spring配置很繁杂且体积很大,所以,可以将部分配置拆解到其他配置文件中,而在 Spring主配置文件通过impor标签进行加载。 1&lt;import resource=&quot;applicationContext-user.xml&quot;&gt;&lt;/import&gt; Spring相关APIApplicationContext application Context：接口类型,代表应用上下文,可以通过其实例获得 Spring容器中的Bean对象 三种实现类 ClassPathXmlApplicationContext它是从类的根路径下加载配置文件推荐使用这种 FileSystemXmlApplicationContext它是从磁盘路径上加载配置文件,配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext当使用注解配置容器对象时,需要使用此类来创建 spring容器。它用来读取注解。 getBean()方法 12UserService userService1 = (UserService) app.getBean(&quot;userService&quot;);UserService userService2 = app.getBean(UserService.class); Spring配置数据源数据源（连接池）的作用 数据源(连接池)是提高程序性能如出现的 事先实例化数据源,初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 手动创建数据源的开发步骤 导入Maven依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 创建jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/数据库名jdbc.username=rootjdbc.password=123456789 加载properties配置文件 12345ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;);String driver = rb.getString(&quot;jdbc.driver&quot;);String url = rb.getString(&quot;jdbc.url&quot;);String username = rb.getString(&quot;jdbc.username&quot;);String password = rb.getString(&quot;jdbc.password&quot;); 创建数据源 1234567// 创建c3p0数据源ComboPooledDataSource dataSource = new ComboPooledDataSource();dataSource.setDriverClass(driver);dataSource.setJdbcUrl(url);dataSource.setUser(username);dataSource.setPassword(password);Connection connection = dataSource.getConnection(); 1234567// 创建Druid数据源DruidDataSource dataSource = new DruidDataSource();dataSource.setDriverClassName(driver);dataSource.setUrl(url);dataSource.setUsername(username);dataSource.setPassword(password);DruidPooledConnection connection = dataSource.getConnection(); 使用Spring创建数据源的开发步骤 导入相关依赖 在applicationContext中配置数据源bean 12345678910111213141516171819202122&lt;!-- 引入context命名空间和约束路径 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 加载外部的properties文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;&lt;!-- c3p0 --&gt;&lt;bean id=&quot;dataSource1&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- Driud --&gt;&lt;bean id=&quot;dataSource2&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/property&gt;&lt;/bean&gt; 创建数据源对象 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);DataSource dataSource = applicationContext.getBean(DataSource.class);Connection connection = dataSource.getConnection(); Spring注解开发 Spring原始注解主要是替代的配置 原始注解 组件扫描使用注解进行开发时,需要在 applicationContext. xm中配置组件扫描,作用是指定哪个包及其子包下的Bean，需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!-- 配置组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt; Dao类12&lt;!-- 配置文件 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.myspring.dao.impl.UserDaoImpl&quot; scope=&quot;prototype&quot;&gt; &lt;/bean&gt; 1234// 注解配置，写在类名之上@Component(&quot;userDao&quot;)// 第二种可读性更强@Repository(&quot;userDao&quot;) Service类1234&lt;!-- 配置文件 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.myspring.service.impl.UserServiceImpl&quot; &gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot; /&gt;&lt;/bean&gt; 1234// 注解配置，写在类名之上@Component(&quot;userService&quot;)// 第二种可读性更强@Service(&quot;userService&quot;) 1234567891011// 注解配置，写在字段之前// Autowired从spring容器中根据 数据类型 进行匹配，所以同一数据类型只有单个bean可以只写Autowired@Autowired// Qualifier从spring容器中根据 id值类型 进行匹配，但是必须结合Autowired一起使用@Qualifier(&quot;userDao&quot;)// @Resource(name = &quot;userDao&quot;) 相当于前两者结合private UserDao userDao;// 此时类中可以不写set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 普通属性注入12@Value(&quot;$&#123;jdbc.driver&#125;&quot;)private String driver; 新注解 整合在一起的样子，如下： 1234567891011121314151617181920212223@Configuration // 标志该类是Spring的核心配置类@ComponentScan(&quot;com.myspring&quot;) // 配置组件扫描,替换&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt;@PropertySource(&quot;classpath:jdbc.properties&quot;) // 加载外部的properties文件,替换&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;public class SpringConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) // spring会将当前方法的返回值以指定名称存储到spring容器当中 public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 分模块如下（推荐）： 123456@Configuration // 标志该类是Spring的核心配置类@ComponentScan(&quot;com.myspring&quot;) // 配置组件扫描,替换&lt;context:component-scan base-package=&quot;com.myspring&quot;/&gt;@Import(&#123;DataSourceConfiguration.class,&#125;) //括号内写数组&#123;xxx.class,xxx.class&#125;,替换&lt;import resource=&quot;&quot;/&gt;public class SpringConfiguration &#123; &#125; 123456789101112131415161718192021@PropertySource(&quot;classpath:jdbc.properties&quot;) // 加载外部的properties文件,替换&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean(&quot;dataSource&quot;) // spring会将当前方法的返回值以指定名称存储到spring容器当中 public DataSource getDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; Spring集成junit 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 编写测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)// @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) // 非注解方式注入配置@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) // 注解方式注入配置public class SpringJunitTest &#123; @Resource(name = &quot;userService&quot;) private UserService userService; @Test public void test1() &#123; userService.save(); &#125;&#125; Spring集成web环境 应用上下文对象是通过 new ClasspathXmlApplication Context( spring配置文件)方式获取的,但是每次从容器中获得Bean时都要编写 new ClasspathXmlApplication Context( spring配置文件),这样的弊端是配置文件加载多次,应用上下文对象创建多次。 在Web项目中,可以使用 ServletcontextListener监听Web应用的启动,我们可以在Web应用启动时,就加载 Spring的配置文件,创建应用上下文对象 Application Context,在将其存储到最大的域 servletContext域中,这样就可以在任意位置从域中获得应用上下文 Application Context对象了 手动使用listener获取应用上下文对象 创建listener类 123456789101112131415public class ContextLoaderListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; // ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //使用非注解时用该方法创建 ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfiguration.class); // 使用注解时用该方法创建 // 将Spring的应用上下文对象存储到ServletContext域对象中 servletContextEvent.getServletContext().setAttribute(&quot;app&quot;, app); System.out.println(&quot;spring容器创建完毕&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; &#125;&#125; 在web.xml中配置listener 123&lt;listener&gt; &lt;listener-class&gt;com.myspring.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取servletContext域对象中的应用上下文对象 1ApplicationContext app = (ApplicationContext) this.getServletContext().getAttribute(&quot;app&quot;); 使用Spring获取应用上下文对象 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 123456789&lt;!-- 设置全局参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 配置监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 获取应用上下文对象 1WebApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(req.getServletContext()); JdbcTemplate概述 它是 spring框架中提供的个对象,是对原始繁琐的 dbc API对象的简单封装。 spring框架为我们提供了很多的操作模板类。例如:操作关系型数据的 dbcTemplate和 bernate Template,操作nosq数据库的 RedisTemplate,操作消息队列的 UmsTemplate等等。 手动开发步骤 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建数据库表和javaBean 创建jdbcTemplate对象、执行数据库操作 12345678910111213141516public class JdbcTemplateTest &#123; @Test // 测试dbcTemplate开发步骤 public void test() &#123; // 创建Druid数据源 DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456789&quot;); // 创建jdbcTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 数据库操作 jdbcTemplate.update(&quot;insert into test1 values(?,?)&quot;, &quot;张三&quot;, 18); &#125;&#125; Spring使用JdbcTemplate开发步骤 添加依赖 编写jdbc.properties文件 编写spring-config文件applicationContext.xml，添加数据源对象，jdbcTemplate对象 12345678910111213141516171819&lt;!-- 引入context命名空间和约束路径 --&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 加载外部的properties文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!-- Druid DataSource --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring JdbcTemplate --&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 编写代码 123456// 获得applicationContextApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 从容器中获得jdbcTemplate对象JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class);// 数据库操作jdbcTemplate.update(&quot;insert into test1 values(?,?)&quot;, &quot;张三&quot;, 18); 常用操作1234jdbcTemplate.update(&quot;update test1 set age=? where name =?&quot;, 10, &quot;张三&quot;);List&lt;User&gt; userList = jdbcTemplate.query(&quot;select * from test1&quot;, new BeanPropertyRowMapper&lt;&gt;(User.class));User user = jdbcTemplate.queryForObject(&quot;select * from test1 where age=?&quot;, new BeanPropertyRowMapper&lt;&gt;(User.class), 18);Long count = jdbcTemplate.queryForObject(&quot;select count(*) from test1&quot;, Long.class); AOP概述 AOP为 Aspect Oriented Programming的缩写,意思为面向切面编程,是通过预编译方式和运行期动态代理现程序功能的同统一维护的一种技术。 AOP是OOP的延续,是软件开发中的一个热点,也是 Spring框架中的个重要内容,是函数式编程的种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 作用与优势黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili JDK动态代理、cglib动态代理黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili 概念 Target(目标对象):代理的目标对象。 Proxy(代理):—个类被AOP织入增强后,就产生一个结果代理类。 Joinpoint(连接点):所谓连接点是指那些被拦截到的点。在 spring中这些点指的是方法,因为 spring只支持方法类型的连接点。 Pointcut(切入点):所谓切入点是指我们要对哪些 Joinpoint迸行拦截的定义。 Advice(通知/增强):所谓通知是指拦截到 Joinpoint之后所要做的事情就是通知。 Aspect(切面):是切入点和通知(引介个)的结合。 eaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring釆用动态代理织入,而Aspect采用编译期织入和类装载期织入。 基于XML开发AOP步骤 导入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.7&lt;/version&gt;&lt;/dependency&gt; 创建目标接口和目标类 创建切面类（含增强方法） 123456789101112public class MyAspect &#123; public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125; public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;前置增强。。。&quot;); Object proceed = pjp.proceed(); System.out.println(&quot;后置增强。。。&quot;); return proceed; &#125;&#125; 配置applicationContext.xml 12345678910111213141516xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&lt;!-- 目标对象 --&gt;&lt;bean id=&quot;target&quot; class=&quot;com.myspring.aop.Target&quot;/&gt;&lt;!-- 切面对象 --&gt;&lt;bean id=&quot;myAspect&quot; class=&quot;com.myspring.aop.MyAspect&quot;/&gt;&lt;!-- 配置织入，即哪些方法需要哪些增强(前置后置增强等) --&gt;&lt;aop:config&gt; &lt;!-- 声明切面 --&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 切点+通知(增强) --&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(* com.myspring.aop.*.*(..))&quot;&gt;&lt;/aop:before&gt; &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.myspring.aop.*.*(..))&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) // 非注解方式注入配置public class SpringJunitTest &#123; @Autowired private TargetInterface target; @Test public void test1() &#123; target.save(); &#125;&#125; 切点表达式 12345678910&lt;aop:config&gt; &lt;!-- 声明切面 --&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!-- 切点表达式的抽取 --&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.myspring.aop.*.*(..))&quot;/&gt; &lt;!-- 切点+通知(增强) --&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知类型 基于注解开发AOP 目标类、切面类 配置目标类、切面类 1234@Component(&quot;target&quot;)public class Target implements TargetInterface &#123;&#125; 12345678@Component(&quot;myAspect&quot;)@Aspect //标注当前是一个切面类public class MyAspect &#123; @Before(&quot;execution(* com.myspring.aop.*.*(..))&quot;) public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125;&#125; 配置applicationContext.xml 1234&lt;!-- 注解开发组件扫描 --&gt;&lt;context:component-scan base-package=&quot;com.myspring.aop&quot;/&gt;&lt;!-- aop自动代理 --&gt;&lt;aop:aspectj-autoproxy/&gt; 切点表达式抽取12345678910111213@Component(&quot;myAspect&quot;)@Aspect //标注当前是一个切面类public class MyAspect &#123; @Before(&quot;pointCut()&quot;) public void before() &#123; System.out.println(&quot;前置增强。。。&quot;); &#125; // 定义切点表达式 @Pointcut(&quot;execution(* com.myspring.aop.*.*(..))&quot;) public void pointCut() &#123; &#125;&#125; 事务控制黑马程序员最全SSM框架教程|Spring+SpringMVC+MyBatis全覆盖_SSM整合_哔哩哔哩_bilibili","categories":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"【集训】Servlet","slug":"【集训】servlet","date":"2021-07-11T11:56:48.738Z","updated":"2021-07-23T05:50:22.649Z","comments":true,"path":"2021/07/11/ji-xun-servlet/","link":"","permalink":"http://example.com/2021/07/11/ji-xun-servlet/","excerpt":"","text":"什么是Servlet？ Servlet 是运行在 Web 服务器或应用服务器上的java程序，是Java EE规范之一（一种接口）。 它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层，即接收客户端发送过来的请求并且响应数据给客户端。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 💡配置Servlet 创建一个Java类并实现Servlet接口（一般通过继承HTTPServlet类去实现servlet） 重写方法，实现逻辑操作 在web.xml中配置这个servlet的访问地址 1234567891011121314&lt;!-- 给tomcat配置servlet相关信息 --&gt;&lt;servlet&gt; &lt;!-- 写明servlet的名字（一般使用类名即可） --&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;!-- 写明servlet的全类名 --&gt; &lt;servlet-class&gt;servlet.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 给servlet配置访问地址 --&gt;&lt;servlet-mapping&gt; &lt;!-- 写明需要配置访问地址的servlet --&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;!-- 写明为该servlet配置的访问地址 --&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;url-pattern&gt;/myServlet&lt;/url-pattern&gt;标签中 / 的作用：相当于拼接到 http://ip:port/工程路径后，即http://ip:port/工程路径/myServlet HTTP协议什么是HTTP协议 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准，即客户端与服务器之间通信、传输数据需要遵守的规则。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 请求与响应 客户端给服务器发送数据为请求，请求分为GET、POST请求 服务器给客户端回传数据为响应 💡HTTP协议内容 请求/响应行 请求/响应头： 属性名：属性值 请求/响应体： 重要，自行阅读学习 常见响应码 200：表示请求成功 302：表示请求重定向 404：表示服务器找不到该请求地址（地址有错） 500：表示服务器内部错误（代码有错） 💡表单处理、常用API request对象常用方法 方法介绍 getParameter(String name) 返回name指定参数的参数值 getParameterValues(String name) 返回包含参数name的所有值的数组 setAttribute(String,Object) 存储此请求中的属性 getAttribute(String name) 返回指定属性的属性值 getContextPath() 返回当前WEB项目相对路径 getMethod() 获取请求类型 getSession() 获取Session对象 getCookies() 获取所有Cookie,返回一个Cookie数组 request对象常用方法 方法介绍 setHeader() 设置消息头 setStatus() 设置状态码 addCookie() 添加Cookie getWriter() 获取通向浏览器的字符流 获取/回传数据123456789&lt;form action=&quot;http://localhost:8080/jsp_war_exploded/myServlet&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;画画&quot;&gt;画画 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;打篮球&quot;&gt;打篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;敲代码&quot;&gt;敲代码 &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345String username = req.getParameter(&quot;username&quot;);String password = req.getParameter(&quot;password&quot;);String[] hobby = req.getParameterValues(&quot;hobby&quot;);System.out.println(&quot;用户名：&quot;+username+&quot;,密码：&quot;+password);System.out.println(Arrays.toString(hobby)); 1resp.getWriter().println(&quot;&lt;div&gt;这是一个div&lt;/div&gt;&quot;); http://localhost:8080/jsp_war_exploded/myServlet?username=111&amp;password=222使用?传递参数 请求转发与重定向 1234String username = req.getParameter(&quot;username&quot;);req.setAttribute(&quot;key&quot;, &quot;MyServlet处理的信息:&quot;);System.out.println(&quot;MyServlet中的request获得的数据&quot;+username);req.getRequestDispatcher(&quot;/myServlet2&quot;).forward(req, resp); 123String username = req.getParameter(&quot;username&quot;);System.out.println(&quot;MyServlet2中的request获得的数据:&quot;+username);System.out.println(&quot;MyServlet2中显示之前处理并保存的数据:&quot;+req.getAttribute(&quot;key&quot;)); 请求转发的特点： 浏览器地址栏没有变化 一次请求 共享request中的数据 可以转发到WEB-INF目录下（工程路径下） 1234resp.sendRedirect(req.getContextPath()+&quot;/myServlet2&quot;);// req.getContextPath()获得当前WEB项目相对路径resp.sendRedirect(&quot;http://www.baidu.com&quot;);// 访问外部资源必写http 重定向的特点： 浏览器地址栏发生变化 两次请求 不共享request中的数据 不能访问WEB-INF目录下资源 可以访问工程外的资源 💡Filter过滤器自行学习 中文乱码问题12req.setCharacterEncoding(&quot;UTF-8&quot;);resp.setContentType(&quot;text/html;charset=UTF-8&quot;); 相关阅读材料 Web开发 - 廖雪峰的官方网站 (liaoxuefeng.com) 尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版_哔哩哔哩_bilibili 作业 熟悉servlet、jsp并实现一些功能，并写一篇博文。 博文内容要求（必须要求）： 写一篇博文记录你使用servlet、jsp实现功能时遇到了哪些困难、不理解、不知道该如何实现的地方，以及写上解决的过程与结果（未解决的也可以写上有哪些疑惑），或者学习笔记等等皆可。 功能实例（仅参考，不是最低/最高标准）： 含有登陆/注册页面、其他页面。 登录功能：手动输入信息，符合已存在的用户信息则成功登录。 注册功能：手动输入信息，不能重复注册已存在的用户名，否则注册失败。 用户展示：在页面上展示所有已经注册的用户的信息。 登陆过滤：其他页面，只有登陆成功后才可访问，否则跳转至登陆页面。 其他页面：利用循环控制语句或其他工具功能输出由后台传递而来的数据。 等等 提交内容与时间： 提交内容：程序源码+博文链接 提交时间：7.27日晚零点前，将压缩包命名为班级+姓名+学号发送至&#55;&#x30;&#55;&#x38;&#x32;&#51;&#x38;&#x31;&#52;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109; 可能时间太短无法实现太多功能，没有关系，程序源码附上自己实现了的东西就行，没有实现完整也没关系，实现了更多功能也挺好，这个作业打分主要看你的博文里面写的记录内容，程序主要是用来练习以熟悉servlet和jsp的，毕竟大作业会用到。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"}]},{"title":"【集训】jsp","slug":"【集训】jsp","date":"2021-07-11T07:14:09.093Z","updated":"2021-07-23T05:51:57.089Z","comments":true,"path":"2021/07/11/ji-xun-jsp/","link":"","permalink":"http://example.com/2021/07/11/ji-xun-jsp/","excerpt":"","text":"什么是JSP JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。 JSP全称Java Server Pages，是建立在JAVA基础上的一种网络编程语言，JSP是一种Java servlet（JSP在执行前首先被编译成一个Servlet），主要用于实现Java web应用程序的用户界面部分。 网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。 jsp &lt;-&gt; java(servlet)C:\\Users\\卢荟\\AppData\\Local\\JetBrains\\IntelliJIdea2021.1\\tomcat\\20e10a3d-4da9-4eee-b7fa-327b2feb3d84\\work\\Catalina\\localhost\\jsp_war_exploded\\org\\apache\\jsp 类似于上述文件目录（tomcat下的webapp目录下存放工程项目，只不过现在tomcat在idea里用）即找到生成的java文件。 可见JSP本质上就是一个Servlet，只不过无需配置映射路径，Web Server会根据路径查找对应的.jsp文件，如果找到了，就自动编译成Servlet再执行。 JSP语法JSP注释 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 HTML注释，通过浏览器查看网页源代码时可以看见注释内容 💡脚本（在JSP中编写Java代码）先导入jsp-api.jar和servlet-api.jar（tomcat自带，但是IDE并无提示会报红） 语法 描述 &lt;% 代码片段 %&gt; 一般定义变量和编写语句。 &lt;%! 声明代码 %&gt; 可以声明常量，编写方法，编写类 &lt;%= 表达式 %&gt; 表达式被转化成String，然后插入到表达式出现的地方 123456789101112131415161718192021&lt;%! public class MyMath &#123; int a,b; public MyMath(int a, int b) &#123; this.a = a; this.b = b; &#125; int doMath()&#123; return a+b; &#125; &#125;%&gt;&lt;% out.println(&quot;打印语句&quot;); MyMath myMath = new MyMath(1, 1); int num = myMath.doMath();%&gt;&lt;h1&gt; 和为&lt;%= num %&gt; &lt;/h1&gt;&lt;div&gt; &lt;%= &quot;&lt;h2&gt;这是一个标签&lt;/h2&gt;&quot; %&gt; &lt;/div&gt; 对于流程控制语句的编写可能稍微繁琐 123456789101112&lt;% int day = 1 %&gt;&lt;% if (day == 1 || day == 7) &#123; %&gt;&lt;p&gt;今天是周末&lt;/p&gt;&lt;% &#125; else &#123; %&gt;&lt;p&gt;今天不是周末&lt;/p&gt;&lt;% &#125; %&gt; &lt;%for ( int fontSize = 1; fontSize &lt;= 3; fontSize++)&#123; %&gt; &lt;font color=&quot;green&quot; size=&quot;&lt;%= fontSize %&gt;&quot;&gt; 菜鸟教程 &lt;/font&gt;&lt;br /&gt;&lt;%&#125;%&gt; 当然也可以用out对象输出 12345678&lt;% int fontSize; for ( fontSize = 10; fontSize &lt;= 13; fontSize++) &#123; out.write(&quot;&lt;div&gt;&quot;); out.write(fontSize+&quot;&quot;); out.write(&quot;&lt;/div&gt;&lt;br&gt;&quot;); &#125;%&gt; JSP指令JSP指令用来设置与整个JSP页面相关的属性。 JSP指令 描述 &lt;%@ page 属性名=”属性值” %&gt; 定义页面的依赖属性，导包 &lt;%@ include 属性名=”属性值” %&gt; 包含其他文件（静态包含） &lt;%@ taglib 属性名=”属性值” %&gt; 引入标签库的定义，可以是自定义标签 123&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot; &quot; %&gt; &lt;%@ include file=&quot; &quot;%&gt; JSP行为自行学习 1&lt;jsp:行为名 属性名=&quot;属性值&quot; /&gt; 中文编码问题1&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; 💡JSP九大内置对象与四大作用域四大域对象 对象 作用域 变化操作 pageContext 当前页面有效，当当前页面关闭或转到其他页面时，page对象将在响应回馈给客户端后释放。 跳转页面 request 当次请求有效，可以跨越forward()不重定向跳转前后的两页，可以通过setAttribute()方法实现页面中的信息传递。 两次请求 session 当前会话有效，指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应 关闭浏览器 application 所有应用程序中有效，整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。 关闭服务器 12345678910&lt;% pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;); request.setAttribute(&quot;key&quot;, &quot;request&quot;); session.setAttribute(&quot;key&quot;, &quot;session&quot;); application.setAttribute(&quot;key&quot;, &quot;application&quot;);%&gt;pageContext的值：&lt;%=pageContext.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;request的值：&lt;%=request.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;session的值：&lt;%=session.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt;application的值：&lt;%=application.getAttribute(&quot;key&quot;) %&gt;&lt;br&gt; 九大内置对象在生成的java文件中可以找到 对象 描述 作用域 request javax.servlet.http.HttpServletRequest 类的实例 request response javax.servlet.http.HttpServletResponse类的实例 pageContext out javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。 pageContext session javax.servlet.http.HttpSession 类的实例 session application javax.servlet.ServletContext 类的实例。与应用上下文有关 application config javax.servlet.ServletConfig 类的实例。这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 pageContext pageContext javax.servlet.jsp.PageContext 类的实例，提供对JSP页面所有对象以及命名空间的访问 pageContext page 指向当前JSP对象 pageContext exception exception 类的对象，代表发生错误的 JSP 页面中对应的异常对象，&lt;%@ page …… isErrorPage=”true” %&gt; pageContext EL表达式与JSTL标准标签库自行学习 💡MVC框架MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。 Model（模型）：如一个存取数据的对象或 JavaBean View（视图）：如jsp动态页面 Controller（控制器）：控制数据流向模型对象，并在数据变化时更新视图，使视图与模型分离开，如servlet MVC重要特点就是两种分离： 视图和数据模型的分离：使用不同的视图对相同的数据进行展示；分离可视和不可视的组件，能够对模型进行独立测试。因为分离了可视组件减少了外部（数据库也是一种外部组件）依赖利于测试。 视图和表现逻辑(Controller)的分离：Controller是一个表现逻辑的组件，并非一个业务逻辑组件。MVC可以作为表现模式也可以作为建构模式，意味这Controller也可以是业务逻辑。分离逻辑和具体展示，能够对逻辑进行独立测试。 MVC优缺点： 优点：低耦合、重用性高、生命周期成本低、部署快、可维护性高 缺点：没有明确的定义、不适合小、中型应用程序、增加系统结构和实现的复杂性、视图对模型数据的低效率访问 作业在上一个文档中已经声明，这两节课只要交一个作业就行。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"jsp","slug":"jsp","permalink":"http://example.com/tags/jsp/"}]}],"categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/categories/ssm/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://example.com/tags/SpringCloud/"},{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://example.com/tags/MyBatisPlus/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"Unity2D","slug":"Unity2D","permalink":"http://example.com/tags/Unity2D/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"集训","slug":"集训","permalink":"http://example.com/tags/%E9%9B%86%E8%AE%AD/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"javaEE","slug":"javaEE","permalink":"http://example.com/tags/javaEE/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"},{"name":"jsp","slug":"jsp","permalink":"http://example.com/tags/jsp/"}]}